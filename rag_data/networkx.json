[{"type": "class", "name": "networkx.AmbiguousSolution", "documentation": "Raised if more than one valid solution exists for an intermediary step\nof an algorithm.\n\nIn the face of ambiguity, refuse the temptation to guess.\nThis may occur, for example, when trying to determine the\nbipartite node sets in a disconnected bipartite graph when\ncomputing bipartite matchings."}, {"type": "class", "name": "networkx.ArborescenceIterator", "documentation": "Iterate over all spanning arborescences of a graph in either increasing or\ndecreasing cost.\n\nNotes\n-----\nThis iterator uses the partition scheme from [1]_ (included edges,\nexcluded edges and open edges). It generates minimum spanning\narborescences using a modified Edmonds' Algorithm which respects the\npartition of edges. For arborescences with the same weight, ties are\nbroken arbitrarily.\n\nReferences\n----------\n.. [1] G.K. Janssens, K. S\u00f6rensen, An algorithm to generate all spanning\n       trees in order of increasing cost, Pesquisa Operacional, 2005-08,\n       Vol. 25 (2), p. 219-229,\n       https://www.scielo.br/j/pope/a/XHswBwRwJyrfL88dmMwYNWp/?lang=en"}, {"type": "method", "name": "networkx.ArborescenceIterator.__init__", "documentation": "Initialize the iterator\n\nParameters\n----------\nG : nx.DiGraph\n    The directed graph which we need to iterate trees over\n\nweight : String, default = \"weight\"\n    The edge attribute used to store the weight of the edge\n\nminimum : bool, default = True\n    Return the trees in increasing order while true and decreasing order\n    while false.\n\ninit_partition : tuple, default = None\n    In the case that certain edges have to be included or excluded from\n    the arborescences, `init_partition` should be in the form\n    `(included_edges, excluded_edges)` where each edges is a\n    `(u, v)`-tuple inside an iterable such as a list or set."}, {"type": "method", "name": "networkx.ArborescenceIterator.__iter__", "documentation": "Returns\n-------\nArborescenceIterator\n    The iterator object for this graph"}, {"type": "method", "name": "networkx.ArborescenceIterator.__next__", "documentation": "Returns\n-------\n(multi)Graph\n    The spanning tree of next greatest weight, which ties broken\n    arbitrarily."}, {"type": "method", "name": "networkx.ArborescenceIterator._clear_partition", "documentation": "Removes partition data from the graph"}, {"type": "method", "name": "networkx.ArborescenceIterator._partition", "documentation": "Create new partitions based of the minimum spanning tree of the\ncurrent minimum partition.\n\nParameters\n----------\npartition : Partition\n    The Partition instance used to generate the current minimum spanning\n    tree.\npartition_arborescence : nx.Graph\n    The minimum spanning arborescence of the input partition."}, {"type": "method", "name": "networkx.ArborescenceIterator._write_partition", "documentation": "Writes the desired partition into the graph to calculate the minimum\nspanning tree. Also, if one incoming edge is included, mark all others\nas excluded so that if that vertex is merged during Edmonds' algorithm\nwe cannot still pick another of that vertex's included edges.\n\nParameters\n----------\npartition : Partition\n    A Partition dataclass describing a partition on the edges of the\n    graph."}, {"type": "class", "name": "networkx.DiGraph", "documentation": "Base class for directed graphs.\n\nA DiGraph stores nodes and edges with optional data, or attributes.\n\nDiGraphs hold directed edges.  Self loops are allowed but multiple\n(parallel) edges are not.\n\nNodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention `None` is not used as a node.\n\nEdges are represented as links between nodes with optional\nkey/value attributes.\n\nParameters\n----------\nincoming_graph_data : input graph (optional, default: None)\n    Data to initialize graph. If None (default) an empty\n    graph is created.  The data can be any format that is supported\n    by the to_networkx_graph() function, currently including edge list,\n    dict of dicts, dict of lists, NetworkX graph, 2D NumPy array, SciPy\n    sparse matrix, or PyGraphviz graph.\n\nattr : keyword arguments, optional (default= no attributes)\n    Attributes to add to graph as key=value pairs.\n\nSee Also\n--------\nGraph\nMultiGraph\nMultiDiGraph\n\nExamples\n--------\nCreate an empty graph structure (a \"null graph\") with no nodes and\nno edges.\n\n>>> G = nx.DiGraph()\n\nG can be grown in several ways.\n\n**Nodes:**\n\nAdd one node at a time:\n\n>>> G.add_node(1)\n\nAdd the nodes from any container (a list, dict, set or\neven the lines from a file or the nodes from another graph).\n\n>>> G.add_nodes_from([2, 3])\n>>> G.add_nodes_from(range(100, 110))\n>>> H = nx.path_graph(10)\n>>> G.add_nodes_from(H)\n\nIn addition to strings and integers any hashable Python object\n(except None) can represent a node, e.g. a customized node object,\nor even another Graph.\n\n>>> G.add_node(H)\n\n**Edges:**\n\nG can also be grown by adding edges.\n\nAdd one edge,\n\n>>> G.add_edge(1, 2)\n\na list of edges,\n\n>>> G.add_edges_from([(1, 2), (1, 3)])\n\nor a collection of edges,\n\n>>> G.add_edges_from(H.edges)\n\nIf some edges connect nodes not yet in the graph, the nodes\nare added automatically.  There are no errors when adding\nnodes or edges that already exist.\n\n**Attributes:**\n\nEach graph, node, and edge can hold key/value attribute pairs\nin an associated attribute dictionary (the keys must be hashable).\nBy default these are empty, but can be added or changed using\nadd_edge, add_node or direct manipulation of the attribute\ndictionaries named graph, node and edge respectively.\n\n>>> G = nx.DiGraph(day=\"Friday\")\n>>> G.graph\n{'day': 'Friday'}\n\nAdd node attributes using add_node(), add_nodes_from() or G.nodes\n\n>>> G.add_node(1, time=\"5pm\")\n>>> G.add_nodes_from([3], time=\"2pm\")\n>>> G.nodes[1]\n{'time': '5pm'}\n>>> G.nodes[1][\"room\"] = 714\n>>> del G.nodes[1][\"room\"]  # remove attribute\n>>> list(G.nodes(data=True))\n[(1, {'time': '5pm'}), (3, {'time': '2pm'})]\n\nAdd edge attributes using add_edge(), add_edges_from(), subscript\nnotation, or G.edges.\n\n>>> G.add_edge(1, 2, weight=4.7)\n>>> G.add_edges_from([(3, 4), (4, 5)], color=\"red\")\n>>> G.add_edges_from([(1, 2, {\"color\": \"blue\"}), (2, 3, {\"weight\": 8})])\n>>> G[1][2][\"weight\"] = 4.7\n>>> G.edges[1, 2][\"weight\"] = 4\n\nWarning: we protect the graph data structure by making `G.edges[1, 2]` a\nread-only dict-like structure. However, you can assign to attributes\nin e.g. `G.edges[1, 2]`. Thus, use 2 sets of brackets to add/change\ndata attributes: `G.edges[1, 2]['weight'] = 4`\n(For multigraphs: `MG.edges[u, v, key][name] = value`).\n\n**Shortcuts:**\n\nMany common graph features allow python syntax to speed reporting.\n\n>>> 1 in G  # check if node in graph\nTrue\n>>> [n for n in G if n < 3]  # iterate through nodes\n[1, 2]\n>>> len(G)  # number of nodes in graph\n5\n\nOften the best way to traverse all edges of a graph is via the neighbors.\nThe neighbors are reported as an adjacency-dict `G.adj` or `G.adjacency()`\n\n>>> for n, nbrsdict in G.adjacency():\n...     for nbr, eattr in nbrsdict.items():\n...         if \"weight\" in eattr:\n...             # Do something useful with the edges\n...             pass\n\nBut the edges reporting object is often more convenient:\n\n>>> for u, v, weight in G.edges(data=\"weight\"):\n...     if weight is not None:\n...         # Do something useful with the edges\n...         pass\n\n**Reporting:**\n\nSimple graph information is obtained using object-attributes and methods.\nReporting usually provides views instead of containers to reduce memory\nusage. The views update as the graph is updated similarly to dict-views.\nThe objects `nodes`, `edges` and `adj` provide access to data attributes\nvia lookup (e.g. `nodes[n]`, `edges[u, v]`, `adj[u][v]`) and iteration\n(e.g. `nodes.items()`, `nodes.data('color')`,\n`nodes.data('color', default='blue')` and similarly for `edges`)\nViews exist for `nodes`, `edges`, `neighbors()`/`adj` and `degree`.\n\nFor details on these and other miscellaneous methods, see below.\n\n**Subclasses (Advanced):**\n\nThe Graph class uses a dict-of-dict-of-dict data structure.\nThe outer dict (node_dict) holds adjacency information keyed by node.\nThe next dict (adjlist_dict) represents the adjacency information and holds\nedge data keyed by neighbor.  The inner dict (edge_attr_dict) represents\nthe edge data and holds edge attribute values keyed by attribute names.\n\nEach of these three dicts can be replaced in a subclass by a user defined\ndict-like object. In general, the dict-like features should be\nmaintained but extra features can be added. To replace one of the\ndicts create a new graph class by changing the class(!) variable\nholding the factory for that dict-like structure. The variable names are\nnode_dict_factory, node_attr_dict_factory, adjlist_inner_dict_factory,\nadjlist_outer_dict_factory, edge_attr_dict_factory and graph_attr_dict_factory.\n\nnode_dict_factory : function, (default: dict)\n    Factory function to be used to create the dict containing node\n    attributes, keyed by node id.\n    It should require no arguments and return a dict-like object\n\nnode_attr_dict_factory: function, (default: dict)\n    Factory function to be used to create the node attribute\n    dict which holds attribute values keyed by attribute name.\n    It should require no arguments and return a dict-like object\n\nadjlist_outer_dict_factory : function, (default: dict)\n    Factory function to be used to create the outer-most dict\n    in the data structure that holds adjacency info keyed by node.\n    It should require no arguments and return a dict-like object.\n\nadjlist_inner_dict_factory : function, optional (default: dict)\n    Factory function to be used to create the adjacency list\n    dict which holds edge data keyed by neighbor.\n    It should require no arguments and return a dict-like object\n\nedge_attr_dict_factory : function, optional (default: dict)\n    Factory function to be used to create the edge attribute\n    dict which holds attribute values keyed by attribute name.\n    It should require no arguments and return a dict-like object.\n\ngraph_attr_dict_factory : function, (default: dict)\n    Factory function to be used to create the graph attribute\n    dict which holds attribute values keyed by attribute name.\n    It should require no arguments and return a dict-like object.\n\nTypically, if your extension doesn't impact the data structure all\nmethods will inherited without issue except: `to_directed/to_undirected`.\nBy default these methods create a DiGraph/Graph class and you probably\nwant them to create your extension of a DiGraph/Graph. To facilitate\nthis we define two class variables that you can set in your subclass.\n\nto_directed_class : callable, (default: DiGraph or MultiDiGraph)\n    Class to create a new graph structure in the `to_directed` method.\n    If `None`, a NetworkX class (DiGraph or MultiDiGraph) is used.\n\nto_undirected_class : callable, (default: Graph or MultiGraph)\n    Class to create a new graph structure in the `to_undirected` method.\n    If `None`, a NetworkX class (Graph or MultiGraph) is used.\n\n**Subclassing Example**\n\nCreate a low memory graph class that effectively disallows edge\nattributes by using a single attribute dict for all edges.\nThis reduces the memory used, but you lose edge attributes.\n\n>>> class ThinGraph(nx.Graph):\n...     all_edge_dict = {\"weight\": 1}\n...\n...     def single_edge_dict(self):\n...         return self.all_edge_dict\n...\n...     edge_attr_dict_factory = single_edge_dict\n>>> G = ThinGraph()\n>>> G.add_edge(2, 1)\n>>> G[2][1]\n{'weight': 1}\n>>> G.add_edge(2, 2)\n>>> G[2][1] is G[2][2]\nTrue"}, {"type": "method", "name": "networkx.DiGraph.__contains__", "documentation": "Returns True if n is a node, False otherwise. Use: 'n in G'.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> 1 in G\nTrue"}, {"type": "method", "name": "networkx.DiGraph.__getitem__", "documentation": "Returns a dict of neighbors of node n.  Use: 'G[n]'.\n\nParameters\n----------\nn : node\n   A node in the graph.\n\nReturns\n-------\nadj_dict : dictionary\n   The adjacency dictionary for nodes connected to n.\n\nNotes\n-----\nG[n] is the same as G.adj[n] and similar to G.neighbors(n)\n(which is an iterator over G.adj[n])\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G[0]\nAtlasView({1: {}})"}, {"type": "method", "name": "networkx.DiGraph.__init__", "documentation": "Initialize a graph with edges, name, or graph attributes.\n\nParameters\n----------\nincoming_graph_data : input graph (optional, default: None)\n    Data to initialize graph.  If None (default) an empty\n    graph is created.  The data can be an edge list, or any\n    NetworkX graph object.  If the corresponding optional Python\n    packages are installed the data can also be a 2D NumPy array, a\n    SciPy sparse array, or a PyGraphviz graph.\n\nattr : keyword arguments, optional (default= no attributes)\n    Attributes to add to graph as key=value pairs.\n\nSee Also\n--------\nconvert\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G = nx.Graph(name=\"my graph\")\n>>> e = [(1, 2), (2, 3), (3, 4)]  # list of edges\n>>> G = nx.Graph(e)\n\nArbitrary graph attribute pairs (key=value) may be assigned\n\n>>> G = nx.Graph(e, day=\"Friday\")\n>>> G.graph\n{'day': 'Friday'}"}, {"type": "method", "name": "networkx.DiGraph.__iter__", "documentation": "Iterate over the nodes. Use: 'for n in G'.\n\nReturns\n-------\nniter : iterator\n    An iterator over all nodes in the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> [n for n in G]\n[0, 1, 2, 3]\n>>> list(G)\n[0, 1, 2, 3]"}, {"type": "method", "name": "networkx.DiGraph.__len__", "documentation": "Returns the number of nodes in the graph. Use: 'len(G)'.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\nnumber_of_nodes: identical method\norder: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> len(G)\n4"}, {"type": "method", "name": "networkx.DiGraph.__str__", "documentation": "Returns a short summary of the graph.\n\nReturns\n-------\ninfo : string\n    Graph information including the graph name (if any), graph type, and the\n    number of nodes and edges.\n\nExamples\n--------\n>>> G = nx.Graph(name=\"foo\")\n>>> str(G)\n\"Graph named 'foo' with 0 nodes and 0 edges\"\n\n>>> G = nx.path_graph(3)\n>>> str(G)\n'Graph with 3 nodes and 2 edges'"}, {"type": "method", "name": "networkx.DiGraph.add_edge", "documentation": "Add an edge between u and v.\n\nThe nodes u and v will be automatically added if they are\nnot already in the graph.\n\nEdge attributes can be specified with keywords or by directly\naccessing the edge's attribute dictionary. See examples below.\n\nParameters\n----------\nu_of_edge, v_of_edge : nodes\n    Nodes can be, for example, strings or numbers.\n    Nodes must be hashable (and not None) Python objects.\nattr : keyword arguments, optional\n    Edge data (or labels or objects) can be assigned using\n    keyword arguments.\n\nSee Also\n--------\nadd_edges_from : add a collection of edges\n\nNotes\n-----\nAdding an edge that already exists updates the edge data.\n\nMany NetworkX algorithms designed for weighted graphs use\nan edge attribute (by default `weight`) to hold a numerical value.\n\nExamples\n--------\nThe following all add the edge e=(1, 2) to graph G:\n\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> e = (1, 2)\n>>> G.add_edge(1, 2)  # explicit two-node form\n>>> G.add_edge(*e)  # single edge as tuple of two nodes\n>>> G.add_edges_from([(1, 2)])  # add edges from iterable container\n\nAssociate data to edges using keywords:\n\n>>> G.add_edge(1, 2, weight=3)\n>>> G.add_edge(1, 3, weight=7, capacity=15, length=342.7)\n\nFor non-string attribute keys, use subscript notation.\n\n>>> G.add_edge(1, 2)\n>>> G[1][2].update({0: 5})\n>>> G.edges[1, 2].update({0: 5})"}, {"type": "method", "name": "networkx.DiGraph.add_edges_from", "documentation": "Add all the edges in ebunch_to_add.\n\nParameters\n----------\nebunch_to_add : container of edges\n    Each edge given in the container will be added to the\n    graph. The edges must be given as 2-tuples (u, v) or\n    3-tuples (u, v, d) where d is a dictionary containing edge data.\nattr : keyword arguments, optional\n    Edge data (or labels or objects) can be assigned using\n    keyword arguments.\n\nSee Also\n--------\nadd_edge : add a single edge\nadd_weighted_edges_from : convenient way to add weighted edges\n\nNotes\n-----\nAdding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added.\n\nEdge attributes specified in an ebunch take precedence over\nattributes specified via keyword arguments.\n\nWhen adding edges from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_edges)`, and pass this\nobject to `G.add_edges_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edges_from([(0, 1), (1, 2)])  # using a list of edge tuples\n>>> e = zip(range(0, 3), range(1, 4))\n>>> G.add_edges_from(e)  # Add the path graph 0-1-2-3\n\nAssociate data to edges\n\n>>> G.add_edges_from([(1, 2), (2, 3)], weight=3)\n>>> G.add_edges_from([(3, 4), (1, 4)], label=\"WN2898\")\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.DiGraph([(1, 2), (2, 3), (3, 4)])\n>>> # Grow graph by one new node, adding edges to all existing nodes.\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_edges_from(((5, n) for n in G.nodes))\n>>> # right way - note that there will be no self-edge for node 5\n>>> G.add_edges_from(list((5, n) for n in G.nodes))"}, {"type": "method", "name": "networkx.DiGraph.add_node", "documentation": "Add a single node `node_for_adding` and update node attributes.\n\nParameters\n----------\nnode_for_adding : node\n    A node can be any hashable Python object except None.\nattr : keyword arguments, optional\n    Set or change node attributes using key=value.\n\nSee Also\n--------\nadd_nodes_from\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_node(1)\n>>> G.add_node(\"Hello\")\n>>> K3 = nx.Graph([(0, 1), (1, 2), (2, 0)])\n>>> G.add_node(K3)\n>>> G.number_of_nodes()\n3\n\nUse keywords set/change node attributes:\n\n>>> G.add_node(1, size=10)\n>>> G.add_node(3, weight=0.4, UTM=(\"13S\", 382871, 3972649))\n\nNotes\n-----\nA hashable object is one that can be used as a key in a Python\ndictionary. This includes strings, numbers, tuples of strings\nand numbers, etc.\n\nOn many platforms hashable items also include mutables such as\nNetworkX Graphs, though one should be careful that the hash\ndoesn't change on mutables."}, {"type": "method", "name": "networkx.DiGraph.add_nodes_from", "documentation": "Add multiple nodes.\n\nParameters\n----------\nnodes_for_adding : iterable container\n    A container of nodes (list, dict, set, etc.).\n    OR\n    A container of (node, attribute dict) tuples.\n    Node attributes are updated using the attribute dict.\nattr : keyword arguments, optional (default= no attributes)\n    Update attributes for all nodes in nodes.\n    Node attributes specified in nodes as a tuple take\n    precedence over attributes specified via keyword arguments.\n\nSee Also\n--------\nadd_node\n\nNotes\n-----\nWhen adding nodes from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_nodes)`, and pass this\nobject to `G.add_nodes_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_nodes_from(\"Hello\")\n>>> K3 = nx.Graph([(0, 1), (1, 2), (2, 0)])\n>>> G.add_nodes_from(K3)\n>>> sorted(G.nodes(), key=str)\n[0, 1, 2, 'H', 'e', 'l', 'o']\n\nUse keywords to update specific node attributes for every node.\n\n>>> G.add_nodes_from([1, 2], size=10)\n>>> G.add_nodes_from([3, 4], weight=0.4)\n\nUse (node, attrdict) tuples to update attributes for specific nodes.\n\n>>> G.add_nodes_from([(1, dict(size=11)), (2, {\"color\": \"blue\"})])\n>>> G.nodes[1][\"size\"]\n11\n>>> H = nx.Graph()\n>>> H.add_nodes_from(G.nodes(data=True))\n>>> H.nodes[1][\"size\"]\n11\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.DiGraph([(0, 1), (1, 2), (3, 4)])\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_nodes_from(n + 1 for n in G.nodes)\n>>> # correct way\n>>> G.add_nodes_from(list(n + 1 for n in G.nodes))"}, {"type": "method", "name": "networkx.DiGraph.add_weighted_edges_from", "documentation": "Add weighted edges in `ebunch_to_add` with specified weight attr\n\nParameters\n----------\nebunch_to_add : container of edges\n    Each edge given in the list or container will be added\n    to the graph. The edges must be given as 3-tuples (u, v, w)\n    where w is a number.\nweight : string, optional (default= 'weight')\n    The attribute name for the edge weights to be added.\nattr : keyword arguments, optional (default= no attributes)\n    Edge attributes to add/update for all edges.\n\nSee Also\n--------\nadd_edge : add a single edge\nadd_edges_from : add multiple edges\n\nNotes\n-----\nAdding the same edge twice for Graph/DiGraph simply updates\nthe edge data. For MultiGraph/MultiDiGraph, duplicate edges\nare stored.\n\nWhen adding edges from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_edges)`, and pass this\nobject to `G.add_weighted_edges_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_weighted_edges_from([(0, 1, 3.0), (1, 2, 7.5)])\n\nEvaluate an iterator over edges before passing it\n\n>>> G = nx.Graph([(1, 2), (2, 3), (3, 4)])\n>>> weight = 0.1\n>>> # Grow graph by one new node, adding edges to all existing nodes.\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))\n>>> # correct way - note that there will be no self-edge for node 5\n>>> G.add_weighted_edges_from(list((5, n, weight) for n in G.nodes))"}, {"type": "method", "name": "networkx.DiGraph.adjacency", "documentation": "Returns an iterator over (node, adjacency dict) tuples for all nodes.\n\nFor directed graphs, only outgoing neighbors/adjacencies are included.\n\nReturns\n-------\nadj_iter : iterator\n   An iterator over (node, adjacency dictionary) for all nodes in\n   the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> [(n, nbrdict) for n, nbrdict in G.adjacency()]\n[(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]"}, {"type": "method", "name": "networkx.DiGraph.clear", "documentation": "Remove all nodes and edges from the graph.\n\nThis also removes the name, and all graph, node, and edge attributes.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.clear()\n>>> list(G.nodes)\n[]\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.DiGraph.clear_edges", "documentation": "Remove all edges from the graph without altering nodes.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.clear_edges()\n>>> list(G.nodes)\n[0, 1, 2, 3]\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.DiGraph.copy", "documentation": "Returns a copy of the graph.\n\nThe copy method by default returns an independent shallow copy\nof the graph and attributes. That is, if an attribute is a\ncontainer, that container is shared by the original an the copy.\nUse Python's `copy.deepcopy` for new containers.\n\nIf `as_view` is True then a view is returned instead of a copy.\n\nNotes\n-----\nAll copies reproduce the graph structure, but data attributes\nmay be handled in different ways. There are four types of copies\nof a graph that people might want.\n\nDeepcopy -- A \"deepcopy\" copies the graph structure as well as\nall data attributes and any objects they might contain.\nThe entire graph object is new so that changes in the copy\ndo not affect the original object. (see Python's copy.deepcopy)\n\nData Reference (Shallow) -- For a shallow copy the graph structure\nis copied but the edge, node and graph attribute dicts are\nreferences to those in the original graph. This saves\ntime and memory but could cause confusion if you change an attribute\nin one graph and it changes the attribute in the other.\nNetworkX does not provide this level of shallow copy.\n\nIndependent Shallow -- This copy creates new independent attribute\ndicts and then does a shallow copy of the attributes. That is, any\nattributes that are containers are shared between the new graph\nand the original. This is exactly what `dict.copy()` provides.\nYou can obtain this style copy using:\n\n    >>> G = nx.path_graph(5)\n    >>> H = G.copy()\n    >>> H = G.copy(as_view=False)\n    >>> H = nx.Graph(G)\n    >>> H = G.__class__(G)\n\nFresh Data -- For fresh data, the graph structure is copied while\nnew empty data attribute dicts are created. The resulting graph\nis independent of the original and it has no edge, node or graph\nattributes. Fresh copies are not enabled. Instead use:\n\n    >>> H = G.__class__()\n    >>> H.add_nodes_from(G)\n    >>> H.add_edges_from(G.edges)\n\nView -- Inspired by dict-views, graph-views act like read-only\nversions of the original graph, providing a copy of the original\nstructure without requiring any memory for copying the information.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nParameters\n----------\nas_view : bool, optional (default=False)\n    If True, the returned graph-view provides a read-only view\n    of the original graph without actually copying any data.\n\nReturns\n-------\nG : Graph\n    A copy of the graph.\n\nSee Also\n--------\nto_directed: return a directed copy of the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> H = G.copy()"}, {"type": "method", "name": "networkx.DiGraph.edge_subgraph", "documentation": "Returns the subgraph induced by the specified edges.\n\nThe induced subgraph contains each edge in `edges` and each\nnode incident to any one of those edges.\n\nParameters\n----------\nedges : iterable\n    An iterable of edges in this graph.\n\nReturns\n-------\nG : Graph\n    An edge-induced subgraph of this graph with the same edge\n    attributes.\n\nNotes\n-----\nThe graph, edge, and node attributes in the returned subgraph\nview are references to the corresponding attributes in the original\ngraph. The view is read-only.\n\nTo create a full graph version of the subgraph with its own copy\nof the edge or node attributes, use::\n\n    G.edge_subgraph(edges).copy()\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> H = G.edge_subgraph([(0, 1), (3, 4)])\n>>> list(H.nodes)\n[0, 1, 3, 4]\n>>> list(H.edges)\n[(0, 1), (3, 4)]"}, {"type": "method", "name": "networkx.DiGraph.get_edge_data", "documentation": "Returns the attribute dictionary associated with edge (u, v).\n\nThis is identical to `G[u][v]` except the default is returned\ninstead of an exception if the edge doesn't exist.\n\nParameters\n----------\nu, v : nodes\ndefault:  any Python object (default=None)\n    Value to return if the edge (u, v) is not found.\n\nReturns\n-------\nedge_dict : dictionary\n    The edge attribute dictionary.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G[0][1]\n{}\n\nWarning: Assigning to `G[u][v]` is not permitted.\nBut it is safe to assign attributes `G[u][v]['foo']`\n\n>>> G[0][1][\"weight\"] = 7\n>>> G[0][1][\"weight\"]\n7\n>>> G[1][0][\"weight\"]\n7\n\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.get_edge_data(0, 1)  # default edge data is {}\n{}\n>>> e = (0, 1)\n>>> G.get_edge_data(*e)  # tuple form\n{}\n>>> G.get_edge_data(\"a\", \"b\", default=0)  # edge not in graph, return 0\n0"}, {"type": "method", "name": "networkx.DiGraph.has_edge", "documentation": "Returns True if the edge (u, v) is in the graph.\n\nThis is the same as `v in G[u]` without KeyError exceptions.\n\nParameters\n----------\nu, v : nodes\n    Nodes can be, for example, strings or numbers.\n    Nodes must be hashable (and not None) Python objects.\n\nReturns\n-------\nedge_ind : bool\n    True if edge is in the graph, False otherwise.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.has_edge(0, 1)  # using two nodes\nTrue\n>>> e = (0, 1)\n>>> G.has_edge(*e)  #  e is a 2-tuple (u, v)\nTrue\n>>> e = (0, 1, {\"weight\": 7})\n>>> G.has_edge(*e[:2])  # e is a 3-tuple (u, v, data_dictionary)\nTrue\n\nThe following syntax are equivalent:\n\n>>> G.has_edge(0, 1)\nTrue\n>>> 1 in G[0]  # though this gives KeyError if 0 not in G\nTrue"}, {"type": "method", "name": "networkx.DiGraph.has_node", "documentation": "Returns True if the graph contains the node n.\n\nIdentical to `n in G`\n\nParameters\n----------\nn : node\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.has_node(0)\nTrue\n\nIt is more readable and simpler to use\n\n>>> 0 in G\nTrue"}, {"type": "method", "name": "networkx.DiGraph.has_predecessor", "documentation": "Returns True if node u has predecessor v.\n\nThis is true if graph has the edge u<-v."}, {"type": "method", "name": "networkx.DiGraph.has_successor", "documentation": "Returns True if node u has successor v.\n\nThis is true if graph has the edge u->v."}, {"type": "method", "name": "networkx.DiGraph.is_directed", "documentation": "Returns True if graph is directed, False otherwise."}, {"type": "method", "name": "networkx.DiGraph.is_multigraph", "documentation": "Returns True if graph is a multigraph, False otherwise."}, {"type": "method", "name": "networkx.DiGraph.nbunch_iter", "documentation": "Returns an iterator over nodes contained in nbunch that are\nalso in the graph.\n\nThe nodes in nbunch are checked for membership in the graph\nand if not are silently ignored.\n\nParameters\n----------\nnbunch : single node, container, or all nodes (default= all nodes)\n    The view will only report edges incident to these nodes.\n\nReturns\n-------\nniter : iterator\n    An iterator over nodes in nbunch that are also in the graph.\n    If nbunch is None, iterate over all nodes in the graph.\n\nRaises\n------\nNetworkXError\n    If nbunch is not a node or sequence of nodes.\n    If a node in nbunch is not hashable.\n\nSee Also\n--------\nGraph.__iter__\n\nNotes\n-----\nWhen nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted.\n\nTo test whether nbunch is a single node, one can use\n\"if nbunch in self:\", even after processing with this routine.\n\nIf nbunch is not a node or a (possibly empty) sequence/iterator\nor None, a :exc:`NetworkXError` is raised.  Also, if any object in\nnbunch is not hashable, a :exc:`NetworkXError` is raised."}, {"type": "method", "name": "networkx.DiGraph.neighbors", "documentation": "Returns an iterator over successor nodes of n.\n\nA successor of n is a node m such that there exists a directed\nedge from n to m.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\npredecessors\n\nNotes\n-----\nneighbors() and successors() are the same."}, {"type": "method", "name": "networkx.DiGraph.number_of_edges", "documentation": "Returns the number of edges between two nodes.\n\nParameters\n----------\nu, v : nodes, optional (default=all edges)\n    If u and v are specified, return the number of edges between\n    u and v. Otherwise return the total number of all edges.\n\nReturns\n-------\nnedges : int\n    The number of edges in the graph.  If nodes `u` and `v` are\n    specified return the number of edges between those nodes. If\n    the graph is directed, this only returns the number of edges\n    from `u` to `v`.\n\nSee Also\n--------\nsize\n\nExamples\n--------\nFor undirected graphs, this method counts the total number of\nedges in the graph:\n\n>>> G = nx.path_graph(4)\n>>> G.number_of_edges()\n3\n\nIf you specify two nodes, this counts the total number of edges\njoining the two nodes:\n\n>>> G.number_of_edges(0, 1)\n1\n\nFor directed graphs, this method can count the total number of\ndirected edges from `u` to `v`:\n\n>>> G = nx.DiGraph()\n>>> G.add_edge(0, 1)\n>>> G.add_edge(1, 0)\n>>> G.number_of_edges(0, 1)\n1"}, {"type": "method", "name": "networkx.DiGraph.number_of_nodes", "documentation": "Returns the number of nodes in the graph.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\norder: identical method\n__len__: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.number_of_nodes()\n3"}, {"type": "method", "name": "networkx.DiGraph.order", "documentation": "Returns the number of nodes in the graph.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\nnumber_of_nodes: identical method\n__len__: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.order()\n3"}, {"type": "method", "name": "networkx.DiGraph.predecessors", "documentation": "Returns an iterator over predecessor nodes of n.\n\nA predecessor of n is a node m such that there exists a directed\nedge from m to n.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\nsuccessors"}, {"type": "method", "name": "networkx.DiGraph.remove_edge", "documentation": "Remove the edge between u and v.\n\nParameters\n----------\nu, v : nodes\n    Remove the edge between nodes u and v.\n\nRaises\n------\nNetworkXError\n    If there is not an edge between u and v.\n\nSee Also\n--------\nremove_edges_from : remove a collection of edges\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, etc\n>>> nx.add_path(G, [0, 1, 2, 3])\n>>> G.remove_edge(0, 1)\n>>> e = (1, 2)\n>>> G.remove_edge(*e)  # unpacks e from an edge tuple\n>>> e = (2, 3, {\"weight\": 7})  # an edge with attribute data\n>>> G.remove_edge(*e[:2])  # select first part of edge tuple"}, {"type": "method", "name": "networkx.DiGraph.remove_edges_from", "documentation": "Remove all edges specified in ebunch.\n\nParameters\n----------\nebunch: list or container of edge tuples\n    Each edge given in the list or container will be removed\n    from the graph. The edges can be:\n\n        - 2-tuples (u, v) edge between u and v.\n        - 3-tuples (u, v, k) where k is ignored.\n\nSee Also\n--------\nremove_edge : remove a single edge\n\nNotes\n-----\nWill fail silently if an edge in ebunch is not in the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> ebunch = [(1, 2), (2, 3)]\n>>> G.remove_edges_from(ebunch)"}, {"type": "method", "name": "networkx.DiGraph.remove_node", "documentation": "Remove node n.\n\nRemoves the node n and all adjacent edges.\nAttempting to remove a nonexistent node will raise an exception.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\nremove_nodes_from\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> list(G.edges)\n[(0, 1), (1, 2)]\n>>> G.remove_node(1)\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.DiGraph.remove_nodes_from", "documentation": "Remove multiple nodes.\n\nParameters\n----------\nnodes : iterable container\n    A container of nodes (list, dict, set, etc.).  If a node\n    in the container is not in the graph it is silently ignored.\n\nSee Also\n--------\nremove_node\n\nNotes\n-----\nWhen removing nodes from an iterator over the graph you are changing,\na `RuntimeError` will be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_nodes)`, and pass this\nobject to `G.remove_nodes_from`.\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> e = list(G.nodes)\n>>> e\n[0, 1, 2]\n>>> G.remove_nodes_from(e)\n>>> list(G.nodes)\n[]\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.DiGraph([(0, 1), (1, 2), (3, 4)])\n>>> # this command will fail, as the graph's dict is modified during iteration\n>>> # G.remove_nodes_from(n for n in G.nodes if n < 2)\n>>> # this command will work, since the dictionary underlying graph is not modified\n>>> G.remove_nodes_from(list(n for n in G.nodes if n < 2))"}, {"type": "method", "name": "networkx.DiGraph.reverse", "documentation": "Returns the reverse of the graph.\n\nThe reverse is a graph with the same nodes and edges\nbut with the directions of the edges reversed.\n\nParameters\n----------\ncopy : bool optional (default=True)\n    If True, return a new DiGraph holding the reversed edges.\n    If False, the reverse graph is created using a view of\n    the original graph."}, {"type": "method", "name": "networkx.DiGraph.size", "documentation": "Returns the number of edges or total of all edge weights.\n\nParameters\n----------\nweight : string or None, optional (default=None)\n    The edge attribute that holds the numerical value used\n    as a weight. If None, then each edge has weight 1.\n\nReturns\n-------\nsize : numeric\n    The number of edges or\n    (if weight keyword is provided) the total weight sum.\n\n    If weight is None, returns an int. Otherwise a float\n    (or more general numeric if the weights are more general).\n\nSee Also\n--------\nnumber_of_edges\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.size()\n3\n\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edge(\"a\", \"b\", weight=2)\n>>> G.add_edge(\"b\", \"c\", weight=4)\n>>> G.size()\n2\n>>> G.size(weight=\"weight\")\n6.0"}, {"type": "method", "name": "networkx.DiGraph.subgraph", "documentation": "Returns a SubGraph view of the subgraph induced on `nodes`.\n\nThe induced subgraph of the graph contains the nodes in `nodes`\nand the edges between those nodes.\n\nParameters\n----------\nnodes : list, iterable\n    A container of nodes which will be iterated through once.\n\nReturns\n-------\nG : SubGraph View\n    A subgraph view of the graph. The graph structure cannot be\n    changed but node/edge attributes can and are shared with the\n    original graph.\n\nNotes\n-----\nThe graph, edge and node attributes are shared with the original graph.\nChanges to the graph structure is ruled out by the view, but changes\nto attributes are reflected in the original graph.\n\nTo create a subgraph with its own copy of the edge/node attributes use:\nG.subgraph(nodes).copy()\n\nFor an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([n for n in G if n not in set(nodes)])\n\nSubgraph views are sometimes NOT what you want. In most cases where\nyou want to do more than simply look at the induced edges, it makes\nmore sense to just create the subgraph as its own graph with code like:\n\n::\n\n    # Create a subgraph SG based on a (possibly multigraph) G\n    SG = G.__class__()\n    SG.add_nodes_from((n, G.nodes[n]) for n in largest_wcc)\n    if SG.is_multigraph():\n        SG.add_edges_from(\n            (n, nbr, key, d)\n            for n, nbrs in G.adj.items()\n            if n in largest_wcc\n            for nbr, keydict in nbrs.items()\n            if nbr in largest_wcc\n            for key, d in keydict.items()\n        )\n    else:\n        SG.add_edges_from(\n            (n, nbr, d)\n            for n, nbrs in G.adj.items()\n            if n in largest_wcc\n            for nbr, d in nbrs.items()\n            if nbr in largest_wcc\n        )\n    SG.graph.update(G.graph)\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> H = G.subgraph([0, 1, 2])\n>>> list(H.edges)\n[(0, 1), (1, 2)]"}, {"type": "method", "name": "networkx.DiGraph.successors", "documentation": "Returns an iterator over successor nodes of n.\n\nA successor of n is a node m such that there exists a directed\nedge from n to m.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\npredecessors\n\nNotes\n-----\nneighbors() and successors() are the same."}, {"type": "method", "name": "networkx.DiGraph.to_directed", "documentation": "Returns a directed representation of the graph.\n\nReturns\n-------\nG : DiGraph\n    A directed graph with the same name, same nodes, and with\n    each edge (u, v, data) replaced by two directed edges\n    (u, v, data) and (v, u, data).\n\nNotes\n-----\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar D=DiGraph(G) which returns a\nshallow copy of the data.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nWarning: If you have subclassed Graph to use dict-like objects\nin the data structure, those changes do not transfer to the\nDiGraph created by this method.\n\nExamples\n--------\n>>> G = nx.Graph()  # or MultiGraph, etc\n>>> G.add_edge(0, 1)\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1), (1, 0)]\n\nIf already directed, return a (deep) copy\n\n>>> G = nx.DiGraph()  # or MultiDiGraph, etc\n>>> G.add_edge(0, 1)\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1)]"}, {"type": "method", "name": "networkx.DiGraph.to_directed_class", "documentation": "Returns the class to use for empty directed copies.\n\nIf you subclass the base classes, use this to designate\nwhat directed class to use for `to_directed()` copies."}, {"type": "method", "name": "networkx.DiGraph.to_undirected", "documentation": "Returns an undirected representation of the digraph.\n\nParameters\n----------\nreciprocal : bool (optional)\n  If True only keep edges that appear in both directions\n  in the original digraph.\nas_view : bool (optional, default=False)\n  If True return an undirected view of the original directed graph.\n\nReturns\n-------\nG : Graph\n    An undirected graph with the same name and nodes and\n    with edge (u, v, data) if either (u, v, data) or (v, u, data)\n    is in the digraph.  If both edges exist in digraph and\n    their edge data is different, only one edge is created\n    with an arbitrary choice of which edge data to use.\n    You must check and correct for this manually if desired.\n\nSee Also\n--------\nGraph, copy, add_edge, add_edges_from\n\nNotes\n-----\nIf edges in both directions (u, v) and (v, u) exist in the\ngraph, attributes for the new undirected edge will be a combination of\nthe attributes of the directed edges.  The edge data is updated\nin the (arbitrary) order that the edges are encountered.  For\nmore customized control of the edge attributes use add_edge().\n\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar G=DiGraph(D) which returns a\nshallow copy of the data.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nWarning: If you have subclassed DiGraph to use dict-like objects\nin the data structure, those changes do not transfer to the\nGraph created by this method.\n\nExamples\n--------\n>>> G = nx.path_graph(2)  # or MultiGraph, etc\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1), (1, 0)]\n>>> G2 = H.to_undirected()\n>>> list(G2.edges)\n[(0, 1)]"}, {"type": "method", "name": "networkx.DiGraph.to_undirected_class", "documentation": "Returns the class to use for empty undirected copies.\n\nIf you subclass the base classes, use this to designate\nwhat directed class to use for `to_directed()` copies."}, {"type": "method", "name": "networkx.DiGraph.update", "documentation": "Update the graph using nodes/edges/graphs as input.\n\nLike dict.update, this method takes a graph as input, adding the\ngraph's nodes and edges to this graph. It can also take two inputs:\nedges and nodes. Finally it can take either edges or nodes.\nTo specify only nodes the keyword `nodes` must be used.\n\nThe collections of edges and nodes are treated similarly to\nthe add_edges_from/add_nodes_from methods. When iterated, they\nshould yield 2-tuples (u, v) or 3-tuples (u, v, datadict).\n\nParameters\n----------\nedges : Graph object, collection of edges, or None\n    The first parameter can be a graph or some edges. If it has\n    attributes `nodes` and `edges`, then it is taken to be a\n    Graph-like object and those attributes are used as collections\n    of nodes and edges to be added to the graph.\n    If the first parameter does not have those attributes, it is\n    treated as a collection of edges and added to the graph.\n    If the first argument is None, no edges are added.\nnodes : collection of nodes, or None\n    The second parameter is treated as a collection of nodes\n    to be added to the graph unless it is None.\n    If `edges is None` and `nodes is None` an exception is raised.\n    If the first parameter is a Graph, then `nodes` is ignored.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> G.update(nx.complete_graph(range(4, 10)))\n>>> from itertools import combinations\n>>> edges = (\n...     (u, v, {\"power\": u * v})\n...     for u, v in combinations(range(10, 20), 2)\n...     if u * v < 225\n... )\n>>> nodes = [1000]  # for singleton, use a container\n>>> G.update(edges, nodes)\n\nNotes\n-----\nIt you want to update the graph using an adjacency structure\nit is straightforward to obtain the edges/nodes from adjacency.\nThe following examples provide common cases, your adjacency may\nbe slightly different and require tweaks of these examples::\n\n>>> # dict-of-set/list/tuple\n>>> adj = {1: {2, 3}, 2: {1, 3}, 3: {1, 2}}\n>>> e = [(u, v) for u, nbrs in adj.items() for v in nbrs]\n>>> G.update(edges=e, nodes=adj)\n\n>>> DG = nx.DiGraph()\n>>> # dict-of-dict-of-attribute\n>>> adj = {1: {2: 1.3, 3: 0.7}, 2: {1: 1.4}, 3: {1: 0.7}}\n>>> e = [(u, v, {\"weight\": d}) for u, nbrs in adj.items() for v, d in nbrs.items()]\n>>> DG.update(edges=e, nodes=adj)\n\n>>> # dict-of-dict-of-dict\n>>> adj = {1: {2: {\"weight\": 1.3}, 3: {\"color\": 0.7, \"weight\": 1.2}}}\n>>> e = [(u, v, {\"weight\": d}) for u, nbrs in adj.items() for v, d in nbrs.items()]\n>>> DG.update(edges=e, nodes=adj)\n\n>>> # predecessor adjacency (dict-of-set)\n>>> pred = {1: {2, 3}, 2: {3}, 3: {3}}\n>>> e = [(v, u) for u, nbrs in pred.items() for v in nbrs]\n\n>>> # MultiGraph dict-of-dict-of-dict-of-attribute\n>>> MDG = nx.MultiDiGraph()\n>>> adj = {\n...     1: {2: {0: {\"weight\": 1.3}, 1: {\"weight\": 1.2}}},\n...     3: {2: {0: {\"weight\": 0.7}}},\n... }\n>>> e = [\n...     (u, v, ekey, d)\n...     for u, nbrs in adj.items()\n...     for v, keydict in nbrs.items()\n...     for ekey, d in keydict.items()\n... ]\n>>> MDG.update(edges=e)\n\nSee Also\n--------\nadd_edges_from: add multiple edges to a graph\nadd_nodes_from: add multiple nodes to a graph"}, {"type": "class", "name": "networkx.EdgePartition", "documentation": "An enum to store the state of an edge partition. The enum is written to the\nedges of a graph before being pasted to `kruskal_mst_edges`. Options are:\n\n- EdgePartition.OPEN\n- EdgePartition.INCLUDED\n- EdgePartition.EXCLUDED"}, {"type": "class", "name": "networkx.ExceededMaxIterations", "documentation": "Raised if a loop iterates too many times without breaking.\n\nThis may occur, for example, in an algorithm that computes\nprogressively better approximations to a value but exceeds an\niteration bound specified by the user."}, {"type": "class", "name": "networkx.Graph", "documentation": "Base class for undirected graphs.\n\nA Graph stores nodes and edges with optional data, or attributes.\n\nGraphs hold undirected edges.  Self loops are allowed but multiple\n(parallel) edges are not.\n\nNodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes, except that `None` is not allowed as a node.\n\nEdges are represented as links between nodes with optional\nkey/value attributes.\n\nParameters\n----------\nincoming_graph_data : input graph (optional, default: None)\n    Data to initialize graph. If None (default) an empty\n    graph is created.  The data can be any format that is supported\n    by the to_networkx_graph() function, currently including edge list,\n    dict of dicts, dict of lists, NetworkX graph, 2D NumPy array, SciPy\n    sparse matrix, or PyGraphviz graph.\n\nattr : keyword arguments, optional (default= no attributes)\n    Attributes to add to graph as key=value pairs.\n\nSee Also\n--------\nDiGraph\nMultiGraph\nMultiDiGraph\n\nExamples\n--------\nCreate an empty graph structure (a \"null graph\") with no nodes and\nno edges.\n\n>>> G = nx.Graph()\n\nG can be grown in several ways.\n\n**Nodes:**\n\nAdd one node at a time:\n\n>>> G.add_node(1)\n\nAdd the nodes from any container (a list, dict, set or\neven the lines from a file or the nodes from another graph).\n\n>>> G.add_nodes_from([2, 3])\n>>> G.add_nodes_from(range(100, 110))\n>>> H = nx.path_graph(10)\n>>> G.add_nodes_from(H)\n\nIn addition to strings and integers any hashable Python object\n(except None) can represent a node, e.g. a customized node object,\nor even another Graph.\n\n>>> G.add_node(H)\n\n**Edges:**\n\nG can also be grown by adding edges.\n\nAdd one edge,\n\n>>> G.add_edge(1, 2)\n\na list of edges,\n\n>>> G.add_edges_from([(1, 2), (1, 3)])\n\nor a collection of edges,\n\n>>> G.add_edges_from(H.edges)\n\nIf some edges connect nodes not yet in the graph, the nodes\nare added automatically.  There are no errors when adding\nnodes or edges that already exist.\n\n**Attributes:**\n\nEach graph, node, and edge can hold key/value attribute pairs\nin an associated attribute dictionary (the keys must be hashable).\nBy default these are empty, but can be added or changed using\nadd_edge, add_node or direct manipulation of the attribute\ndictionaries named graph, node and edge respectively.\n\n>>> G = nx.Graph(day=\"Friday\")\n>>> G.graph\n{'day': 'Friday'}\n\nAdd node attributes using add_node(), add_nodes_from() or G.nodes\n\n>>> G.add_node(1, time=\"5pm\")\n>>> G.add_nodes_from([3], time=\"2pm\")\n>>> G.nodes[1]\n{'time': '5pm'}\n>>> G.nodes[1][\"room\"] = 714  # node must exist already to use G.nodes\n>>> del G.nodes[1][\"room\"]  # remove attribute\n>>> list(G.nodes(data=True))\n[(1, {'time': '5pm'}), (3, {'time': '2pm'})]\n\nAdd edge attributes using add_edge(), add_edges_from(), subscript\nnotation, or G.edges.\n\n>>> G.add_edge(1, 2, weight=4.7)\n>>> G.add_edges_from([(3, 4), (4, 5)], color=\"red\")\n>>> G.add_edges_from([(1, 2, {\"color\": \"blue\"}), (2, 3, {\"weight\": 8})])\n>>> G[1][2][\"weight\"] = 4.7\n>>> G.edges[1, 2][\"weight\"] = 4\n\nWarning: we protect the graph data structure by making `G.edges` a\nread-only dict-like structure. However, you can assign to attributes\nin e.g. `G.edges[1, 2]`. Thus, use 2 sets of brackets to add/change\ndata attributes: `G.edges[1, 2]['weight'] = 4`\n(For multigraphs: `MG.edges[u, v, key][name] = value`).\n\n**Shortcuts:**\n\nMany common graph features allow python syntax to speed reporting.\n\n>>> 1 in G  # check if node in graph\nTrue\n>>> [n for n in G if n < 3]  # iterate through nodes\n[1, 2]\n>>> len(G)  # number of nodes in graph\n5\n\nOften the best way to traverse all edges of a graph is via the neighbors.\nThe neighbors are reported as an adjacency-dict `G.adj` or `G.adjacency()`\n\n>>> for n, nbrsdict in G.adjacency():\n...     for nbr, eattr in nbrsdict.items():\n...         if \"weight\" in eattr:\n...             # Do something useful with the edges\n...             pass\n\nBut the edges() method is often more convenient:\n\n>>> for u, v, weight in G.edges.data(\"weight\"):\n...     if weight is not None:\n...         # Do something useful with the edges\n...         pass\n\n**Reporting:**\n\nSimple graph information is obtained using object-attributes and methods.\nReporting typically provides views instead of containers to reduce memory\nusage. The views update as the graph is updated similarly to dict-views.\nThe objects `nodes`, `edges` and `adj` provide access to data attributes\nvia lookup (e.g. `nodes[n]`, `edges[u, v]`, `adj[u][v]`) and iteration\n(e.g. `nodes.items()`, `nodes.data('color')`,\n`nodes.data('color', default='blue')` and similarly for `edges`)\nViews exist for `nodes`, `edges`, `neighbors()`/`adj` and `degree`.\n\nFor details on these and other miscellaneous methods, see below.\n\n**Subclasses (Advanced):**\n\nThe Graph class uses a dict-of-dict-of-dict data structure.\nThe outer dict (node_dict) holds adjacency information keyed by node.\nThe next dict (adjlist_dict) represents the adjacency information and holds\nedge data keyed by neighbor.  The inner dict (edge_attr_dict) represents\nthe edge data and holds edge attribute values keyed by attribute names.\n\nEach of these three dicts can be replaced in a subclass by a user defined\ndict-like object. In general, the dict-like features should be\nmaintained but extra features can be added. To replace one of the\ndicts create a new graph class by changing the class(!) variable\nholding the factory for that dict-like structure.\n\nnode_dict_factory : function, (default: dict)\n    Factory function to be used to create the dict containing node\n    attributes, keyed by node id.\n    It should require no arguments and return a dict-like object\n\nnode_attr_dict_factory: function, (default: dict)\n    Factory function to be used to create the node attribute\n    dict which holds attribute values keyed by attribute name.\n    It should require no arguments and return a dict-like object\n\nadjlist_outer_dict_factory : function, (default: dict)\n    Factory function to be used to create the outer-most dict\n    in the data structure that holds adjacency info keyed by node.\n    It should require no arguments and return a dict-like object.\n\nadjlist_inner_dict_factory : function, (default: dict)\n    Factory function to be used to create the adjacency list\n    dict which holds edge data keyed by neighbor.\n    It should require no arguments and return a dict-like object\n\nedge_attr_dict_factory : function, (default: dict)\n    Factory function to be used to create the edge attribute\n    dict which holds attribute values keyed by attribute name.\n    It should require no arguments and return a dict-like object.\n\ngraph_attr_dict_factory : function, (default: dict)\n    Factory function to be used to create the graph attribute\n    dict which holds attribute values keyed by attribute name.\n    It should require no arguments and return a dict-like object.\n\nTypically, if your extension doesn't impact the data structure all\nmethods will inherit without issue except: `to_directed/to_undirected`.\nBy default these methods create a DiGraph/Graph class and you probably\nwant them to create your extension of a DiGraph/Graph. To facilitate\nthis we define two class variables that you can set in your subclass.\n\nto_directed_class : callable, (default: DiGraph or MultiDiGraph)\n    Class to create a new graph structure in the `to_directed` method.\n    If `None`, a NetworkX class (DiGraph or MultiDiGraph) is used.\n\nto_undirected_class : callable, (default: Graph or MultiGraph)\n    Class to create a new graph structure in the `to_undirected` method.\n    If `None`, a NetworkX class (Graph or MultiGraph) is used.\n\n**Subclassing Example**\n\nCreate a low memory graph class that effectively disallows edge\nattributes by using a single attribute dict for all edges.\nThis reduces the memory used, but you lose edge attributes.\n\n>>> class ThinGraph(nx.Graph):\n...     all_edge_dict = {\"weight\": 1}\n...\n...     def single_edge_dict(self):\n...         return self.all_edge_dict\n...\n...     edge_attr_dict_factory = single_edge_dict\n>>> G = ThinGraph()\n>>> G.add_edge(2, 1)\n>>> G[2][1]\n{'weight': 1}\n>>> G.add_edge(2, 2)\n>>> G[2][1] is G[2][2]\nTrue"}, {"type": "method", "name": "networkx.Graph.__contains__", "documentation": "Returns True if n is a node, False otherwise. Use: 'n in G'.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> 1 in G\nTrue"}, {"type": "method", "name": "networkx.Graph.__getitem__", "documentation": "Returns a dict of neighbors of node n.  Use: 'G[n]'.\n\nParameters\n----------\nn : node\n   A node in the graph.\n\nReturns\n-------\nadj_dict : dictionary\n   The adjacency dictionary for nodes connected to n.\n\nNotes\n-----\nG[n] is the same as G.adj[n] and similar to G.neighbors(n)\n(which is an iterator over G.adj[n])\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G[0]\nAtlasView({1: {}})"}, {"type": "method", "name": "networkx.Graph.__init__", "documentation": "Initialize a graph with edges, name, or graph attributes.\n\nParameters\n----------\nincoming_graph_data : input graph (optional, default: None)\n    Data to initialize graph. If None (default) an empty\n    graph is created.  The data can be an edge list, or any\n    NetworkX graph object.  If the corresponding optional Python\n    packages are installed the data can also be a 2D NumPy array, a\n    SciPy sparse array, or a PyGraphviz graph.\n\nattr : keyword arguments, optional (default= no attributes)\n    Attributes to add to graph as key=value pairs.\n\nSee Also\n--------\nconvert\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G = nx.Graph(name=\"my graph\")\n>>> e = [(1, 2), (2, 3), (3, 4)]  # list of edges\n>>> G = nx.Graph(e)\n\nArbitrary graph attribute pairs (key=value) may be assigned\n\n>>> G = nx.Graph(e, day=\"Friday\")\n>>> G.graph\n{'day': 'Friday'}"}, {"type": "method", "name": "networkx.Graph.__iter__", "documentation": "Iterate over the nodes. Use: 'for n in G'.\n\nReturns\n-------\nniter : iterator\n    An iterator over all nodes in the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> [n for n in G]\n[0, 1, 2, 3]\n>>> list(G)\n[0, 1, 2, 3]"}, {"type": "method", "name": "networkx.Graph.__len__", "documentation": "Returns the number of nodes in the graph. Use: 'len(G)'.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\nnumber_of_nodes: identical method\norder: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> len(G)\n4"}, {"type": "method", "name": "networkx.Graph.__str__", "documentation": "Returns a short summary of the graph.\n\nReturns\n-------\ninfo : string\n    Graph information including the graph name (if any), graph type, and the\n    number of nodes and edges.\n\nExamples\n--------\n>>> G = nx.Graph(name=\"foo\")\n>>> str(G)\n\"Graph named 'foo' with 0 nodes and 0 edges\"\n\n>>> G = nx.path_graph(3)\n>>> str(G)\n'Graph with 3 nodes and 2 edges'"}, {"type": "method", "name": "networkx.Graph.add_edge", "documentation": "Add an edge between u and v.\n\nThe nodes u and v will be automatically added if they are\nnot already in the graph.\n\nEdge attributes can be specified with keywords or by directly\naccessing the edge's attribute dictionary. See examples below.\n\nParameters\n----------\nu_of_edge, v_of_edge : nodes\n    Nodes can be, for example, strings or numbers.\n    Nodes must be hashable (and not None) Python objects.\nattr : keyword arguments, optional\n    Edge data (or labels or objects) can be assigned using\n    keyword arguments.\n\nSee Also\n--------\nadd_edges_from : add a collection of edges\n\nNotes\n-----\nAdding an edge that already exists updates the edge data.\n\nMany NetworkX algorithms designed for weighted graphs use\nan edge attribute (by default `weight`) to hold a numerical value.\n\nExamples\n--------\nThe following all add the edge e=(1, 2) to graph G:\n\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> e = (1, 2)\n>>> G.add_edge(1, 2)  # explicit two-node form\n>>> G.add_edge(*e)  # single edge as tuple of two nodes\n>>> G.add_edges_from([(1, 2)])  # add edges from iterable container\n\nAssociate data to edges using keywords:\n\n>>> G.add_edge(1, 2, weight=3)\n>>> G.add_edge(1, 3, weight=7, capacity=15, length=342.7)\n\nFor non-string attribute keys, use subscript notation.\n\n>>> G.add_edge(1, 2)\n>>> G[1][2].update({0: 5})\n>>> G.edges[1, 2].update({0: 5})"}, {"type": "method", "name": "networkx.Graph.add_edges_from", "documentation": "Add all the edges in ebunch_to_add.\n\nParameters\n----------\nebunch_to_add : container of edges\n    Each edge given in the container will be added to the\n    graph. The edges must be given as 2-tuples (u, v) or\n    3-tuples (u, v, d) where d is a dictionary containing edge data.\nattr : keyword arguments, optional\n    Edge data (or labels or objects) can be assigned using\n    keyword arguments.\n\nSee Also\n--------\nadd_edge : add a single edge\nadd_weighted_edges_from : convenient way to add weighted edges\n\nNotes\n-----\nAdding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added.\n\nEdge attributes specified in an ebunch take precedence over\nattributes specified via keyword arguments.\n\nWhen adding edges from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_edges)`, and pass this\nobject to `G.add_edges_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edges_from([(0, 1), (1, 2)])  # using a list of edge tuples\n>>> e = zip(range(0, 3), range(1, 4))\n>>> G.add_edges_from(e)  # Add the path graph 0-1-2-3\n\nAssociate data to edges\n\n>>> G.add_edges_from([(1, 2), (2, 3)], weight=3)\n>>> G.add_edges_from([(3, 4), (1, 4)], label=\"WN2898\")\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.Graph([(1, 2), (2, 3), (3, 4)])\n>>> # Grow graph by one new node, adding edges to all existing nodes.\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_edges_from(((5, n) for n in G.nodes))\n>>> # correct way - note that there will be no self-edge for node 5\n>>> G.add_edges_from(list((5, n) for n in G.nodes))"}, {"type": "method", "name": "networkx.Graph.add_node", "documentation": "Add a single node `node_for_adding` and update node attributes.\n\nParameters\n----------\nnode_for_adding : node\n    A node can be any hashable Python object except None.\nattr : keyword arguments, optional\n    Set or change node attributes using key=value.\n\nSee Also\n--------\nadd_nodes_from\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_node(1)\n>>> G.add_node(\"Hello\")\n>>> K3 = nx.Graph([(0, 1), (1, 2), (2, 0)])\n>>> G.add_node(K3)\n>>> G.number_of_nodes()\n3\n\nUse keywords set/change node attributes:\n\n>>> G.add_node(1, size=10)\n>>> G.add_node(3, weight=0.4, UTM=(\"13S\", 382871, 3972649))\n\nNotes\n-----\nA hashable object is one that can be used as a key in a Python\ndictionary. This includes strings, numbers, tuples of strings\nand numbers, etc.\n\nOn many platforms hashable items also include mutables such as\nNetworkX Graphs, though one should be careful that the hash\ndoesn't change on mutables."}, {"type": "method", "name": "networkx.Graph.add_nodes_from", "documentation": "Add multiple nodes.\n\nParameters\n----------\nnodes_for_adding : iterable container\n    A container of nodes (list, dict, set, etc.).\n    OR\n    A container of (node, attribute dict) tuples.\n    Node attributes are updated using the attribute dict.\nattr : keyword arguments, optional (default= no attributes)\n    Update attributes for all nodes in nodes.\n    Node attributes specified in nodes as a tuple take\n    precedence over attributes specified via keyword arguments.\n\nSee Also\n--------\nadd_node\n\nNotes\n-----\nWhen adding nodes from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_nodes)`, and pass this\nobject to `G.add_nodes_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_nodes_from(\"Hello\")\n>>> K3 = nx.Graph([(0, 1), (1, 2), (2, 0)])\n>>> G.add_nodes_from(K3)\n>>> sorted(G.nodes(), key=str)\n[0, 1, 2, 'H', 'e', 'l', 'o']\n\nUse keywords to update specific node attributes for every node.\n\n>>> G.add_nodes_from([1, 2], size=10)\n>>> G.add_nodes_from([3, 4], weight=0.4)\n\nUse (node, attrdict) tuples to update attributes for specific nodes.\n\n>>> G.add_nodes_from([(1, dict(size=11)), (2, {\"color\": \"blue\"})])\n>>> G.nodes[1][\"size\"]\n11\n>>> H = nx.Graph()\n>>> H.add_nodes_from(G.nodes(data=True))\n>>> H.nodes[1][\"size\"]\n11\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.Graph([(0, 1), (1, 2), (3, 4)])\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_nodes_from(n + 1 for n in G.nodes)\n>>> # correct way\n>>> G.add_nodes_from(list(n + 1 for n in G.nodes))"}, {"type": "method", "name": "networkx.Graph.add_weighted_edges_from", "documentation": "Add weighted edges in `ebunch_to_add` with specified weight attr\n\nParameters\n----------\nebunch_to_add : container of edges\n    Each edge given in the list or container will be added\n    to the graph. The edges must be given as 3-tuples (u, v, w)\n    where w is a number.\nweight : string, optional (default= 'weight')\n    The attribute name for the edge weights to be added.\nattr : keyword arguments, optional (default= no attributes)\n    Edge attributes to add/update for all edges.\n\nSee Also\n--------\nadd_edge : add a single edge\nadd_edges_from : add multiple edges\n\nNotes\n-----\nAdding the same edge twice for Graph/DiGraph simply updates\nthe edge data. For MultiGraph/MultiDiGraph, duplicate edges\nare stored.\n\nWhen adding edges from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_edges)`, and pass this\nobject to `G.add_weighted_edges_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_weighted_edges_from([(0, 1, 3.0), (1, 2, 7.5)])\n\nEvaluate an iterator over edges before passing it\n\n>>> G = nx.Graph([(1, 2), (2, 3), (3, 4)])\n>>> weight = 0.1\n>>> # Grow graph by one new node, adding edges to all existing nodes.\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))\n>>> # correct way - note that there will be no self-edge for node 5\n>>> G.add_weighted_edges_from(list((5, n, weight) for n in G.nodes))"}, {"type": "method", "name": "networkx.Graph.adjacency", "documentation": "Returns an iterator over (node, adjacency dict) tuples for all nodes.\n\nFor directed graphs, only outgoing neighbors/adjacencies are included.\n\nReturns\n-------\nadj_iter : iterator\n   An iterator over (node, adjacency dictionary) for all nodes in\n   the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> [(n, nbrdict) for n, nbrdict in G.adjacency()]\n[(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]"}, {"type": "method", "name": "networkx.Graph.clear", "documentation": "Remove all nodes and edges from the graph.\n\nThis also removes the name, and all graph, node, and edge attributes.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.clear()\n>>> list(G.nodes)\n[]\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.Graph.clear_edges", "documentation": "Remove all edges from the graph without altering nodes.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.clear_edges()\n>>> list(G.nodes)\n[0, 1, 2, 3]\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.Graph.copy", "documentation": "Returns a copy of the graph.\n\nThe copy method by default returns an independent shallow copy\nof the graph and attributes. That is, if an attribute is a\ncontainer, that container is shared by the original an the copy.\nUse Python's `copy.deepcopy` for new containers.\n\nIf `as_view` is True then a view is returned instead of a copy.\n\nNotes\n-----\nAll copies reproduce the graph structure, but data attributes\nmay be handled in different ways. There are four types of copies\nof a graph that people might want.\n\nDeepcopy -- A \"deepcopy\" copies the graph structure as well as\nall data attributes and any objects they might contain.\nThe entire graph object is new so that changes in the copy\ndo not affect the original object. (see Python's copy.deepcopy)\n\nData Reference (Shallow) -- For a shallow copy the graph structure\nis copied but the edge, node and graph attribute dicts are\nreferences to those in the original graph. This saves\ntime and memory but could cause confusion if you change an attribute\nin one graph and it changes the attribute in the other.\nNetworkX does not provide this level of shallow copy.\n\nIndependent Shallow -- This copy creates new independent attribute\ndicts and then does a shallow copy of the attributes. That is, any\nattributes that are containers are shared between the new graph\nand the original. This is exactly what `dict.copy()` provides.\nYou can obtain this style copy using:\n\n    >>> G = nx.path_graph(5)\n    >>> H = G.copy()\n    >>> H = G.copy(as_view=False)\n    >>> H = nx.Graph(G)\n    >>> H = G.__class__(G)\n\nFresh Data -- For fresh data, the graph structure is copied while\nnew empty data attribute dicts are created. The resulting graph\nis independent of the original and it has no edge, node or graph\nattributes. Fresh copies are not enabled. Instead use:\n\n    >>> H = G.__class__()\n    >>> H.add_nodes_from(G)\n    >>> H.add_edges_from(G.edges)\n\nView -- Inspired by dict-views, graph-views act like read-only\nversions of the original graph, providing a copy of the original\nstructure without requiring any memory for copying the information.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nParameters\n----------\nas_view : bool, optional (default=False)\n    If True, the returned graph-view provides a read-only view\n    of the original graph without actually copying any data.\n\nReturns\n-------\nG : Graph\n    A copy of the graph.\n\nSee Also\n--------\nto_directed: return a directed copy of the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> H = G.copy()"}, {"type": "method", "name": "networkx.Graph.edge_subgraph", "documentation": "Returns the subgraph induced by the specified edges.\n\nThe induced subgraph contains each edge in `edges` and each\nnode incident to any one of those edges.\n\nParameters\n----------\nedges : iterable\n    An iterable of edges in this graph.\n\nReturns\n-------\nG : Graph\n    An edge-induced subgraph of this graph with the same edge\n    attributes.\n\nNotes\n-----\nThe graph, edge, and node attributes in the returned subgraph\nview are references to the corresponding attributes in the original\ngraph. The view is read-only.\n\nTo create a full graph version of the subgraph with its own copy\nof the edge or node attributes, use::\n\n    G.edge_subgraph(edges).copy()\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> H = G.edge_subgraph([(0, 1), (3, 4)])\n>>> list(H.nodes)\n[0, 1, 3, 4]\n>>> list(H.edges)\n[(0, 1), (3, 4)]"}, {"type": "method", "name": "networkx.Graph.get_edge_data", "documentation": "Returns the attribute dictionary associated with edge (u, v).\n\nThis is identical to `G[u][v]` except the default is returned\ninstead of an exception if the edge doesn't exist.\n\nParameters\n----------\nu, v : nodes\ndefault:  any Python object (default=None)\n    Value to return if the edge (u, v) is not found.\n\nReturns\n-------\nedge_dict : dictionary\n    The edge attribute dictionary.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G[0][1]\n{}\n\nWarning: Assigning to `G[u][v]` is not permitted.\nBut it is safe to assign attributes `G[u][v]['foo']`\n\n>>> G[0][1][\"weight\"] = 7\n>>> G[0][1][\"weight\"]\n7\n>>> G[1][0][\"weight\"]\n7\n\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.get_edge_data(0, 1)  # default edge data is {}\n{}\n>>> e = (0, 1)\n>>> G.get_edge_data(*e)  # tuple form\n{}\n>>> G.get_edge_data(\"a\", \"b\", default=0)  # edge not in graph, return 0\n0"}, {"type": "method", "name": "networkx.Graph.has_edge", "documentation": "Returns True if the edge (u, v) is in the graph.\n\nThis is the same as `v in G[u]` without KeyError exceptions.\n\nParameters\n----------\nu, v : nodes\n    Nodes can be, for example, strings or numbers.\n    Nodes must be hashable (and not None) Python objects.\n\nReturns\n-------\nedge_ind : bool\n    True if edge is in the graph, False otherwise.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.has_edge(0, 1)  # using two nodes\nTrue\n>>> e = (0, 1)\n>>> G.has_edge(*e)  #  e is a 2-tuple (u, v)\nTrue\n>>> e = (0, 1, {\"weight\": 7})\n>>> G.has_edge(*e[:2])  # e is a 3-tuple (u, v, data_dictionary)\nTrue\n\nThe following syntax are equivalent:\n\n>>> G.has_edge(0, 1)\nTrue\n>>> 1 in G[0]  # though this gives KeyError if 0 not in G\nTrue"}, {"type": "method", "name": "networkx.Graph.has_node", "documentation": "Returns True if the graph contains the node n.\n\nIdentical to `n in G`\n\nParameters\n----------\nn : node\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.has_node(0)\nTrue\n\nIt is more readable and simpler to use\n\n>>> 0 in G\nTrue"}, {"type": "method", "name": "networkx.Graph.is_directed", "documentation": "Returns True if graph is directed, False otherwise."}, {"type": "method", "name": "networkx.Graph.is_multigraph", "documentation": "Returns True if graph is a multigraph, False otherwise."}, {"type": "method", "name": "networkx.Graph.nbunch_iter", "documentation": "Returns an iterator over nodes contained in nbunch that are\nalso in the graph.\n\nThe nodes in nbunch are checked for membership in the graph\nand if not are silently ignored.\n\nParameters\n----------\nnbunch : single node, container, or all nodes (default= all nodes)\n    The view will only report edges incident to these nodes.\n\nReturns\n-------\nniter : iterator\n    An iterator over nodes in nbunch that are also in the graph.\n    If nbunch is None, iterate over all nodes in the graph.\n\nRaises\n------\nNetworkXError\n    If nbunch is not a node or sequence of nodes.\n    If a node in nbunch is not hashable.\n\nSee Also\n--------\nGraph.__iter__\n\nNotes\n-----\nWhen nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted.\n\nTo test whether nbunch is a single node, one can use\n\"if nbunch in self:\", even after processing with this routine.\n\nIf nbunch is not a node or a (possibly empty) sequence/iterator\nor None, a :exc:`NetworkXError` is raised.  Also, if any object in\nnbunch is not hashable, a :exc:`NetworkXError` is raised."}, {"type": "method", "name": "networkx.Graph.neighbors", "documentation": "Returns an iterator over all neighbors of node n.\n\nThis is identical to `iter(G[n])`\n\nParameters\n----------\nn : node\n   A node in the graph\n\nReturns\n-------\nneighbors : iterator\n    An iterator over all neighbors of node n\n\nRaises\n------\nNetworkXError\n    If the node n is not in the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> [n for n in G.neighbors(0)]\n[1]\n\nNotes\n-----\nAlternate ways to access the neighbors are ``G.adj[n]`` or ``G[n]``:\n\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edge(\"a\", \"b\", weight=7)\n>>> G[\"a\"]\nAtlasView({'b': {'weight': 7}})\n>>> G = nx.path_graph(4)\n>>> [n for n in G[0]]\n[1]"}, {"type": "method", "name": "networkx.Graph.number_of_edges", "documentation": "Returns the number of edges between two nodes.\n\nParameters\n----------\nu, v : nodes, optional (default=all edges)\n    If u and v are specified, return the number of edges between\n    u and v. Otherwise return the total number of all edges.\n\nReturns\n-------\nnedges : int\n    The number of edges in the graph.  If nodes `u` and `v` are\n    specified return the number of edges between those nodes. If\n    the graph is directed, this only returns the number of edges\n    from `u` to `v`.\n\nSee Also\n--------\nsize\n\nExamples\n--------\nFor undirected graphs, this method counts the total number of\nedges in the graph:\n\n>>> G = nx.path_graph(4)\n>>> G.number_of_edges()\n3\n\nIf you specify two nodes, this counts the total number of edges\njoining the two nodes:\n\n>>> G.number_of_edges(0, 1)\n1\n\nFor directed graphs, this method can count the total number of\ndirected edges from `u` to `v`:\n\n>>> G = nx.DiGraph()\n>>> G.add_edge(0, 1)\n>>> G.add_edge(1, 0)\n>>> G.number_of_edges(0, 1)\n1"}, {"type": "method", "name": "networkx.Graph.number_of_nodes", "documentation": "Returns the number of nodes in the graph.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\norder: identical method\n__len__: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.number_of_nodes()\n3"}, {"type": "method", "name": "networkx.Graph.order", "documentation": "Returns the number of nodes in the graph.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\nnumber_of_nodes: identical method\n__len__: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.order()\n3"}, {"type": "method", "name": "networkx.Graph.remove_edge", "documentation": "Remove the edge between u and v.\n\nParameters\n----------\nu, v : nodes\n    Remove the edge between nodes u and v.\n\nRaises\n------\nNetworkXError\n    If there is not an edge between u and v.\n\nSee Also\n--------\nremove_edges_from : remove a collection of edges\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, etc\n>>> G.remove_edge(0, 1)\n>>> e = (1, 2)\n>>> G.remove_edge(*e)  # unpacks e from an edge tuple\n>>> e = (2, 3, {\"weight\": 7})  # an edge with attribute data\n>>> G.remove_edge(*e[:2])  # select first part of edge tuple"}, {"type": "method", "name": "networkx.Graph.remove_edges_from", "documentation": "Remove all edges specified in ebunch.\n\nParameters\n----------\nebunch: list or container of edge tuples\n    Each edge given in the list or container will be removed\n    from the graph. The edges can be:\n\n        - 2-tuples (u, v) edge between u and v.\n        - 3-tuples (u, v, k) where k is ignored.\n\nSee Also\n--------\nremove_edge : remove a single edge\n\nNotes\n-----\nWill fail silently if an edge in ebunch is not in the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> ebunch = [(1, 2), (2, 3)]\n>>> G.remove_edges_from(ebunch)"}, {"type": "method", "name": "networkx.Graph.remove_node", "documentation": "Remove node n.\n\nRemoves the node n and all adjacent edges.\nAttempting to remove a nonexistent node will raise an exception.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\nremove_nodes_from\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> list(G.edges)\n[(0, 1), (1, 2)]\n>>> G.remove_node(1)\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.Graph.remove_nodes_from", "documentation": "Remove multiple nodes.\n\nParameters\n----------\nnodes : iterable container\n    A container of nodes (list, dict, set, etc.).  If a node\n    in the container is not in the graph it is silently\n    ignored.\n\nSee Also\n--------\nremove_node\n\nNotes\n-----\nWhen removing nodes from an iterator over the graph you are changing,\na `RuntimeError` will be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_nodes)`, and pass this\nobject to `G.remove_nodes_from`.\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> e = list(G.nodes)\n>>> e\n[0, 1, 2]\n>>> G.remove_nodes_from(e)\n>>> list(G.nodes)\n[]\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.Graph([(0, 1), (1, 2), (3, 4)])\n>>> # this command will fail, as the graph's dict is modified during iteration\n>>> # G.remove_nodes_from(n for n in G.nodes if n < 2)\n>>> # this command will work, since the dictionary underlying graph is not modified\n>>> G.remove_nodes_from(list(n for n in G.nodes if n < 2))"}, {"type": "method", "name": "networkx.Graph.size", "documentation": "Returns the number of edges or total of all edge weights.\n\nParameters\n----------\nweight : string or None, optional (default=None)\n    The edge attribute that holds the numerical value used\n    as a weight. If None, then each edge has weight 1.\n\nReturns\n-------\nsize : numeric\n    The number of edges or\n    (if weight keyword is provided) the total weight sum.\n\n    If weight is None, returns an int. Otherwise a float\n    (or more general numeric if the weights are more general).\n\nSee Also\n--------\nnumber_of_edges\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.size()\n3\n\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edge(\"a\", \"b\", weight=2)\n>>> G.add_edge(\"b\", \"c\", weight=4)\n>>> G.size()\n2\n>>> G.size(weight=\"weight\")\n6.0"}, {"type": "method", "name": "networkx.Graph.subgraph", "documentation": "Returns a SubGraph view of the subgraph induced on `nodes`.\n\nThe induced subgraph of the graph contains the nodes in `nodes`\nand the edges between those nodes.\n\nParameters\n----------\nnodes : list, iterable\n    A container of nodes which will be iterated through once.\n\nReturns\n-------\nG : SubGraph View\n    A subgraph view of the graph. The graph structure cannot be\n    changed but node/edge attributes can and are shared with the\n    original graph.\n\nNotes\n-----\nThe graph, edge and node attributes are shared with the original graph.\nChanges to the graph structure is ruled out by the view, but changes\nto attributes are reflected in the original graph.\n\nTo create a subgraph with its own copy of the edge/node attributes use:\nG.subgraph(nodes).copy()\n\nFor an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([n for n in G if n not in set(nodes)])\n\nSubgraph views are sometimes NOT what you want. In most cases where\nyou want to do more than simply look at the induced edges, it makes\nmore sense to just create the subgraph as its own graph with code like:\n\n::\n\n    # Create a subgraph SG based on a (possibly multigraph) G\n    SG = G.__class__()\n    SG.add_nodes_from((n, G.nodes[n]) for n in largest_wcc)\n    if SG.is_multigraph():\n        SG.add_edges_from(\n            (n, nbr, key, d)\n            for n, nbrs in G.adj.items()\n            if n in largest_wcc\n            for nbr, keydict in nbrs.items()\n            if nbr in largest_wcc\n            for key, d in keydict.items()\n        )\n    else:\n        SG.add_edges_from(\n            (n, nbr, d)\n            for n, nbrs in G.adj.items()\n            if n in largest_wcc\n            for nbr, d in nbrs.items()\n            if nbr in largest_wcc\n        )\n    SG.graph.update(G.graph)\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> H = G.subgraph([0, 1, 2])\n>>> list(H.edges)\n[(0, 1), (1, 2)]"}, {"type": "method", "name": "networkx.Graph.to_directed", "documentation": "Returns a directed representation of the graph.\n\nReturns\n-------\nG : DiGraph\n    A directed graph with the same name, same nodes, and with\n    each edge (u, v, data) replaced by two directed edges\n    (u, v, data) and (v, u, data).\n\nNotes\n-----\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar D=DiGraph(G) which returns a\nshallow copy of the data.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nWarning: If you have subclassed Graph to use dict-like objects\nin the data structure, those changes do not transfer to the\nDiGraph created by this method.\n\nExamples\n--------\n>>> G = nx.Graph()  # or MultiGraph, etc\n>>> G.add_edge(0, 1)\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1), (1, 0)]\n\nIf already directed, return a (deep) copy\n\n>>> G = nx.DiGraph()  # or MultiDiGraph, etc\n>>> G.add_edge(0, 1)\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1)]"}, {"type": "method", "name": "networkx.Graph.to_directed_class", "documentation": "Returns the class to use for empty directed copies.\n\nIf you subclass the base classes, use this to designate\nwhat directed class to use for `to_directed()` copies."}, {"type": "method", "name": "networkx.Graph.to_undirected", "documentation": "Returns an undirected copy of the graph.\n\nParameters\n----------\nas_view : bool (optional, default=False)\n  If True return a view of the original undirected graph.\n\nReturns\n-------\nG : Graph/MultiGraph\n    A deepcopy of the graph.\n\nSee Also\n--------\nGraph, copy, add_edge, add_edges_from\n\nNotes\n-----\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar `G = nx.DiGraph(D)` which returns a\nshallow copy of the data.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nWarning: If you have subclassed DiGraph to use dict-like objects\nin the data structure, those changes do not transfer to the\nGraph created by this method.\n\nExamples\n--------\n>>> G = nx.path_graph(2)  # or MultiGraph, etc\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1), (1, 0)]\n>>> G2 = H.to_undirected()\n>>> list(G2.edges)\n[(0, 1)]"}, {"type": "method", "name": "networkx.Graph.to_undirected_class", "documentation": "Returns the class to use for empty undirected copies.\n\nIf you subclass the base classes, use this to designate\nwhat directed class to use for `to_directed()` copies."}, {"type": "method", "name": "networkx.Graph.update", "documentation": "Update the graph using nodes/edges/graphs as input.\n\nLike dict.update, this method takes a graph as input, adding the\ngraph's nodes and edges to this graph. It can also take two inputs:\nedges and nodes. Finally it can take either edges or nodes.\nTo specify only nodes the keyword `nodes` must be used.\n\nThe collections of edges and nodes are treated similarly to\nthe add_edges_from/add_nodes_from methods. When iterated, they\nshould yield 2-tuples (u, v) or 3-tuples (u, v, datadict).\n\nParameters\n----------\nedges : Graph object, collection of edges, or None\n    The first parameter can be a graph or some edges. If it has\n    attributes `nodes` and `edges`, then it is taken to be a\n    Graph-like object and those attributes are used as collections\n    of nodes and edges to be added to the graph.\n    If the first parameter does not have those attributes, it is\n    treated as a collection of edges and added to the graph.\n    If the first argument is None, no edges are added.\nnodes : collection of nodes, or None\n    The second parameter is treated as a collection of nodes\n    to be added to the graph unless it is None.\n    If `edges is None` and `nodes is None` an exception is raised.\n    If the first parameter is a Graph, then `nodes` is ignored.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> G.update(nx.complete_graph(range(4, 10)))\n>>> from itertools import combinations\n>>> edges = (\n...     (u, v, {\"power\": u * v})\n...     for u, v in combinations(range(10, 20), 2)\n...     if u * v < 225\n... )\n>>> nodes = [1000]  # for singleton, use a container\n>>> G.update(edges, nodes)\n\nNotes\n-----\nIt you want to update the graph using an adjacency structure\nit is straightforward to obtain the edges/nodes from adjacency.\nThe following examples provide common cases, your adjacency may\nbe slightly different and require tweaks of these examples::\n\n>>> # dict-of-set/list/tuple\n>>> adj = {1: {2, 3}, 2: {1, 3}, 3: {1, 2}}\n>>> e = [(u, v) for u, nbrs in adj.items() for v in nbrs]\n>>> G.update(edges=e, nodes=adj)\n\n>>> DG = nx.DiGraph()\n>>> # dict-of-dict-of-attribute\n>>> adj = {1: {2: 1.3, 3: 0.7}, 2: {1: 1.4}, 3: {1: 0.7}}\n>>> e = [(u, v, {\"weight\": d}) for u, nbrs in adj.items() for v, d in nbrs.items()]\n>>> DG.update(edges=e, nodes=adj)\n\n>>> # dict-of-dict-of-dict\n>>> adj = {1: {2: {\"weight\": 1.3}, 3: {\"color\": 0.7, \"weight\": 1.2}}}\n>>> e = [(u, v, {\"weight\": d}) for u, nbrs in adj.items() for v, d in nbrs.items()]\n>>> DG.update(edges=e, nodes=adj)\n\n>>> # predecessor adjacency (dict-of-set)\n>>> pred = {1: {2, 3}, 2: {3}, 3: {3}}\n>>> e = [(v, u) for u, nbrs in pred.items() for v in nbrs]\n\n>>> # MultiGraph dict-of-dict-of-dict-of-attribute\n>>> MDG = nx.MultiDiGraph()\n>>> adj = {\n...     1: {2: {0: {\"weight\": 1.3}, 1: {\"weight\": 1.2}}},\n...     3: {2: {0: {\"weight\": 0.7}}},\n... }\n>>> e = [\n...     (u, v, ekey, d)\n...     for u, nbrs in adj.items()\n...     for v, keydict in nbrs.items()\n...     for ekey, d in keydict.items()\n... ]\n>>> MDG.update(edges=e)\n\nSee Also\n--------\nadd_edges_from: add multiple edges to a graph\nadd_nodes_from: add multiple nodes to a graph"}, {"type": "class", "name": "networkx.GraphMLReader", "documentation": "Read a GraphML document.  Produces NetworkX graph objects."}, {"type": "method", "name": "networkx.GraphMLReader.__call__", "documentation": "Call self as a function."}, {"type": "method", "name": "networkx.GraphMLReader.__init__", "documentation": "Initialize self.  See help(type(self)) for accurate signature."}, {"type": "method", "name": "networkx.GraphMLReader.add_edge", "documentation": "Add an edge to the graph."}, {"type": "method", "name": "networkx.GraphMLReader.add_node", "documentation": "Add a node to the graph."}, {"type": "method", "name": "networkx.GraphMLReader.construct_types", "documentation": null}, {"type": "method", "name": "networkx.GraphMLReader.decode_data_elements", "documentation": "Use the key information to decode the data XML if present."}, {"type": "method", "name": "networkx.GraphMLReader.find_graphml_keys", "documentation": "Extracts all the keys and key defaults from the xml."}, {"type": "method", "name": "networkx.GraphMLReader.get_xml_type", "documentation": "Wrapper around the xml_type dict that raises a more informative\nexception message when a user attempts to use data of a type not\nsupported by GraphML."}, {"type": "method", "name": "networkx.GraphMLReader.make_graph", "documentation": null}, {"type": "class", "name": "networkx.GraphMLWriter", "documentation": null}, {"type": "method", "name": "networkx.GraphMLWriter.__init__", "documentation": "Initialize self.  See help(type(self)) for accurate signature."}, {"type": "method", "name": "networkx.GraphMLWriter.__str__", "documentation": "Return str(self)."}, {"type": "method", "name": "networkx.GraphMLWriter.add_attributes", "documentation": "Appends attribute data to edges or nodes, and stores type information\nto be added later. See add_graph_element."}, {"type": "method", "name": "networkx.GraphMLWriter.add_data", "documentation": "Make a data element for an edge or a node. Keep a log of the\ntype in the keys table."}, {"type": "method", "name": "networkx.GraphMLWriter.add_edges", "documentation": null}, {"type": "method", "name": "networkx.GraphMLWriter.add_graph_element", "documentation": "Serialize graph G in GraphML to the stream."}, {"type": "method", "name": "networkx.GraphMLWriter.add_graphs", "documentation": "Add many graphs to this GraphML document."}, {"type": "method", "name": "networkx.GraphMLWriter.add_nodes", "documentation": null}, {"type": "method", "name": "networkx.GraphMLWriter.attr_type", "documentation": "Infer the attribute type of data named name. Currently this only\nsupports inference of numeric types.\n\nIf self.infer_numeric_types is false, type is used. Otherwise, pick the\nmost general of types found across all values with name and scope. This\nmeans edges with data named 'weight' are treated separately from nodes\nwith data named 'weight'."}, {"type": "method", "name": "networkx.GraphMLWriter.construct_types", "documentation": null}, {"type": "method", "name": "networkx.GraphMLWriter.dump", "documentation": null}, {"type": "method", "name": "networkx.GraphMLWriter.get_key", "documentation": null}, {"type": "method", "name": "networkx.GraphMLWriter.get_xml_type", "documentation": "Wrapper around the xml_type dict that raises a more informative\nexception message when a user attempts to use data of a type not\nsupported by GraphML."}, {"type": "method", "name": "networkx.GraphMLWriter.indent", "documentation": null}, {"type": "class", "name": "networkx.HasACycle", "documentation": "Raised if a graph has a cycle when an algorithm expects that it\nwill have no cycles."}, {"type": "function", "name": "networkx.LCF_graph", "documentation": "Return the cubic graph specified in LCF notation.\n\nLCF (Lederberg-Coxeter-Fruchte) notation[1]_ is a compressed\nnotation used in the generation of various cubic Hamiltonian\ngraphs of high symmetry. See, for example, `dodecahedral_graph`,\n`desargues_graph`, `heawood_graph` and `pappus_graph`.\n\nNodes are drawn from ``range(n)``. Each node ``n_i`` is connected with\nnode ``n_i + shift % n`` where ``shift`` is given by cycling through\nthe input `shift_list` `repeat` s times.\n\nParameters\n----------\nn : int\n   The starting graph is the `n`-cycle with nodes ``0, ..., n-1``.\n   The null graph is returned if `n` < 1.\n\nshift_list : list\n   A list of integer shifts mod `n`, ``[s1, s2, .., sk]``\n\nrepeats : int\n   Integer specifying the number of times that shifts in `shift_list`\n   are successively applied to each current node in the n-cycle\n   to generate an edge between ``n_current`` and ``n_current + shift mod n``.\n\nReturns\n-------\nG : Graph\n   A graph instance created from the specified LCF notation.\n\nExamples\n--------\nThe utility graph $K_{3,3}$\n\n>>> G = nx.LCF_graph(6, [3, -3], 3)\n>>> G.edges()\nEdgeView([(0, 1), (0, 5), (0, 3), (1, 2), (1, 4), (2, 3), (2, 5), (3, 4), (4, 5)])\n\nThe Heawood graph:\n\n>>> G = nx.LCF_graph(14, [5, -5], 7)\n>>> nx.is_isomorphic(G, nx.heawood_graph())\nTrue\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/LCF_notation"}, {"type": "function", "name": "networkx.LFR_benchmark_graph", "documentation": "Returns the LFR benchmark graph.\n\nThis algorithm proceeds as follows:\n\n1) Find a degree sequence with a power law distribution, and minimum\n   value ``min_degree``, which has approximate average degree\n   ``average_degree``. This is accomplished by either\n\n   a) specifying ``min_degree`` and not ``average_degree``,\n   b) specifying ``average_degree`` and not ``min_degree``, in which\n      case a suitable minimum degree will be found.\n\n   ``max_degree`` can also be specified, otherwise it will be set to\n   ``n``. Each node *u* will have $\\mu \\mathrm{deg}(u)$ edges\n   joining it to nodes in communities other than its own and $(1 -\n   \\mu) \\mathrm{deg}(u)$ edges joining it to nodes in its own\n   community.\n2) Generate community sizes according to a power law distribution\n   with exponent ``tau2``. If ``min_community`` and\n   ``max_community`` are not specified they will be selected to be\n   ``min_degree`` and ``max_degree``, respectively.  Community sizes\n   are generated until the sum of their sizes equals ``n``.\n3) Each node will be randomly assigned a community with the\n   condition that the community is large enough for the node's\n   intra-community degree, $(1 - \\mu) \\mathrm{deg}(u)$ as\n   described in step 2. If a community grows too large, a random node\n   will be selected for reassignment to a new community, until all\n   nodes have been assigned a community.\n4) Each node *u* then adds $(1 - \\mu) \\mathrm{deg}(u)$\n   intra-community edges and $\\mu \\mathrm{deg}(u)$ inter-community\n   edges.\n\nParameters\n----------\nn : int\n    Number of nodes in the created graph.\n\ntau1 : float\n    Power law exponent for the degree distribution of the created\n    graph. This value must be strictly greater than one.\n\ntau2 : float\n    Power law exponent for the community size distribution in the\n    created graph. This value must be strictly greater than one.\n\nmu : float\n    Fraction of inter-community edges incident to each node. This\n    value must be in the interval [0, 1].\n\naverage_degree : float\n    Desired average degree of nodes in the created graph. This value\n    must be in the interval [0, *n*]. Exactly one of this and\n    ``min_degree`` must be specified, otherwise a\n    :exc:`NetworkXError` is raised.\n\nmin_degree : int\n    Minimum degree of nodes in the created graph. This value must be\n    in the interval [0, *n*]. Exactly one of this and\n    ``average_degree`` must be specified, otherwise a\n    :exc:`NetworkXError` is raised.\n\nmax_degree : int\n    Maximum degree of nodes in the created graph. If not specified,\n    this is set to ``n``, the total number of nodes in the graph.\n\nmin_community : int\n    Minimum size of communities in the graph. If not specified, this\n    is set to ``min_degree``.\n\nmax_community : int\n    Maximum size of communities in the graph. If not specified, this\n    is set to ``n``, the total number of nodes in the graph.\n\ntol : float\n    Tolerance when comparing floats, specifically when comparing\n    average degree values.\n\nmax_iters : int\n    Maximum number of iterations to try to create the community sizes,\n    degree distribution, and community affiliations.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : NetworkX graph\n    The LFR benchmark graph generated according to the specified\n    parameters.\n\n    Each node in the graph has a node attribute ``'community'`` that\n    stores the community (that is, the set of nodes) that includes\n    it.\n\nRaises\n------\nNetworkXError\n    If any of the parameters do not meet their upper and lower bounds:\n\n    - ``tau1`` and ``tau2`` must be strictly greater than 1.\n    - ``mu`` must be in [0, 1].\n    - ``max_degree`` must be in {1, ..., *n*}.\n    - ``min_community`` and ``max_community`` must be in {0, ...,\n      *n*}.\n\n    If not exactly one of ``average_degree`` and ``min_degree`` is\n    specified.\n\n    If ``min_degree`` is not specified and a suitable ``min_degree``\n    cannot be found.\n\nExceededMaxIterations\n    If a valid degree sequence cannot be created within\n    ``max_iters`` number of iterations.\n\n    If a valid set of community sizes cannot be created within\n    ``max_iters`` number of iterations.\n\n    If a valid community assignment cannot be created within ``10 *\n    n * max_iters`` number of iterations.\n\nExamples\n--------\nBasic usage::\n\n    >>> from networkx.generators.community import LFR_benchmark_graph\n    >>> n = 250\n    >>> tau1 = 3\n    >>> tau2 = 1.5\n    >>> mu = 0.1\n    >>> G = LFR_benchmark_graph(\n    ...     n, tau1, tau2, mu, average_degree=5, min_community=20, seed=10\n    ... )\n\nContinuing the example above, you can get the communities from the\nnode attributes of the graph::\n\n    >>> communities = {frozenset(G.nodes[v][\"community\"]) for v in G}\n\nNotes\n-----\nThis algorithm differs slightly from the original way it was\npresented in [1].\n\n1) Rather than connecting the graph via a configuration model then\n   rewiring to match the intra-community and inter-community\n   degrees, we do this wiring explicitly at the end, which should be\n   equivalent.\n2) The code posted on the author's website [2] calculates the random\n   power law distributed variables and their average using\n   continuous approximations, whereas we use the discrete\n   distributions here as both degree and community size are\n   discrete.\n\nThough the authors describe the algorithm as quite robust, testing\nduring development indicates that a somewhat narrower parameter set\nis likely to successfully produce a graph. Some suggestions have\nbeen provided in the event of exceptions.\n\nReferences\n----------\n.. [1] \"Benchmark graphs for testing community detection algorithms\",\n       Andrea Lancichinetti, Santo Fortunato, and Filippo Radicchi,\n       Phys. Rev. E 78, 046110 2008\n.. [2] https://www.santofortunato.net/resources"}, {"type": "class", "name": "networkx.MultiDiGraph", "documentation": "A directed graph class that can store multiedges.\n\nMultiedges are multiple edges between two nodes.  Each edge\ncan hold optional data or attributes.\n\nA MultiDiGraph holds directed edges.  Self loops are allowed.\n\nNodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention `None` is not used as a node.\n\nEdges are represented as links between nodes with optional\nkey/value attributes.\n\nParameters\n----------\nincoming_graph_data : input graph (optional, default: None)\n    Data to initialize graph. If None (default) an empty\n    graph is created.  The data can be any format that is supported\n    by the to_networkx_graph() function, currently including edge list,\n    dict of dicts, dict of lists, NetworkX graph, 2D NumPy array, SciPy\n    sparse matrix, or PyGraphviz graph.\n\nmultigraph_input : bool or None (default None)\n    Note: Only used when `incoming_graph_data` is a dict.\n    If True, `incoming_graph_data` is assumed to be a\n    dict-of-dict-of-dict-of-dict structure keyed by\n    node to neighbor to edge keys to edge data for multi-edges.\n    A NetworkXError is raised if this is not the case.\n    If False, :func:`to_networkx_graph` is used to try to determine\n    the dict's graph data structure as either a dict-of-dict-of-dict\n    keyed by node to neighbor to edge data, or a dict-of-iterable\n    keyed by node to neighbors.\n    If None, the treatment for True is tried, but if it fails,\n    the treatment for False is tried.\n\nattr : keyword arguments, optional (default= no attributes)\n    Attributes to add to graph as key=value pairs.\n\nSee Also\n--------\nGraph\nDiGraph\nMultiGraph\n\nExamples\n--------\nCreate an empty graph structure (a \"null graph\") with no nodes and\nno edges.\n\n>>> G = nx.MultiDiGraph()\n\nG can be grown in several ways.\n\n**Nodes:**\n\nAdd one node at a time:\n\n>>> G.add_node(1)\n\nAdd the nodes from any container (a list, dict, set or\neven the lines from a file or the nodes from another graph).\n\n>>> G.add_nodes_from([2, 3])\n>>> G.add_nodes_from(range(100, 110))\n>>> H = nx.path_graph(10)\n>>> G.add_nodes_from(H)\n\nIn addition to strings and integers any hashable Python object\n(except None) can represent a node, e.g. a customized node object,\nor even another Graph.\n\n>>> G.add_node(H)\n\n**Edges:**\n\nG can also be grown by adding edges.\n\nAdd one edge,\n\n>>> key = G.add_edge(1, 2)\n\na list of edges,\n\n>>> keys = G.add_edges_from([(1, 2), (1, 3)])\n\nor a collection of edges,\n\n>>> keys = G.add_edges_from(H.edges)\n\nIf some edges connect nodes not yet in the graph, the nodes\nare added automatically.  If an edge already exists, an additional\nedge is created and stored using a key to identify the edge.\nBy default the key is the lowest unused integer.\n\n>>> keys = G.add_edges_from([(4, 5, dict(route=282)), (4, 5, dict(route=37))])\n>>> G[4]\nAdjacencyView({5: {0: {}, 1: {'route': 282}, 2: {'route': 37}}})\n\n**Attributes:**\n\nEach graph, node, and edge can hold key/value attribute pairs\nin an associated attribute dictionary (the keys must be hashable).\nBy default these are empty, but can be added or changed using\nadd_edge, add_node or direct manipulation of the attribute\ndictionaries named graph, node and edge respectively.\n\n>>> G = nx.MultiDiGraph(day=\"Friday\")\n>>> G.graph\n{'day': 'Friday'}\n\nAdd node attributes using add_node(), add_nodes_from() or G.nodes\n\n>>> G.add_node(1, time=\"5pm\")\n>>> G.add_nodes_from([3], time=\"2pm\")\n>>> G.nodes[1]\n{'time': '5pm'}\n>>> G.nodes[1][\"room\"] = 714\n>>> del G.nodes[1][\"room\"]  # remove attribute\n>>> list(G.nodes(data=True))\n[(1, {'time': '5pm'}), (3, {'time': '2pm'})]\n\nAdd edge attributes using add_edge(), add_edges_from(), subscript\nnotation, or G.edges.\n\n>>> key = G.add_edge(1, 2, weight=4.7)\n>>> keys = G.add_edges_from([(3, 4), (4, 5)], color=\"red\")\n>>> keys = G.add_edges_from([(1, 2, {\"color\": \"blue\"}), (2, 3, {\"weight\": 8})])\n>>> G[1][2][0][\"weight\"] = 4.7\n>>> G.edges[1, 2, 0][\"weight\"] = 4\n\nWarning: we protect the graph data structure by making `G.edges[1,\n2, 0]` a read-only dict-like structure. However, you can assign to\nattributes in e.g. `G.edges[1, 2, 0]`. Thus, use 2 sets of brackets\nto add/change data attributes: `G.edges[1, 2, 0]['weight'] = 4`\n(for multigraphs the edge key is required: `MG.edges[u, v,\nkey][name] = value`).\n\n**Shortcuts:**\n\nMany common graph features allow python syntax to speed reporting.\n\n>>> 1 in G  # check if node in graph\nTrue\n>>> [n for n in G if n < 3]  # iterate through nodes\n[1, 2]\n>>> len(G)  # number of nodes in graph\n5\n>>> G[1]  # adjacency dict-like view mapping neighbor -> edge key -> edge attributes\nAdjacencyView({2: {0: {'weight': 4}, 1: {'color': 'blue'}}})\n\nOften the best way to traverse all edges of a graph is via the neighbors.\nThe neighbors are available as an adjacency-view `G.adj` object or via\nthe method `G.adjacency()`.\n\n>>> for n, nbrsdict in G.adjacency():\n...     for nbr, keydict in nbrsdict.items():\n...         for key, eattr in keydict.items():\n...             if \"weight\" in eattr:\n...                 # Do something useful with the edges\n...                 pass\n\nBut the edges() method is often more convenient:\n\n>>> for u, v, keys, weight in G.edges(data=\"weight\", keys=True):\n...     if weight is not None:\n...         # Do something useful with the edges\n...         pass\n\n**Reporting:**\n\nSimple graph information is obtained using methods and object-attributes.\nReporting usually provides views instead of containers to reduce memory\nusage. The views update as the graph is updated similarly to dict-views.\nThe objects `nodes`, `edges` and `adj` provide access to data attributes\nvia lookup (e.g. `nodes[n]`, `edges[u, v, k]`, `adj[u][v]`) and iteration\n(e.g. `nodes.items()`, `nodes.data('color')`,\n`nodes.data('color', default='blue')` and similarly for `edges`)\nViews exist for `nodes`, `edges`, `neighbors()`/`adj` and `degree`.\n\nFor details on these and other miscellaneous methods, see below.\n\n**Subclasses (Advanced):**\n\nThe MultiDiGraph class uses a dict-of-dict-of-dict-of-dict structure.\nThe outer dict (node_dict) holds adjacency information keyed by node.\nThe next dict (adjlist_dict) represents the adjacency information\nand holds edge_key dicts keyed by neighbor. The edge_key dict holds\neach edge_attr dict keyed by edge key. The inner dict\n(edge_attr_dict) represents the edge data and holds edge attribute\nvalues keyed by attribute names.\n\nEach of these four dicts in the dict-of-dict-of-dict-of-dict\nstructure can be replaced by a user defined dict-like object.\nIn general, the dict-like features should be maintained but\nextra features can be added. To replace one of the dicts create\na new graph class by changing the class(!) variable holding the\nfactory for that dict-like structure. The variable names are\nnode_dict_factory, node_attr_dict_factory, adjlist_inner_dict_factory,\nadjlist_outer_dict_factory, edge_key_dict_factory, edge_attr_dict_factory\nand graph_attr_dict_factory.\n\nnode_dict_factory : function, (default: dict)\n    Factory function to be used to create the dict containing node\n    attributes, keyed by node id.\n    It should require no arguments and return a dict-like object\n\nnode_attr_dict_factory: function, (default: dict)\n    Factory function to be used to create the node attribute\n    dict which holds attribute values keyed by attribute name.\n    It should require no arguments and return a dict-like object\n\nadjlist_outer_dict_factory : function, (default: dict)\n    Factory function to be used to create the outer-most dict\n    in the data structure that holds adjacency info keyed by node.\n    It should require no arguments and return a dict-like object.\n\nadjlist_inner_dict_factory : function, (default: dict)\n    Factory function to be used to create the adjacency list\n    dict which holds multiedge key dicts keyed by neighbor.\n    It should require no arguments and return a dict-like object.\n\nedge_key_dict_factory : function, (default: dict)\n    Factory function to be used to create the edge key dict\n    which holds edge data keyed by edge key.\n    It should require no arguments and return a dict-like object.\n\nedge_attr_dict_factory : function, (default: dict)\n    Factory function to be used to create the edge attribute\n    dict which holds attribute values keyed by attribute name.\n    It should require no arguments and return a dict-like object.\n\ngraph_attr_dict_factory : function, (default: dict)\n    Factory function to be used to create the graph attribute\n    dict which holds attribute values keyed by attribute name.\n    It should require no arguments and return a dict-like object.\n\nTypically, if your extension doesn't impact the data structure all\nmethods will inherited without issue except: `to_directed/to_undirected`.\nBy default these methods create a DiGraph/Graph class and you probably\nwant them to create your extension of a DiGraph/Graph. To facilitate\nthis we define two class variables that you can set in your subclass.\n\nto_directed_class : callable, (default: DiGraph or MultiDiGraph)\n    Class to create a new graph structure in the `to_directed` method.\n    If `None`, a NetworkX class (DiGraph or MultiDiGraph) is used.\n\nto_undirected_class : callable, (default: Graph or MultiGraph)\n    Class to create a new graph structure in the `to_undirected` method.\n    If `None`, a NetworkX class (Graph or MultiGraph) is used.\n\n**Subclassing Example**\n\nCreate a low memory graph class that effectively disallows edge\nattributes by using a single attribute dict for all edges.\nThis reduces the memory used, but you lose edge attributes.\n\n>>> class ThinGraph(nx.Graph):\n...     all_edge_dict = {\"weight\": 1}\n...\n...     def single_edge_dict(self):\n...         return self.all_edge_dict\n...\n...     edge_attr_dict_factory = single_edge_dict\n>>> G = ThinGraph()\n>>> G.add_edge(2, 1)\n>>> G[2][1]\n{'weight': 1}\n>>> G.add_edge(2, 2)\n>>> G[2][1] is G[2][2]\nTrue"}, {"type": "method", "name": "networkx.MultiDiGraph.__contains__", "documentation": "Returns True if n is a node, False otherwise. Use: 'n in G'.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> 1 in G\nTrue"}, {"type": "method", "name": "networkx.MultiDiGraph.__getitem__", "documentation": "Returns a dict of neighbors of node n.  Use: 'G[n]'.\n\nParameters\n----------\nn : node\n   A node in the graph.\n\nReturns\n-------\nadj_dict : dictionary\n   The adjacency dictionary for nodes connected to n.\n\nNotes\n-----\nG[n] is the same as G.adj[n] and similar to G.neighbors(n)\n(which is an iterator over G.adj[n])\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G[0]\nAtlasView({1: {}})"}, {"type": "method", "name": "networkx.MultiDiGraph.__init__", "documentation": "Initialize a graph with edges, name, or graph attributes.\n\nParameters\n----------\nincoming_graph_data : input graph\n    Data to initialize graph.  If incoming_graph_data=None (default)\n    an empty graph is created.  The data can be an edge list, or any\n    NetworkX graph object.  If the corresponding optional Python\n    packages are installed the data can also be a 2D NumPy array, a\n    SciPy sparse array, or a PyGraphviz graph.\n\nmultigraph_input : bool or None (default None)\n    Note: Only used when `incoming_graph_data` is a dict.\n    If True, `incoming_graph_data` is assumed to be a\n    dict-of-dict-of-dict-of-dict structure keyed by\n    node to neighbor to edge keys to edge data for multi-edges.\n    A NetworkXError is raised if this is not the case.\n    If False, :func:`to_networkx_graph` is used to try to determine\n    the dict's graph data structure as either a dict-of-dict-of-dict\n    keyed by node to neighbor to edge data, or a dict-of-iterable\n    keyed by node to neighbors.\n    If None, the treatment for True is tried, but if it fails,\n    the treatment for False is tried.\n\nattr : keyword arguments, optional (default= no attributes)\n    Attributes to add to graph as key=value pairs.\n\nSee Also\n--------\nconvert\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G = nx.Graph(name=\"my graph\")\n>>> e = [(1, 2), (2, 3), (3, 4)]  # list of edges\n>>> G = nx.Graph(e)\n\nArbitrary graph attribute pairs (key=value) may be assigned\n\n>>> G = nx.Graph(e, day=\"Friday\")\n>>> G.graph\n{'day': 'Friday'}"}, {"type": "method", "name": "networkx.MultiDiGraph.__iter__", "documentation": "Iterate over the nodes. Use: 'for n in G'.\n\nReturns\n-------\nniter : iterator\n    An iterator over all nodes in the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> [n for n in G]\n[0, 1, 2, 3]\n>>> list(G)\n[0, 1, 2, 3]"}, {"type": "method", "name": "networkx.MultiDiGraph.__len__", "documentation": "Returns the number of nodes in the graph. Use: 'len(G)'.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\nnumber_of_nodes: identical method\norder: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> len(G)\n4"}, {"type": "method", "name": "networkx.MultiDiGraph.__str__", "documentation": "Returns a short summary of the graph.\n\nReturns\n-------\ninfo : string\n    Graph information including the graph name (if any), graph type, and the\n    number of nodes and edges.\n\nExamples\n--------\n>>> G = nx.Graph(name=\"foo\")\n>>> str(G)\n\"Graph named 'foo' with 0 nodes and 0 edges\"\n\n>>> G = nx.path_graph(3)\n>>> str(G)\n'Graph with 3 nodes and 2 edges'"}, {"type": "method", "name": "networkx.MultiDiGraph.add_edge", "documentation": "Add an edge between u and v.\n\nThe nodes u and v will be automatically added if they are\nnot already in the graph.\n\nEdge attributes can be specified with keywords or by directly\naccessing the edge's attribute dictionary. See examples below.\n\nParameters\n----------\nu_for_edge, v_for_edge : nodes\n    Nodes can be, for example, strings or numbers.\n    Nodes must be hashable (and not None) Python objects.\nkey : hashable identifier, optional (default=lowest unused integer)\n    Used to distinguish multiedges between a pair of nodes.\nattr : keyword arguments, optional\n    Edge data (or labels or objects) can be assigned using\n    keyword arguments.\n\nReturns\n-------\nThe edge key assigned to the edge.\n\nSee Also\n--------\nadd_edges_from : add a collection of edges\n\nNotes\n-----\nTo replace/update edge data, use the optional key argument\nto identify a unique edge.  Otherwise a new edge will be created.\n\nNetworkX algorithms designed for weighted graphs cannot use\nmultigraphs directly because it is not clear how to handle\nmultiedge weights.  Convert to Graph using edge attribute\n'weight' to enable weighted graph algorithms.\n\nDefault keys are generated using the method `new_edge_key()`.\nThis method can be overridden by subclassing the base class and\nproviding a custom `new_edge_key()` method.\n\nExamples\n--------\nThe following all add the edge e=(1, 2) to graph G:\n\n>>> G = nx.MultiDiGraph()\n>>> e = (1, 2)\n>>> key = G.add_edge(1, 2)  # explicit two-node form\n>>> G.add_edge(*e)  # single edge as tuple of two nodes\n1\n>>> G.add_edges_from([(1, 2)])  # add edges from iterable container\n[2]\n\nAssociate data to edges using keywords:\n\n>>> key = G.add_edge(1, 2, weight=3)\n>>> key = G.add_edge(1, 2, key=0, weight=4)  # update data for key=0\n>>> key = G.add_edge(1, 3, weight=7, capacity=15, length=342.7)\n\nFor non-string attribute keys, use subscript notation.\n\n>>> ekey = G.add_edge(1, 2)\n>>> G[1][2][0].update({0: 5})\n>>> G.edges[1, 2, 0].update({0: 5})"}, {"type": "method", "name": "networkx.MultiDiGraph.add_edges_from", "documentation": "Add all the edges in ebunch_to_add.\n\nParameters\n----------\nebunch_to_add : container of edges\n    Each edge given in the container will be added to the\n    graph. The edges can be:\n\n        - 2-tuples (u, v) or\n        - 3-tuples (u, v, d) for an edge data dict d, or\n        - 3-tuples (u, v, k) for not iterable key k, or\n        - 4-tuples (u, v, k, d) for an edge with data and key k\n\nattr : keyword arguments, optional\n    Edge data (or labels or objects) can be assigned using\n    keyword arguments.\n\nReturns\n-------\nA list of edge keys assigned to the edges in `ebunch`.\n\nSee Also\n--------\nadd_edge : add a single edge\nadd_weighted_edges_from : convenient way to add weighted edges\n\nNotes\n-----\nAdding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added.\n\nEdge attributes specified in an ebunch take precedence over\nattributes specified via keyword arguments.\n\nDefault keys are generated using the method ``new_edge_key()``.\nThis method can be overridden by subclassing the base class and\nproviding a custom ``new_edge_key()`` method.\n\nWhen adding edges from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_edges)`, and pass this\nobject to `G.add_edges_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edges_from([(0, 1), (1, 2)])  # using a list of edge tuples\n>>> e = zip(range(0, 3), range(1, 4))\n>>> G.add_edges_from(e)  # Add the path graph 0-1-2-3\n\nAssociate data to edges\n\n>>> G.add_edges_from([(1, 2), (2, 3)], weight=3)\n>>> G.add_edges_from([(3, 4), (1, 4)], label=\"WN2898\")\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.MultiGraph([(1, 2), (2, 3), (3, 4)])\n>>> # Grow graph by one new node, adding edges to all existing nodes.\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_edges_from(((5, n) for n in G.nodes))\n>>> # right way - note that there will be no self-edge for node 5\n>>> assigned_keys = G.add_edges_from(list((5, n) for n in G.nodes))"}, {"type": "method", "name": "networkx.MultiDiGraph.add_node", "documentation": "Add a single node `node_for_adding` and update node attributes.\n\nParameters\n----------\nnode_for_adding : node\n    A node can be any hashable Python object except None.\nattr : keyword arguments, optional\n    Set or change node attributes using key=value.\n\nSee Also\n--------\nadd_nodes_from\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_node(1)\n>>> G.add_node(\"Hello\")\n>>> K3 = nx.Graph([(0, 1), (1, 2), (2, 0)])\n>>> G.add_node(K3)\n>>> G.number_of_nodes()\n3\n\nUse keywords set/change node attributes:\n\n>>> G.add_node(1, size=10)\n>>> G.add_node(3, weight=0.4, UTM=(\"13S\", 382871, 3972649))\n\nNotes\n-----\nA hashable object is one that can be used as a key in a Python\ndictionary. This includes strings, numbers, tuples of strings\nand numbers, etc.\n\nOn many platforms hashable items also include mutables such as\nNetworkX Graphs, though one should be careful that the hash\ndoesn't change on mutables."}, {"type": "method", "name": "networkx.MultiDiGraph.add_nodes_from", "documentation": "Add multiple nodes.\n\nParameters\n----------\nnodes_for_adding : iterable container\n    A container of nodes (list, dict, set, etc.).\n    OR\n    A container of (node, attribute dict) tuples.\n    Node attributes are updated using the attribute dict.\nattr : keyword arguments, optional (default= no attributes)\n    Update attributes for all nodes in nodes.\n    Node attributes specified in nodes as a tuple take\n    precedence over attributes specified via keyword arguments.\n\nSee Also\n--------\nadd_node\n\nNotes\n-----\nWhen adding nodes from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_nodes)`, and pass this\nobject to `G.add_nodes_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_nodes_from(\"Hello\")\n>>> K3 = nx.Graph([(0, 1), (1, 2), (2, 0)])\n>>> G.add_nodes_from(K3)\n>>> sorted(G.nodes(), key=str)\n[0, 1, 2, 'H', 'e', 'l', 'o']\n\nUse keywords to update specific node attributes for every node.\n\n>>> G.add_nodes_from([1, 2], size=10)\n>>> G.add_nodes_from([3, 4], weight=0.4)\n\nUse (node, attrdict) tuples to update attributes for specific nodes.\n\n>>> G.add_nodes_from([(1, dict(size=11)), (2, {\"color\": \"blue\"})])\n>>> G.nodes[1][\"size\"]\n11\n>>> H = nx.Graph()\n>>> H.add_nodes_from(G.nodes(data=True))\n>>> H.nodes[1][\"size\"]\n11\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.DiGraph([(0, 1), (1, 2), (3, 4)])\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_nodes_from(n + 1 for n in G.nodes)\n>>> # correct way\n>>> G.add_nodes_from(list(n + 1 for n in G.nodes))"}, {"type": "method", "name": "networkx.MultiDiGraph.add_weighted_edges_from", "documentation": "Add weighted edges in `ebunch_to_add` with specified weight attr\n\nParameters\n----------\nebunch_to_add : container of edges\n    Each edge given in the list or container will be added\n    to the graph. The edges must be given as 3-tuples (u, v, w)\n    where w is a number.\nweight : string, optional (default= 'weight')\n    The attribute name for the edge weights to be added.\nattr : keyword arguments, optional (default= no attributes)\n    Edge attributes to add/update for all edges.\n\nSee Also\n--------\nadd_edge : add a single edge\nadd_edges_from : add multiple edges\n\nNotes\n-----\nAdding the same edge twice for Graph/DiGraph simply updates\nthe edge data. For MultiGraph/MultiDiGraph, duplicate edges\nare stored.\n\nWhen adding edges from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_edges)`, and pass this\nobject to `G.add_weighted_edges_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_weighted_edges_from([(0, 1, 3.0), (1, 2, 7.5)])\n\nEvaluate an iterator over edges before passing it\n\n>>> G = nx.Graph([(1, 2), (2, 3), (3, 4)])\n>>> weight = 0.1\n>>> # Grow graph by one new node, adding edges to all existing nodes.\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))\n>>> # correct way - note that there will be no self-edge for node 5\n>>> G.add_weighted_edges_from(list((5, n, weight) for n in G.nodes))"}, {"type": "method", "name": "networkx.MultiDiGraph.adjacency", "documentation": "Returns an iterator over (node, adjacency dict) tuples for all nodes.\n\nFor directed graphs, only outgoing neighbors/adjacencies are included.\n\nReturns\n-------\nadj_iter : iterator\n   An iterator over (node, adjacency dictionary) for all nodes in\n   the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> [(n, nbrdict) for n, nbrdict in G.adjacency()]\n[(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]"}, {"type": "method", "name": "networkx.MultiDiGraph.clear", "documentation": "Remove all nodes and edges from the graph.\n\nThis also removes the name, and all graph, node, and edge attributes.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.clear()\n>>> list(G.nodes)\n[]\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.MultiDiGraph.clear_edges", "documentation": "Remove all edges from the graph without altering nodes.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.clear_edges()\n>>> list(G.nodes)\n[0, 1, 2, 3]\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.MultiDiGraph.copy", "documentation": "Returns a copy of the graph.\n\nThe copy method by default returns an independent shallow copy\nof the graph and attributes. That is, if an attribute is a\ncontainer, that container is shared by the original an the copy.\nUse Python's `copy.deepcopy` for new containers.\n\nIf `as_view` is True then a view is returned instead of a copy.\n\nNotes\n-----\nAll copies reproduce the graph structure, but data attributes\nmay be handled in different ways. There are four types of copies\nof a graph that people might want.\n\nDeepcopy -- A \"deepcopy\" copies the graph structure as well as\nall data attributes and any objects they might contain.\nThe entire graph object is new so that changes in the copy\ndo not affect the original object. (see Python's copy.deepcopy)\n\nData Reference (Shallow) -- For a shallow copy the graph structure\nis copied but the edge, node and graph attribute dicts are\nreferences to those in the original graph. This saves\ntime and memory but could cause confusion if you change an attribute\nin one graph and it changes the attribute in the other.\nNetworkX does not provide this level of shallow copy.\n\nIndependent Shallow -- This copy creates new independent attribute\ndicts and then does a shallow copy of the attributes. That is, any\nattributes that are containers are shared between the new graph\nand the original. This is exactly what `dict.copy()` provides.\nYou can obtain this style copy using:\n\n    >>> G = nx.path_graph(5)\n    >>> H = G.copy()\n    >>> H = G.copy(as_view=False)\n    >>> H = nx.Graph(G)\n    >>> H = G.__class__(G)\n\nFresh Data -- For fresh data, the graph structure is copied while\nnew empty data attribute dicts are created. The resulting graph\nis independent of the original and it has no edge, node or graph\nattributes. Fresh copies are not enabled. Instead use:\n\n    >>> H = G.__class__()\n    >>> H.add_nodes_from(G)\n    >>> H.add_edges_from(G.edges)\n\nView -- Inspired by dict-views, graph-views act like read-only\nversions of the original graph, providing a copy of the original\nstructure without requiring any memory for copying the information.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nParameters\n----------\nas_view : bool, optional (default=False)\n    If True, the returned graph-view provides a read-only view\n    of the original graph without actually copying any data.\n\nReturns\n-------\nG : Graph\n    A copy of the graph.\n\nSee Also\n--------\nto_directed: return a directed copy of the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> H = G.copy()"}, {"type": "method", "name": "networkx.MultiDiGraph.edge_subgraph", "documentation": "Returns the subgraph induced by the specified edges.\n\nThe induced subgraph contains each edge in `edges` and each\nnode incident to any one of those edges.\n\nParameters\n----------\nedges : iterable\n    An iterable of edges in this graph.\n\nReturns\n-------\nG : Graph\n    An edge-induced subgraph of this graph with the same edge\n    attributes.\n\nNotes\n-----\nThe graph, edge, and node attributes in the returned subgraph\nview are references to the corresponding attributes in the original\ngraph. The view is read-only.\n\nTo create a full graph version of the subgraph with its own copy\nof the edge or node attributes, use::\n\n    G.edge_subgraph(edges).copy()\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> H = G.edge_subgraph([(0, 1), (3, 4)])\n>>> list(H.nodes)\n[0, 1, 3, 4]\n>>> list(H.edges)\n[(0, 1), (3, 4)]"}, {"type": "method", "name": "networkx.MultiDiGraph.get_edge_data", "documentation": "Returns the attribute dictionary associated with edge (u, v,\nkey).\n\nIf a key is not provided, returns a dictionary mapping edge keys\nto attribute dictionaries for each edge between u and v.\n\nThis is identical to `G[u][v][key]` except the default is returned\ninstead of an exception is the edge doesn't exist.\n\nParameters\n----------\nu, v : nodes\n\ndefault :  any Python object (default=None)\n    Value to return if the specific edge (u, v, key) is not\n    found, OR if there are no edges between u and v and no key\n    is specified.\n\nkey : hashable identifier, optional (default=None)\n    Return data only for the edge with specified key, as an\n    attribute dictionary (rather than a dictionary mapping keys\n    to attribute dictionaries).\n\nReturns\n-------\nedge_dict : dictionary\n    The edge attribute dictionary, OR a dictionary mapping edge\n    keys to attribute dictionaries for each of those edges if no\n    specific key is provided (even if there's only one edge\n    between u and v).\n\nExamples\n--------\n>>> G = nx.MultiGraph()  # or MultiDiGraph\n>>> key = G.add_edge(0, 1, key=\"a\", weight=7)\n>>> G[0][1][\"a\"]  # key='a'\n{'weight': 7}\n>>> G.edges[0, 1, \"a\"]  # key='a'\n{'weight': 7}\n\nWarning: we protect the graph data structure by making\n`G.edges` and `G[1][2]` read-only dict-like structures.\nHowever, you can assign values to attributes in e.g.\n`G.edges[1, 2, 'a']` or `G[1][2]['a']` using an additional\nbracket as shown next. You need to specify all edge info\nto assign to the edge data associated with an edge.\n\n>>> G[0][1][\"a\"][\"weight\"] = 10\n>>> G.edges[0, 1, \"a\"][\"weight\"] = 10\n>>> G[0][1][\"a\"][\"weight\"]\n10\n>>> G.edges[1, 0, \"a\"][\"weight\"]\n10\n\n>>> G = nx.MultiGraph()  # or MultiDiGraph\n>>> nx.add_path(G, [0, 1, 2, 3])\n>>> G.edges[0, 1, 0][\"weight\"] = 5\n>>> G.get_edge_data(0, 1)\n{0: {'weight': 5}}\n>>> e = (0, 1)\n>>> G.get_edge_data(*e)  # tuple form\n{0: {'weight': 5}}\n>>> G.get_edge_data(3, 0)  # edge not in graph, returns None\n>>> G.get_edge_data(3, 0, default=0)  # edge not in graph, return default\n0\n>>> G.get_edge_data(1, 0, 0)  # specific key gives back\n{'weight': 5}"}, {"type": "method", "name": "networkx.MultiDiGraph.has_edge", "documentation": "Returns True if the graph has an edge between nodes u and v.\n\nThis is the same as `v in G[u] or key in G[u][v]`\nwithout KeyError exceptions.\n\nParameters\n----------\nu, v : nodes\n    Nodes can be, for example, strings or numbers.\n\nkey : hashable identifier, optional (default=None)\n    If specified return True only if the edge with\n    key is found.\n\nReturns\n-------\nedge_ind : bool\n    True if edge is in the graph, False otherwise.\n\nExamples\n--------\nCan be called either using two nodes u, v, an edge tuple (u, v),\nor an edge tuple (u, v, key).\n\n>>> G = nx.MultiGraph()  # or MultiDiGraph\n>>> nx.add_path(G, [0, 1, 2, 3])\n>>> G.has_edge(0, 1)  # using two nodes\nTrue\n>>> e = (0, 1)\n>>> G.has_edge(*e)  #  e is a 2-tuple (u, v)\nTrue\n>>> G.add_edge(0, 1, key=\"a\")\n'a'\n>>> G.has_edge(0, 1, key=\"a\")  # specify key\nTrue\n>>> G.has_edge(1, 0, key=\"a\")  # edges aren't directed\nTrue\n>>> e = (0, 1, \"a\")\n>>> G.has_edge(*e)  # e is a 3-tuple (u, v, 'a')\nTrue\n\nThe following syntax are equivalent:\n\n>>> G.has_edge(0, 1)\nTrue\n>>> 1 in G[0]  # though this gives :exc:`KeyError` if 0 not in G\nTrue\n>>> 0 in G[1]  # other order; also gives :exc:`KeyError` if 0 not in G\nTrue"}, {"type": "method", "name": "networkx.MultiDiGraph.has_node", "documentation": "Returns True if the graph contains the node n.\n\nIdentical to `n in G`\n\nParameters\n----------\nn : node\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.has_node(0)\nTrue\n\nIt is more readable and simpler to use\n\n>>> 0 in G\nTrue"}, {"type": "method", "name": "networkx.MultiDiGraph.has_predecessor", "documentation": "Returns True if node u has predecessor v.\n\nThis is true if graph has the edge u<-v."}, {"type": "method", "name": "networkx.MultiDiGraph.has_successor", "documentation": "Returns True if node u has successor v.\n\nThis is true if graph has the edge u->v."}, {"type": "method", "name": "networkx.MultiDiGraph.is_directed", "documentation": "Returns True if graph is directed, False otherwise."}, {"type": "method", "name": "networkx.MultiDiGraph.is_multigraph", "documentation": "Returns True if graph is a multigraph, False otherwise."}, {"type": "method", "name": "networkx.MultiDiGraph.nbunch_iter", "documentation": "Returns an iterator over nodes contained in nbunch that are\nalso in the graph.\n\nThe nodes in nbunch are checked for membership in the graph\nand if not are silently ignored.\n\nParameters\n----------\nnbunch : single node, container, or all nodes (default= all nodes)\n    The view will only report edges incident to these nodes.\n\nReturns\n-------\nniter : iterator\n    An iterator over nodes in nbunch that are also in the graph.\n    If nbunch is None, iterate over all nodes in the graph.\n\nRaises\n------\nNetworkXError\n    If nbunch is not a node or sequence of nodes.\n    If a node in nbunch is not hashable.\n\nSee Also\n--------\nGraph.__iter__\n\nNotes\n-----\nWhen nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted.\n\nTo test whether nbunch is a single node, one can use\n\"if nbunch in self:\", even after processing with this routine.\n\nIf nbunch is not a node or a (possibly empty) sequence/iterator\nor None, a :exc:`NetworkXError` is raised.  Also, if any object in\nnbunch is not hashable, a :exc:`NetworkXError` is raised."}, {"type": "method", "name": "networkx.MultiDiGraph.neighbors", "documentation": "Returns an iterator over successor nodes of n.\n\nA successor of n is a node m such that there exists a directed\nedge from n to m.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\npredecessors\n\nNotes\n-----\nneighbors() and successors() are the same."}, {"type": "method", "name": "networkx.MultiDiGraph.new_edge_key", "documentation": "Returns an unused key for edges between nodes `u` and `v`.\n\nThe nodes `u` and `v` do not need to be already in the graph.\n\nNotes\n-----\nIn the standard MultiGraph class the new key is the number of existing\nedges between `u` and `v` (increased if necessary to ensure unused).\nThe first edge will have key 0, then 1, etc. If an edge is removed\nfurther new_edge_keys may not be in this order.\n\nParameters\n----------\nu, v : nodes\n\nReturns\n-------\nkey : int"}, {"type": "method", "name": "networkx.MultiDiGraph.number_of_edges", "documentation": "Returns the number of edges between two nodes.\n\nParameters\n----------\nu, v : nodes, optional (Default=all edges)\n    If u and v are specified, return the number of edges between\n    u and v. Otherwise return the total number of all edges.\n\nReturns\n-------\nnedges : int\n    The number of edges in the graph.  If nodes `u` and `v` are\n    specified return the number of edges between those nodes. If\n    the graph is directed, this only returns the number of edges\n    from `u` to `v`.\n\nSee Also\n--------\nsize\n\nExamples\n--------\nFor undirected multigraphs, this method counts the total number\nof edges in the graph::\n\n    >>> G = nx.MultiGraph()\n    >>> G.add_edges_from([(0, 1), (0, 1), (1, 2)])\n    [0, 1, 0]\n    >>> G.number_of_edges()\n    3\n\nIf you specify two nodes, this counts the total number of edges\njoining the two nodes::\n\n    >>> G.number_of_edges(0, 1)\n    2\n\nFor directed multigraphs, this method can count the total number\nof directed edges from `u` to `v`::\n\n    >>> G = nx.MultiDiGraph()\n    >>> G.add_edges_from([(0, 1), (0, 1), (1, 0)])\n    [0, 1, 0]\n    >>> G.number_of_edges(0, 1)\n    2\n    >>> G.number_of_edges(1, 0)\n    1"}, {"type": "method", "name": "networkx.MultiDiGraph.number_of_nodes", "documentation": "Returns the number of nodes in the graph.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\norder: identical method\n__len__: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.number_of_nodes()\n3"}, {"type": "method", "name": "networkx.MultiDiGraph.order", "documentation": "Returns the number of nodes in the graph.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\nnumber_of_nodes: identical method\n__len__: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.order()\n3"}, {"type": "method", "name": "networkx.MultiDiGraph.predecessors", "documentation": "Returns an iterator over predecessor nodes of n.\n\nA predecessor of n is a node m such that there exists a directed\nedge from m to n.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\nsuccessors"}, {"type": "method", "name": "networkx.MultiDiGraph.remove_edge", "documentation": "Remove an edge between u and v.\n\nParameters\n----------\nu, v : nodes\n    Remove an edge between nodes u and v.\nkey : hashable identifier, optional (default=None)\n    Used to distinguish multiple edges between a pair of nodes.\n    If None, remove a single edge between u and v. If there are\n    multiple edges, removes the last edge added in terms of\n    insertion order.\n\nRaises\n------\nNetworkXError\n    If there is not an edge between u and v, or\n    if there is no edge with the specified key.\n\nSee Also\n--------\nremove_edges_from : remove a collection of edges\n\nExamples\n--------\n>>> G = nx.MultiDiGraph()\n>>> nx.add_path(G, [0, 1, 2, 3])\n>>> G.remove_edge(0, 1)\n>>> e = (1, 2)\n>>> G.remove_edge(*e)  # unpacks e from an edge tuple\n\nFor multiple edges\n\n>>> G = nx.MultiDiGraph()\n>>> G.add_edges_from([(1, 2), (1, 2), (1, 2)])  # key_list returned\n[0, 1, 2]\n\nWhen ``key=None`` (the default), edges are removed in the opposite\norder that they were added:\n\n>>> G.remove_edge(1, 2)\n>>> G.edges(keys=True)\nOutMultiEdgeView([(1, 2, 0), (1, 2, 1)])\n\nFor edges with keys\n\n>>> G = nx.MultiDiGraph()\n>>> G.add_edge(1, 2, key=\"first\")\n'first'\n>>> G.add_edge(1, 2, key=\"second\")\n'second'\n>>> G.remove_edge(1, 2, key=\"first\")\n>>> G.edges(keys=True)\nOutMultiEdgeView([(1, 2, 'second')])"}, {"type": "method", "name": "networkx.MultiDiGraph.remove_edges_from", "documentation": "Remove all edges specified in ebunch.\n\nParameters\n----------\nebunch: list or container of edge tuples\n    Each edge given in the list or container will be removed\n    from the graph. The edges can be:\n\n        - 2-tuples (u, v) A single edge between u and v is removed.\n        - 3-tuples (u, v, key) The edge identified by key is removed.\n        - 4-tuples (u, v, key, data) where data is ignored.\n\nSee Also\n--------\nremove_edge : remove a single edge\n\nNotes\n-----\nWill fail silently if an edge in ebunch is not in the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> ebunch = [(1, 2), (2, 3)]\n>>> G.remove_edges_from(ebunch)\n\nRemoving multiple copies of edges\n\n>>> G = nx.MultiGraph()\n>>> keys = G.add_edges_from([(1, 2), (1, 2), (1, 2)])\n>>> G.remove_edges_from([(1, 2), (2, 1)])  # edges aren't directed\n>>> list(G.edges())\n[(1, 2)]\n>>> G.remove_edges_from([(1, 2), (1, 2)])  # silently ignore extra copy\n>>> list(G.edges)  # now empty graph\n[]\n\nWhen the edge is a 2-tuple ``(u, v)`` but there are multiple edges between\nu and v in the graph, the most recent edge (in terms of insertion\norder) is removed.\n\n>>> G = nx.MultiGraph()\n>>> for key in (\"x\", \"y\", \"a\"):\n...     k = G.add_edge(0, 1, key=key)\n>>> G.edges(keys=True)\nMultiEdgeView([(0, 1, 'x'), (0, 1, 'y'), (0, 1, 'a')])\n>>> G.remove_edges_from([(0, 1)])\n>>> G.edges(keys=True)\nMultiEdgeView([(0, 1, 'x'), (0, 1, 'y')])"}, {"type": "method", "name": "networkx.MultiDiGraph.remove_node", "documentation": "Remove node n.\n\nRemoves the node n and all adjacent edges.\nAttempting to remove a nonexistent node will raise an exception.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\nremove_nodes_from\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> list(G.edges)\n[(0, 1), (1, 2)]\n>>> G.remove_node(1)\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.MultiDiGraph.remove_nodes_from", "documentation": "Remove multiple nodes.\n\nParameters\n----------\nnodes : iterable container\n    A container of nodes (list, dict, set, etc.).  If a node\n    in the container is not in the graph it is silently ignored.\n\nSee Also\n--------\nremove_node\n\nNotes\n-----\nWhen removing nodes from an iterator over the graph you are changing,\na `RuntimeError` will be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_nodes)`, and pass this\nobject to `G.remove_nodes_from`.\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> e = list(G.nodes)\n>>> e\n[0, 1, 2]\n>>> G.remove_nodes_from(e)\n>>> list(G.nodes)\n[]\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.DiGraph([(0, 1), (1, 2), (3, 4)])\n>>> # this command will fail, as the graph's dict is modified during iteration\n>>> # G.remove_nodes_from(n for n in G.nodes if n < 2)\n>>> # this command will work, since the dictionary underlying graph is not modified\n>>> G.remove_nodes_from(list(n for n in G.nodes if n < 2))"}, {"type": "method", "name": "networkx.MultiDiGraph.reverse", "documentation": "Returns the reverse of the graph.\n\nThe reverse is a graph with the same nodes and edges\nbut with the directions of the edges reversed.\n\nParameters\n----------\ncopy : bool optional (default=True)\n    If True, return a new DiGraph holding the reversed edges.\n    If False, the reverse graph is created using a view of\n    the original graph."}, {"type": "method", "name": "networkx.MultiDiGraph.size", "documentation": "Returns the number of edges or total of all edge weights.\n\nParameters\n----------\nweight : string or None, optional (default=None)\n    The edge attribute that holds the numerical value used\n    as a weight. If None, then each edge has weight 1.\n\nReturns\n-------\nsize : numeric\n    The number of edges or\n    (if weight keyword is provided) the total weight sum.\n\n    If weight is None, returns an int. Otherwise a float\n    (or more general numeric if the weights are more general).\n\nSee Also\n--------\nnumber_of_edges\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.size()\n3\n\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edge(\"a\", \"b\", weight=2)\n>>> G.add_edge(\"b\", \"c\", weight=4)\n>>> G.size()\n2\n>>> G.size(weight=\"weight\")\n6.0"}, {"type": "method", "name": "networkx.MultiDiGraph.subgraph", "documentation": "Returns a SubGraph view of the subgraph induced on `nodes`.\n\nThe induced subgraph of the graph contains the nodes in `nodes`\nand the edges between those nodes.\n\nParameters\n----------\nnodes : list, iterable\n    A container of nodes which will be iterated through once.\n\nReturns\n-------\nG : SubGraph View\n    A subgraph view of the graph. The graph structure cannot be\n    changed but node/edge attributes can and are shared with the\n    original graph.\n\nNotes\n-----\nThe graph, edge and node attributes are shared with the original graph.\nChanges to the graph structure is ruled out by the view, but changes\nto attributes are reflected in the original graph.\n\nTo create a subgraph with its own copy of the edge/node attributes use:\nG.subgraph(nodes).copy()\n\nFor an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([n for n in G if n not in set(nodes)])\n\nSubgraph views are sometimes NOT what you want. In most cases where\nyou want to do more than simply look at the induced edges, it makes\nmore sense to just create the subgraph as its own graph with code like:\n\n::\n\n    # Create a subgraph SG based on a (possibly multigraph) G\n    SG = G.__class__()\n    SG.add_nodes_from((n, G.nodes[n]) for n in largest_wcc)\n    if SG.is_multigraph():\n        SG.add_edges_from(\n            (n, nbr, key, d)\n            for n, nbrs in G.adj.items()\n            if n in largest_wcc\n            for nbr, keydict in nbrs.items()\n            if nbr in largest_wcc\n            for key, d in keydict.items()\n        )\n    else:\n        SG.add_edges_from(\n            (n, nbr, d)\n            for n, nbrs in G.adj.items()\n            if n in largest_wcc\n            for nbr, d in nbrs.items()\n            if nbr in largest_wcc\n        )\n    SG.graph.update(G.graph)\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> H = G.subgraph([0, 1, 2])\n>>> list(H.edges)\n[(0, 1), (1, 2)]"}, {"type": "method", "name": "networkx.MultiDiGraph.successors", "documentation": "Returns an iterator over successor nodes of n.\n\nA successor of n is a node m such that there exists a directed\nedge from n to m.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\npredecessors\n\nNotes\n-----\nneighbors() and successors() are the same."}, {"type": "method", "name": "networkx.MultiDiGraph.to_directed", "documentation": "Returns a directed representation of the graph.\n\nReturns\n-------\nG : MultiDiGraph\n    A directed graph with the same name, same nodes, and with\n    each edge (u, v, k, data) replaced by two directed edges\n    (u, v, k, data) and (v, u, k, data).\n\nNotes\n-----\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar D=MultiDiGraph(G) which\nreturns a shallow copy of the data.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nWarning: If you have subclassed MultiGraph to use dict-like objects\nin the data structure, those changes do not transfer to the\nMultiDiGraph created by this method.\n\nExamples\n--------\n>>> G = nx.MultiGraph()\n>>> G.add_edge(0, 1)\n0\n>>> G.add_edge(0, 1)\n1\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1)]\n\nIf already directed, return a (deep) copy\n\n>>> G = nx.MultiDiGraph()\n>>> G.add_edge(0, 1)\n0\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1, 0)]"}, {"type": "method", "name": "networkx.MultiDiGraph.to_directed_class", "documentation": "Returns the class to use for empty directed copies.\n\nIf you subclass the base classes, use this to designate\nwhat directed class to use for `to_directed()` copies."}, {"type": "method", "name": "networkx.MultiDiGraph.to_undirected", "documentation": "Returns an undirected representation of the digraph.\n\nParameters\n----------\nreciprocal : bool (optional)\n  If True only keep edges that appear in both directions\n  in the original digraph.\nas_view : bool (optional, default=False)\n  If True return an undirected view of the original directed graph.\n\nReturns\n-------\nG : MultiGraph\n    An undirected graph with the same name and nodes and\n    with edge (u, v, data) if either (u, v, data) or (v, u, data)\n    is in the digraph.  If both edges exist in digraph and\n    their edge data is different, only one edge is created\n    with an arbitrary choice of which edge data to use.\n    You must check and correct for this manually if desired.\n\nSee Also\n--------\nMultiGraph, copy, add_edge, add_edges_from\n\nNotes\n-----\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar D=MultiDiGraph(G) which\nreturns a shallow copy of the data.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nWarning: If you have subclassed MultiDiGraph to use dict-like\nobjects in the data structure, those changes do not transfer\nto the MultiGraph created by this method.\n\nExamples\n--------\n>>> G = nx.path_graph(2)  # or MultiGraph, etc\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1), (1, 0)]\n>>> G2 = H.to_undirected()\n>>> list(G2.edges)\n[(0, 1)]"}, {"type": "method", "name": "networkx.MultiDiGraph.to_undirected_class", "documentation": "Returns the class to use for empty undirected copies.\n\nIf you subclass the base classes, use this to designate\nwhat directed class to use for `to_directed()` copies."}, {"type": "method", "name": "networkx.MultiDiGraph.update", "documentation": "Update the graph using nodes/edges/graphs as input.\n\nLike dict.update, this method takes a graph as input, adding the\ngraph's nodes and edges to this graph. It can also take two inputs:\nedges and nodes. Finally it can take either edges or nodes.\nTo specify only nodes the keyword `nodes` must be used.\n\nThe collections of edges and nodes are treated similarly to\nthe add_edges_from/add_nodes_from methods. When iterated, they\nshould yield 2-tuples (u, v) or 3-tuples (u, v, datadict).\n\nParameters\n----------\nedges : Graph object, collection of edges, or None\n    The first parameter can be a graph or some edges. If it has\n    attributes `nodes` and `edges`, then it is taken to be a\n    Graph-like object and those attributes are used as collections\n    of nodes and edges to be added to the graph.\n    If the first parameter does not have those attributes, it is\n    treated as a collection of edges and added to the graph.\n    If the first argument is None, no edges are added.\nnodes : collection of nodes, or None\n    The second parameter is treated as a collection of nodes\n    to be added to the graph unless it is None.\n    If `edges is None` and `nodes is None` an exception is raised.\n    If the first parameter is a Graph, then `nodes` is ignored.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> G.update(nx.complete_graph(range(4, 10)))\n>>> from itertools import combinations\n>>> edges = (\n...     (u, v, {\"power\": u * v})\n...     for u, v in combinations(range(10, 20), 2)\n...     if u * v < 225\n... )\n>>> nodes = [1000]  # for singleton, use a container\n>>> G.update(edges, nodes)\n\nNotes\n-----\nIt you want to update the graph using an adjacency structure\nit is straightforward to obtain the edges/nodes from adjacency.\nThe following examples provide common cases, your adjacency may\nbe slightly different and require tweaks of these examples::\n\n>>> # dict-of-set/list/tuple\n>>> adj = {1: {2, 3}, 2: {1, 3}, 3: {1, 2}}\n>>> e = [(u, v) for u, nbrs in adj.items() for v in nbrs]\n>>> G.update(edges=e, nodes=adj)\n\n>>> DG = nx.DiGraph()\n>>> # dict-of-dict-of-attribute\n>>> adj = {1: {2: 1.3, 3: 0.7}, 2: {1: 1.4}, 3: {1: 0.7}}\n>>> e = [(u, v, {\"weight\": d}) for u, nbrs in adj.items() for v, d in nbrs.items()]\n>>> DG.update(edges=e, nodes=adj)\n\n>>> # dict-of-dict-of-dict\n>>> adj = {1: {2: {\"weight\": 1.3}, 3: {\"color\": 0.7, \"weight\": 1.2}}}\n>>> e = [(u, v, {\"weight\": d}) for u, nbrs in adj.items() for v, d in nbrs.items()]\n>>> DG.update(edges=e, nodes=adj)\n\n>>> # predecessor adjacency (dict-of-set)\n>>> pred = {1: {2, 3}, 2: {3}, 3: {3}}\n>>> e = [(v, u) for u, nbrs in pred.items() for v in nbrs]\n\n>>> # MultiGraph dict-of-dict-of-dict-of-attribute\n>>> MDG = nx.MultiDiGraph()\n>>> adj = {\n...     1: {2: {0: {\"weight\": 1.3}, 1: {\"weight\": 1.2}}},\n...     3: {2: {0: {\"weight\": 0.7}}},\n... }\n>>> e = [\n...     (u, v, ekey, d)\n...     for u, nbrs in adj.items()\n...     for v, keydict in nbrs.items()\n...     for ekey, d in keydict.items()\n... ]\n>>> MDG.update(edges=e)\n\nSee Also\n--------\nadd_edges_from: add multiple edges to a graph\nadd_nodes_from: add multiple nodes to a graph"}, {"type": "class", "name": "networkx.MultiGraph", "documentation": "An undirected graph class that can store multiedges.\n\nMultiedges are multiple edges between two nodes.  Each edge\ncan hold optional data or attributes.\n\nA MultiGraph holds undirected edges.  Self loops are allowed.\n\nNodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention `None` is not used as a node.\n\nEdges are represented as links between nodes with optional\nkey/value attributes, in a MultiGraph each edge has a key to\ndistinguish between multiple edges that have the same source and\ndestination nodes.\n\nParameters\n----------\nincoming_graph_data : input graph (optional, default: None)\n    Data to initialize graph. If None (default) an empty\n    graph is created.  The data can be any format that is supported\n    by the to_networkx_graph() function, currently including edge list,\n    dict of dicts, dict of lists, NetworkX graph, 2D NumPy array,\n    SciPy sparse array, or PyGraphviz graph.\n\nmultigraph_input : bool or None (default None)\n    Note: Only used when `incoming_graph_data` is a dict.\n    If True, `incoming_graph_data` is assumed to be a\n    dict-of-dict-of-dict-of-dict structure keyed by\n    node to neighbor to edge keys to edge data for multi-edges.\n    A NetworkXError is raised if this is not the case.\n    If False, :func:`to_networkx_graph` is used to try to determine\n    the dict's graph data structure as either a dict-of-dict-of-dict\n    keyed by node to neighbor to edge data, or a dict-of-iterable\n    keyed by node to neighbors.\n    If None, the treatment for True is tried, but if it fails,\n    the treatment for False is tried.\n\nattr : keyword arguments, optional (default= no attributes)\n    Attributes to add to graph as key=value pairs.\n\nSee Also\n--------\nGraph\nDiGraph\nMultiDiGraph\n\nExamples\n--------\nCreate an empty graph structure (a \"null graph\") with no nodes and\nno edges.\n\n>>> G = nx.MultiGraph()\n\nG can be grown in several ways.\n\n**Nodes:**\n\nAdd one node at a time:\n\n>>> G.add_node(1)\n\nAdd the nodes from any container (a list, dict, set or\neven the lines from a file or the nodes from another graph).\n\n>>> G.add_nodes_from([2, 3])\n>>> G.add_nodes_from(range(100, 110))\n>>> H = nx.path_graph(10)\n>>> G.add_nodes_from(H)\n\nIn addition to strings and integers any hashable Python object\n(except None) can represent a node, e.g. a customized node object,\nor even another Graph.\n\n>>> G.add_node(H)\n\n**Edges:**\n\nG can also be grown by adding edges.\n\nAdd one edge,\n\n>>> key = G.add_edge(1, 2)\n\na list of edges,\n\n>>> keys = G.add_edges_from([(1, 2), (1, 3)])\n\nor a collection of edges,\n\n>>> keys = G.add_edges_from(H.edges)\n\nIf some edges connect nodes not yet in the graph, the nodes\nare added automatically.  If an edge already exists, an additional\nedge is created and stored using a key to identify the edge.\nBy default the key is the lowest unused integer.\n\n>>> keys = G.add_edges_from([(4, 5, {\"route\": 28}), (4, 5, {\"route\": 37})])\n>>> G[4]\nAdjacencyView({3: {0: {}}, 5: {0: {}, 1: {'route': 28}, 2: {'route': 37}}})\n\n**Attributes:**\n\nEach graph, node, and edge can hold key/value attribute pairs\nin an associated attribute dictionary (the keys must be hashable).\nBy default these are empty, but can be added or changed using\nadd_edge, add_node or direct manipulation of the attribute\ndictionaries named graph, node and edge respectively.\n\n>>> G = nx.MultiGraph(day=\"Friday\")\n>>> G.graph\n{'day': 'Friday'}\n\nAdd node attributes using add_node(), add_nodes_from() or G.nodes\n\n>>> G.add_node(1, time=\"5pm\")\n>>> G.add_nodes_from([3], time=\"2pm\")\n>>> G.nodes[1]\n{'time': '5pm'}\n>>> G.nodes[1][\"room\"] = 714\n>>> del G.nodes[1][\"room\"]  # remove attribute\n>>> list(G.nodes(data=True))\n[(1, {'time': '5pm'}), (3, {'time': '2pm'})]\n\nAdd edge attributes using add_edge(), add_edges_from(), subscript\nnotation, or G.edges.\n\n>>> key = G.add_edge(1, 2, weight=4.7)\n>>> keys = G.add_edges_from([(3, 4), (4, 5)], color=\"red\")\n>>> keys = G.add_edges_from([(1, 2, {\"color\": \"blue\"}), (2, 3, {\"weight\": 8})])\n>>> G[1][2][0][\"weight\"] = 4.7\n>>> G.edges[1, 2, 0][\"weight\"] = 4\n\nWarning: we protect the graph data structure by making `G.edges[1,\n2, 0]` a read-only dict-like structure. However, you can assign to\nattributes in e.g. `G.edges[1, 2, 0]`. Thus, use 2 sets of brackets\nto add/change data attributes: `G.edges[1, 2, 0]['weight'] = 4`.\n\n**Shortcuts:**\n\nMany common graph features allow python syntax to speed reporting.\n\n>>> 1 in G  # check if node in graph\nTrue\n>>> [n for n in G if n < 3]  # iterate through nodes\n[1, 2]\n>>> len(G)  # number of nodes in graph\n5\n>>> G[1]  # adjacency dict-like view mapping neighbor -> edge key -> edge attributes\nAdjacencyView({2: {0: {'weight': 4}, 1: {'color': 'blue'}}})\n\nOften the best way to traverse all edges of a graph is via the neighbors.\nThe neighbors are reported as an adjacency-dict `G.adj` or `G.adjacency()`.\n\n>>> for n, nbrsdict in G.adjacency():\n...     for nbr, keydict in nbrsdict.items():\n...         for key, eattr in keydict.items():\n...             if \"weight\" in eattr:\n...                 # Do something useful with the edges\n...                 pass\n\nBut the edges() method is often more convenient:\n\n>>> for u, v, keys, weight in G.edges(data=\"weight\", keys=True):\n...     if weight is not None:\n...         # Do something useful with the edges\n...         pass\n\n**Reporting:**\n\nSimple graph information is obtained using methods and object-attributes.\nReporting usually provides views instead of containers to reduce memory\nusage. The views update as the graph is updated similarly to dict-views.\nThe objects `nodes`, `edges` and `adj` provide access to data attributes\nvia lookup (e.g. `nodes[n]`, `edges[u, v, k]`, `adj[u][v]`) and iteration\n(e.g. `nodes.items()`, `nodes.data('color')`,\n`nodes.data('color', default='blue')` and similarly for `edges`)\nViews exist for `nodes`, `edges`, `neighbors()`/`adj` and `degree`.\n\nFor details on these and other miscellaneous methods, see below.\n\n**Subclasses (Advanced):**\n\nThe MultiGraph class uses a dict-of-dict-of-dict-of-dict data structure.\nThe outer dict (node_dict) holds adjacency information keyed by node.\nThe next dict (adjlist_dict) represents the adjacency information\nand holds edge_key dicts keyed by neighbor. The edge_key dict holds\neach edge_attr dict keyed by edge key. The inner dict\n(edge_attr_dict) represents the edge data and holds edge attribute\nvalues keyed by attribute names.\n\nEach of these four dicts in the dict-of-dict-of-dict-of-dict\nstructure can be replaced by a user defined dict-like object.\nIn general, the dict-like features should be maintained but\nextra features can be added. To replace one of the dicts create\na new graph class by changing the class(!) variable holding the\nfactory for that dict-like structure. The variable names are\nnode_dict_factory, node_attr_dict_factory, adjlist_inner_dict_factory,\nadjlist_outer_dict_factory, edge_key_dict_factory, edge_attr_dict_factory\nand graph_attr_dict_factory.\n\nnode_dict_factory : function, (default: dict)\n    Factory function to be used to create the dict containing node\n    attributes, keyed by node id.\n    It should require no arguments and return a dict-like object\n\nnode_attr_dict_factory: function, (default: dict)\n    Factory function to be used to create the node attribute\n    dict which holds attribute values keyed by attribute name.\n    It should require no arguments and return a dict-like object\n\nadjlist_outer_dict_factory : function, (default: dict)\n    Factory function to be used to create the outer-most dict\n    in the data structure that holds adjacency info keyed by node.\n    It should require no arguments and return a dict-like object.\n\nadjlist_inner_dict_factory : function, (default: dict)\n    Factory function to be used to create the adjacency list\n    dict which holds multiedge key dicts keyed by neighbor.\n    It should require no arguments and return a dict-like object.\n\nedge_key_dict_factory : function, (default: dict)\n    Factory function to be used to create the edge key dict\n    which holds edge data keyed by edge key.\n    It should require no arguments and return a dict-like object.\n\nedge_attr_dict_factory : function, (default: dict)\n    Factory function to be used to create the edge attribute\n    dict which holds attribute values keyed by attribute name.\n    It should require no arguments and return a dict-like object.\n\ngraph_attr_dict_factory : function, (default: dict)\n    Factory function to be used to create the graph attribute\n    dict which holds attribute values keyed by attribute name.\n    It should require no arguments and return a dict-like object.\n\nTypically, if your extension doesn't impact the data structure all\nmethods will inherited without issue except: `to_directed/to_undirected`.\nBy default these methods create a DiGraph/Graph class and you probably\nwant them to create your extension of a DiGraph/Graph. To facilitate\nthis we define two class variables that you can set in your subclass.\n\nto_directed_class : callable, (default: DiGraph or MultiDiGraph)\n    Class to create a new graph structure in the `to_directed` method.\n    If `None`, a NetworkX class (DiGraph or MultiDiGraph) is used.\n\nto_undirected_class : callable, (default: Graph or MultiGraph)\n    Class to create a new graph structure in the `to_undirected` method.\n    If `None`, a NetworkX class (Graph or MultiGraph) is used.\n\n**Subclassing Example**\n\nCreate a low memory graph class that effectively disallows edge\nattributes by using a single attribute dict for all edges.\nThis reduces the memory used, but you lose edge attributes.\n\n>>> class ThinGraph(nx.Graph):\n...     all_edge_dict = {\"weight\": 1}\n...\n...     def single_edge_dict(self):\n...         return self.all_edge_dict\n...\n...     edge_attr_dict_factory = single_edge_dict\n>>> G = ThinGraph()\n>>> G.add_edge(2, 1)\n>>> G[2][1]\n{'weight': 1}\n>>> G.add_edge(2, 2)\n>>> G[2][1] is G[2][2]\nTrue"}, {"type": "method", "name": "networkx.MultiGraph.__contains__", "documentation": "Returns True if n is a node, False otherwise. Use: 'n in G'.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> 1 in G\nTrue"}, {"type": "method", "name": "networkx.MultiGraph.__getitem__", "documentation": "Returns a dict of neighbors of node n.  Use: 'G[n]'.\n\nParameters\n----------\nn : node\n   A node in the graph.\n\nReturns\n-------\nadj_dict : dictionary\n   The adjacency dictionary for nodes connected to n.\n\nNotes\n-----\nG[n] is the same as G.adj[n] and similar to G.neighbors(n)\n(which is an iterator over G.adj[n])\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G[0]\nAtlasView({1: {}})"}, {"type": "method", "name": "networkx.MultiGraph.__init__", "documentation": "Initialize a graph with edges, name, or graph attributes.\n\nParameters\n----------\nincoming_graph_data : input graph\n    Data to initialize graph.  If incoming_graph_data=None (default)\n    an empty graph is created.  The data can be an edge list, or any\n    NetworkX graph object.  If the corresponding optional Python\n    packages are installed the data can also be a 2D NumPy array, a\n    SciPy sparse array, or a PyGraphviz graph.\n\nmultigraph_input : bool or None (default None)\n    Note: Only used when `incoming_graph_data` is a dict.\n    If True, `incoming_graph_data` is assumed to be a\n    dict-of-dict-of-dict-of-dict structure keyed by\n    node to neighbor to edge keys to edge data for multi-edges.\n    A NetworkXError is raised if this is not the case.\n    If False, :func:`to_networkx_graph` is used to try to determine\n    the dict's graph data structure as either a dict-of-dict-of-dict\n    keyed by node to neighbor to edge data, or a dict-of-iterable\n    keyed by node to neighbors.\n    If None, the treatment for True is tried, but if it fails,\n    the treatment for False is tried.\n\nattr : keyword arguments, optional (default= no attributes)\n    Attributes to add to graph as key=value pairs.\n\nSee Also\n--------\nconvert\n\nExamples\n--------\n>>> G = nx.MultiGraph()\n>>> G = nx.MultiGraph(name=\"my graph\")\n>>> e = [(1, 2), (1, 2), (2, 3), (3, 4)]  # list of edges\n>>> G = nx.MultiGraph(e)\n\nArbitrary graph attribute pairs (key=value) may be assigned\n\n>>> G = nx.MultiGraph(e, day=\"Friday\")\n>>> G.graph\n{'day': 'Friday'}"}, {"type": "method", "name": "networkx.MultiGraph.__iter__", "documentation": "Iterate over the nodes. Use: 'for n in G'.\n\nReturns\n-------\nniter : iterator\n    An iterator over all nodes in the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> [n for n in G]\n[0, 1, 2, 3]\n>>> list(G)\n[0, 1, 2, 3]"}, {"type": "method", "name": "networkx.MultiGraph.__len__", "documentation": "Returns the number of nodes in the graph. Use: 'len(G)'.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\nnumber_of_nodes: identical method\norder: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> len(G)\n4"}, {"type": "method", "name": "networkx.MultiGraph.__str__", "documentation": "Returns a short summary of the graph.\n\nReturns\n-------\ninfo : string\n    Graph information including the graph name (if any), graph type, and the\n    number of nodes and edges.\n\nExamples\n--------\n>>> G = nx.Graph(name=\"foo\")\n>>> str(G)\n\"Graph named 'foo' with 0 nodes and 0 edges\"\n\n>>> G = nx.path_graph(3)\n>>> str(G)\n'Graph with 3 nodes and 2 edges'"}, {"type": "method", "name": "networkx.MultiGraph.add_edge", "documentation": "Add an edge between u and v.\n\nThe nodes u and v will be automatically added if they are\nnot already in the graph.\n\nEdge attributes can be specified with keywords or by directly\naccessing the edge's attribute dictionary. See examples below.\n\nParameters\n----------\nu_for_edge, v_for_edge : nodes\n    Nodes can be, for example, strings or numbers.\n    Nodes must be hashable (and not None) Python objects.\nkey : hashable identifier, optional (default=lowest unused integer)\n    Used to distinguish multiedges between a pair of nodes.\nattr : keyword arguments, optional\n    Edge data (or labels or objects) can be assigned using\n    keyword arguments.\n\nReturns\n-------\nThe edge key assigned to the edge.\n\nSee Also\n--------\nadd_edges_from : add a collection of edges\n\nNotes\n-----\nTo replace/update edge data, use the optional key argument\nto identify a unique edge.  Otherwise a new edge will be created.\n\nNetworkX algorithms designed for weighted graphs cannot use\nmultigraphs directly because it is not clear how to handle\nmultiedge weights.  Convert to Graph using edge attribute\n'weight' to enable weighted graph algorithms.\n\nDefault keys are generated using the method `new_edge_key()`.\nThis method can be overridden by subclassing the base class and\nproviding a custom `new_edge_key()` method.\n\nExamples\n--------\nThe following each add an additional edge e=(1, 2) to graph G:\n\n>>> G = nx.MultiGraph()\n>>> e = (1, 2)\n>>> ekey = G.add_edge(1, 2)  # explicit two-node form\n>>> G.add_edge(*e)  # single edge as tuple of two nodes\n1\n>>> G.add_edges_from([(1, 2)])  # add edges from iterable container\n[2]\n\nAssociate data to edges using keywords:\n\n>>> ekey = G.add_edge(1, 2, weight=3)\n>>> ekey = G.add_edge(1, 2, key=0, weight=4)  # update data for key=0\n>>> ekey = G.add_edge(1, 3, weight=7, capacity=15, length=342.7)\n\nFor non-string attribute keys, use subscript notation.\n\n>>> ekey = G.add_edge(1, 2)\n>>> G[1][2][0].update({0: 5})\n>>> G.edges[1, 2, 0].update({0: 5})"}, {"type": "method", "name": "networkx.MultiGraph.add_edges_from", "documentation": "Add all the edges in ebunch_to_add.\n\nParameters\n----------\nebunch_to_add : container of edges\n    Each edge given in the container will be added to the\n    graph. The edges can be:\n\n        - 2-tuples (u, v) or\n        - 3-tuples (u, v, d) for an edge data dict d, or\n        - 3-tuples (u, v, k) for not iterable key k, or\n        - 4-tuples (u, v, k, d) for an edge with data and key k\n\nattr : keyword arguments, optional\n    Edge data (or labels or objects) can be assigned using\n    keyword arguments.\n\nReturns\n-------\nA list of edge keys assigned to the edges in `ebunch`.\n\nSee Also\n--------\nadd_edge : add a single edge\nadd_weighted_edges_from : convenient way to add weighted edges\n\nNotes\n-----\nAdding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added.\n\nEdge attributes specified in an ebunch take precedence over\nattributes specified via keyword arguments.\n\nDefault keys are generated using the method ``new_edge_key()``.\nThis method can be overridden by subclassing the base class and\nproviding a custom ``new_edge_key()`` method.\n\nWhen adding edges from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_edges)`, and pass this\nobject to `G.add_edges_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edges_from([(0, 1), (1, 2)])  # using a list of edge tuples\n>>> e = zip(range(0, 3), range(1, 4))\n>>> G.add_edges_from(e)  # Add the path graph 0-1-2-3\n\nAssociate data to edges\n\n>>> G.add_edges_from([(1, 2), (2, 3)], weight=3)\n>>> G.add_edges_from([(3, 4), (1, 4)], label=\"WN2898\")\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.MultiGraph([(1, 2), (2, 3), (3, 4)])\n>>> # Grow graph by one new node, adding edges to all existing nodes.\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_edges_from(((5, n) for n in G.nodes))\n>>> # right way - note that there will be no self-edge for node 5\n>>> assigned_keys = G.add_edges_from(list((5, n) for n in G.nodes))"}, {"type": "method", "name": "networkx.MultiGraph.add_node", "documentation": "Add a single node `node_for_adding` and update node attributes.\n\nParameters\n----------\nnode_for_adding : node\n    A node can be any hashable Python object except None.\nattr : keyword arguments, optional\n    Set or change node attributes using key=value.\n\nSee Also\n--------\nadd_nodes_from\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_node(1)\n>>> G.add_node(\"Hello\")\n>>> K3 = nx.Graph([(0, 1), (1, 2), (2, 0)])\n>>> G.add_node(K3)\n>>> G.number_of_nodes()\n3\n\nUse keywords set/change node attributes:\n\n>>> G.add_node(1, size=10)\n>>> G.add_node(3, weight=0.4, UTM=(\"13S\", 382871, 3972649))\n\nNotes\n-----\nA hashable object is one that can be used as a key in a Python\ndictionary. This includes strings, numbers, tuples of strings\nand numbers, etc.\n\nOn many platforms hashable items also include mutables such as\nNetworkX Graphs, though one should be careful that the hash\ndoesn't change on mutables."}, {"type": "method", "name": "networkx.MultiGraph.add_nodes_from", "documentation": "Add multiple nodes.\n\nParameters\n----------\nnodes_for_adding : iterable container\n    A container of nodes (list, dict, set, etc.).\n    OR\n    A container of (node, attribute dict) tuples.\n    Node attributes are updated using the attribute dict.\nattr : keyword arguments, optional (default= no attributes)\n    Update attributes for all nodes in nodes.\n    Node attributes specified in nodes as a tuple take\n    precedence over attributes specified via keyword arguments.\n\nSee Also\n--------\nadd_node\n\nNotes\n-----\nWhen adding nodes from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_nodes)`, and pass this\nobject to `G.add_nodes_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_nodes_from(\"Hello\")\n>>> K3 = nx.Graph([(0, 1), (1, 2), (2, 0)])\n>>> G.add_nodes_from(K3)\n>>> sorted(G.nodes(), key=str)\n[0, 1, 2, 'H', 'e', 'l', 'o']\n\nUse keywords to update specific node attributes for every node.\n\n>>> G.add_nodes_from([1, 2], size=10)\n>>> G.add_nodes_from([3, 4], weight=0.4)\n\nUse (node, attrdict) tuples to update attributes for specific nodes.\n\n>>> G.add_nodes_from([(1, dict(size=11)), (2, {\"color\": \"blue\"})])\n>>> G.nodes[1][\"size\"]\n11\n>>> H = nx.Graph()\n>>> H.add_nodes_from(G.nodes(data=True))\n>>> H.nodes[1][\"size\"]\n11\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.Graph([(0, 1), (1, 2), (3, 4)])\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_nodes_from(n + 1 for n in G.nodes)\n>>> # correct way\n>>> G.add_nodes_from(list(n + 1 for n in G.nodes))"}, {"type": "method", "name": "networkx.MultiGraph.add_weighted_edges_from", "documentation": "Add weighted edges in `ebunch_to_add` with specified weight attr\n\nParameters\n----------\nebunch_to_add : container of edges\n    Each edge given in the list or container will be added\n    to the graph. The edges must be given as 3-tuples (u, v, w)\n    where w is a number.\nweight : string, optional (default= 'weight')\n    The attribute name for the edge weights to be added.\nattr : keyword arguments, optional (default= no attributes)\n    Edge attributes to add/update for all edges.\n\nSee Also\n--------\nadd_edge : add a single edge\nadd_edges_from : add multiple edges\n\nNotes\n-----\nAdding the same edge twice for Graph/DiGraph simply updates\nthe edge data. For MultiGraph/MultiDiGraph, duplicate edges\nare stored.\n\nWhen adding edges from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_edges)`, and pass this\nobject to `G.add_weighted_edges_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_weighted_edges_from([(0, 1, 3.0), (1, 2, 7.5)])\n\nEvaluate an iterator over edges before passing it\n\n>>> G = nx.Graph([(1, 2), (2, 3), (3, 4)])\n>>> weight = 0.1\n>>> # Grow graph by one new node, adding edges to all existing nodes.\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))\n>>> # correct way - note that there will be no self-edge for node 5\n>>> G.add_weighted_edges_from(list((5, n, weight) for n in G.nodes))"}, {"type": "method", "name": "networkx.MultiGraph.adjacency", "documentation": "Returns an iterator over (node, adjacency dict) tuples for all nodes.\n\nFor directed graphs, only outgoing neighbors/adjacencies are included.\n\nReturns\n-------\nadj_iter : iterator\n   An iterator over (node, adjacency dictionary) for all nodes in\n   the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> [(n, nbrdict) for n, nbrdict in G.adjacency()]\n[(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]"}, {"type": "method", "name": "networkx.MultiGraph.clear", "documentation": "Remove all nodes and edges from the graph.\n\nThis also removes the name, and all graph, node, and edge attributes.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.clear()\n>>> list(G.nodes)\n[]\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.MultiGraph.clear_edges", "documentation": "Remove all edges from the graph without altering nodes.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.clear_edges()\n>>> list(G.nodes)\n[0, 1, 2, 3]\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.MultiGraph.copy", "documentation": "Returns a copy of the graph.\n\nThe copy method by default returns an independent shallow copy\nof the graph and attributes. That is, if an attribute is a\ncontainer, that container is shared by the original an the copy.\nUse Python's `copy.deepcopy` for new containers.\n\nIf `as_view` is True then a view is returned instead of a copy.\n\nNotes\n-----\nAll copies reproduce the graph structure, but data attributes\nmay be handled in different ways. There are four types of copies\nof a graph that people might want.\n\nDeepcopy -- A \"deepcopy\" copies the graph structure as well as\nall data attributes and any objects they might contain.\nThe entire graph object is new so that changes in the copy\ndo not affect the original object. (see Python's copy.deepcopy)\n\nData Reference (Shallow) -- For a shallow copy the graph structure\nis copied but the edge, node and graph attribute dicts are\nreferences to those in the original graph. This saves\ntime and memory but could cause confusion if you change an attribute\nin one graph and it changes the attribute in the other.\nNetworkX does not provide this level of shallow copy.\n\nIndependent Shallow -- This copy creates new independent attribute\ndicts and then does a shallow copy of the attributes. That is, any\nattributes that are containers are shared between the new graph\nand the original. This is exactly what `dict.copy()` provides.\nYou can obtain this style copy using:\n\n    >>> G = nx.path_graph(5)\n    >>> H = G.copy()\n    >>> H = G.copy(as_view=False)\n    >>> H = nx.Graph(G)\n    >>> H = G.__class__(G)\n\nFresh Data -- For fresh data, the graph structure is copied while\nnew empty data attribute dicts are created. The resulting graph\nis independent of the original and it has no edge, node or graph\nattributes. Fresh copies are not enabled. Instead use:\n\n    >>> H = G.__class__()\n    >>> H.add_nodes_from(G)\n    >>> H.add_edges_from(G.edges)\n\nView -- Inspired by dict-views, graph-views act like read-only\nversions of the original graph, providing a copy of the original\nstructure without requiring any memory for copying the information.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nParameters\n----------\nas_view : bool, optional (default=False)\n    If True, the returned graph-view provides a read-only view\n    of the original graph without actually copying any data.\n\nReturns\n-------\nG : Graph\n    A copy of the graph.\n\nSee Also\n--------\nto_directed: return a directed copy of the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> H = G.copy()"}, {"type": "method", "name": "networkx.MultiGraph.edge_subgraph", "documentation": "Returns the subgraph induced by the specified edges.\n\nThe induced subgraph contains each edge in `edges` and each\nnode incident to any one of those edges.\n\nParameters\n----------\nedges : iterable\n    An iterable of edges in this graph.\n\nReturns\n-------\nG : Graph\n    An edge-induced subgraph of this graph with the same edge\n    attributes.\n\nNotes\n-----\nThe graph, edge, and node attributes in the returned subgraph\nview are references to the corresponding attributes in the original\ngraph. The view is read-only.\n\nTo create a full graph version of the subgraph with its own copy\nof the edge or node attributes, use::\n\n    G.edge_subgraph(edges).copy()\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> H = G.edge_subgraph([(0, 1), (3, 4)])\n>>> list(H.nodes)\n[0, 1, 3, 4]\n>>> list(H.edges)\n[(0, 1), (3, 4)]"}, {"type": "method", "name": "networkx.MultiGraph.get_edge_data", "documentation": "Returns the attribute dictionary associated with edge (u, v,\nkey).\n\nIf a key is not provided, returns a dictionary mapping edge keys\nto attribute dictionaries for each edge between u and v.\n\nThis is identical to `G[u][v][key]` except the default is returned\ninstead of an exception is the edge doesn't exist.\n\nParameters\n----------\nu, v : nodes\n\ndefault :  any Python object (default=None)\n    Value to return if the specific edge (u, v, key) is not\n    found, OR if there are no edges between u and v and no key\n    is specified.\n\nkey : hashable identifier, optional (default=None)\n    Return data only for the edge with specified key, as an\n    attribute dictionary (rather than a dictionary mapping keys\n    to attribute dictionaries).\n\nReturns\n-------\nedge_dict : dictionary\n    The edge attribute dictionary, OR a dictionary mapping edge\n    keys to attribute dictionaries for each of those edges if no\n    specific key is provided (even if there's only one edge\n    between u and v).\n\nExamples\n--------\n>>> G = nx.MultiGraph()  # or MultiDiGraph\n>>> key = G.add_edge(0, 1, key=\"a\", weight=7)\n>>> G[0][1][\"a\"]  # key='a'\n{'weight': 7}\n>>> G.edges[0, 1, \"a\"]  # key='a'\n{'weight': 7}\n\nWarning: we protect the graph data structure by making\n`G.edges` and `G[1][2]` read-only dict-like structures.\nHowever, you can assign values to attributes in e.g.\n`G.edges[1, 2, 'a']` or `G[1][2]['a']` using an additional\nbracket as shown next. You need to specify all edge info\nto assign to the edge data associated with an edge.\n\n>>> G[0][1][\"a\"][\"weight\"] = 10\n>>> G.edges[0, 1, \"a\"][\"weight\"] = 10\n>>> G[0][1][\"a\"][\"weight\"]\n10\n>>> G.edges[1, 0, \"a\"][\"weight\"]\n10\n\n>>> G = nx.MultiGraph()  # or MultiDiGraph\n>>> nx.add_path(G, [0, 1, 2, 3])\n>>> G.edges[0, 1, 0][\"weight\"] = 5\n>>> G.get_edge_data(0, 1)\n{0: {'weight': 5}}\n>>> e = (0, 1)\n>>> G.get_edge_data(*e)  # tuple form\n{0: {'weight': 5}}\n>>> G.get_edge_data(3, 0)  # edge not in graph, returns None\n>>> G.get_edge_data(3, 0, default=0)  # edge not in graph, return default\n0\n>>> G.get_edge_data(1, 0, 0)  # specific key gives back\n{'weight': 5}"}, {"type": "method", "name": "networkx.MultiGraph.has_edge", "documentation": "Returns True if the graph has an edge between nodes u and v.\n\nThis is the same as `v in G[u] or key in G[u][v]`\nwithout KeyError exceptions.\n\nParameters\n----------\nu, v : nodes\n    Nodes can be, for example, strings or numbers.\n\nkey : hashable identifier, optional (default=None)\n    If specified return True only if the edge with\n    key is found.\n\nReturns\n-------\nedge_ind : bool\n    True if edge is in the graph, False otherwise.\n\nExamples\n--------\nCan be called either using two nodes u, v, an edge tuple (u, v),\nor an edge tuple (u, v, key).\n\n>>> G = nx.MultiGraph()  # or MultiDiGraph\n>>> nx.add_path(G, [0, 1, 2, 3])\n>>> G.has_edge(0, 1)  # using two nodes\nTrue\n>>> e = (0, 1)\n>>> G.has_edge(*e)  #  e is a 2-tuple (u, v)\nTrue\n>>> G.add_edge(0, 1, key=\"a\")\n'a'\n>>> G.has_edge(0, 1, key=\"a\")  # specify key\nTrue\n>>> G.has_edge(1, 0, key=\"a\")  # edges aren't directed\nTrue\n>>> e = (0, 1, \"a\")\n>>> G.has_edge(*e)  # e is a 3-tuple (u, v, 'a')\nTrue\n\nThe following syntax are equivalent:\n\n>>> G.has_edge(0, 1)\nTrue\n>>> 1 in G[0]  # though this gives :exc:`KeyError` if 0 not in G\nTrue\n>>> 0 in G[1]  # other order; also gives :exc:`KeyError` if 0 not in G\nTrue"}, {"type": "method", "name": "networkx.MultiGraph.has_node", "documentation": "Returns True if the graph contains the node n.\n\nIdentical to `n in G`\n\nParameters\n----------\nn : node\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.has_node(0)\nTrue\n\nIt is more readable and simpler to use\n\n>>> 0 in G\nTrue"}, {"type": "method", "name": "networkx.MultiGraph.is_directed", "documentation": "Returns True if graph is directed, False otherwise."}, {"type": "method", "name": "networkx.MultiGraph.is_multigraph", "documentation": "Returns True if graph is a multigraph, False otherwise."}, {"type": "method", "name": "networkx.MultiGraph.nbunch_iter", "documentation": "Returns an iterator over nodes contained in nbunch that are\nalso in the graph.\n\nThe nodes in nbunch are checked for membership in the graph\nand if not are silently ignored.\n\nParameters\n----------\nnbunch : single node, container, or all nodes (default= all nodes)\n    The view will only report edges incident to these nodes.\n\nReturns\n-------\nniter : iterator\n    An iterator over nodes in nbunch that are also in the graph.\n    If nbunch is None, iterate over all nodes in the graph.\n\nRaises\n------\nNetworkXError\n    If nbunch is not a node or sequence of nodes.\n    If a node in nbunch is not hashable.\n\nSee Also\n--------\nGraph.__iter__\n\nNotes\n-----\nWhen nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted.\n\nTo test whether nbunch is a single node, one can use\n\"if nbunch in self:\", even after processing with this routine.\n\nIf nbunch is not a node or a (possibly empty) sequence/iterator\nor None, a :exc:`NetworkXError` is raised.  Also, if any object in\nnbunch is not hashable, a :exc:`NetworkXError` is raised."}, {"type": "method", "name": "networkx.MultiGraph.neighbors", "documentation": "Returns an iterator over all neighbors of node n.\n\nThis is identical to `iter(G[n])`\n\nParameters\n----------\nn : node\n   A node in the graph\n\nReturns\n-------\nneighbors : iterator\n    An iterator over all neighbors of node n\n\nRaises\n------\nNetworkXError\n    If the node n is not in the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> [n for n in G.neighbors(0)]\n[1]\n\nNotes\n-----\nAlternate ways to access the neighbors are ``G.adj[n]`` or ``G[n]``:\n\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edge(\"a\", \"b\", weight=7)\n>>> G[\"a\"]\nAtlasView({'b': {'weight': 7}})\n>>> G = nx.path_graph(4)\n>>> [n for n in G[0]]\n[1]"}, {"type": "method", "name": "networkx.MultiGraph.new_edge_key", "documentation": "Returns an unused key for edges between nodes `u` and `v`.\n\nThe nodes `u` and `v` do not need to be already in the graph.\n\nNotes\n-----\nIn the standard MultiGraph class the new key is the number of existing\nedges between `u` and `v` (increased if necessary to ensure unused).\nThe first edge will have key 0, then 1, etc. If an edge is removed\nfurther new_edge_keys may not be in this order.\n\nParameters\n----------\nu, v : nodes\n\nReturns\n-------\nkey : int"}, {"type": "method", "name": "networkx.MultiGraph.number_of_edges", "documentation": "Returns the number of edges between two nodes.\n\nParameters\n----------\nu, v : nodes, optional (Default=all edges)\n    If u and v are specified, return the number of edges between\n    u and v. Otherwise return the total number of all edges.\n\nReturns\n-------\nnedges : int\n    The number of edges in the graph.  If nodes `u` and `v` are\n    specified return the number of edges between those nodes. If\n    the graph is directed, this only returns the number of edges\n    from `u` to `v`.\n\nSee Also\n--------\nsize\n\nExamples\n--------\nFor undirected multigraphs, this method counts the total number\nof edges in the graph::\n\n    >>> G = nx.MultiGraph()\n    >>> G.add_edges_from([(0, 1), (0, 1), (1, 2)])\n    [0, 1, 0]\n    >>> G.number_of_edges()\n    3\n\nIf you specify two nodes, this counts the total number of edges\njoining the two nodes::\n\n    >>> G.number_of_edges(0, 1)\n    2\n\nFor directed multigraphs, this method can count the total number\nof directed edges from `u` to `v`::\n\n    >>> G = nx.MultiDiGraph()\n    >>> G.add_edges_from([(0, 1), (0, 1), (1, 0)])\n    [0, 1, 0]\n    >>> G.number_of_edges(0, 1)\n    2\n    >>> G.number_of_edges(1, 0)\n    1"}, {"type": "method", "name": "networkx.MultiGraph.number_of_nodes", "documentation": "Returns the number of nodes in the graph.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\norder: identical method\n__len__: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.number_of_nodes()\n3"}, {"type": "method", "name": "networkx.MultiGraph.order", "documentation": "Returns the number of nodes in the graph.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\nnumber_of_nodes: identical method\n__len__: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.order()\n3"}, {"type": "method", "name": "networkx.MultiGraph.remove_edge", "documentation": "Remove an edge between u and v.\n\nParameters\n----------\nu, v : nodes\n    Remove an edge between nodes u and v.\nkey : hashable identifier, optional (default=None)\n    Used to distinguish multiple edges between a pair of nodes.\n    If None, remove a single edge between u and v. If there are\n    multiple edges, removes the last edge added in terms of\n    insertion order.\n\nRaises\n------\nNetworkXError\n    If there is not an edge between u and v, or\n    if there is no edge with the specified key.\n\nSee Also\n--------\nremove_edges_from : remove a collection of edges\n\nExamples\n--------\n>>> G = nx.MultiGraph()\n>>> nx.add_path(G, [0, 1, 2, 3])\n>>> G.remove_edge(0, 1)\n>>> e = (1, 2)\n>>> G.remove_edge(*e)  # unpacks e from an edge tuple\n\nFor multiple edges\n\n>>> G = nx.MultiGraph()  # or MultiDiGraph, etc\n>>> G.add_edges_from([(1, 2), (1, 2), (1, 2)])  # key_list returned\n[0, 1, 2]\n\nWhen ``key=None`` (the default), edges are removed in the opposite\norder that they were added:\n\n>>> G.remove_edge(1, 2)\n>>> G.edges(keys=True)\nMultiEdgeView([(1, 2, 0), (1, 2, 1)])\n>>> G.remove_edge(2, 1)  # edges are not directed\n>>> G.edges(keys=True)\nMultiEdgeView([(1, 2, 0)])\n\nFor edges with keys\n\n>>> G = nx.MultiGraph()\n>>> G.add_edge(1, 2, key=\"first\")\n'first'\n>>> G.add_edge(1, 2, key=\"second\")\n'second'\n>>> G.remove_edge(1, 2, key=\"first\")\n>>> G.edges(keys=True)\nMultiEdgeView([(1, 2, 'second')])"}, {"type": "method", "name": "networkx.MultiGraph.remove_edges_from", "documentation": "Remove all edges specified in ebunch.\n\nParameters\n----------\nebunch: list or container of edge tuples\n    Each edge given in the list or container will be removed\n    from the graph. The edges can be:\n\n        - 2-tuples (u, v) A single edge between u and v is removed.\n        - 3-tuples (u, v, key) The edge identified by key is removed.\n        - 4-tuples (u, v, key, data) where data is ignored.\n\nSee Also\n--------\nremove_edge : remove a single edge\n\nNotes\n-----\nWill fail silently if an edge in ebunch is not in the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> ebunch = [(1, 2), (2, 3)]\n>>> G.remove_edges_from(ebunch)\n\nRemoving multiple copies of edges\n\n>>> G = nx.MultiGraph()\n>>> keys = G.add_edges_from([(1, 2), (1, 2), (1, 2)])\n>>> G.remove_edges_from([(1, 2), (2, 1)])  # edges aren't directed\n>>> list(G.edges())\n[(1, 2)]\n>>> G.remove_edges_from([(1, 2), (1, 2)])  # silently ignore extra copy\n>>> list(G.edges)  # now empty graph\n[]\n\nWhen the edge is a 2-tuple ``(u, v)`` but there are multiple edges between\nu and v in the graph, the most recent edge (in terms of insertion\norder) is removed.\n\n>>> G = nx.MultiGraph()\n>>> for key in (\"x\", \"y\", \"a\"):\n...     k = G.add_edge(0, 1, key=key)\n>>> G.edges(keys=True)\nMultiEdgeView([(0, 1, 'x'), (0, 1, 'y'), (0, 1, 'a')])\n>>> G.remove_edges_from([(0, 1)])\n>>> G.edges(keys=True)\nMultiEdgeView([(0, 1, 'x'), (0, 1, 'y')])"}, {"type": "method", "name": "networkx.MultiGraph.remove_node", "documentation": "Remove node n.\n\nRemoves the node n and all adjacent edges.\nAttempting to remove a nonexistent node will raise an exception.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\nremove_nodes_from\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> list(G.edges)\n[(0, 1), (1, 2)]\n>>> G.remove_node(1)\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.MultiGraph.remove_nodes_from", "documentation": "Remove multiple nodes.\n\nParameters\n----------\nnodes : iterable container\n    A container of nodes (list, dict, set, etc.).  If a node\n    in the container is not in the graph it is silently\n    ignored.\n\nSee Also\n--------\nremove_node\n\nNotes\n-----\nWhen removing nodes from an iterator over the graph you are changing,\na `RuntimeError` will be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_nodes)`, and pass this\nobject to `G.remove_nodes_from`.\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> e = list(G.nodes)\n>>> e\n[0, 1, 2]\n>>> G.remove_nodes_from(e)\n>>> list(G.nodes)\n[]\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.Graph([(0, 1), (1, 2), (3, 4)])\n>>> # this command will fail, as the graph's dict is modified during iteration\n>>> # G.remove_nodes_from(n for n in G.nodes if n < 2)\n>>> # this command will work, since the dictionary underlying graph is not modified\n>>> G.remove_nodes_from(list(n for n in G.nodes if n < 2))"}, {"type": "method", "name": "networkx.MultiGraph.size", "documentation": "Returns the number of edges or total of all edge weights.\n\nParameters\n----------\nweight : string or None, optional (default=None)\n    The edge attribute that holds the numerical value used\n    as a weight. If None, then each edge has weight 1.\n\nReturns\n-------\nsize : numeric\n    The number of edges or\n    (if weight keyword is provided) the total weight sum.\n\n    If weight is None, returns an int. Otherwise a float\n    (or more general numeric if the weights are more general).\n\nSee Also\n--------\nnumber_of_edges\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.size()\n3\n\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edge(\"a\", \"b\", weight=2)\n>>> G.add_edge(\"b\", \"c\", weight=4)\n>>> G.size()\n2\n>>> G.size(weight=\"weight\")\n6.0"}, {"type": "method", "name": "networkx.MultiGraph.subgraph", "documentation": "Returns a SubGraph view of the subgraph induced on `nodes`.\n\nThe induced subgraph of the graph contains the nodes in `nodes`\nand the edges between those nodes.\n\nParameters\n----------\nnodes : list, iterable\n    A container of nodes which will be iterated through once.\n\nReturns\n-------\nG : SubGraph View\n    A subgraph view of the graph. The graph structure cannot be\n    changed but node/edge attributes can and are shared with the\n    original graph.\n\nNotes\n-----\nThe graph, edge and node attributes are shared with the original graph.\nChanges to the graph structure is ruled out by the view, but changes\nto attributes are reflected in the original graph.\n\nTo create a subgraph with its own copy of the edge/node attributes use:\nG.subgraph(nodes).copy()\n\nFor an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([n for n in G if n not in set(nodes)])\n\nSubgraph views are sometimes NOT what you want. In most cases where\nyou want to do more than simply look at the induced edges, it makes\nmore sense to just create the subgraph as its own graph with code like:\n\n::\n\n    # Create a subgraph SG based on a (possibly multigraph) G\n    SG = G.__class__()\n    SG.add_nodes_from((n, G.nodes[n]) for n in largest_wcc)\n    if SG.is_multigraph():\n        SG.add_edges_from(\n            (n, nbr, key, d)\n            for n, nbrs in G.adj.items()\n            if n in largest_wcc\n            for nbr, keydict in nbrs.items()\n            if nbr in largest_wcc\n            for key, d in keydict.items()\n        )\n    else:\n        SG.add_edges_from(\n            (n, nbr, d)\n            for n, nbrs in G.adj.items()\n            if n in largest_wcc\n            for nbr, d in nbrs.items()\n            if nbr in largest_wcc\n        )\n    SG.graph.update(G.graph)\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> H = G.subgraph([0, 1, 2])\n>>> list(H.edges)\n[(0, 1), (1, 2)]"}, {"type": "method", "name": "networkx.MultiGraph.to_directed", "documentation": "Returns a directed representation of the graph.\n\nReturns\n-------\nG : MultiDiGraph\n    A directed graph with the same name, same nodes, and with\n    each edge (u, v, k, data) replaced by two directed edges\n    (u, v, k, data) and (v, u, k, data).\n\nNotes\n-----\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar D=MultiDiGraph(G) which\nreturns a shallow copy of the data.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nWarning: If you have subclassed MultiGraph to use dict-like objects\nin the data structure, those changes do not transfer to the\nMultiDiGraph created by this method.\n\nExamples\n--------\n>>> G = nx.MultiGraph()\n>>> G.add_edge(0, 1)\n0\n>>> G.add_edge(0, 1)\n1\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1)]\n\nIf already directed, return a (deep) copy\n\n>>> G = nx.MultiDiGraph()\n>>> G.add_edge(0, 1)\n0\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1, 0)]"}, {"type": "method", "name": "networkx.MultiGraph.to_directed_class", "documentation": "Returns the class to use for empty directed copies.\n\nIf you subclass the base classes, use this to designate\nwhat directed class to use for `to_directed()` copies."}, {"type": "method", "name": "networkx.MultiGraph.to_undirected", "documentation": "Returns an undirected copy of the graph.\n\nReturns\n-------\nG : Graph/MultiGraph\n    A deepcopy of the graph.\n\nSee Also\n--------\ncopy, add_edge, add_edges_from\n\nNotes\n-----\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar `G = nx.MultiGraph(D)`\nwhich returns a shallow copy of the data.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nWarning: If you have subclassed MultiGraph to use dict-like\nobjects in the data structure, those changes do not transfer\nto the MultiGraph created by this method.\n\nExamples\n--------\n>>> G = nx.MultiGraph([(0, 1), (0, 1), (1, 2)])\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 2, 0), (2, 1, 0)]\n>>> G2 = H.to_undirected()\n>>> list(G2.edges)\n[(0, 1, 0), (0, 1, 1), (1, 2, 0)]"}, {"type": "method", "name": "networkx.MultiGraph.to_undirected_class", "documentation": "Returns the class to use for empty undirected copies.\n\nIf you subclass the base classes, use this to designate\nwhat directed class to use for `to_directed()` copies."}, {"type": "method", "name": "networkx.MultiGraph.update", "documentation": "Update the graph using nodes/edges/graphs as input.\n\nLike dict.update, this method takes a graph as input, adding the\ngraph's nodes and edges to this graph. It can also take two inputs:\nedges and nodes. Finally it can take either edges or nodes.\nTo specify only nodes the keyword `nodes` must be used.\n\nThe collections of edges and nodes are treated similarly to\nthe add_edges_from/add_nodes_from methods. When iterated, they\nshould yield 2-tuples (u, v) or 3-tuples (u, v, datadict).\n\nParameters\n----------\nedges : Graph object, collection of edges, or None\n    The first parameter can be a graph or some edges. If it has\n    attributes `nodes` and `edges`, then it is taken to be a\n    Graph-like object and those attributes are used as collections\n    of nodes and edges to be added to the graph.\n    If the first parameter does not have those attributes, it is\n    treated as a collection of edges and added to the graph.\n    If the first argument is None, no edges are added.\nnodes : collection of nodes, or None\n    The second parameter is treated as a collection of nodes\n    to be added to the graph unless it is None.\n    If `edges is None` and `nodes is None` an exception is raised.\n    If the first parameter is a Graph, then `nodes` is ignored.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> G.update(nx.complete_graph(range(4, 10)))\n>>> from itertools import combinations\n>>> edges = (\n...     (u, v, {\"power\": u * v})\n...     for u, v in combinations(range(10, 20), 2)\n...     if u * v < 225\n... )\n>>> nodes = [1000]  # for singleton, use a container\n>>> G.update(edges, nodes)\n\nNotes\n-----\nIt you want to update the graph using an adjacency structure\nit is straightforward to obtain the edges/nodes from adjacency.\nThe following examples provide common cases, your adjacency may\nbe slightly different and require tweaks of these examples::\n\n>>> # dict-of-set/list/tuple\n>>> adj = {1: {2, 3}, 2: {1, 3}, 3: {1, 2}}\n>>> e = [(u, v) for u, nbrs in adj.items() for v in nbrs]\n>>> G.update(edges=e, nodes=adj)\n\n>>> DG = nx.DiGraph()\n>>> # dict-of-dict-of-attribute\n>>> adj = {1: {2: 1.3, 3: 0.7}, 2: {1: 1.4}, 3: {1: 0.7}}\n>>> e = [(u, v, {\"weight\": d}) for u, nbrs in adj.items() for v, d in nbrs.items()]\n>>> DG.update(edges=e, nodes=adj)\n\n>>> # dict-of-dict-of-dict\n>>> adj = {1: {2: {\"weight\": 1.3}, 3: {\"color\": 0.7, \"weight\": 1.2}}}\n>>> e = [(u, v, {\"weight\": d}) for u, nbrs in adj.items() for v, d in nbrs.items()]\n>>> DG.update(edges=e, nodes=adj)\n\n>>> # predecessor adjacency (dict-of-set)\n>>> pred = {1: {2, 3}, 2: {3}, 3: {3}}\n>>> e = [(v, u) for u, nbrs in pred.items() for v in nbrs]\n\n>>> # MultiGraph dict-of-dict-of-dict-of-attribute\n>>> MDG = nx.MultiDiGraph()\n>>> adj = {\n...     1: {2: {0: {\"weight\": 1.3}, 1: {\"weight\": 1.2}}},\n...     3: {2: {0: {\"weight\": 0.7}}},\n... }\n>>> e = [\n...     (u, v, ekey, d)\n...     for u, nbrs in adj.items()\n...     for v, keydict in nbrs.items()\n...     for ekey, d in keydict.items()\n... ]\n>>> MDG.update(edges=e)\n\nSee Also\n--------\nadd_edges_from: add multiple edges to a graph\nadd_nodes_from: add multiple nodes to a graph"}, {"type": "class", "name": "networkx.NetworkXAlgorithmError", "documentation": "Exception for unexpected termination of algorithms."}, {"type": "class", "name": "networkx.NetworkXError", "documentation": "Exception for a serious error in NetworkX"}, {"type": "class", "name": "networkx.NetworkXException", "documentation": "Base class for exceptions in NetworkX."}, {"type": "class", "name": "networkx.NetworkXNoCycle", "documentation": "Exception for algorithms that should return a cycle when running\non graphs where such a cycle does not exist."}, {"type": "class", "name": "networkx.NetworkXNoPath", "documentation": "Exception for algorithms that should return a path when running\non graphs where such a path does not exist."}, {"type": "class", "name": "networkx.NetworkXNotImplemented", "documentation": "Exception raised by algorithms not implemented for a type of graph."}, {"type": "class", "name": "networkx.NetworkXPointlessConcept", "documentation": "Raised when a null graph is provided as input to an algorithm\nthat cannot use it.\n\nThe null graph is sometimes considered a pointless concept [1]_,\nthus the name of the exception.\n\nReferences\n----------\n.. [1] Harary, F. and Read, R. \"Is the Null Graph a Pointless\n   Concept?\"  In Graphs and Combinatorics Conference, George\n   Washington University.  New York: Springer-Verlag, 1973."}, {"type": "class", "name": "networkx.NetworkXTreewidthBoundExceeded", "documentation": "Exception raised when a treewidth bound has been provided and it has\nbeen exceeded"}, {"type": "class", "name": "networkx.NetworkXUnbounded", "documentation": "Exception raised by algorithms trying to solve a maximization\nor a minimization problem instance that is unbounded."}, {"type": "class", "name": "networkx.NetworkXUnfeasible", "documentation": "Exception raised by algorithms trying to solve a problem\ninstance that has no feasible solution."}, {"type": "class", "name": "networkx.NodeNotFound", "documentation": "Exception raised if requested node is not present in the graph"}, {"type": "class", "name": "networkx.NotATree", "documentation": "Raised when a function expects a tree (that is, a connected\nundirected graph with no cycles) but gets a non-tree graph as input\ninstead."}, {"type": "class", "name": "networkx.PlanarEmbedding", "documentation": "Represents a planar graph with its planar embedding.\n\nThe planar embedding is given by a `combinatorial embedding\n<https://en.wikipedia.org/wiki/Graph_embedding#Combinatorial_embedding>`_.\n\n.. note:: `check_planarity` is the preferred way to check if a graph is planar.\n\n**Neighbor ordering:**\n\nIn comparison to a usual graph structure, the embedding also stores the\norder of all neighbors for every vertex.\nThe order of the neighbors can be given in clockwise (cw) direction or\ncounterclockwise (ccw) direction. This order is stored as edge attributes\nin the underlying directed graph. For the edge (u, v) the edge attribute\n'cw' is set to the neighbor of u that follows immediately after v in\nclockwise direction.\n\nIn order for a PlanarEmbedding to be valid it must fulfill multiple\nconditions. It is possible to check if these conditions are fulfilled with\nthe method :meth:`check_structure`.\nThe conditions are:\n\n* Edges must go in both directions (because the edge attributes differ)\n* Every edge must have a 'cw' and 'ccw' attribute which corresponds to a\n  correct planar embedding.\n\nAs long as a PlanarEmbedding is invalid only the following methods should\nbe called:\n\n* :meth:`add_half_edge`\n* :meth:`connect_components`\n\nEven though the graph is a subclass of nx.DiGraph, it can still be used\nfor algorithms that require undirected graphs, because the method\n:meth:`is_directed` is overridden. This is possible, because a valid\nPlanarGraph must have edges in both directions.\n\n**Half edges:**\n\nIn methods like `add_half_edge` the term \"half-edge\" is used, which is\na term that is used in `doubly connected edge lists\n<https://en.wikipedia.org/wiki/Doubly_connected_edge_list>`_. It is used\nto emphasize that the edge is only in one direction and there exists\nanother half-edge in the opposite direction.\nWhile conventional edges always have two faces (including outer face) next\nto them, it is possible to assign each half-edge *exactly one* face.\nFor a half-edge (u, v) that is oriented such that u is below v then the\nface that belongs to (u, v) is to the right of this half-edge.\n\nSee Also\n--------\nis_planar :\n    Preferred way to check if an existing graph is planar.\n\ncheck_planarity :\n    A convenient way to create a `PlanarEmbedding`. If not planar,\n    it returns a subgraph that shows this.\n\nExamples\n--------\n\nCreate an embedding of a star graph (compare `nx.star_graph(3)`):\n\n>>> G = nx.PlanarEmbedding()\n>>> G.add_half_edge(0, 1)\n>>> G.add_half_edge(0, 2, ccw=1)\n>>> G.add_half_edge(0, 3, ccw=2)\n>>> G.add_half_edge(1, 0)\n>>> G.add_half_edge(2, 0)\n>>> G.add_half_edge(3, 0)\n\nAlternatively the same embedding can also be defined in counterclockwise\norientation. The following results in exactly the same PlanarEmbedding:\n\n>>> G = nx.PlanarEmbedding()\n>>> G.add_half_edge(0, 1)\n>>> G.add_half_edge(0, 3, cw=1)\n>>> G.add_half_edge(0, 2, cw=3)\n>>> G.add_half_edge(1, 0)\n>>> G.add_half_edge(2, 0)\n>>> G.add_half_edge(3, 0)\n\nAfter creating a graph, it is possible to validate that the PlanarEmbedding\nobject is correct:\n\n>>> G.check_structure()"}, {"type": "method", "name": "networkx.PlanarEmbedding._PlanarEmbedding__forbidden", "documentation": "Forbidden operation\n\nAny edge additions to a PlanarEmbedding should be done using\nmethod `add_half_edge`."}, {"type": "method", "name": "networkx.PlanarEmbedding.__contains__", "documentation": "Returns True if n is a node, False otherwise. Use: 'n in G'.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> 1 in G\nTrue"}, {"type": "method", "name": "networkx.PlanarEmbedding.__getitem__", "documentation": "Returns a dict of neighbors of node n.  Use: 'G[n]'.\n\nParameters\n----------\nn : node\n   A node in the graph.\n\nReturns\n-------\nadj_dict : dictionary\n   The adjacency dictionary for nodes connected to n.\n\nNotes\n-----\nG[n] is the same as G.adj[n] and similar to G.neighbors(n)\n(which is an iterator over G.adj[n])\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G[0]\nAtlasView({1: {}})"}, {"type": "method", "name": "networkx.PlanarEmbedding.__init__", "documentation": "Initialize a graph with edges, name, or graph attributes.\n\nParameters\n----------\nincoming_graph_data : input graph (optional, default: None)\n    Data to initialize graph.  If None (default) an empty\n    graph is created.  The data can be an edge list, or any\n    NetworkX graph object.  If the corresponding optional Python\n    packages are installed the data can also be a 2D NumPy array, a\n    SciPy sparse array, or a PyGraphviz graph.\n\nattr : keyword arguments, optional (default= no attributes)\n    Attributes to add to graph as key=value pairs.\n\nSee Also\n--------\nconvert\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G = nx.Graph(name=\"my graph\")\n>>> e = [(1, 2), (2, 3), (3, 4)]  # list of edges\n>>> G = nx.Graph(e)\n\nArbitrary graph attribute pairs (key=value) may be assigned\n\n>>> G = nx.Graph(e, day=\"Friday\")\n>>> G.graph\n{'day': 'Friday'}"}, {"type": "method", "name": "networkx.PlanarEmbedding.__iter__", "documentation": "Iterate over the nodes. Use: 'for n in G'.\n\nReturns\n-------\nniter : iterator\n    An iterator over all nodes in the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> [n for n in G]\n[0, 1, 2, 3]\n>>> list(G)\n[0, 1, 2, 3]"}, {"type": "method", "name": "networkx.PlanarEmbedding.__len__", "documentation": "Returns the number of nodes in the graph. Use: 'len(G)'.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\nnumber_of_nodes: identical method\norder: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> len(G)\n4"}, {"type": "method", "name": "networkx.PlanarEmbedding.__str__", "documentation": "Returns a short summary of the graph.\n\nReturns\n-------\ninfo : string\n    Graph information including the graph name (if any), graph type, and the\n    number of nodes and edges.\n\nExamples\n--------\n>>> G = nx.Graph(name=\"foo\")\n>>> str(G)\n\"Graph named 'foo' with 0 nodes and 0 edges\"\n\n>>> G = nx.path_graph(3)\n>>> str(G)\n'Graph with 3 nodes and 2 edges'"}, {"type": "method", "name": "networkx.PlanarEmbedding.add_edge", "documentation": "Add an edge between u and v.\n\nThe nodes u and v will be automatically added if they are\nnot already in the graph.\n\nEdge attributes can be specified with keywords or by directly\naccessing the edge's attribute dictionary. See examples below.\n\nParameters\n----------\nu_of_edge, v_of_edge : nodes\n    Nodes can be, for example, strings or numbers.\n    Nodes must be hashable (and not None) Python objects.\nattr : keyword arguments, optional\n    Edge data (or labels or objects) can be assigned using\n    keyword arguments.\n\nSee Also\n--------\nadd_edges_from : add a collection of edges\n\nNotes\n-----\nAdding an edge that already exists updates the edge data.\n\nMany NetworkX algorithms designed for weighted graphs use\nan edge attribute (by default `weight`) to hold a numerical value.\n\nExamples\n--------\nThe following all add the edge e=(1, 2) to graph G:\n\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> e = (1, 2)\n>>> G.add_edge(1, 2)  # explicit two-node form\n>>> G.add_edge(*e)  # single edge as tuple of two nodes\n>>> G.add_edges_from([(1, 2)])  # add edges from iterable container\n\nAssociate data to edges using keywords:\n\n>>> G.add_edge(1, 2, weight=3)\n>>> G.add_edge(1, 3, weight=7, capacity=15, length=342.7)\n\nFor non-string attribute keys, use subscript notation.\n\n>>> G.add_edge(1, 2)\n>>> G[1][2].update({0: 5})\n>>> G.edges[1, 2].update({0: 5})"}, {"type": "method", "name": "networkx.PlanarEmbedding.add_edges_from", "documentation": "Add all the edges in ebunch_to_add.\n\nParameters\n----------\nebunch_to_add : container of edges\n    Each edge given in the container will be added to the\n    graph. The edges must be given as 2-tuples (u, v) or\n    3-tuples (u, v, d) where d is a dictionary containing edge data.\nattr : keyword arguments, optional\n    Edge data (or labels or objects) can be assigned using\n    keyword arguments.\n\nSee Also\n--------\nadd_edge : add a single edge\nadd_weighted_edges_from : convenient way to add weighted edges\n\nNotes\n-----\nAdding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added.\n\nEdge attributes specified in an ebunch take precedence over\nattributes specified via keyword arguments.\n\nWhen adding edges from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_edges)`, and pass this\nobject to `G.add_edges_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edges_from([(0, 1), (1, 2)])  # using a list of edge tuples\n>>> e = zip(range(0, 3), range(1, 4))\n>>> G.add_edges_from(e)  # Add the path graph 0-1-2-3\n\nAssociate data to edges\n\n>>> G.add_edges_from([(1, 2), (2, 3)], weight=3)\n>>> G.add_edges_from([(3, 4), (1, 4)], label=\"WN2898\")\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.DiGraph([(1, 2), (2, 3), (3, 4)])\n>>> # Grow graph by one new node, adding edges to all existing nodes.\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_edges_from(((5, n) for n in G.nodes))\n>>> # right way - note that there will be no self-edge for node 5\n>>> G.add_edges_from(list((5, n) for n in G.nodes))"}, {"type": "method", "name": "networkx.PlanarEmbedding.add_half_edge", "documentation": "Adds a half-edge from `start_node` to `end_node`.\n\nIf the half-edge is not the first one out of `start_node`, a reference\nnode must be provided either in the clockwise (parameter `cw`) or in\nthe counterclockwise (parameter `ccw`) direction. Only one of `cw`/`ccw`\ncan be specified (or neither in the case of the first edge).\nNote that specifying a reference in the clockwise (`cw`) direction means\ninserting the new edge in the first counterclockwise position with\nrespect to the reference (and vice-versa).\n\nParameters\n----------\nstart_node : node\n    Start node of inserted edge.\nend_node : node\n    End node of inserted edge.\ncw, ccw: node\n    End node of reference edge.\n    Omit or pass `None` if adding the first out-half-edge of `start_node`.\n\n\nRaises\n------\nNetworkXException\n    If the `cw` or `ccw` node is not a successor of `start_node`.\n    If `start_node` has successors, but neither `cw` or `ccw` is provided.\n    If both `cw` and `ccw` are specified.\n\nSee Also\n--------\nconnect_components"}, {"type": "method", "name": "networkx.PlanarEmbedding.add_half_edge_ccw", "documentation": "Adds a half-edge from start_node to end_node.\n\nThe half-edge is added counter clockwise next to the existing half-edge\n(start_node, reference_neighbor).\n\nParameters\n----------\nstart_node : node\n    Start node of inserted edge.\nend_node : node\n    End node of inserted edge.\nreference_neighbor: node\n    End node of reference edge.\n\nRaises\n------\nNetworkXException\n    If the reference_neighbor does not exist.\n\nSee Also\n--------\nadd_half_edge\nadd_half_edge_cw\nconnect_components"}, {"type": "method", "name": "networkx.PlanarEmbedding.add_half_edge_cw", "documentation": "Adds a half-edge from start_node to end_node.\n\nThe half-edge is added clockwise next to the existing half-edge\n(start_node, reference_neighbor).\n\nParameters\n----------\nstart_node : node\n    Start node of inserted edge.\nend_node : node\n    End node of inserted edge.\nreference_neighbor: node\n    End node of reference edge.\n\nRaises\n------\nNetworkXException\n    If the reference_neighbor does not exist.\n\nSee Also\n--------\nadd_half_edge\nadd_half_edge_ccw\nconnect_components"}, {"type": "method", "name": "networkx.PlanarEmbedding.add_half_edge_first", "documentation": "Add a half-edge and set end_node as start_node's leftmost neighbor.\n\nThe new edge is inserted counterclockwise with respect to the current\nleftmost neighbor, if there is one.\n\nParameters\n----------\nstart_node : node\nend_node : node\n\nSee Also\n--------\nadd_half_edge\nconnect_components"}, {"type": "method", "name": "networkx.PlanarEmbedding.add_node", "documentation": "Add a single node `node_for_adding` and update node attributes.\n\nParameters\n----------\nnode_for_adding : node\n    A node can be any hashable Python object except None.\nattr : keyword arguments, optional\n    Set or change node attributes using key=value.\n\nSee Also\n--------\nadd_nodes_from\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_node(1)\n>>> G.add_node(\"Hello\")\n>>> K3 = nx.Graph([(0, 1), (1, 2), (2, 0)])\n>>> G.add_node(K3)\n>>> G.number_of_nodes()\n3\n\nUse keywords set/change node attributes:\n\n>>> G.add_node(1, size=10)\n>>> G.add_node(3, weight=0.4, UTM=(\"13S\", 382871, 3972649))\n\nNotes\n-----\nA hashable object is one that can be used as a key in a Python\ndictionary. This includes strings, numbers, tuples of strings\nand numbers, etc.\n\nOn many platforms hashable items also include mutables such as\nNetworkX Graphs, though one should be careful that the hash\ndoesn't change on mutables."}, {"type": "method", "name": "networkx.PlanarEmbedding.add_nodes_from", "documentation": "Add multiple nodes.\n\nParameters\n----------\nnodes_for_adding : iterable container\n    A container of nodes (list, dict, set, etc.).\n    OR\n    A container of (node, attribute dict) tuples.\n    Node attributes are updated using the attribute dict.\nattr : keyword arguments, optional (default= no attributes)\n    Update attributes for all nodes in nodes.\n    Node attributes specified in nodes as a tuple take\n    precedence over attributes specified via keyword arguments.\n\nSee Also\n--------\nadd_node\n\nNotes\n-----\nWhen adding nodes from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_nodes)`, and pass this\nobject to `G.add_nodes_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_nodes_from(\"Hello\")\n>>> K3 = nx.Graph([(0, 1), (1, 2), (2, 0)])\n>>> G.add_nodes_from(K3)\n>>> sorted(G.nodes(), key=str)\n[0, 1, 2, 'H', 'e', 'l', 'o']\n\nUse keywords to update specific node attributes for every node.\n\n>>> G.add_nodes_from([1, 2], size=10)\n>>> G.add_nodes_from([3, 4], weight=0.4)\n\nUse (node, attrdict) tuples to update attributes for specific nodes.\n\n>>> G.add_nodes_from([(1, dict(size=11)), (2, {\"color\": \"blue\"})])\n>>> G.nodes[1][\"size\"]\n11\n>>> H = nx.Graph()\n>>> H.add_nodes_from(G.nodes(data=True))\n>>> H.nodes[1][\"size\"]\n11\n\nEvaluate an iterator over a graph if using it to modify the same graph\n\n>>> G = nx.DiGraph([(0, 1), (1, 2), (3, 4)])\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_nodes_from(n + 1 for n in G.nodes)\n>>> # correct way\n>>> G.add_nodes_from(list(n + 1 for n in G.nodes))"}, {"type": "method", "name": "networkx.PlanarEmbedding.add_weighted_edges_from", "documentation": "Add weighted edges in `ebunch_to_add` with specified weight attr\n\nParameters\n----------\nebunch_to_add : container of edges\n    Each edge given in the list or container will be added\n    to the graph. The edges must be given as 3-tuples (u, v, w)\n    where w is a number.\nweight : string, optional (default= 'weight')\n    The attribute name for the edge weights to be added.\nattr : keyword arguments, optional (default= no attributes)\n    Edge attributes to add/update for all edges.\n\nSee Also\n--------\nadd_edge : add a single edge\nadd_edges_from : add multiple edges\n\nNotes\n-----\nAdding the same edge twice for Graph/DiGraph simply updates\nthe edge data. For MultiGraph/MultiDiGraph, duplicate edges\nare stored.\n\nWhen adding edges from an iterator over the graph you are changing,\na `RuntimeError` can be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_edges)`, and pass this\nobject to `G.add_weighted_edges_from`.\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_weighted_edges_from([(0, 1, 3.0), (1, 2, 7.5)])\n\nEvaluate an iterator over edges before passing it\n\n>>> G = nx.Graph([(1, 2), (2, 3), (3, 4)])\n>>> weight = 0.1\n>>> # Grow graph by one new node, adding edges to all existing nodes.\n>>> # wrong way - will raise RuntimeError\n>>> # G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))\n>>> # correct way - note that there will be no self-edge for node 5\n>>> G.add_weighted_edges_from(list((5, n, weight) for n in G.nodes))"}, {"type": "method", "name": "networkx.PlanarEmbedding.adjacency", "documentation": "Returns an iterator over (node, adjacency dict) tuples for all nodes.\n\nFor directed graphs, only outgoing neighbors/adjacencies are included.\n\nReturns\n-------\nadj_iter : iterator\n   An iterator over (node, adjacency dictionary) for all nodes in\n   the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> [(n, nbrdict) for n, nbrdict in G.adjacency()]\n[(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]"}, {"type": "method", "name": "networkx.PlanarEmbedding.check_structure", "documentation": "Runs without exceptions if this object is valid.\n\nChecks that the following properties are fulfilled:\n\n* Edges go in both directions (because the edge attributes differ).\n* Every edge has a 'cw' and 'ccw' attribute which corresponds to a\n  correct planar embedding.\n\nRunning this method verifies that the underlying Graph must be planar.\n\nRaises\n------\nNetworkXException\n    This exception is raised with a short explanation if the\n    PlanarEmbedding is invalid."}, {"type": "method", "name": "networkx.PlanarEmbedding.clear", "documentation": "Remove all nodes and edges from the graph.\n\nThis also removes the name, and all graph, node, and edge attributes.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.clear()\n>>> list(G.nodes)\n[]\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.PlanarEmbedding.clear_edges", "documentation": "Remove all edges from the graph without altering nodes.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.clear_edges()\n>>> list(G.nodes)\n[0, 1, 2, 3]\n>>> list(G.edges)\n[]"}, {"type": "method", "name": "networkx.PlanarEmbedding.connect_components", "documentation": "Adds half-edges for (v, w) and (w, v) at some position.\n\nThis method should only be called if v and w are in different\ncomponents, or it might break the embedding.\nThis especially means that if `connect_components(v, w)`\nis called it is not allowed to call `connect_components(w, v)`\nafterwards. The neighbor orientations in both directions are\nall set correctly after the first call.\n\nParameters\n----------\nv : node\nw : node\n\nSee Also\n--------\nadd_half_edge"}, {"type": "method", "name": "networkx.PlanarEmbedding.copy", "documentation": "Returns a copy of the graph.\n\nThe copy method by default returns an independent shallow copy\nof the graph and attributes. That is, if an attribute is a\ncontainer, that container is shared by the original an the copy.\nUse Python's `copy.deepcopy` for new containers.\n\nIf `as_view` is True then a view is returned instead of a copy.\n\nNotes\n-----\nAll copies reproduce the graph structure, but data attributes\nmay be handled in different ways. There are four types of copies\nof a graph that people might want.\n\nDeepcopy -- A \"deepcopy\" copies the graph structure as well as\nall data attributes and any objects they might contain.\nThe entire graph object is new so that changes in the copy\ndo not affect the original object. (see Python's copy.deepcopy)\n\nData Reference (Shallow) -- For a shallow copy the graph structure\nis copied but the edge, node and graph attribute dicts are\nreferences to those in the original graph. This saves\ntime and memory but could cause confusion if you change an attribute\nin one graph and it changes the attribute in the other.\nNetworkX does not provide this level of shallow copy.\n\nIndependent Shallow -- This copy creates new independent attribute\ndicts and then does a shallow copy of the attributes. That is, any\nattributes that are containers are shared between the new graph\nand the original. This is exactly what `dict.copy()` provides.\nYou can obtain this style copy using:\n\n    >>> G = nx.path_graph(5)\n    >>> H = G.copy()\n    >>> H = G.copy(as_view=False)\n    >>> H = nx.Graph(G)\n    >>> H = G.__class__(G)\n\nFresh Data -- For fresh data, the graph structure is copied while\nnew empty data attribute dicts are created. The resulting graph\nis independent of the original and it has no edge, node or graph\nattributes. Fresh copies are not enabled. Instead use:\n\n    >>> H = G.__class__()\n    >>> H.add_nodes_from(G)\n    >>> H.add_edges_from(G.edges)\n\nView -- Inspired by dict-views, graph-views act like read-only\nversions of the original graph, providing a copy of the original\nstructure without requiring any memory for copying the information.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nParameters\n----------\nas_view : bool, optional (default=False)\n    If True, the returned graph-view provides a read-only view\n    of the original graph without actually copying any data.\n\nReturns\n-------\nG : Graph\n    A copy of the graph.\n\nSee Also\n--------\nto_directed: return a directed copy of the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> H = G.copy()"}, {"type": "method", "name": "networkx.PlanarEmbedding.edge_subgraph", "documentation": "Returns the subgraph induced by the specified edges.\n\nThe induced subgraph contains each edge in `edges` and each\nnode incident to any one of those edges.\n\nParameters\n----------\nedges : iterable\n    An iterable of edges in this graph.\n\nReturns\n-------\nG : Graph\n    An edge-induced subgraph of this graph with the same edge\n    attributes.\n\nNotes\n-----\nThe graph, edge, and node attributes in the returned subgraph\nview are references to the corresponding attributes in the original\ngraph. The view is read-only.\n\nTo create a full graph version of the subgraph with its own copy\nof the edge or node attributes, use::\n\n    G.edge_subgraph(edges).copy()\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> H = G.edge_subgraph([(0, 1), (3, 4)])\n>>> list(H.nodes)\n[0, 1, 3, 4]\n>>> list(H.edges)\n[(0, 1), (3, 4)]"}, {"type": "method", "name": "networkx.PlanarEmbedding.get_data", "documentation": "Converts the adjacency structure into a better readable structure.\n\nReturns\n-------\nembedding : dict\n    A dict mapping all nodes to a list of neighbors sorted in\n    clockwise order.\n\nSee Also\n--------\nset_data"}, {"type": "method", "name": "networkx.PlanarEmbedding.get_edge_data", "documentation": "Returns the attribute dictionary associated with edge (u, v).\n\nThis is identical to `G[u][v]` except the default is returned\ninstead of an exception if the edge doesn't exist.\n\nParameters\n----------\nu, v : nodes\ndefault:  any Python object (default=None)\n    Value to return if the edge (u, v) is not found.\n\nReturns\n-------\nedge_dict : dictionary\n    The edge attribute dictionary.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G[0][1]\n{}\n\nWarning: Assigning to `G[u][v]` is not permitted.\nBut it is safe to assign attributes `G[u][v]['foo']`\n\n>>> G[0][1][\"weight\"] = 7\n>>> G[0][1][\"weight\"]\n7\n>>> G[1][0][\"weight\"]\n7\n\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.get_edge_data(0, 1)  # default edge data is {}\n{}\n>>> e = (0, 1)\n>>> G.get_edge_data(*e)  # tuple form\n{}\n>>> G.get_edge_data(\"a\", \"b\", default=0)  # edge not in graph, return 0\n0"}, {"type": "method", "name": "networkx.PlanarEmbedding.has_edge", "documentation": "Returns True if the edge (u, v) is in the graph.\n\nThis is the same as `v in G[u]` without KeyError exceptions.\n\nParameters\n----------\nu, v : nodes\n    Nodes can be, for example, strings or numbers.\n    Nodes must be hashable (and not None) Python objects.\n\nReturns\n-------\nedge_ind : bool\n    True if edge is in the graph, False otherwise.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.has_edge(0, 1)  # using two nodes\nTrue\n>>> e = (0, 1)\n>>> G.has_edge(*e)  #  e is a 2-tuple (u, v)\nTrue\n>>> e = (0, 1, {\"weight\": 7})\n>>> G.has_edge(*e[:2])  # e is a 3-tuple (u, v, data_dictionary)\nTrue\n\nThe following syntax are equivalent:\n\n>>> G.has_edge(0, 1)\nTrue\n>>> 1 in G[0]  # though this gives KeyError if 0 not in G\nTrue"}, {"type": "method", "name": "networkx.PlanarEmbedding.has_node", "documentation": "Returns True if the graph contains the node n.\n\nIdentical to `n in G`\n\nParameters\n----------\nn : node\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.has_node(0)\nTrue\n\nIt is more readable and simpler to use\n\n>>> 0 in G\nTrue"}, {"type": "method", "name": "networkx.PlanarEmbedding.has_predecessor", "documentation": "Returns True if node u has predecessor v.\n\nThis is true if graph has the edge u<-v."}, {"type": "method", "name": "networkx.PlanarEmbedding.has_successor", "documentation": "Returns True if node u has successor v.\n\nThis is true if graph has the edge u->v."}, {"type": "method", "name": "networkx.PlanarEmbedding.is_directed", "documentation": "A valid PlanarEmbedding is undirected.\n\nAll reverse edges are contained, i.e. for every existing\nhalf-edge (v, w) the half-edge in the opposite direction (w, v) is also\ncontained."}, {"type": "method", "name": "networkx.PlanarEmbedding.is_multigraph", "documentation": "Returns True if graph is a multigraph, False otherwise."}, {"type": "method", "name": "networkx.PlanarEmbedding.nbunch_iter", "documentation": "Returns an iterator over nodes contained in nbunch that are\nalso in the graph.\n\nThe nodes in nbunch are checked for membership in the graph\nand if not are silently ignored.\n\nParameters\n----------\nnbunch : single node, container, or all nodes (default= all nodes)\n    The view will only report edges incident to these nodes.\n\nReturns\n-------\nniter : iterator\n    An iterator over nodes in nbunch that are also in the graph.\n    If nbunch is None, iterate over all nodes in the graph.\n\nRaises\n------\nNetworkXError\n    If nbunch is not a node or sequence of nodes.\n    If a node in nbunch is not hashable.\n\nSee Also\n--------\nGraph.__iter__\n\nNotes\n-----\nWhen nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted.\n\nTo test whether nbunch is a single node, one can use\n\"if nbunch in self:\", even after processing with this routine.\n\nIf nbunch is not a node or a (possibly empty) sequence/iterator\nor None, a :exc:`NetworkXError` is raised.  Also, if any object in\nnbunch is not hashable, a :exc:`NetworkXError` is raised."}, {"type": "method", "name": "networkx.PlanarEmbedding.neighbors", "documentation": "Returns an iterator over successor nodes of n.\n\nA successor of n is a node m such that there exists a directed\nedge from n to m.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\npredecessors\n\nNotes\n-----\nneighbors() and successors() are the same."}, {"type": "method", "name": "networkx.PlanarEmbedding.neighbors_cw_order", "documentation": "Generator for the neighbors of v in clockwise order.\n\nParameters\n----------\nv : node\n\nYields\n------\nnode"}, {"type": "method", "name": "networkx.PlanarEmbedding.next_face_half_edge", "documentation": "Returns the following half-edge left of a face.\n\nParameters\n----------\nv : node\nw : node\n\nReturns\n-------\nhalf-edge : tuple"}, {"type": "method", "name": "networkx.PlanarEmbedding.number_of_edges", "documentation": "Returns the number of edges between two nodes.\n\nParameters\n----------\nu, v : nodes, optional (default=all edges)\n    If u and v are specified, return the number of edges between\n    u and v. Otherwise return the total number of all edges.\n\nReturns\n-------\nnedges : int\n    The number of edges in the graph.  If nodes `u` and `v` are\n    specified return the number of edges between those nodes. If\n    the graph is directed, this only returns the number of edges\n    from `u` to `v`.\n\nSee Also\n--------\nsize\n\nExamples\n--------\nFor undirected graphs, this method counts the total number of\nedges in the graph:\n\n>>> G = nx.path_graph(4)\n>>> G.number_of_edges()\n3\n\nIf you specify two nodes, this counts the total number of edges\njoining the two nodes:\n\n>>> G.number_of_edges(0, 1)\n1\n\nFor directed graphs, this method can count the total number of\ndirected edges from `u` to `v`:\n\n>>> G = nx.DiGraph()\n>>> G.add_edge(0, 1)\n>>> G.add_edge(1, 0)\n>>> G.number_of_edges(0, 1)\n1"}, {"type": "method", "name": "networkx.PlanarEmbedding.number_of_nodes", "documentation": "Returns the number of nodes in the graph.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\norder: identical method\n__len__: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.number_of_nodes()\n3"}, {"type": "method", "name": "networkx.PlanarEmbedding.order", "documentation": "Returns the number of nodes in the graph.\n\nReturns\n-------\nnnodes : int\n    The number of nodes in the graph.\n\nSee Also\n--------\nnumber_of_nodes: identical method\n__len__: identical method\n\nExamples\n--------\n>>> G = nx.path_graph(3)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.order()\n3"}, {"type": "method", "name": "networkx.PlanarEmbedding.predecessors", "documentation": "Returns an iterator over predecessor nodes of n.\n\nA predecessor of n is a node m such that there exists a directed\nedge from m to n.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\nsuccessors"}, {"type": "method", "name": "networkx.PlanarEmbedding.remove_edge", "documentation": "Remove the edge between u and v.\n\nParameters\n----------\nu, v : nodes\nRemove the half-edges (u, v) and (v, u) and update the\nedge ordering around the removed edge.\n\nRaises\n------\nNetworkXError\nIf there is not an edge between u and v.\n\nSee Also\n--------\nremove_edges_from : remove a collection of edges"}, {"type": "method", "name": "networkx.PlanarEmbedding.remove_edges_from", "documentation": "Remove all edges specified in ebunch.\n\nParameters\n----------\nebunch: list or container of edge tuples\n    Each pair of half-edges between the nodes given in the tuples\n    will be removed from the graph. The nodes can be passed as:\n\n        - 2-tuples (u, v) half-edges (u, v) and (v, u).\n        - 3-tuples (u, v, k) where k is ignored.\n\nSee Also\n--------\nremove_edge : remove a single edge\n\nNotes\n-----\nWill fail silently if an edge in ebunch is not in the graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> ebunch = [(1, 2), (2, 3)]\n>>> G.remove_edges_from(ebunch)"}, {"type": "method", "name": "networkx.PlanarEmbedding.remove_node", "documentation": "Remove node n.\n\nRemoves the node n and all adjacent edges, updating the\nPlanarEmbedding to account for any resulting edge removal.\nAttempting to remove a non-existent node will raise an exception.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\nremove_nodes_from"}, {"type": "method", "name": "networkx.PlanarEmbedding.remove_nodes_from", "documentation": "Remove multiple nodes.\n\nParameters\n----------\nnodes : iterable container\n    A container of nodes (list, dict, set, etc.).  If a node\n    in the container is not in the graph it is silently ignored.\n\nSee Also\n--------\nremove_node\n\nNotes\n-----\nWhen removing nodes from an iterator over the graph you are changing,\na `RuntimeError` will be raised with message:\n`RuntimeError: dictionary changed size during iteration`. This\nhappens when the graph's underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using `list(iterator_of_nodes)`, and pass this\nobject to `G.remove_nodes_from`."}, {"type": "method", "name": "networkx.PlanarEmbedding.reverse", "documentation": "Returns the reverse of the graph.\n\nThe reverse is a graph with the same nodes and edges\nbut with the directions of the edges reversed.\n\nParameters\n----------\ncopy : bool optional (default=True)\n    If True, return a new DiGraph holding the reversed edges.\n    If False, the reverse graph is created using a view of\n    the original graph."}, {"type": "method", "name": "networkx.PlanarEmbedding.set_data", "documentation": "Inserts edges according to given sorted neighbor list.\n\nThe input format is the same as the output format of get_data().\n\nParameters\n----------\ndata : dict\n    A dict mapping all nodes to a list of neighbors sorted in\n    clockwise order.\n\nSee Also\n--------\nget_data"}, {"type": "method", "name": "networkx.PlanarEmbedding.size", "documentation": "Returns the number of edges or total of all edge weights.\n\nParameters\n----------\nweight : string or None, optional (default=None)\n    The edge attribute that holds the numerical value used\n    as a weight. If None, then each edge has weight 1.\n\nReturns\n-------\nsize : numeric\n    The number of edges or\n    (if weight keyword is provided) the total weight sum.\n\n    If weight is None, returns an int. Otherwise a float\n    (or more general numeric if the weights are more general).\n\nSee Also\n--------\nnumber_of_edges\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.size()\n3\n\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edge(\"a\", \"b\", weight=2)\n>>> G.add_edge(\"b\", \"c\", weight=4)\n>>> G.size()\n2\n>>> G.size(weight=\"weight\")\n6.0"}, {"type": "method", "name": "networkx.PlanarEmbedding.subgraph", "documentation": "Returns a SubGraph view of the subgraph induced on `nodes`.\n\nThe induced subgraph of the graph contains the nodes in `nodes`\nand the edges between those nodes.\n\nParameters\n----------\nnodes : list, iterable\n    A container of nodes which will be iterated through once.\n\nReturns\n-------\nG : SubGraph View\n    A subgraph view of the graph. The graph structure cannot be\n    changed but node/edge attributes can and are shared with the\n    original graph.\n\nNotes\n-----\nThe graph, edge and node attributes are shared with the original graph.\nChanges to the graph structure is ruled out by the view, but changes\nto attributes are reflected in the original graph.\n\nTo create a subgraph with its own copy of the edge/node attributes use:\nG.subgraph(nodes).copy()\n\nFor an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([n for n in G if n not in set(nodes)])\n\nSubgraph views are sometimes NOT what you want. In most cases where\nyou want to do more than simply look at the induced edges, it makes\nmore sense to just create the subgraph as its own graph with code like:\n\n::\n\n    # Create a subgraph SG based on a (possibly multigraph) G\n    SG = G.__class__()\n    SG.add_nodes_from((n, G.nodes[n]) for n in largest_wcc)\n    if SG.is_multigraph():\n        SG.add_edges_from(\n            (n, nbr, key, d)\n            for n, nbrs in G.adj.items()\n            if n in largest_wcc\n            for nbr, keydict in nbrs.items()\n            if nbr in largest_wcc\n            for key, d in keydict.items()\n        )\n    else:\n        SG.add_edges_from(\n            (n, nbr, d)\n            for n, nbrs in G.adj.items()\n            if n in largest_wcc\n            for nbr, d in nbrs.items()\n            if nbr in largest_wcc\n        )\n    SG.graph.update(G.graph)\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> H = G.subgraph([0, 1, 2])\n>>> list(H.edges)\n[(0, 1), (1, 2)]"}, {"type": "method", "name": "networkx.PlanarEmbedding.successors", "documentation": "Returns an iterator over successor nodes of n.\n\nA successor of n is a node m such that there exists a directed\nedge from n to m.\n\nParameters\n----------\nn : node\n   A node in the graph\n\nRaises\n------\nNetworkXError\n   If n is not in the graph.\n\nSee Also\n--------\npredecessors\n\nNotes\n-----\nneighbors() and successors() are the same."}, {"type": "method", "name": "networkx.PlanarEmbedding.to_directed", "documentation": "Returns a directed representation of the graph.\n\nReturns\n-------\nG : DiGraph\n    A directed graph with the same name, same nodes, and with\n    each edge (u, v, data) replaced by two directed edges\n    (u, v, data) and (v, u, data).\n\nNotes\n-----\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar D=DiGraph(G) which returns a\nshallow copy of the data.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nWarning: If you have subclassed Graph to use dict-like objects\nin the data structure, those changes do not transfer to the\nDiGraph created by this method.\n\nExamples\n--------\n>>> G = nx.Graph()  # or MultiGraph, etc\n>>> G.add_edge(0, 1)\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1), (1, 0)]\n\nIf already directed, return a (deep) copy\n\n>>> G = nx.DiGraph()  # or MultiDiGraph, etc\n>>> G.add_edge(0, 1)\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1)]"}, {"type": "method", "name": "networkx.PlanarEmbedding.to_directed_class", "documentation": "Returns the class to use for empty directed copies.\n\nIf you subclass the base classes, use this to designate\nwhat directed class to use for `to_directed()` copies."}, {"type": "method", "name": "networkx.PlanarEmbedding.to_undirected", "documentation": "Returns an undirected representation of the digraph.\n\nParameters\n----------\nreciprocal : bool (optional)\n  If True only keep edges that appear in both directions\n  in the original digraph.\nas_view : bool (optional, default=False)\n  If True return an undirected view of the original directed graph.\n\nReturns\n-------\nG : Graph\n    An undirected graph with the same name and nodes and\n    with edge (u, v, data) if either (u, v, data) or (v, u, data)\n    is in the digraph.  If both edges exist in digraph and\n    their edge data is different, only one edge is created\n    with an arbitrary choice of which edge data to use.\n    You must check and correct for this manually if desired.\n\nSee Also\n--------\nGraph, copy, add_edge, add_edges_from\n\nNotes\n-----\nIf edges in both directions (u, v) and (v, u) exist in the\ngraph, attributes for the new undirected edge will be a combination of\nthe attributes of the directed edges.  The edge data is updated\nin the (arbitrary) order that the edges are encountered.  For\nmore customized control of the edge attributes use add_edge().\n\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar G=DiGraph(D) which returns a\nshallow copy of the data.\n\nSee the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html.\n\nWarning: If you have subclassed DiGraph to use dict-like objects\nin the data structure, those changes do not transfer to the\nGraph created by this method.\n\nExamples\n--------\n>>> G = nx.path_graph(2)  # or MultiGraph, etc\n>>> H = G.to_directed()\n>>> list(H.edges)\n[(0, 1), (1, 0)]\n>>> G2 = H.to_undirected()\n>>> list(G2.edges)\n[(0, 1)]"}, {"type": "method", "name": "networkx.PlanarEmbedding.to_undirected_class", "documentation": "Returns the class to use for empty undirected copies.\n\nIf you subclass the base classes, use this to designate\nwhat directed class to use for `to_directed()` copies."}, {"type": "method", "name": "networkx.PlanarEmbedding.traverse_face", "documentation": "Returns nodes on the face that belong to the half-edge (v, w).\n\nThe face that is traversed lies to the right of the half-edge (in an\norientation where v is below w).\n\nOptionally it is possible to pass a set to which all encountered half\nedges are added. Before calling this method, this set must not include\nany half-edges that belong to the face.\n\nParameters\n----------\nv : node\n    Start node of half-edge.\nw : node\n    End node of half-edge.\nmark_half_edges: set, optional\n    Set to which all encountered half-edges are added.\n\nReturns\n-------\nface : list\n    A list of nodes that lie on this face."}, {"type": "method", "name": "networkx.PlanarEmbedding.update", "documentation": "Update the graph using nodes/edges/graphs as input.\n\nLike dict.update, this method takes a graph as input, adding the\ngraph's nodes and edges to this graph. It can also take two inputs:\nedges and nodes. Finally it can take either edges or nodes.\nTo specify only nodes the keyword `nodes` must be used.\n\nThe collections of edges and nodes are treated similarly to\nthe add_edges_from/add_nodes_from methods. When iterated, they\nshould yield 2-tuples (u, v) or 3-tuples (u, v, datadict).\n\nParameters\n----------\nedges : Graph object, collection of edges, or None\n    The first parameter can be a graph or some edges. If it has\n    attributes `nodes` and `edges`, then it is taken to be a\n    Graph-like object and those attributes are used as collections\n    of nodes and edges to be added to the graph.\n    If the first parameter does not have those attributes, it is\n    treated as a collection of edges and added to the graph.\n    If the first argument is None, no edges are added.\nnodes : collection of nodes, or None\n    The second parameter is treated as a collection of nodes\n    to be added to the graph unless it is None.\n    If `edges is None` and `nodes is None` an exception is raised.\n    If the first parameter is a Graph, then `nodes` is ignored.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> G.update(nx.complete_graph(range(4, 10)))\n>>> from itertools import combinations\n>>> edges = (\n...     (u, v, {\"power\": u * v})\n...     for u, v in combinations(range(10, 20), 2)\n...     if u * v < 225\n... )\n>>> nodes = [1000]  # for singleton, use a container\n>>> G.update(edges, nodes)\n\nNotes\n-----\nIt you want to update the graph using an adjacency structure\nit is straightforward to obtain the edges/nodes from adjacency.\nThe following examples provide common cases, your adjacency may\nbe slightly different and require tweaks of these examples::\n\n>>> # dict-of-set/list/tuple\n>>> adj = {1: {2, 3}, 2: {1, 3}, 3: {1, 2}}\n>>> e = [(u, v) for u, nbrs in adj.items() for v in nbrs]\n>>> G.update(edges=e, nodes=adj)\n\n>>> DG = nx.DiGraph()\n>>> # dict-of-dict-of-attribute\n>>> adj = {1: {2: 1.3, 3: 0.7}, 2: {1: 1.4}, 3: {1: 0.7}}\n>>> e = [(u, v, {\"weight\": d}) for u, nbrs in adj.items() for v, d in nbrs.items()]\n>>> DG.update(edges=e, nodes=adj)\n\n>>> # dict-of-dict-of-dict\n>>> adj = {1: {2: {\"weight\": 1.3}, 3: {\"color\": 0.7, \"weight\": 1.2}}}\n>>> e = [(u, v, {\"weight\": d}) for u, nbrs in adj.items() for v, d in nbrs.items()]\n>>> DG.update(edges=e, nodes=adj)\n\n>>> # predecessor adjacency (dict-of-set)\n>>> pred = {1: {2, 3}, 2: {3}, 3: {3}}\n>>> e = [(v, u) for u, nbrs in pred.items() for v in nbrs]\n\n>>> # MultiGraph dict-of-dict-of-dict-of-attribute\n>>> MDG = nx.MultiDiGraph()\n>>> adj = {\n...     1: {2: {0: {\"weight\": 1.3}, 1: {\"weight\": 1.2}}},\n...     3: {2: {0: {\"weight\": 0.7}}},\n... }\n>>> e = [\n...     (u, v, ekey, d)\n...     for u, nbrs in adj.items()\n...     for v, keydict in nbrs.items()\n...     for ekey, d in keydict.items()\n... ]\n>>> MDG.update(edges=e)\n\nSee Also\n--------\nadd_edges_from: add multiple edges to a graph\nadd_nodes_from: add multiple nodes to a graph"}, {"type": "class", "name": "networkx.PowerIterationFailedConvergence", "documentation": "Raised when the power iteration method fails to converge within a\nspecified iteration limit.\n\n`num_iterations` is the number of iterations that have been\ncompleted when this exception was raised."}, {"type": "method", "name": "networkx.PowerIterationFailedConvergence.__init__", "documentation": "Initialize self.  See help(type(self)) for accurate signature."}, {"type": "class", "name": "networkx.SpanningTreeIterator", "documentation": "Iterate over all spanning trees of a graph in either increasing or\ndecreasing cost.\n\nNotes\n-----\nThis iterator uses the partition scheme from [1]_ (included edges,\nexcluded edges and open edges) as well as a modified Kruskal's Algorithm\nto generate minimum spanning trees which respect the partition of edges.\nFor spanning trees with the same weight, ties are broken arbitrarily.\n\nReferences\n----------\n.. [1] G.K. Janssens, K. S\u00f6rensen, An algorithm to generate all spanning\n       trees in order of increasing cost, Pesquisa Operacional, 2005-08,\n       Vol. 25 (2), p. 219-229,\n       https://www.scielo.br/j/pope/a/XHswBwRwJyrfL88dmMwYNWp/?lang=en"}, {"type": "method", "name": "networkx.SpanningTreeIterator.__init__", "documentation": "Initialize the iterator\n\nParameters\n----------\nG : nx.Graph\n    The directed graph which we need to iterate trees over\n\nweight : String, default = \"weight\"\n    The edge attribute used to store the weight of the edge\n\nminimum : bool, default = True\n    Return the trees in increasing order while true and decreasing order\n    while false.\n\nignore_nan : bool, default = False\n    If a NaN is found as an edge weight normally an exception is raised.\n    If `ignore_nan is True` then that edge is ignored instead."}, {"type": "method", "name": "networkx.SpanningTreeIterator.__iter__", "documentation": "Returns\n-------\nSpanningTreeIterator\n    The iterator object for this graph"}, {"type": "method", "name": "networkx.SpanningTreeIterator.__next__", "documentation": "Returns\n-------\n(multi)Graph\n    The spanning tree of next greatest weight, which ties broken\n    arbitrarily."}, {"type": "method", "name": "networkx.SpanningTreeIterator._clear_partition", "documentation": "Removes partition data from the graph"}, {"type": "method", "name": "networkx.SpanningTreeIterator._partition", "documentation": "Create new partitions based of the minimum spanning tree of the\ncurrent minimum partition.\n\nParameters\n----------\npartition : Partition\n    The Partition instance used to generate the current minimum spanning\n    tree.\npartition_tree : nx.Graph\n    The minimum spanning tree of the input partition."}, {"type": "method", "name": "networkx.SpanningTreeIterator._write_partition", "documentation": "Writes the desired partition into the graph to calculate the minimum\nspanning tree.\n\nParameters\n----------\npartition : Partition\n    A Partition dataclass describing a partition on the edges of the\n    graph."}, {"type": "function", "name": "networkx._clear_cache", "documentation": "Clear the cache of a graph (currently stores converted graphs).\n\nCaching is controlled via ``nx.config.cache_converted_graphs`` configuration."}, {"type": "class", "name": "networkx._dispatchable", "documentation": null}, {"type": "method", "name": "networkx._dispatchable.__call__", "documentation": "Returns the result of the original function, or the backend function if\nthe backend is specified and that backend implements `func`."}, {"type": "method", "name": "networkx._dispatchable.__new__", "documentation": "A decorator that makes certain input graph types dispatch to ``func``'s\nbackend implementation.\n\nUsage can be any of the following decorator forms:\n- @_dispatchable\n- @_dispatchable()\n- @_dispatchable(name=\"override_name\")\n- @_dispatchable(graphs=\"graph_var_name\")\n- @_dispatchable(edge_attrs=\"weight\")\n- @_dispatchable(graphs={\"G\": 0, \"H\": 1}, edge_attrs={\"weight\": \"default\"})\nwith 0 and 1 giving the position in the signature function for graph objects.\nWhen edge_attrs is a dict, keys are keyword names and values are defaults.\n\nThe class attributes are used to allow backends to run networkx tests.\nFor example: `PYTHONPATH=. pytest --backend graphblas --fallback-to-nx`\nFuture work: add configuration to control these.\n\nParameters\n----------\nfunc : callable, optional\n    The function to be decorated. If ``func`` is not provided, returns a\n    partial object that can be used to decorate a function later. If ``func``\n    is provided, returns a new callable object that dispatches to a backend\n    algorithm based on input graph types.\n\nname : str, optional\n    The name of the algorithm to use for dispatching. If not provided,\n    the name of ``func`` will be used. ``name`` is useful to avoid name\n    conflicts, as all dispatched algorithms live in a single namespace.\n    For example, ``tournament.is_strongly_connected`` had a name conflict\n    with the standard ``nx.is_strongly_connected``, so we used\n    ``@_dispatchable(name=\"tournament_is_strongly_connected\")``.\n\ngraphs : str or dict or None, default \"G\"\n    If a string, the parameter name of the graph, which must be the first\n    argument of the wrapped function. If more than one graph is required\n    for the algorithm (or if the graph is not the first argument), provide\n    a dict of parameter name to argument position for each graph argument.\n    For example, ``@_dispatchable(graphs={\"G\": 0, \"auxiliary?\": 4})``\n    indicates the 0th parameter ``G`` of the function is a required graph,\n    and the 4th parameter ``auxiliary`` is an optional graph.\n    To indicate an argument is a list of graphs, do e.g. ``\"[graphs]\"``.\n    Use ``graphs=None`` if *no* arguments are NetworkX graphs such as for\n    graph generators, readers, and conversion functions.\n\nedge_attrs : str or dict, optional\n    ``edge_attrs`` holds information about edge attribute arguments\n    and default values for those edge attributes.\n    If a string, ``edge_attrs`` holds the function argument name that\n    indicates a single edge attribute to include in the converted graph.\n    The default value for this attribute is 1. To indicate that an argument\n    is a list of attributes (all with default value 1), use e.g. ``\"[attrs]\"``.\n    If a dict, ``edge_attrs`` holds a dict keyed by argument names, with\n    values that are either the default value or, if a string, the argument\n    name that indicates the default value.\n\nnode_attrs : str or dict, optional\n    Like ``edge_attrs``, but for node attributes.\n\npreserve_edge_attrs : bool or str or dict, optional\n    For bool, whether to preserve all edge attributes.\n    For str, the parameter name that may indicate (with ``True`` or a\n    callable argument) whether all edge attributes should be preserved\n    when converting.\n    For dict of ``{graph_name: {attr: default}}``, indicate pre-determined\n    edge attributes (and defaults) to preserve for input graphs.\n\npreserve_node_attrs : bool or str or dict, optional\n    Like ``preserve_edge_attrs``, but for node attributes.\n\npreserve_graph_attrs : bool or set\n    For bool, whether to preserve all graph attributes.\n    For set, which input graph arguments to preserve graph attributes.\n\npreserve_all_attrs : bool\n    Whether to preserve all edge, node and graph attributes.\n    This overrides all the other preserve_*_attrs.\n\nmutates_input : bool or dict, default False\n    For bool, whether the functions mutates an input graph argument.\n    For dict of ``{arg_name: arg_pos}``, arguments that indicates whether an\n    input graph will be mutated, and ``arg_name`` may begin with ``\"not \"``\n    to negate the logic (for example, this is used by ``copy=`` arguments).\n    By default, dispatching doesn't convert input graphs to a different\n    backend for functions that mutate input graphs.\n\nreturns_graph : bool, default False\n    Whether the function can return or yield a graph object. By default,\n    dispatching doesn't convert input graphs to a different backend for\n    functions that return graphs."}, {"type": "method", "name": "networkx._dispatchable.__reduce__", "documentation": "Allow this object to be serialized with pickle.\n\nThis uses the global registry `_registered_algorithms` to deserialize."}, {"type": "method", "name": "networkx._dispatchable._can_backend_run", "documentation": "Can the specified backend run this algorithm with these arguments?"}, {"type": "method", "name": "networkx._dispatchable._convert_and_call", "documentation": "Call this dispatchable function with a backend, converting graphs if necessary."}, {"type": "method", "name": "networkx._dispatchable._convert_and_call_for_tests", "documentation": "Call this dispatchable function with a backend; for use with testing."}, {"type": "method", "name": "networkx._dispatchable._convert_arguments", "documentation": "Convert graph arguments to the specified backend.\n\nReturns\n-------\nargs tuple and kwargs dict"}, {"type": "method", "name": "networkx._dispatchable._convert_graph", "documentation": null}, {"type": "method", "name": "networkx._dispatchable._make_doc", "documentation": "Generate the backends section at the end for functions having an alternate\nbackend implementation(s) using the `backend_info` entry-point."}, {"type": "method", "name": "networkx._dispatchable._should_backend_run", "documentation": "Can/should the specified backend run this algorithm with these arguments?"}, {"type": "function", "name": "networkx._lazy_import", "documentation": "Return a lazily imported proxy for a module or library.\n\nWarning\n-------\nImporting using this function can currently cause trouble\nwhen the user tries to import from a subpackage of a module before\nthe package is fully imported. In particular, this idiom may not work:\n\n  np = lazy_import(\"numpy\")\n  from numpy.lib import recfunctions\n\nThis is due to a difference in the way Python's LazyLoader handles\nsubpackage imports compared to the normal import process. Hopefully\nwe will get Python's LazyLoader to fix this, or find a workaround.\nIn the meantime, this is a potential problem.\n\nThe workaround is to import numpy before importing from the subpackage.\n\nNotes\n-----\nWe often see the following pattern::\n\n  def myfunc():\n      import scipy as sp\n      sp.argmin(...)\n      ....\n\nThis is to prevent a library, in this case `scipy`, from being\nimported at function definition time, since that can be slow.\n\nThis function provides a proxy module that, upon access, imports\nthe actual module.  So the idiom equivalent to the above example is::\n\n  sp = lazy.load(\"scipy\")\n\n  def myfunc():\n      sp.argmin(...)\n      ....\n\nThe initial import time is fast because the actual import is delayed\nuntil the first attribute is requested. The overall import time may\ndecrease as well for users that don't make use of large portions\nof the library.\n\nParameters\n----------\nfullname : str\n    The full name of the package or subpackage to import.  For example::\n\n      sp = lazy.load(\"scipy\")  # import scipy as sp\n      spla = lazy.load(\"scipy.linalg\")  # import scipy.linalg as spla\n\nReturns\n-------\npm : importlib.util._LazyModule\n    Proxy module. Can be used like any regularly imported module.\n    Actual loading of the module occurs upon first attribute request."}, {"type": "function", "name": "networkx.adamic_adar_index", "documentation": "Compute the Adamic-Adar index of all node pairs in ebunch.\n\nAdamic-Adar index of `u` and `v` is defined as\n\n.. math::\n\n    \\sum_{w \\in \\Gamma(u) \\cap \\Gamma(v)} \\frac{1}{\\log |\\Gamma(w)|}\n\nwhere $\\Gamma(u)$ denotes the set of neighbors of $u$.\nThis index leads to zero-division for nodes only connected via self-loops.\nIt is intended to be used when no self-loops are present.\n\nParameters\n----------\nG : graph\n    NetworkX undirected graph.\n\nebunch : iterable of node pairs, optional (default = None)\n    Adamic-Adar index will be computed for each pair of nodes given\n    in the iterable. The pairs must be given as 2-tuples (u, v)\n    where u and v are nodes in the graph. If ebunch is None then all\n    nonexistent edges in the graph will be used.\n    Default value: None.\n\nReturns\n-------\npiter : iterator\n    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\n    pair of nodes and p is their Adamic-Adar index.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is a `DiGraph`, a `Multigraph` or a `MultiDiGraph`.\n\nNodeNotFound\n    If `ebunch` has a node that is not in `G`.\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> preds = nx.adamic_adar_index(G, [(0, 1), (2, 3)])\n>>> for u, v, p in preds:\n...     print(f\"({u}, {v}) -> {p:.8f}\")\n(0, 1) -> 2.16404256\n(2, 3) -> 2.16404256\n\nReferences\n----------\n.. [1] D. Liben-Nowell, J. Kleinberg.\n       The Link Prediction Problem for Social Networks (2004).\n       http://www.cs.cornell.edu/home/kleinber/link-pred.pdf"}, {"type": "function", "name": "networkx.add_cycle", "documentation": "Add a cycle to the Graph G_to_add_to.\n\nParameters\n----------\nG_to_add_to : graph\n    A NetworkX graph\nnodes_for_cycle: iterable container\n    A container of nodes.  A cycle will be constructed from\n    the nodes (in order) and added to the graph.\nattr : keyword arguments, optional (default= no attributes)\n    Attributes to add to every edge in cycle.\n\nSee Also\n--------\nadd_path, add_star\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> nx.add_cycle(G, [0, 1, 2, 3])\n>>> nx.add_cycle(G, [10, 11, 12], weight=7)"}, {"type": "function", "name": "networkx.add_path", "documentation": "Add a path to the Graph G_to_add_to.\n\nParameters\n----------\nG_to_add_to : graph\n    A NetworkX graph\nnodes_for_path : iterable container\n    A container of nodes.  A path will be constructed from\n    the nodes (in order) and added to the graph.\nattr : keyword arguments, optional (default= no attributes)\n    Attributes to add to every edge in path.\n\nSee Also\n--------\nadd_star, add_cycle\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> nx.add_path(G, [0, 1, 2, 3])\n>>> nx.add_path(G, [10, 11, 12], weight=7)"}, {"type": "function", "name": "networkx.add_star", "documentation": "Add a star to Graph G_to_add_to.\n\nThe first node in `nodes_for_star` is the middle of the star.\nIt is connected to all other nodes.\n\nParameters\n----------\nG_to_add_to : graph\n    A NetworkX graph\nnodes_for_star : iterable container\n    A container of nodes.\nattr : keyword arguments, optional (default= no attributes)\n    Attributes to add to every edge in star.\n\nSee Also\n--------\nadd_path, add_cycle\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> nx.add_star(G, [0, 1, 2, 3])\n>>> nx.add_star(G, [10, 11, 12], weight=2)"}, {"type": "function", "name": "networkx.adjacency_data", "documentation": "Returns data in adjacency format that is suitable for JSON serialization\nand use in JavaScript documents.\n\nParameters\n----------\nG : NetworkX graph\n\nattrs : dict\n    A dictionary that contains two keys 'id' and 'key'. The corresponding\n    values provide the attribute names for storing NetworkX-internal graph\n    data. The values should be unique. Default value:\n    :samp:`dict(id='id', key='key')`.\n\n    If some user-defined graph data use these attribute names as data keys,\n    they may be silently dropped.\n\nReturns\n-------\ndata : dict\n   A dictionary with adjacency formatted data.\n\nRaises\n------\nNetworkXError\n    If values in attrs are not unique.\n\nExamples\n--------\n>>> from networkx.readwrite import json_graph\n>>> G = nx.Graph([(1, 2)])\n>>> data = json_graph.adjacency_data(G)\n\nTo serialize with json\n\n>>> import json\n>>> s = json.dumps(data)\n\nNotes\n-----\nGraph, node, and link attributes will be written when using this format\nbut attribute keys must be strings if you want to serialize the resulting\ndata with JSON.\n\nThe default value of attrs will be changed in a future release of NetworkX.\n\nSee Also\n--------\nadjacency_graph, node_link_data, tree_data"}, {"type": "function", "name": "networkx.adjacency_graph", "documentation": "Returns graph from adjacency data format.\n\nParameters\n----------\ndata : dict\n    Adjacency list formatted graph data\n\ndirected : bool\n    If True, and direction not specified in data, return a directed graph.\n\nmultigraph : bool\n    If True, and multigraph not specified in data, return a multigraph.\n\nattrs : dict\n    A dictionary that contains two keys 'id' and 'key'. The corresponding\n    values provide the attribute names for storing NetworkX-internal graph\n    data. The values should be unique. Default value:\n    :samp:`dict(id='id', key='key')`.\n\nReturns\n-------\nG : NetworkX graph\n   A NetworkX graph object\n\nExamples\n--------\n>>> from networkx.readwrite import json_graph\n>>> G = nx.Graph([(1, 2)])\n>>> data = json_graph.adjacency_data(G)\n>>> H = json_graph.adjacency_graph(data)\n\nNotes\n-----\nThe default value of attrs will be changed in a future release of NetworkX.\n\nSee Also\n--------\nadjacency_graph, node_link_data, tree_data"}, {"type": "function", "name": "networkx.adjacency_matrix", "documentation": "Returns adjacency matrix of G.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nnodelist : list, optional\n   The rows and columns are ordered according to the nodes in nodelist.\n   If nodelist is None, then the ordering is produced by G.nodes().\n\ndtype : NumPy data-type, optional\n    The desired data-type for the array.\n    If None, then the NumPy default is used.\n\nweight : string or None, optional (default='weight')\n   The edge data key used to provide each value in the matrix.\n   If None, then each edge has weight 1.\n\nReturns\n-------\nA : SciPy sparse array\n  Adjacency matrix representation of G.\n\nNotes\n-----\nFor directed graphs, entry i,j corresponds to an edge from i to j.\n\nIf you want a pure Python adjacency matrix representation try\nnetworkx.convert.to_dict_of_dicts which will return a\ndictionary-of-dictionaries format that can be addressed as a\nsparse matrix.\n\nFor MultiGraph/MultiDiGraph with parallel edges the weights are summed.\nSee `to_numpy_array` for other options.\n\nThe convention used for self-loop edges in graphs is to assign the\ndiagonal matrix entry value to the edge weight attribute\n(or the number 1 if the edge has no weight attribute).  If the\nalternate convention of doubling the edge weight is desired the\nresulting SciPy sparse array can be modified as follows:\n\n>>> G = nx.Graph([(1, 1)])\n>>> A = nx.adjacency_matrix(G)\n>>> print(A.todense())\n[[1]]\n>>> A.setdiag(A.diagonal() * 2)\n>>> print(A.todense())\n[[2]]\n\nSee Also\n--------\nto_numpy_array\nto_scipy_sparse_array\nto_dict_of_dicts\nadjacency_spectrum"}, {"type": "function", "name": "networkx.adjacency_spectrum", "documentation": "Returns eigenvalues of the adjacency matrix of G.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nweight : string or None, optional (default='weight')\n   The edge data key used to compute each value in the matrix.\n   If None, then each edge has weight 1.\n\nReturns\n-------\nevals : NumPy array\n  Eigenvalues\n\nNotes\n-----\nFor MultiGraph/MultiDiGraph, the edges weights are summed.\nSee to_numpy_array for other options.\n\nSee Also\n--------\nadjacency_matrix"}, {"type": "function", "name": "networkx.algebraic_connectivity", "documentation": "Returns the algebraic connectivity of an undirected graph.\n\nThe algebraic connectivity of a connected undirected graph is the second\nsmallest eigenvalue of its Laplacian matrix.\n\nParameters\n----------\nG : NetworkX graph\n    An undirected graph.\n\nweight : object, optional (default: None)\n    The data key used to determine the weight of each edge. If None, then\n    each edge has unit weight.\n\nnormalized : bool, optional (default: False)\n    Whether the normalized Laplacian matrix is used.\n\ntol : float, optional (default: 1e-8)\n    Tolerance of relative residual in eigenvalue computation.\n\nmethod : string, optional (default: 'tracemin_pcg')\n    Method of eigenvalue computation. It must be one of the tracemin\n    options shown below (TraceMIN), 'lanczos' (Lanczos iteration)\n    or 'lobpcg' (LOBPCG).\n\n    The TraceMIN algorithm uses a linear system solver. The following\n    values allow specifying the solver to be used.\n\n    =============== ========================================\n    Value           Solver\n    =============== ========================================\n    'tracemin_pcg'  Preconditioned conjugate gradient method\n    'tracemin_lu'   LU factorization\n    =============== ========================================\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nalgebraic_connectivity : float\n    Algebraic connectivity.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is directed.\n\nNetworkXError\n    If G has less than two nodes.\n\nNotes\n-----\nEdge weights are interpreted by their absolute values. For MultiGraph's,\nweights of parallel edges are summed. Zero-weighted edges are ignored.\n\nSee Also\n--------\nlaplacian_matrix\n\nExamples\n--------\nFor undirected graphs algebraic connectivity can tell us if a graph is connected or not\n`G` is connected iff  ``algebraic_connectivity(G) > 0``:\n\n>>> G = nx.complete_graph(5)\n>>> nx.algebraic_connectivity(G) > 0\nTrue\n>>> G.add_node(10)  # G is no longer connected\n>>> nx.algebraic_connectivity(G) > 0\nFalse"}, {"type": "function", "name": "networkx.all_neighbors", "documentation": "Returns all of the neighbors of a node in the graph.\n\nIf the graph is directed returns predecessors as well as successors.\n\nParameters\n----------\ngraph : NetworkX graph\n    Graph to find neighbors.\n\nnode : node\n    The node whose neighbors will be returned.\n\nReturns\n-------\nneighbors : iterator\n    Iterator of neighbors"}, {"type": "function", "name": "networkx.all_node_cuts", "documentation": "Returns all minimum k cutsets of an undirected graph G.\n\nThis implementation is based on Kanevsky's algorithm [1]_ for finding all\nminimum-size node cut-sets of an undirected graph G; ie the set (or sets)\nof nodes of cardinality equal to the node connectivity of G. Thus if\nremoved, would break G into two or more connected components.\n\nParameters\n----------\nG : NetworkX graph\n    Undirected graph\n\nk : Integer\n    Node connectivity of the input graph. If k is None, then it is\n    computed. Default value: None.\n\nflow_func : function\n    Function to perform the underlying flow computations. Default value is\n    :func:`~networkx.algorithms.flow.edmonds_karp`. This function performs\n    better in sparse graphs with right tailed degree distributions.\n    :func:`~networkx.algorithms.flow.shortest_augmenting_path` will\n    perform better in denser graphs.\n\n\nReturns\n-------\ncuts : a generator of node cutsets\n    Each node cutset has cardinality equal to the node connectivity of\n    the input graph.\n\nExamples\n--------\n>>> # A two-dimensional grid graph has 4 cutsets of cardinality 2\n>>> G = nx.grid_2d_graph(5, 5)\n>>> cutsets = list(nx.all_node_cuts(G))\n>>> len(cutsets)\n4\n>>> all(2 == len(cutset) for cutset in cutsets)\nTrue\n>>> nx.node_connectivity(G)\n2\n\nNotes\n-----\nThis implementation is based on the sequential algorithm for finding all\nminimum-size separating vertex sets in a graph [1]_. The main idea is to\ncompute minimum cuts using local maximum flow computations among a set\nof nodes of highest degree and all other non-adjacent nodes in the Graph.\nOnce we find a minimum cut, we add an edge between the high degree\nnode and the target node of the local maximum flow computation to make\nsure that we will not find that minimum cut again.\n\nSee also\n--------\nnode_connectivity\nedmonds_karp\nshortest_augmenting_path\n\nReferences\n----------\n.. [1]  Kanevsky, A. (1993). Finding all minimum-size separating vertex\n        sets in a graph. Networks 23(6), 533--541.\n        http://onlinelibrary.wiley.com/doi/10.1002/net.3230230604/abstract"}, {"type": "function", "name": "networkx.all_pairs_all_shortest_paths", "documentation": "Compute all shortest paths between all nodes.\n\nParameters\n----------\nG : NetworkX graph\n\nweight : None, string or function, optional (default = None)\n    If None, every edge has weight/distance/cost 1.\n    If a string, use this edge attribute as the edge weight.\n    Any edge attribute not present defaults to 1.\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly\n    three positional arguments: the two endpoints of an edge and\n    the dictionary of edge attributes for that edge.\n    The function must return a number.\n\nmethod : string, optional (default = 'dijkstra')\n   The algorithm to use to compute the path lengths.\n   Supported options: 'dijkstra', 'bellman-ford'.\n   Other inputs produce a ValueError.\n   If `weight` is None, unweighted graph methods are used, and this\n   suggestion is ignored.\n\nReturns\n-------\npaths : generator of dictionary\n    Dictionary of arrays, keyed by source and target, of all shortest paths.\n\nRaises\n------\nValueError\n    If `method` is not among the supported options.\n\nExamples\n--------\n>>> G = nx.cycle_graph(4)\n>>> dict(nx.all_pairs_all_shortest_paths(G))[0][2]\n[[0, 1, 2], [0, 3, 2]]\n>>> dict(nx.all_pairs_all_shortest_paths(G))[0][3]\n[[0, 3]]\n\nNotes\n-----\nThere may be multiple shortest paths with equal lengths. Unlike\nall_pairs_shortest_path, this method returns all shortest paths.\n\nSee Also\n--------\nall_pairs_shortest_path\nsingle_source_all_shortest_paths"}, {"type": "function", "name": "networkx.all_pairs_bellman_ford_path", "documentation": "Compute shortest paths between all nodes in a weighted graph.\n\nParameters\n----------\nG : NetworkX graph\n\nweight : string or function (default=\"weight\")\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\nReturns\n-------\npaths : iterator\n    (source, dictionary) iterator with dictionary keyed by target and\n    shortest path as the key value.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> path = dict(nx.all_pairs_bellman_ford_path(G))\n>>> path[0][4]\n[0, 1, 2, 3, 4]\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nSee Also\n--------\nfloyd_warshall, all_pairs_dijkstra_path"}, {"type": "function", "name": "networkx.all_pairs_bellman_ford_path_length", "documentation": "Compute shortest path lengths between all nodes in a weighted graph.\n\nParameters\n----------\nG : NetworkX graph\n\nweight : string or function (default=\"weight\")\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\nReturns\n-------\ndistance : iterator\n    (source, dictionary) iterator with dictionary keyed by target and\n    shortest path length as the key value.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> length = dict(nx.all_pairs_bellman_ford_path_length(G))\n>>> for node in [0, 1, 2, 3, 4]:\n...     print(f\"1 - {node}: {length[1][node]}\")\n1 - 0: 1\n1 - 1: 0\n1 - 2: 1\n1 - 3: 2\n1 - 4: 3\n>>> length[3][2]\n1\n>>> length[2][2]\n0\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe dictionary returned only has keys for reachable node pairs."}, {"type": "function", "name": "networkx.all_pairs_dijkstra", "documentation": "Find shortest weighted paths and lengths between all nodes.\n\nParameters\n----------\nG : NetworkX graph\n\ncutoff : integer or float, optional\n    Length (sum of edge weights) at which the search is stopped.\n    If cutoff is provided, only return paths with summed weight <= cutoff.\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edge[u][v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number or None to indicate a hidden edge.\n\nYields\n------\n(node, (distance, path)) : (node obj, (dict, dict))\n    Each source node has two associated dicts. The first holds distance\n    keyed by target and the second holds paths keyed by target.\n    (See single_source_dijkstra for the source/target node terminology.)\n    If desired you can apply `dict()` to this function to create a dict\n    keyed by source node to the two dicts.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> len_path = dict(nx.all_pairs_dijkstra(G))\n>>> len_path[3][0][1]\n2\n>>> for node in [0, 1, 2, 3, 4]:\n...     print(f\"3 - {node}: {len_path[3][0][node]}\")\n3 - 0: 3\n3 - 1: 2\n3 - 2: 1\n3 - 3: 0\n3 - 4: 1\n>>> len_path[3][1][1]\n[3, 2, 1]\n>>> for n, (dist, path) in nx.all_pairs_dijkstra(G):\n...     print(path[1])\n[0, 1]\n[1]\n[2, 1]\n[3, 2, 1]\n[4, 3, 2, 1]\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe yielded dicts only have keys for reachable nodes."}, {"type": "function", "name": "networkx.all_pairs_dijkstra_path", "documentation": "Compute shortest paths between all nodes in a weighted graph.\n\nParameters\n----------\nG : NetworkX graph\n\ncutoff : integer or float, optional\n    Length (sum of edge weights) at which the search is stopped.\n    If cutoff is provided, only return paths with summed weight <= cutoff.\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number or None to indicate a hidden edge.\n\nReturns\n-------\npaths : iterator\n    (source, dictionary) iterator with dictionary keyed by target and\n    shortest path as the key value.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> path = dict(nx.all_pairs_dijkstra_path(G))\n>>> path[0][4]\n[0, 1, 2, 3, 4]\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nSee Also\n--------\nfloyd_warshall, all_pairs_bellman_ford_path"}, {"type": "function", "name": "networkx.all_pairs_dijkstra_path_length", "documentation": "Compute shortest path lengths between all nodes in a weighted graph.\n\nParameters\n----------\nG : NetworkX graph\n\ncutoff : integer or float, optional\n    Length (sum of edge weights) at which the search is stopped.\n    If cutoff is provided, only return paths with summed weight <= cutoff.\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number or None to indicate a hidden edge.\n\nReturns\n-------\ndistance : iterator\n    (source, dictionary) iterator with dictionary keyed by target and\n    shortest path length as the key value.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> length = dict(nx.all_pairs_dijkstra_path_length(G))\n>>> for node in [0, 1, 2, 3, 4]:\n...     print(f\"1 - {node}: {length[1][node]}\")\n1 - 0: 1\n1 - 1: 0\n1 - 2: 1\n1 - 3: 2\n1 - 4: 3\n>>> length[3][2]\n1\n>>> length[2][2]\n0\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe dictionary returned only has keys for reachable node pairs."}, {"type": "function", "name": "networkx.all_pairs_lowest_common_ancestor", "documentation": "Return the lowest common ancestor of all pairs or the provided pairs\n\nParameters\n----------\nG : NetworkX directed graph\n\npairs : iterable of pairs of nodes, optional (default: all pairs)\n    The pairs of nodes of interest.\n    If None, will find the LCA of all pairs of nodes.\n\nYields\n------\n((node1, node2), lca) : 2-tuple\n    Where lca is least common ancestor of node1 and node2.\n    Note that for the default case, the order of the node pair is not considered,\n    e.g. you will not get both ``(a, b)`` and ``(b, a)``\n\nRaises\n------\nNetworkXPointlessConcept\n    If `G` is null.\nNetworkXError\n    If `G` is not a DAG.\n\nExamples\n--------\nThe default behavior is to yield the lowest common ancestor for all\npossible combinations of nodes in `G`, including self-pairings:\n\n>>> G = nx.DiGraph([(0, 1), (0, 3), (1, 2)])\n>>> dict(nx.all_pairs_lowest_common_ancestor(G))\n{(0, 0): 0, (0, 1): 0, (0, 3): 0, (0, 2): 0, (1, 1): 1, (1, 3): 0, (1, 2): 1, (3, 3): 3, (3, 2): 0, (2, 2): 2}\n\nThe pairs argument can be used to limit the output to only the\nspecified node pairings:\n\n>>> dict(nx.all_pairs_lowest_common_ancestor(G, pairs=[(1, 2), (2, 3)]))\n{(1, 2): 1, (2, 3): 0}\n\nNotes\n-----\nOnly defined on non-null directed acyclic graphs.\n\nSee Also\n--------\nlowest_common_ancestor"}, {"type": "function", "name": "networkx.all_pairs_node_connectivity", "documentation": "Compute node connectivity between all pairs of nodes of G.\n\nParameters\n----------\nG : NetworkX graph\n    Undirected graph\n\nnbunch: container\n    Container of nodes. If provided node connectivity will be computed\n    only over pairs of nodes in nbunch.\n\nflow_func : function\n    A function for computing the maximum flow among a pair of nodes.\n    The function has to accept at least three parameters: a Digraph,\n    a source node, and a target node. And return a residual network\n    that follows NetworkX conventions (see :meth:`maximum_flow` for\n    details). If flow_func is None, the default maximum flow function\n    (:meth:`edmonds_karp`) is used. See below for details. The\n    choice of the default function may change from version\n    to version and should not be relied on. Default value: None.\n\nReturns\n-------\nall_pairs : dict\n    A dictionary with node connectivity between all pairs of nodes\n    in G, or in nbunch if provided.\n\nSee also\n--------\n:meth:`local_node_connectivity`\n:meth:`edge_connectivity`\n:meth:`local_edge_connectivity`\n:meth:`maximum_flow`\n:meth:`edmonds_karp`\n:meth:`preflow_push`\n:meth:`shortest_augmenting_path`"}, {"type": "function", "name": "networkx.all_pairs_shortest_path", "documentation": "Compute shortest paths between all nodes.\n\nParameters\n----------\nG : NetworkX graph\n\ncutoff : integer, optional\n    Depth at which to stop the search. Only paths of length at most\n    `cutoff` are returned.\n\nReturns\n-------\npaths : iterator\n    Dictionary, keyed by source and target, of shortest paths.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> path = dict(nx.all_pairs_shortest_path(G))\n>>> print(path[0][4])\n[0, 1, 2, 3, 4]\n\nNotes\n-----\nThere may be multiple shortest paths with the same length between\ntwo nodes. For each pair, this function returns only one of those paths.\n\nSee Also\n--------\nfloyd_warshall\nall_pairs_all_shortest_paths"}, {"type": "function", "name": "networkx.all_pairs_shortest_path_length", "documentation": "Computes the shortest path lengths between all nodes in `G`.\n\nParameters\n----------\nG : NetworkX graph\n\ncutoff : integer, optional\n    Depth at which to stop the search. Only paths of length at most\n    `cutoff` are returned.\n\nReturns\n-------\nlengths : iterator\n    (source, dictionary) iterator with dictionary keyed by target and\n    shortest path length as the key value.\n\nNotes\n-----\nThe iterator returned only has reachable node pairs.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> length = dict(nx.all_pairs_shortest_path_length(G))\n>>> for node in [0, 1, 2, 3, 4]:\n...     print(f\"1 - {node}: {length[1][node]}\")\n1 - 0: 1\n1 - 1: 0\n1 - 2: 1\n1 - 3: 2\n1 - 4: 3\n>>> length[3][2]\n1\n>>> length[2][2]\n0"}, {"type": "function", "name": "networkx.all_shortest_paths", "documentation": "Compute all shortest simple paths in the graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n   Starting node for path.\n\ntarget : node\n   Ending node for path.\n\nweight : None, string or function, optional (default = None)\n    If None, every edge has weight/distance/cost 1.\n    If a string, use this edge attribute as the edge weight.\n    Any edge attribute not present defaults to 1.\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly\n    three positional arguments: the two endpoints of an edge and\n    the dictionary of edge attributes for that edge.\n    The function must return a number.\n\nmethod : string, optional (default = 'dijkstra')\n   The algorithm to use to compute the path lengths.\n   Supported options: 'dijkstra', 'bellman-ford'.\n   Other inputs produce a ValueError.\n   If `weight` is None, unweighted graph methods are used, and this\n   suggestion is ignored.\n\nReturns\n-------\npaths : generator of lists\n    A generator of all paths between source and target.\n\nRaises\n------\nValueError\n    If `method` is not among the supported options.\n\nNetworkXNoPath\n    If `target` cannot be reached from `source`.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> nx.add_path(G, [0, 1, 2])\n>>> nx.add_path(G, [0, 10, 2])\n>>> print([p for p in nx.all_shortest_paths(G, source=0, target=2)])\n[[0, 1, 2], [0, 10, 2]]\n\nNotes\n-----\nThere may be many shortest paths between the source and target.  If G\ncontains zero-weight cycles, this function will not produce all shortest\npaths because doing so would produce infinitely many paths of unbounded\nlength -- instead, we only produce the shortest simple paths.\n\nSee Also\n--------\nshortest_path\nsingle_source_shortest_path\nall_pairs_shortest_path"}, {"type": "function", "name": "networkx.all_simple_edge_paths", "documentation": "Generate lists of edges for all simple paths in G from source to target.\n\nA simple path is a path with no repeated nodes.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n   Starting node for path\n\ntarget : nodes\n   Single node or iterable of nodes at which to end path\n\ncutoff : integer, optional\n    Depth to stop the search. Only paths of length <= cutoff are returned.\n\nReturns\n-------\npath_generator: generator\n   A generator that produces lists of simple paths.  If there are no paths\n   between the source and target within the given cutoff the generator\n   produces no output.\n   For multigraphs, the list of edges have elements of the form `(u,v,k)`.\n   Where `k` corresponds to the edge key.\n\nExamples\n--------\n\nPrint the simple path edges of a Graph::\n\n    >>> g = nx.Graph([(1, 2), (2, 4), (1, 3), (3, 4)])\n    >>> for path in sorted(nx.all_simple_edge_paths(g, 1, 4)):\n    ...     print(path)\n    [(1, 2), (2, 4)]\n    [(1, 3), (3, 4)]\n\nPrint the simple path edges of a MultiGraph. Returned edges come with\ntheir associated keys::\n\n    >>> mg = nx.MultiGraph()\n    >>> mg.add_edge(1, 2, key=\"k0\")\n    'k0'\n    >>> mg.add_edge(1, 2, key=\"k1\")\n    'k1'\n    >>> mg.add_edge(2, 3, key=\"k0\")\n    'k0'\n    >>> for path in sorted(nx.all_simple_edge_paths(mg, 1, 3)):\n    ...     print(path)\n    [(1, 2, 'k0'), (2, 3, 'k0')]\n    [(1, 2, 'k1'), (2, 3, 'k0')]\n\nWhen ``source`` is one of the targets, the empty path starting and ending at\n``source`` without traversing any edge is considered a valid simple edge path\nand is included in the results:\n\n    >>> G = nx.Graph()\n    >>> G.add_node(0)\n    >>> paths = list(nx.all_simple_edge_paths(G, 0, 0))\n    >>> for path in paths:\n    ...     print(path)\n    []\n    >>> len(paths)\n    1\n\n\nNotes\n-----\nThis algorithm uses a modified depth-first search to generate the\npaths [1]_.  A single path can be found in $O(V+E)$ time but the\nnumber of simple paths in a graph can be very large, e.g. $O(n!)$ in\nthe complete graph of order $n$.\n\nReferences\n----------\n.. [1] R. Sedgewick, \"Algorithms in C, Part 5: Graph Algorithms\",\n   Addison Wesley Professional, 3rd ed., 2001.\n\nSee Also\n--------\nall_shortest_paths, shortest_path, all_simple_paths"}, {"type": "function", "name": "networkx.all_simple_paths", "documentation": "Generate all simple paths in the graph G from source to target.\n\nA simple path is a path with no repeated nodes.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n   Starting node for path\n\ntarget : nodes\n   Single node or iterable of nodes at which to end path\n\ncutoff : integer, optional\n    Depth to stop the search. Only paths of length <= cutoff are returned.\n\nReturns\n-------\npath_generator: generator\n   A generator that produces lists of simple paths.  If there are no paths\n   between the source and target within the given cutoff the generator\n   produces no output. If it is possible to traverse the same sequence of\n   nodes in multiple ways, namely through parallel edges, then it will be\n   returned multiple times (once for each viable edge combination).\n\nExamples\n--------\nThis iterator generates lists of nodes::\n\n    >>> G = nx.complete_graph(4)\n    >>> for path in nx.all_simple_paths(G, source=0, target=3):\n    ...     print(path)\n    ...\n    [0, 1, 2, 3]\n    [0, 1, 3]\n    [0, 2, 1, 3]\n    [0, 2, 3]\n    [0, 3]\n\nYou can generate only those paths that are shorter than a certain\nlength by using the `cutoff` keyword argument::\n\n    >>> paths = nx.all_simple_paths(G, source=0, target=3, cutoff=2)\n    >>> print(list(paths))\n    [[0, 1, 3], [0, 2, 3], [0, 3]]\n\nTo get each path as the corresponding list of edges, you can use the\n:func:`networkx.utils.pairwise` helper function::\n\n    >>> paths = nx.all_simple_paths(G, source=0, target=3)\n    >>> for path in map(nx.utils.pairwise, paths):\n    ...     print(list(path))\n    [(0, 1), (1, 2), (2, 3)]\n    [(0, 1), (1, 3)]\n    [(0, 2), (2, 1), (1, 3)]\n    [(0, 2), (2, 3)]\n    [(0, 3)]\n\nPass an iterable of nodes as target to generate all paths ending in any of several nodes::\n\n    >>> G = nx.complete_graph(4)\n    >>> for path in nx.all_simple_paths(G, source=0, target=[3, 2]):\n    ...     print(path)\n    ...\n    [0, 1, 2]\n    [0, 1, 2, 3]\n    [0, 1, 3]\n    [0, 1, 3, 2]\n    [0, 2]\n    [0, 2, 1, 3]\n    [0, 2, 3]\n    [0, 3]\n    [0, 3, 1, 2]\n    [0, 3, 2]\n\nThe singleton path from ``source`` to itself is considered a simple path and is\nincluded in the results:\n\n    >>> G = nx.empty_graph(5)\n    >>> list(nx.all_simple_paths(G, source=0, target=0))\n    [[0]]\n\n    >>> G = nx.path_graph(3)\n    >>> list(nx.all_simple_paths(G, source=0, target={0, 1, 2}))\n    [[0], [0, 1], [0, 1, 2]]\n\nIterate over each path from the root nodes to the leaf nodes in a\ndirected acyclic graph using a functional programming approach::\n\n    >>> from itertools import chain\n    >>> from itertools import product\n    >>> from itertools import starmap\n    >>> from functools import partial\n    >>>\n    >>> chaini = chain.from_iterable\n    >>>\n    >>> G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])\n    >>> roots = (v for v, d in G.in_degree() if d == 0)\n    >>> leaves = (v for v, d in G.out_degree() if d == 0)\n    >>> all_paths = partial(nx.all_simple_paths, G)\n    >>> list(chaini(starmap(all_paths, product(roots, leaves))))\n    [[0, 1, 2], [0, 3, 2]]\n\nThe same list computed using an iterative approach::\n\n    >>> G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])\n    >>> roots = (v for v, d in G.in_degree() if d == 0)\n    >>> leaves = (v for v, d in G.out_degree() if d == 0)\n    >>> all_paths = []\n    >>> for root in roots:\n    ...     for leaf in leaves:\n    ...         paths = nx.all_simple_paths(G, root, leaf)\n    ...         all_paths.extend(paths)\n    >>> all_paths\n    [[0, 1, 2], [0, 3, 2]]\n\nIterate over each path from the root nodes to the leaf nodes in a\ndirected acyclic graph passing all leaves together to avoid unnecessary\ncompute::\n\n    >>> G = nx.DiGraph([(0, 1), (2, 1), (1, 3), (1, 4)])\n    >>> roots = (v for v, d in G.in_degree() if d == 0)\n    >>> leaves = [v for v, d in G.out_degree() if d == 0]\n    >>> all_paths = []\n    >>> for root in roots:\n    ...     paths = nx.all_simple_paths(G, root, leaves)\n    ...     all_paths.extend(paths)\n    >>> all_paths\n    [[0, 1, 3], [0, 1, 4], [2, 1, 3], [2, 1, 4]]\n\nIf parallel edges offer multiple ways to traverse a given sequence of\nnodes, this sequence of nodes will be returned multiple times:\n\n    >>> G = nx.MultiDiGraph([(0, 1), (0, 1), (1, 2)])\n    >>> list(nx.all_simple_paths(G, 0, 2))\n    [[0, 1, 2], [0, 1, 2]]\n\nNotes\n-----\nThis algorithm uses a modified depth-first search to generate the\npaths [1]_.  A single path can be found in $O(V+E)$ time but the\nnumber of simple paths in a graph can be very large, e.g. $O(n!)$ in\nthe complete graph of order $n$.\n\nThis function does not check that a path exists between `source` and\n`target`. For large graphs, this may result in very long runtimes.\nConsider using `has_path` to check that a path exists between `source` and\n`target` before calling this function on large graphs.\n\nReferences\n----------\n.. [1] R. Sedgewick, \"Algorithms in C, Part 5: Graph Algorithms\",\n   Addison Wesley Professional, 3rd ed., 2001.\n\nSee Also\n--------\nall_shortest_paths, shortest_path, has_path"}, {"type": "function", "name": "networkx.all_topological_sorts", "documentation": "Returns a generator of _all_ topological sorts of the directed graph G.\n\nA topological sort is a nonunique permutation of the nodes such that an\nedge from u to v implies that u appears before v in the topological sort\norder.\n\nParameters\n----------\nG : NetworkX DiGraph\n    A directed graph\n\nYields\n------\ntopological_sort_order : list\n    a list of nodes in `G`, representing one of the topological sort orders\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is not directed\nNetworkXUnfeasible\n    If `G` is not acyclic\n\nExamples\n--------\nTo enumerate all topological sorts of directed graph:\n\n>>> DG = nx.DiGraph([(1, 2), (2, 3), (2, 4)])\n>>> list(nx.all_topological_sorts(DG))\n[[1, 2, 4, 3], [1, 2, 3, 4]]\n\nNotes\n-----\nImplements an iterative version of the algorithm given in [1].\n\nReferences\n----------\n.. [1] Knuth, Donald E., Szwarcfiter, Jayme L. (1974).\n   \"A Structured Program to Generate All Topological Sorting Arrangements\"\n   Information Processing Letters, Volume 2, Issue 6, 1974, Pages 153-157,\n   ISSN 0020-0190,\n   https://doi.org/10.1016/0020-0190(74)90001-5.\n   Elsevier (North-Holland), Amsterdam"}, {"type": "function", "name": "networkx.all_triads", "documentation": "A generator of all possible triads in G.\n\nParameters\n----------\nG : digraph\n   A NetworkX DiGraph\n\nReturns\n-------\nall_triads : generator of DiGraphs\n   Generator of triads (order-3 DiGraphs)\n\nExamples\n--------\n>>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\n>>> for triad in nx.all_triads(G):\n...     print(triad.edges)\n[(1, 2), (2, 3), (3, 1)]\n[(1, 2), (4, 1), (4, 2)]\n[(3, 1), (3, 4), (4, 1)]\n[(2, 3), (3, 4), (4, 2)]"}, {"type": "function", "name": "networkx.all_triplets", "documentation": "Returns a generator of all possible sets of 3 nodes in a DiGraph.\n\n.. deprecated:: 3.3\n\n   all_triplets is deprecated and will be removed in NetworkX version 3.5.\n   Use `itertools.combinations` instead::\n\n      all_triplets = itertools.combinations(G, 3)\n\nParameters\n----------\nG : digraph\n   A NetworkX DiGraph\n\nReturns\n-------\ntriplets : generator of 3-tuples\n   Generator of tuples of 3 nodes\n\nExamples\n--------\n>>> G = nx.DiGraph([(1, 2), (2, 3), (3, 4)])\n>>> list(nx.all_triplets(G))\n[(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]"}, {"type": "function", "name": "networkx.ancestors", "documentation": "Returns all nodes having a path to `source` in `G`.\n\nParameters\n----------\nG : NetworkX Graph\nsource : node in `G`\n\nReturns\n-------\nset()\n    The ancestors of `source` in `G`\n\nRaises\n------\nNetworkXError\n    If node `source` is not in `G`.\n\nExamples\n--------\n>>> DG = nx.path_graph(5, create_using=nx.DiGraph)\n>>> sorted(nx.ancestors(DG, 2))\n[0, 1]\n\nThe `source` node is not an ancestor of itself, but can be included manually:\n\n>>> sorted(nx.ancestors(DG, 2) | {2})\n[0, 1, 2]\n\nSee also\n--------\ndescendants"}, {"type": "function", "name": "networkx.antichains", "documentation": "Generates antichains from a directed acyclic graph (DAG).\n\nAn antichain is a subset of a partially ordered set such that any\ntwo elements in the subset are incomparable.\n\nParameters\n----------\nG : NetworkX DiGraph\n    A directed acyclic graph (DAG)\n\ntopo_order: list or tuple, optional\n    A topological order for G (if None, the function will compute one)\n\nYields\n------\nantichain : list\n    a list of nodes in `G` representing an antichain\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is not directed\n\nNetworkXUnfeasible\n    If `G` contains a cycle\n\nExamples\n--------\n>>> DG = nx.DiGraph([(1, 2), (1, 3)])\n>>> list(nx.antichains(DG))\n[[], [3], [2], [2, 3], [1]]\n\nNotes\n-----\nThis function was originally developed by Peter Jipsen and Franco Saliola\nfor the SAGE project. It's included in NetworkX with permission from the\nauthors. Original SAGE code at:\n\nhttps://github.com/sagemath/sage/blob/master/src/sage/combinat/posets/hasse_diagram.py\n\nReferences\n----------\n.. [1] Free Lattices, by R. Freese, J. Jezek and J. B. Nation,\n   AMS, Vol 42, 1995, p. 226."}, {"type": "function", "name": "networkx.approximate_current_flow_betweenness_centrality", "documentation": "Compute the approximate current-flow betweenness centrality for nodes.\n\nApproximates the current-flow betweenness centrality within absolute\nerror of epsilon with high probability [1]_.\n\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nnormalized : bool, optional (default=True)\n  If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\n  n is the number of nodes in G.\n\nweight : string or None, optional (default=None)\n  Key for edge data used as the edge weight.\n  If None, then use 1 as each edge weight.\n  The weight reflects the capacity or the strength of the\n  edge.\n\ndtype : data type (float)\n  Default data type for internal matrices.\n  Set to np.float32 for lower memory consumption.\n\nsolver : string (default='full')\n   Type of linear solver to use for computing the flow matrix.\n   Options are \"full\" (uses most memory), \"lu\" (recommended), and\n   \"cg\" (uses least memory).\n\nepsilon: float\n    Absolute error tolerance.\n\nkmax: int\n   Maximum number of sample node pairs to use for approximation.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with betweenness centrality as the value.\n\nSee Also\n--------\ncurrent_flow_betweenness_centrality\n\nNotes\n-----\nThe running time is $O((1/\\epsilon^2)m{\\sqrt k} \\log n)$\nand the space required is $O(m)$ for $n$ nodes and $m$ edges.\n\nIf the edges have a 'weight' attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.\n\nReferences\n----------\n.. [1] Ulrik Brandes and Daniel Fleischer:\n   Centrality Measures Based on Current Flow.\n   Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n   LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n   https://doi.org/10.1007/978-3-540-31856-9_44"}, {"type": "function", "name": "networkx.arf_layout", "documentation": "Arf layout for networkx\n\nThe attractive and repulsive forces (arf) layout [1]\nimproves the spring layout in three ways. First, it\nprevents congestion of highly connected nodes due to\nstrong forcing between nodes. Second, it utilizes the\nlayout space more effectively by preventing large gaps\nthat spring layout tends to create. Lastly, the arf\nlayout represents symmetries in the layout better than\nthe default spring layout.\n\nParameters\n----------\nG : nx.Graph or nx.DiGraph\n    Networkx graph.\npos : dict\n    Initial  position of  the nodes.  If set  to None  a\n    random layout will be used.\nscaling : float\n    Scales the radius of the circular layout space.\na : float\n    Strength of springs between connected nodes. Should be larger than 1. The greater a, the clearer the separation ofunconnected sub clusters.\netol : float\n    Gradient sum of spring forces must be larger than `etol` before successful termination.\ndt : float\n    Time step for force differential equation simulations.\nmax_iter : int\n    Max iterations before termination of the algorithm.\n\nReferences\n.. [1] \"Self-Organization Applied to Dynamic Network Layout\", M. Geipel,\n        International Journal of Modern Physics C, 2007, Vol 18, No 10, pp. 1537-1549.\n        https://doi.org/10.1142/S0129183107011558 https://arxiv.org/abs/0704.1748\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node.\n\nExamples\n--------\n>>> G = nx.grid_graph((5, 5))\n>>> pos = nx.arf_layout(G)"}, {"type": "function", "name": "networkx.articulation_points", "documentation": "Yield the articulation points, or cut vertices, of a graph.\n\nAn articulation point or cut vertex is any node whose removal (along with\nall its incident edges) increases the number of connected components of\na graph.  An undirected connected graph without articulation points is\nbiconnected. Articulation points belong to more than one biconnected\ncomponent of a graph.\n\nNotice that by convention a dyad is considered a biconnected component.\n\nParameters\n----------\nG : NetworkX Graph\n    An undirected graph.\n\nYields\n------\nnode\n    An articulation point in the graph.\n\nRaises\n------\nNetworkXNotImplemented\n    If the input graph is not undirected.\n\nExamples\n--------\n\n>>> G = nx.barbell_graph(4, 2)\n>>> print(nx.is_biconnected(G))\nFalse\n>>> len(list(nx.articulation_points(G)))\n4\n>>> G.add_edge(2, 8)\n>>> print(nx.is_biconnected(G))\nTrue\n>>> len(list(nx.articulation_points(G)))\n0\n\nSee Also\n--------\nis_biconnected\nbiconnected_components\nbiconnected_component_edges\n\nNotes\n-----\nThe algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node `n` is an articulation point if, and only\nif, there exists a subtree rooted at `n` such that there is no\nback edge from any successor of `n` that links to a predecessor of\n`n` in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.\n\nReferences\n----------\n.. [1] Hopcroft, J.; Tarjan, R. (1973).\n       \"Efficient algorithms for graph manipulation\".\n       Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272"}, {"type": "function", "name": "networkx.astar_path", "documentation": "Returns a list of nodes in a shortest path between source and target\nusing the A* (\"A-star\") algorithm.\n\nThere may be more than one shortest path.  This returns only one.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n   Starting node for path\n\ntarget : node\n   Ending node for path\n\nheuristic : function\n   A function to evaluate the estimate of the distance\n   from the a node to the target.  The function takes\n   two nodes arguments and must return a number.\n   If the heuristic is inadmissible (if it might\n   overestimate the cost of reaching the goal from a node),\n   the result may not be a shortest path.\n   The algorithm does not support updating heuristic\n   values for the same node due to caching the first\n   heuristic calculation per node.\n\nweight : string or function\n   If this is a string, then edge weights will be accessed via the\n   edge attribute with this key (that is, the weight of the edge\n   joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n   such edge attribute exists, the weight of the edge is assumed to\n   be one.\n   If this is a function, the weight of an edge is the value\n   returned by the function. The function must accept exactly three\n   positional arguments: the two endpoints of an edge and the\n   dictionary of edge attributes for that edge. The function must\n   return a number or None to indicate a hidden edge.\n\ncutoff : float, optional\n   If this is provided, the search will be bounded to this value. I.e. if\n   the evaluation function surpasses this value for a node n, the node will not\n   be expanded further and will be ignored. More formally, let h'(n) be the\n   heuristic function, and g(n) be the cost of reaching n from the source node. Then,\n   if g(n) + h'(n) > cutoff, the node will not be explored further.\n   Note that if the heuristic is inadmissible, it is possible that paths\n   are ignored even though they satisfy the cutoff.\n\nRaises\n------\nNetworkXNoPath\n    If no path exists between source and target.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> print(nx.astar_path(G, 0, 4))\n[0, 1, 2, 3, 4]\n>>> G = nx.grid_graph(dim=[3, 3])  # nodes are two-tuples (x,y)\n>>> nx.set_edge_attributes(G, {e: e[1][0] * 2 for e in G.edges()}, \"cost\")\n>>> def dist(a, b):\n...     (x1, y1) = a\n...     (x2, y2) = b\n...     return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n>>> print(nx.astar_path(G, (0, 0), (2, 2), heuristic=dist, weight=\"cost\"))\n[(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe weight function can be used to hide edges by returning None.\nSo ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\nwill find the shortest red path.\n\nSee Also\n--------\nshortest_path, dijkstra_path"}, {"type": "function", "name": "networkx.astar_path_length", "documentation": "Returns the length of the shortest path between source and target using\nthe A* (\"A-star\") algorithm.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n   Starting node for path\n\ntarget : node\n   Ending node for path\n\nheuristic : function\n   A function to evaluate the estimate of the distance\n   from the a node to the target.  The function takes\n   two nodes arguments and must return a number.\n   If the heuristic is inadmissible (if it might\n   overestimate the cost of reaching the goal from a node),\n   the result may not be a shortest path.\n   The algorithm does not support updating heuristic\n   values for the same node due to caching the first\n   heuristic calculation per node.\n\nweight : string or function\n   If this is a string, then edge weights will be accessed via the\n   edge attribute with this key (that is, the weight of the edge\n   joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n   such edge attribute exists, the weight of the edge is assumed to\n   be one.\n   If this is a function, the weight of an edge is the value\n   returned by the function. The function must accept exactly three\n   positional arguments: the two endpoints of an edge and the\n   dictionary of edge attributes for that edge. The function must\n   return a number or None to indicate a hidden edge.\n\ncutoff : float, optional\n   If this is provided, the search will be bounded to this value. I.e. if\n   the evaluation function surpasses this value for a node n, the node will not\n   be expanded further and will be ignored. More formally, let h'(n) be the\n   heuristic function, and g(n) be the cost of reaching n from the source node. Then,\n   if g(n) + h'(n) > cutoff, the node will not be explored further.\n   Note that if the heuristic is inadmissible, it is possible that paths\n   are ignored even though they satisfy the cutoff.\n\nRaises\n------\nNetworkXNoPath\n    If no path exists between source and target.\n\nSee Also\n--------\nastar_path"}, {"type": "function", "name": "networkx.attr_matrix", "documentation": "Returns the attribute matrix using attributes from `G` as a numpy array.\n\nIf only `G` is passed in, then the adjacency matrix is constructed.\n\nLet A be a discrete set of values for the node attribute `node_attr`. Then\nthe elements of A represent the rows and columns of the constructed matrix.\nNow, iterate through every edge e=(u,v) in `G` and consider the value\nof the edge attribute `edge_attr`.  If ua and va are the values of the\nnode attribute `node_attr` for u and v, respectively, then the value of\nthe edge attribute is added to the matrix element at (ua, va).\n\nParameters\n----------\nG : graph\n    The NetworkX graph used to construct the attribute matrix.\n\nedge_attr : str, optional\n    Each element of the matrix represents a running total of the\n    specified edge attribute for edges whose node attributes correspond\n    to the rows/cols of the matrix. The attribute must be present for\n    all edges in the graph. If no attribute is specified, then we\n    just count the number of edges whose node attributes correspond\n    to the matrix element.\n\nnode_attr : str, optional\n    Each row and column in the matrix represents a particular value\n    of the node attribute.  The attribute must be present for all nodes\n    in the graph. Note, the values of this attribute should be reliably\n    hashable. So, float values are not recommended. If no attribute is\n    specified, then the rows and columns will be the nodes of the graph.\n\nnormalized : bool, optional\n    If True, then each row is normalized by the summation of its values.\n\nrc_order : list, optional\n    A list of the node attribute values. This list specifies the ordering\n    of rows and columns of the array. If no ordering is provided, then\n    the ordering will be random (and also, a return value).\n\nOther Parameters\n----------------\ndtype : NumPy data-type, optional\n    A valid NumPy dtype used to initialize the array. Keep in mind certain\n    dtypes can yield unexpected results if the array is to be normalized.\n    The parameter is passed to numpy.zeros(). If unspecified, the NumPy\n    default is used.\n\norder : {'C', 'F'}, optional\n    Whether to store multidimensional data in C- or Fortran-contiguous\n    (row- or column-wise) order in memory. This parameter is passed to\n    numpy.zeros(). If unspecified, the NumPy default is used.\n\nReturns\n-------\nM : 2D NumPy ndarray\n    The attribute matrix.\n\nordering : list\n    If `rc_order` was specified, then only the attribute matrix is returned.\n    However, if `rc_order` was None, then the ordering used to construct\n    the matrix is returned as well.\n\nExamples\n--------\nConstruct an adjacency matrix:\n\n>>> G = nx.Graph()\n>>> G.add_edge(0, 1, thickness=1, weight=3)\n>>> G.add_edge(0, 2, thickness=2)\n>>> G.add_edge(1, 2, thickness=3)\n>>> nx.attr_matrix(G, rc_order=[0, 1, 2])\narray([[0., 1., 1.],\n       [1., 0., 1.],\n       [1., 1., 0.]])\n\nAlternatively, we can obtain the matrix describing edge thickness.\n\n>>> nx.attr_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\narray([[0., 1., 2.],\n       [1., 0., 3.],\n       [2., 3., 0.]])\n\nWe can also color the nodes and ask for the probability distribution over\nall edges (u,v) describing:\n\n    Pr(v has color Y | u has color X)\n\n>>> G.nodes[0][\"color\"] = \"red\"\n>>> G.nodes[1][\"color\"] = \"red\"\n>>> G.nodes[2][\"color\"] = \"blue\"\n>>> rc = [\"red\", \"blue\"]\n>>> nx.attr_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\narray([[0.33333333, 0.66666667],\n       [1.        , 0.        ]])\n\nFor example, the above tells us that for all edges (u,v):\n\n    Pr( v is red  | u is red)  = 1/3\n    Pr( v is blue | u is red)  = 2/3\n\n    Pr( v is red  | u is blue) = 1\n    Pr( v is blue | u is blue) = 0\n\nFinally, we can obtain the total weights listed by the node colors.\n\n>>> nx.attr_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\narray([[3., 2.],\n       [2., 0.]])\n\nThus, the total weight over all edges (u,v) with u and v having colors:\n\n    (red, red)   is 3   # the sole contribution is from edge (0,1)\n    (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\n    (blue, red)  is 2   # same as (red, blue) since graph is undirected\n    (blue, blue) is 0   # there are no edges with blue endpoints"}, {"type": "function", "name": "networkx.attr_sparse_matrix", "documentation": "Returns a SciPy sparse array using attributes from G.\n\nIf only `G` is passed in, then the adjacency matrix is constructed.\n\nLet A be a discrete set of values for the node attribute `node_attr`. Then\nthe elements of A represent the rows and columns of the constructed matrix.\nNow, iterate through every edge e=(u,v) in `G` and consider the value\nof the edge attribute `edge_attr`.  If ua and va are the values of the\nnode attribute `node_attr` for u and v, respectively, then the value of\nthe edge attribute is added to the matrix element at (ua, va).\n\nParameters\n----------\nG : graph\n    The NetworkX graph used to construct the NumPy matrix.\n\nedge_attr : str, optional\n    Each element of the matrix represents a running total of the\n    specified edge attribute for edges whose node attributes correspond\n    to the rows/cols of the matrix. The attribute must be present for\n    all edges in the graph. If no attribute is specified, then we\n    just count the number of edges whose node attributes correspond\n    to the matrix element.\n\nnode_attr : str, optional\n    Each row and column in the matrix represents a particular value\n    of the node attribute.  The attribute must be present for all nodes\n    in the graph. Note, the values of this attribute should be reliably\n    hashable. So, float values are not recommended. If no attribute is\n    specified, then the rows and columns will be the nodes of the graph.\n\nnormalized : bool, optional\n    If True, then each row is normalized by the summation of its values.\n\nrc_order : list, optional\n    A list of the node attribute values. This list specifies the ordering\n    of rows and columns of the array. If no ordering is provided, then\n    the ordering will be random (and also, a return value).\n\nOther Parameters\n----------------\ndtype : NumPy data-type, optional\n    A valid NumPy dtype used to initialize the array. Keep in mind certain\n    dtypes can yield unexpected results if the array is to be normalized.\n    The parameter is passed to numpy.zeros(). If unspecified, the NumPy\n    default is used.\n\nReturns\n-------\nM : SciPy sparse array\n    The attribute matrix.\n\nordering : list\n    If `rc_order` was specified, then only the matrix is returned.\n    However, if `rc_order` was None, then the ordering used to construct\n    the matrix is returned as well.\n\nExamples\n--------\nConstruct an adjacency matrix:\n\n>>> G = nx.Graph()\n>>> G.add_edge(0, 1, thickness=1, weight=3)\n>>> G.add_edge(0, 2, thickness=2)\n>>> G.add_edge(1, 2, thickness=3)\n>>> M = nx.attr_sparse_matrix(G, rc_order=[0, 1, 2])\n>>> M.toarray()\narray([[0., 1., 1.],\n       [1., 0., 1.],\n       [1., 1., 0.]])\n\nAlternatively, we can obtain the matrix describing edge thickness.\n\n>>> M = nx.attr_sparse_matrix(G, edge_attr=\"thickness\", rc_order=[0, 1, 2])\n>>> M.toarray()\narray([[0., 1., 2.],\n       [1., 0., 3.],\n       [2., 3., 0.]])\n\nWe can also color the nodes and ask for the probability distribution over\nall edges (u,v) describing:\n\n    Pr(v has color Y | u has color X)\n\n>>> G.nodes[0][\"color\"] = \"red\"\n>>> G.nodes[1][\"color\"] = \"red\"\n>>> G.nodes[2][\"color\"] = \"blue\"\n>>> rc = [\"red\", \"blue\"]\n>>> M = nx.attr_sparse_matrix(G, node_attr=\"color\", normalized=True, rc_order=rc)\n>>> M.toarray()\narray([[0.33333333, 0.66666667],\n       [1.        , 0.        ]])\n\nFor example, the above tells us that for all edges (u,v):\n\n    Pr( v is red  | u is red)  = 1/3\n    Pr( v is blue | u is red)  = 2/3\n\n    Pr( v is red  | u is blue) = 1\n    Pr( v is blue | u is blue) = 0\n\nFinally, we can obtain the total weights listed by the node colors.\n\n>>> M = nx.attr_sparse_matrix(G, edge_attr=\"weight\", node_attr=\"color\", rc_order=rc)\n>>> M.toarray()\narray([[3., 2.],\n       [2., 0.]])\n\nThus, the total weight over all edges (u,v) with u and v having colors:\n\n    (red, red)   is 3   # the sole contribution is from edge (0,1)\n    (red, blue)  is 2   # contributions from edges (0,2) and (1,2)\n    (blue, red)  is 2   # same as (red, blue) since graph is undirected\n    (blue, blue) is 0   # there are no edges with blue endpoints"}, {"type": "function", "name": "networkx.attracting_components", "documentation": "Generates the attracting components in `G`.\n\nAn attracting component in a directed graph `G` is a strongly connected\ncomponent with the property that a random walker on the graph will never\nleave the component, once it enters the component.\n\nThe nodes in attracting components can also be thought of as recurrent\nnodes.  If a random walker enters the attractor containing the node, then\nthe node will be visited infinitely often.\n\nTo obtain induced subgraphs on each component use:\n``(G.subgraph(c).copy() for c in attracting_components(G))``\n\nParameters\n----------\nG : DiGraph, MultiDiGraph\n    The graph to be analyzed.\n\nReturns\n-------\nattractors : generator of sets\n    A generator of sets of nodes, one for each attracting component of G.\n\nRaises\n------\nNetworkXNotImplemented\n    If the input graph is undirected.\n\nSee Also\n--------\nnumber_attracting_components\nis_attracting_component"}, {"type": "function", "name": "networkx.attribute_assortativity_coefficient", "documentation": "Compute assortativity for node attributes.\n\nAssortativity measures the similarity of connections\nin the graph with respect to the given attribute.\n\nParameters\n----------\nG : NetworkX graph\n\nattribute : string\n    Node attribute key\n\nnodes: list or iterable (optional)\n    Compute attribute assortativity for nodes in container.\n    The default is all nodes.\n\nReturns\n-------\nr: float\n   Assortativity of graph for given attribute\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_nodes_from([0, 1], color=\"red\")\n>>> G.add_nodes_from([2, 3], color=\"blue\")\n>>> G.add_edges_from([(0, 1), (2, 3)])\n>>> print(nx.attribute_assortativity_coefficient(G, \"color\"))\n1.0\n\nNotes\n-----\nThis computes Eq. (2) in Ref. [1]_ , (trace(M)-sum(M^2))/(1-sum(M^2)),\nwhere M is the joint probability distribution (mixing matrix)\nof the specified attribute.\n\nReferences\n----------\n.. [1] M. E. J. Newman, Mixing patterns in networks,\n   Physical Review E, 67 026126, 2003"}, {"type": "function", "name": "networkx.attribute_mixing_dict", "documentation": "Returns dictionary representation of mixing matrix for attribute.\n\nParameters\n----------\nG : graph\n   NetworkX graph object.\n\nattribute : string\n   Node attribute key.\n\nnodes: list or iterable (optional)\n    Unse nodes in container to build the dict. The default is all nodes.\n\nnormalized : bool (default=False)\n   Return counts if False or probabilities if True.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_nodes_from([0, 1], color=\"red\")\n>>> G.add_nodes_from([2, 3], color=\"blue\")\n>>> G.add_edge(1, 3)\n>>> d = nx.attribute_mixing_dict(G, \"color\")\n>>> print(d[\"red\"][\"blue\"])\n1\n>>> print(d[\"blue\"][\"red\"])  # d symmetric for undirected graphs\n1\n\nReturns\n-------\nd : dictionary\n   Counts or joint probability of occurrence of attribute pairs."}, {"type": "function", "name": "networkx.attribute_mixing_matrix", "documentation": "Returns mixing matrix for attribute.\n\nParameters\n----------\nG : graph\n   NetworkX graph object.\n\nattribute : string\n   Node attribute key.\n\nnodes: list or iterable (optional)\n    Use only nodes in container to build the matrix. The default is\n    all nodes.\n\nmapping : dictionary, optional\n   Mapping from node attribute to integer index in matrix.\n   If not specified, an arbitrary ordering will be used.\n\nnormalized : bool (default=True)\n   Return counts if False or probabilities if True.\n\nReturns\n-------\nm: numpy array\n   Counts or joint probability of occurrence of attribute pairs.\n\nNotes\n-----\nIf each node has a unique attribute value, the unnormalized mixing matrix\nwill be equal to the adjacency matrix. To get a denser mixing matrix,\nthe rounding can be performed to form groups of nodes with equal values.\nFor example, the exact height of persons in cm (180.79155222, 163.9080892,\n163.30095355, 167.99016217, 168.21590163, ...) can be rounded to (180, 163,\n163, 168, 168, ...).\n\nDefinitions of attribute mixing matrix vary on whether the matrix\nshould include rows for attribute values that don't arise. Here we\ndo not include such empty-rows. But you can force them to appear\nby inputting a `mapping` that includes those values.\n\nExamples\n--------\n>>> G = nx.path_graph(3)\n>>> gender = {0: \"male\", 1: \"female\", 2: \"female\"}\n>>> nx.set_node_attributes(G, gender, \"gender\")\n>>> mapping = {\"male\": 0, \"female\": 1}\n>>> mix_mat = nx.attribute_mixing_matrix(G, \"gender\", mapping=mapping)\n>>> mix_mat\narray([[0.  , 0.25],\n       [0.25, 0.5 ]])"}, {"type": "function", "name": "networkx.average_clustering", "documentation": "Compute the average clustering coefficient for the graph G.\n\nThe clustering coefficient for the graph is the average,\n\n.. math::\n\n   C = \\frac{1}{n}\\sum_{v \\in G} c_v,\n\nwhere :math:`n` is the number of nodes in `G`.\n\nParameters\n----------\nG : graph\n\nnodes : container of nodes, optional (default=all nodes in G)\n   Compute average clustering for nodes in this container.\n\nweight : string or None, optional (default=None)\n   The edge attribute that holds the numerical value used as a weight.\n   If None, then each edge has weight 1.\n\ncount_zeros : bool\n   If False include only the nodes with nonzero clustering in the average.\n\nReturns\n-------\navg : float\n   Average clustering\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> print(nx.average_clustering(G))\n1.0\n\nNotes\n-----\nThis is a space saving routine; it might be faster\nto use the clustering function to get a list and then take the average.\n\nSelf loops are ignored.\n\nReferences\n----------\n.. [1] Generalizations of the clustering coefficient to weighted\n   complex networks by J. Saram\u00e4ki, M. Kivel\u00e4, J.-P. Onnela,\n   K. Kaski, and J. Kert\u00e9sz, Physical Review E, 75 027105 (2007).\n   http://jponnela.com/web_documents/a9.pdf\n.. [2] Marcus Kaiser,  Mean clustering coefficients: the role of isolated\n   nodes and leafs on clustering measures for small-world networks.\n   https://arxiv.org/abs/0802.2512"}, {"type": "function", "name": "networkx.average_degree_connectivity", "documentation": "Compute the average degree connectivity of graph.\n\nThe average degree connectivity is the average nearest neighbor degree of\nnodes with degree k. For weighted graphs, an analogous measure can\nbe computed using the weighted average neighbors degree defined in\n[1]_, for a node `i`, as\n\n.. math::\n\n    k_{nn,i}^{w} = \\frac{1}{s_i} \\sum_{j \\in N(i)} w_{ij} k_j\n\nwhere `s_i` is the weighted degree of node `i`,\n`w_{ij}` is the weight of the edge that links `i` and `j`,\nand `N(i)` are the neighbors of node `i`.\n\nParameters\n----------\nG : NetworkX graph\n\nsource :  \"in\"|\"out\"|\"in+out\" (default:\"in+out\")\n   Directed graphs only. Use \"in\"- or \"out\"-degree for source node.\n\ntarget : \"in\"|\"out\"|\"in+out\" (default:\"in+out\"\n   Directed graphs only. Use \"in\"- or \"out\"-degree for target node.\n\nnodes : list or iterable (optional)\n    Compute neighbor connectivity for these nodes. The default is all\n    nodes.\n\nweight : string or None, optional (default=None)\n   The edge attribute that holds the numerical value used as a weight.\n   If None, then each edge has weight 1.\n\nReturns\n-------\nd : dict\n   A dictionary keyed by degree k with the value of average connectivity.\n\nRaises\n------\nNetworkXError\n    If either `source` or `target` are not one of 'in',\n    'out', or 'in+out'.\n    If either `source` or `target` is passed for an undirected graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> G.edges[1, 2][\"weight\"] = 3\n>>> nx.average_degree_connectivity(G)\n{1: 2.0, 2: 1.5}\n>>> nx.average_degree_connectivity(G, weight=\"weight\")\n{1: 2.0, 2: 1.75}\n\nSee Also\n--------\naverage_neighbor_degree\n\nReferences\n----------\n.. [1] A. Barrat, M. Barth\u00e9lemy, R. Pastor-Satorras, and A. Vespignani,\n   \"The architecture of complex weighted networks\".\n   PNAS 101 (11): 3747\u20133752 (2004)."}, {"type": "function", "name": "networkx.average_neighbor_degree", "documentation": "Returns the average degree of the neighborhood of each node.\n\nIn an undirected graph, the neighborhood `N(i)` of node `i` contains the\nnodes that are connected to `i` by an edge.\n\nFor directed graphs, `N(i)` is defined according to the parameter `source`:\n\n    - if source is 'in', then `N(i)` consists of predecessors of node `i`.\n    - if source is 'out', then `N(i)` consists of successors of node `i`.\n    - if source is 'in+out', then `N(i)` is both predecessors and successors.\n\nThe average neighborhood degree of a node `i` is\n\n.. math::\n\n    k_{nn,i} = \\frac{1}{|N(i)|} \\sum_{j \\in N(i)} k_j\n\nwhere `N(i)` are the neighbors of node `i` and `k_j` is\nthe degree of node `j` which belongs to `N(i)`. For weighted\ngraphs, an analogous measure can be defined [1]_,\n\n.. math::\n\n    k_{nn,i}^{w} = \\frac{1}{s_i} \\sum_{j \\in N(i)} w_{ij} k_j\n\nwhere `s_i` is the weighted degree of node `i`, `w_{ij}`\nis the weight of the edge that links `i` and `j` and\n`N(i)` are the neighbors of node `i`.\n\n\nParameters\n----------\nG : NetworkX graph\n\nsource : string (\"in\"|\"out\"|\"in+out\"), optional (default=\"out\")\n   Directed graphs only.\n   Use \"in\"- or \"out\"-neighbors of source node.\n\ntarget : string (\"in\"|\"out\"|\"in+out\"), optional (default=\"out\")\n   Directed graphs only.\n   Use \"in\"- or \"out\"-degree for target node.\n\nnodes : list or iterable, optional (default=G.nodes)\n    Compute neighbor degree only for specified nodes.\n\nweight : string or None, optional (default=None)\n   The edge attribute that holds the numerical value used as a weight.\n   If None, then each edge has weight 1.\n\nReturns\n-------\nd: dict\n   A dictionary keyed by node to the average degree of its neighbors.\n\nRaises\n------\nNetworkXError\n    If either `source` or `target` are not one of 'in', 'out', or 'in+out'.\n    If either `source` or `target` is passed for an undirected graph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> G.edges[0, 1][\"weight\"] = 5\n>>> G.edges[2, 3][\"weight\"] = 3\n\n>>> nx.average_neighbor_degree(G)\n{0: 2.0, 1: 1.5, 2: 1.5, 3: 2.0}\n>>> nx.average_neighbor_degree(G, weight=\"weight\")\n{0: 2.0, 1: 1.1666666666666667, 2: 1.25, 3: 2.0}\n\n>>> G = nx.DiGraph()\n>>> nx.add_path(G, [0, 1, 2, 3])\n>>> nx.average_neighbor_degree(G, source=\"in\", target=\"in\")\n{0: 0.0, 1: 0.0, 2: 1.0, 3: 1.0}\n\n>>> nx.average_neighbor_degree(G, source=\"out\", target=\"out\")\n{0: 1.0, 1: 1.0, 2: 0.0, 3: 0.0}\n\nSee Also\n--------\naverage_degree_connectivity\n\nReferences\n----------\n.. [1] A. Barrat, M. Barth\u00e9lemy, R. Pastor-Satorras, and A. Vespignani,\n   \"The architecture of complex weighted networks\".\n   PNAS 101 (11): 3747\u20133752 (2004)."}, {"type": "function", "name": "networkx.average_node_connectivity", "documentation": "Returns the average connectivity of a graph G.\n\nThe average connectivity `\\bar{\\kappa}` of a graph G is the average\nof local node connectivity over all pairs of nodes of G [1]_ .\n\n.. math::\n\n    \\bar{\\kappa}(G) = \\frac{\\sum_{u,v} \\kappa_{G}(u,v)}{{n \\choose 2}}\n\nParameters\n----------\n\nG : NetworkX graph\n    Undirected graph\n\nflow_func : function\n    A function for computing the maximum flow among a pair of nodes.\n    The function has to accept at least three parameters: a Digraph,\n    a source node, and a target node. And return a residual network\n    that follows NetworkX conventions (see :meth:`maximum_flow` for\n    details). If flow_func is None, the default maximum flow function\n    (:meth:`edmonds_karp`) is used. See :meth:`local_node_connectivity`\n    for details. The choice of the default function may change from\n    version to version and should not be relied on. Default value: None.\n\nReturns\n-------\nK : float\n    Average node connectivity\n\nSee also\n--------\n:meth:`local_node_connectivity`\n:meth:`node_connectivity`\n:meth:`edge_connectivity`\n:meth:`maximum_flow`\n:meth:`edmonds_karp`\n:meth:`preflow_push`\n:meth:`shortest_augmenting_path`\n\nReferences\n----------\n.. [1]  Beineke, L., O. Oellermann, and R. Pippert (2002). The average\n        connectivity of a graph. Discrete mathematics 252(1-3), 31-45.\n        http://www.sciencedirect.com/science/article/pii/S0012365X01001807"}, {"type": "function", "name": "networkx.average_shortest_path_length", "documentation": "Returns the average shortest path length.\n\nThe average shortest path length is\n\n.. math::\n\n   a =\\sum_{\\substack{s,t \\in V \\\\ s\\neq t}} \\frac{d(s, t)}{n(n-1)}\n\nwhere `V` is the set of nodes in `G`,\n`d(s, t)` is the shortest path from `s` to `t`,\nand `n` is the number of nodes in `G`.\n\n.. versionchanged:: 3.0\n   An exception is raised for directed graphs that are not strongly\n   connected.\n\nParameters\n----------\nG : NetworkX graph\n\nweight : None, string or function, optional (default = None)\n    If None, every edge has weight/distance/cost 1.\n    If a string, use this edge attribute as the edge weight.\n    Any edge attribute not present defaults to 1.\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly\n    three positional arguments: the two endpoints of an edge and\n    the dictionary of edge attributes for that edge.\n    The function must return a number.\n\nmethod : string, optional (default = 'unweighted' or 'dijkstra')\n    The algorithm to use to compute the path lengths.\n    Supported options are 'unweighted', 'dijkstra', 'bellman-ford',\n    'floyd-warshall' and 'floyd-warshall-numpy'.\n    Other method values produce a ValueError.\n    The default method is 'unweighted' if `weight` is None,\n    otherwise the default method is 'dijkstra'.\n\nRaises\n------\nNetworkXPointlessConcept\n    If `G` is the null graph (that is, the graph on zero nodes).\n\nNetworkXError\n    If `G` is not connected (or not strongly connected, in the case\n    of a directed graph).\n\nValueError\n    If `method` is not among the supported options.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> nx.average_shortest_path_length(G)\n2.0\n\nFor disconnected graphs, you can compute the average shortest path\nlength for each component\n\n>>> G = nx.Graph([(1, 2), (3, 4)])\n>>> for C in (G.subgraph(c).copy() for c in nx.connected_components(G)):\n...     print(nx.average_shortest_path_length(C))\n1.0\n1.0"}, {"type": "function", "name": "networkx.balanced_tree", "documentation": "Returns the perfectly balanced `r`-ary tree of height `h`.\n\n.. plot::\n\n    >>> nx.draw(nx.balanced_tree(2, 3))\n\nParameters\n----------\nr : int\n    Branching factor of the tree; each node will have `r`\n    children.\n\nh : int\n    Height of the tree.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : NetworkX graph\n    A balanced `r`-ary tree of height `h`.\n\nNotes\n-----\nThis is the rooted tree where all leaves are at distance `h` from\nthe root. The root has degree `r` and all other internal nodes\nhave degree `r + 1`.\n\nNode labels are integers, starting from zero.\n\nA balanced tree is also known as a *complete r-ary tree*."}, {"type": "function", "name": "networkx.barabasi_albert_graph", "documentation": "Returns a random graph using Barab\u00e1si\u2013Albert preferential attachment\n\nA graph of $n$ nodes is grown by attaching new nodes each with $m$\nedges that are preferentially attached to existing nodes with high degree.\n\nParameters\n----------\nn : int\n    Number of nodes\nm : int\n    Number of edges to attach from a new node to existing nodes\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ninitial_graph : Graph or None (default)\n    Initial network for Barab\u00e1si\u2013Albert algorithm.\n    It should be a connected graph for most use cases.\n    A copy of `initial_graph` is used.\n    If None, starts from a star graph on (m+1) nodes.\n\nReturns\n-------\nG : Graph\n\nRaises\n------\nNetworkXError\n    If `m` does not satisfy ``1 <= m < n``, or\n    the initial graph number of nodes m0 does not satisfy ``m <= m0 <= n``.\n\nReferences\n----------\n.. [1] A. L. Barab\u00e1si and R. Albert \"Emergence of scaling in\n   random networks\", Science 286, pp 509-512, 1999."}, {"type": "function", "name": "networkx.barbell_graph", "documentation": "Returns the Barbell Graph: two complete graphs connected by a path.\n\n.. plot::\n\n    >>> nx.draw(nx.barbell_graph(4, 2))\n\nParameters\n----------\nm1 : int\n    Size of the left and right barbells, must be greater than 2.\n\nm2 : int\n    Length of the path connecting the barbells.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n   Only undirected Graphs are supported.\n\nReturns\n-------\nG : NetworkX graph\n    A barbell graph.\n\nNotes\n-----\n\n\nTwo identical complete graphs $K_{m1}$ form the left and right bells,\nand are connected by a path $P_{m2}$.\n\nThe `2*m1+m2`  nodes are numbered\n    `0, ..., m1-1` for the left barbell,\n    `m1, ..., m1+m2-1` for the path,\n    and `m1+m2, ..., 2*m1+m2-1` for the right barbell.\n\nThe 3 subgraphs are joined via the edges `(m1-1, m1)` and\n`(m1+m2-1, m1+m2)`. If `m2=0`, this is merely two complete\ngraphs joined together.\n\nThis graph is an extremal example in David Aldous\nand Jim Fill's e-text on Random Walks on Graphs."}, {"type": "function", "name": "networkx.barycenter", "documentation": "Calculate barycenter of a connected graph, optionally with edge weights.\n\nThe :dfn:`barycenter` a\n:func:`connected <networkx.algorithms.components.is_connected>` graph\n:math:`G` is the subgraph induced by the set of its nodes :math:`v`\nminimizing the objective function\n\n.. math::\n\n    \\sum_{u \\in V(G)} d_G(u, v),\n\nwhere :math:`d_G` is the (possibly weighted) :func:`path length\n<networkx.algorithms.shortest_paths.generic.shortest_path_length>`.\nThe barycenter is also called the :dfn:`median`. See [West01]_, p. 78.\n\nParameters\n----------\nG : :class:`networkx.Graph`\n    The connected graph :math:`G`.\nweight : :class:`str`, optional\n    Passed through to\n    :func:`~networkx.algorithms.shortest_paths.generic.shortest_path_length`.\nattr : :class:`str`, optional\n    If given, write the value of the objective function to each node's\n    `attr` attribute. Otherwise do not store the value.\nsp : dict of dicts, optional\n   All pairs shortest path lengths as a dictionary of dictionaries\n\nReturns\n-------\nlist\n    Nodes of `G` that induce the barycenter of `G`.\n\nRaises\n------\nNetworkXNoPath\n    If `G` is disconnected. `G` may appear disconnected to\n    :func:`barycenter` if `sp` is given but is missing shortest path\n    lengths for any pairs.\nValueError\n    If `sp` and `weight` are both given.\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (1, 4), (3, 4), (3, 5), (4, 5)])\n>>> nx.barycenter(G)\n[1, 3, 4]\n\nSee Also\n--------\ncenter\nperiphery"}, {"type": "function", "name": "networkx.bellman_ford_path", "documentation": "Returns the shortest path from source to target in a weighted graph G.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n    Starting node\n\ntarget : node\n    Ending node\n\nweight : string or function (default=\"weight\")\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\nReturns\n-------\npath : list\n    List of nodes in a shortest path.\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nNetworkXNoPath\n    If no path exists between source and target.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> nx.bellman_ford_path(G, 0, 4)\n[0, 1, 2, 3, 4]\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nSee Also\n--------\ndijkstra_path, bellman_ford_path_length"}, {"type": "function", "name": "networkx.bellman_ford_path_length", "documentation": "Returns the shortest path length from source to target\nin a weighted graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node label\n    starting node for path\n\ntarget : node label\n    ending node for path\n\nweight : string or function (default=\"weight\")\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\nReturns\n-------\nlength : number\n    Shortest path length.\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nNetworkXNoPath\n    If no path exists between source and target.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> nx.bellman_ford_path_length(G, 0, 4)\n4\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nSee Also\n--------\ndijkstra_path_length, bellman_ford_path"}, {"type": "function", "name": "networkx.bellman_ford_predecessor_and_distance", "documentation": "Compute shortest path lengths and predecessors on shortest paths\nin weighted graphs.\n\nThe algorithm has a running time of $O(mn)$ where $n$ is the number of\nnodes and $m$ is the number of edges.  It is slower than Dijkstra but\ncan handle negative edge weights.\n\nIf a negative cycle is detected, you can use :func:`find_negative_cycle`\nto return the cycle and examine it. Shortest paths are not defined when\na negative cycle exists because once reached, the path can cycle forever\nto build up arbitrarily low weights.\n\nParameters\n----------\nG : NetworkX graph\n    The algorithm works for all types of graphs, including directed\n    graphs and multigraphs.\n\nsource: node label\n    Starting node for path\n\ntarget : node label, optional\n    Ending node for path\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\nheuristic : bool\n    Determines whether to use a heuristic to early detect negative\n    cycles at a hopefully negligible cost.\n\nReturns\n-------\npred, dist : dictionaries\n    Returns two dictionaries keyed by node to predecessor in the\n    path and to the distance from the source respectively.\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nNetworkXUnbounded\n    If the (di)graph contains a negative (di)cycle, the\n    algorithm raises an exception to indicate the presence of the\n    negative (di)cycle.  Note: any negative weight edge in an\n    undirected graph is a negative cycle.\n\nExamples\n--------\n>>> G = nx.path_graph(5, create_using=nx.DiGraph())\n>>> pred, dist = nx.bellman_ford_predecessor_and_distance(G, 0)\n>>> sorted(pred.items())\n[(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]\n>>> sorted(dist.items())\n[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\n\n>>> pred, dist = nx.bellman_ford_predecessor_and_distance(G, 0, 1)\n>>> sorted(pred.items())\n[(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]\n>>> sorted(dist.items())\n[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\n\n>>> G = nx.cycle_graph(5, create_using=nx.DiGraph())\n>>> G[1][2][\"weight\"] = -7\n>>> nx.bellman_ford_predecessor_and_distance(G, 0)\nTraceback (most recent call last):\n    ...\nnetworkx.exception.NetworkXUnbounded: Negative cycle detected.\n\nSee Also\n--------\nfind_negative_cycle\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe dictionaries returned only have keys for nodes reachable from\nthe source.\n\nIn the case where the (di)graph is not connected, if a component\nnot containing the source contains a negative (di)cycle, it\nwill not be detected.\n\nIn NetworkX v2.1 and prior, the source node had predecessor `[None]`.\nIn NetworkX v2.2 this changed to the source node having predecessor `[]`"}, {"type": "function", "name": "networkx.bethe_hessian_matrix", "documentation": "Returns the Bethe Hessian matrix of G.\n\nThe Bethe Hessian is a family of matrices parametrized by r, defined as\nH(r) = (r^2 - 1) I - r A + D where A is the adjacency matrix, D is the\ndiagonal matrix of node degrees, and I is the identify matrix. It is equal\nto the graph laplacian when the regularizer r = 1.\n\nThe default choice of regularizer should be the ratio [2]_\n\n.. math::\n  r_m = \\left(\\sum k_i \\right)^{-1}\\left(\\sum k_i^2 \\right) - 1\n\nParameters\n----------\nG : Graph\n   A NetworkX graph\nr : float\n   Regularizer parameter\nnodelist : list, optional\n   The rows and columns are ordered according to the nodes in nodelist.\n   If nodelist is None, then the ordering is produced by ``G.nodes()``.\n\nReturns\n-------\nH : scipy.sparse.csr_array\n  The Bethe Hessian matrix of `G`, with parameter `r`.\n\nExamples\n--------\n>>> k = [3, 2, 2, 1, 0]\n>>> G = nx.havel_hakimi_graph(k)\n>>> H = nx.bethe_hessian_matrix(G)\n>>> H.toarray()\narray([[ 3.5625, -1.25  , -1.25  , -1.25  ,  0.    ],\n       [-1.25  ,  2.5625, -1.25  ,  0.    ,  0.    ],\n       [-1.25  , -1.25  ,  2.5625,  0.    ,  0.    ],\n       [-1.25  ,  0.    ,  0.    ,  1.5625,  0.    ],\n       [ 0.    ,  0.    ,  0.    ,  0.    ,  0.5625]])\n\nSee Also\n--------\nbethe_hessian_spectrum\nadjacency_matrix\nlaplacian_matrix\n\nReferences\n----------\n.. [1] A. Saade, F. Krzakala and L. Zdeborov\u00e1\n   \"Spectral Clustering of Graphs with the Bethe Hessian\",\n   Advances in Neural Information Processing Systems, 2014.\n.. [2] C. M. Le, E. Levina\n   \"Estimating the number of communities in networks by spectral methods\"\n   arXiv:1507.00827, 2015."}, {"type": "function", "name": "networkx.bethe_hessian_spectrum", "documentation": "Returns eigenvalues of the Bethe Hessian matrix of G.\n\nParameters\n----------\nG : Graph\n   A NetworkX Graph or DiGraph\n\nr : float\n   Regularizer parameter\n\nReturns\n-------\nevals : NumPy array\n  Eigenvalues\n\nSee Also\n--------\nbethe_hessian_matrix\n\nReferences\n----------\n.. [1] A. Saade, F. Krzakala and L. Zdeborov\u00e1\n   \"Spectral clustering of graphs with the bethe hessian\",\n   Advances in Neural Information Processing Systems. 2014."}, {"type": "function", "name": "networkx.betweenness_centrality", "documentation": "Compute the shortest-path betweenness centrality for nodes.\n\nBetweenness centrality of a node $v$ is the sum of the\nfraction of all-pairs shortest paths that pass through $v$\n\n.. math::\n\n   c_B(v) =\\sum_{s,t \\in V} \\frac{\\sigma(s, t|v)}{\\sigma(s, t)}\n\nwhere $V$ is the set of nodes, $\\sigma(s, t)$ is the number of\nshortest $(s, t)$-paths,  and $\\sigma(s, t|v)$ is the number of\nthose paths  passing through some  node $v$ other than $s, t$.\nIf $s = t$, $\\sigma(s, t) = 1$, and if $v \\in {s, t}$,\n$\\sigma(s, t|v) = 0$ [2]_.\n\nParameters\n----------\nG : graph\n  A NetworkX graph.\n\nk : int, optional (default=None)\n  If k is not None use k node samples to estimate betweenness.\n  The value of k <= n where n is the number of nodes in the graph.\n  Higher values give better approximation.\n\nnormalized : bool, optional\n  If True the betweenness values are normalized by `2/((n-1)(n-2))`\n  for graphs, and `1/((n-1)(n-2))` for directed graphs where `n`\n  is the number of nodes in G.\n\nweight : None or string, optional (default=None)\n  If None, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n  Weights are used to calculate weighted shortest paths, so they are\n  interpreted as distances.\n\nendpoints : bool, optional\n  If True include the endpoints in the shortest path counts.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n    Note that this is only used if k is not None.\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with betweenness centrality as the value.\n\nSee Also\n--------\nedge_betweenness_centrality\nload_centrality\n\nNotes\n-----\nThe algorithm is from Ulrik Brandes [1]_.\nSee [4]_ for the original first published version and [2]_ for details on\nalgorithms for variations and related metrics.\n\nFor approximate betweenness calculations set k=#samples to use\nk nodes (\"pivots\") to estimate the betweenness values. For an estimate\nof the number of pivots needed see [3]_.\n\nFor weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\n\nThe total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nare easy to count. Undirected paths are tricky: should a path\nfrom \"u\" to \"v\" count as 1 undirected path or as 2 directed paths?\n\nFor betweenness_centrality we report the number of undirected\npaths when G is undirected.\n\nFor betweenness_centrality_subset the reporting is different.\nIf the source and target subsets are the same, then we want\nto count undirected paths. But if the source and target subsets\ndiffer -- for example, if sources is {0} and targets is {1},\nthen we are only counting the paths in one direction. They are\nundirected paths but we are counting them in a directed way.\nTo count them as undirected paths, each should count as half a path.\n\nThis algorithm is not guaranteed to be correct if edge weights\nare floating point numbers. As a workaround you can use integer\nnumbers by multiplying the relevant edge attributes by a convenient\nconstant factor (eg 100) and converting to integers.\n\nReferences\n----------\n.. [1] Ulrik Brandes:\n   A Faster Algorithm for Betweenness Centrality.\n   Journal of Mathematical Sociology 25(2):163-177, 2001.\n   https://doi.org/10.1080/0022250X.2001.9990249\n.. [2] Ulrik Brandes:\n   On Variants of Shortest-Path Betweenness\n   Centrality and their Generic Computation.\n   Social Networks 30(2):136-145, 2008.\n   https://doi.org/10.1016/j.socnet.2007.11.001\n.. [3] Ulrik Brandes and Christian Pich:\n   Centrality Estimation in Large Networks.\n   International Journal of Bifurcation and Chaos 17(7):2303-2318, 2007.\n   https://dx.doi.org/10.1142/S0218127407018403\n.. [4] Linton C. Freeman:\n   A set of measures of centrality based on betweenness.\n   Sociometry 40: 35\u201341, 1977\n   https://doi.org/10.2307/3033543"}, {"type": "function", "name": "networkx.betweenness_centrality_subset", "documentation": "Compute betweenness centrality for a subset of nodes.\n\n.. math::\n\n   c_B(v) =\\sum_{s\\in S, t \\in T} \\frac{\\sigma(s, t|v)}{\\sigma(s, t)}\n\nwhere $S$ is the set of sources, $T$ is the set of targets,\n$\\sigma(s, t)$ is the number of shortest $(s, t)$-paths,\nand $\\sigma(s, t|v)$ is the number of those paths\npassing through some  node $v$ other than $s, t$.\nIf $s = t$, $\\sigma(s, t) = 1$,\nand if $v \\in {s, t}$, $\\sigma(s, t|v) = 0$ [2]_.\n\n\nParameters\n----------\nG : graph\n  A NetworkX graph.\n\nsources: list of nodes\n  Nodes to use as sources for shortest paths in betweenness\n\ntargets: list of nodes\n  Nodes to use as targets for shortest paths in betweenness\n\nnormalized : bool, optional\n  If True the betweenness values are normalized by $2/((n-1)(n-2))$\n  for graphs, and $1/((n-1)(n-2))$ for directed graphs where $n$\n  is the number of nodes in G.\n\nweight : None or string, optional (default=None)\n  If None, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n  Weights are used to calculate weighted shortest paths, so they are\n  interpreted as distances.\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with betweenness centrality as the value.\n\nSee Also\n--------\nedge_betweenness_centrality\nload_centrality\n\nNotes\n-----\nThe basic algorithm is from [1]_.\n\nFor weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\n\nThe normalization might seem a little strange but it is\ndesigned to make betweenness_centrality(G) be the same as\nbetweenness_centrality_subset(G,sources=G.nodes(),targets=G.nodes()).\n\nThe total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nare easy to count. Undirected paths are tricky: should a path\nfrom \"u\" to \"v\" count as 1 undirected path or as 2 directed paths?\n\nFor betweenness_centrality we report the number of undirected\npaths when G is undirected.\n\nFor betweenness_centrality_subset the reporting is different.\nIf the source and target subsets are the same, then we want\nto count undirected paths. But if the source and target subsets\ndiffer -- for example, if sources is {0} and targets is {1},\nthen we are only counting the paths in one direction. They are\nundirected paths but we are counting them in a directed way.\nTo count them as undirected paths, each should count as half a path.\n\nReferences\n----------\n.. [1] Ulrik Brandes, A Faster Algorithm for Betweenness Centrality.\n   Journal of Mathematical Sociology 25(2):163-177, 2001.\n   https://doi.org/10.1080/0022250X.2001.9990249\n.. [2] Ulrik Brandes: On Variants of Shortest-Path Betweenness\n   Centrality and their Generic Computation.\n   Social Networks 30(2):136-145, 2008.\n   https://doi.org/10.1016/j.socnet.2007.11.001"}, {"type": "function", "name": "networkx.bfs_beam_edges", "documentation": "Iterates over edges in a beam search.\n\nThe beam search is a generalized breadth-first search in which only\nthe \"best\" *w* neighbors of the current node are enqueued, where *w*\nis the beam width and \"best\" is an application-specific\nheuristic. In general, a beam search with a small beam width might\nnot visit each node in the graph.\n\n.. note::\n\n   With the default value of ``width=None`` or `width` greater than the\n   maximum degree of the graph, this function equates to a slower\n   version of `~networkx.algorithms.traversal.breadth_first_search.bfs_edges`.\n   All nodes will be visited, though the order of the reported edges may\n   vary. In such cases, `value` has no effect - consider using `bfs_edges`\n   directly instead.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n    Starting node for the breadth-first search; this function\n    iterates over only those edges in the component reachable from\n    this node.\n\nvalue : function\n    A function that takes a node of the graph as input and returns a\n    real number indicating how \"good\" it is. A higher value means it\n    is more likely to be visited sooner during the search. When\n    visiting a new node, only the `width` neighbors with the highest\n    `value` are enqueued (in decreasing order of `value`).\n\nwidth : int (default = None)\n    The beam width for the search. This is the number of neighbors\n    (ordered by `value`) to enqueue when visiting each new node.\n\nYields\n------\nedge\n    Edges in the beam search starting from `source`, given as a pair\n    of nodes.\n\nExamples\n--------\nTo give nodes with, for example, a higher centrality precedence\nduring the search, set the `value` function to return the centrality\nvalue of the node:\n\n>>> G = nx.karate_club_graph()\n>>> centrality = nx.eigenvector_centrality(G)\n>>> list(nx.bfs_beam_edges(G, source=0, value=centrality.get, width=3))\n[(0, 2), (0, 1), (0, 8), (2, 32), (1, 13), (8, 33)]"}, {"type": "function", "name": "networkx.bfs_edges", "documentation": "Iterate over edges in a breadth-first-search starting at source.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n   Specify starting node for breadth-first search; this function\n   iterates over only those edges in the component reachable from\n   this node.\n\nreverse : bool, optional\n   If True traverse a directed graph in the reverse direction\n\ndepth_limit : int, optional(default=len(G))\n    Specify the maximum search depth\n\nsort_neighbors : function (default=None)\n    A function that takes an iterator over nodes as the input, and\n    returns an iterable of the same nodes with a custom ordering.\n    For example, `sorted` will sort the nodes in increasing order.\n\nYields\n------\nedge: 2-tuple of nodes\n   Yields edges resulting from the breadth-first search.\n\nExamples\n--------\nTo get the edges in a breadth-first search::\n\n    >>> G = nx.path_graph(3)\n    >>> list(nx.bfs_edges(G, 0))\n    [(0, 1), (1, 2)]\n    >>> list(nx.bfs_edges(G, source=0, depth_limit=1))\n    [(0, 1)]\n\nTo get the nodes in a breadth-first search order::\n\n    >>> G = nx.path_graph(3)\n    >>> root = 2\n    >>> edges = nx.bfs_edges(G, root)\n    >>> nodes = [root] + [v for u, v in edges]\n    >>> nodes\n    [2, 1, 0]\n\nNotes\n-----\nThe naming of this function is very similar to\n:func:`~networkx.algorithms.traversal.edgebfs.edge_bfs`. The difference\nis that ``edge_bfs`` yields edges even if they extend back to an already\nexplored node while this generator yields the edges of the tree that results\nfrom a breadth-first-search (BFS) so no edges are reported if they extend\nto already explored nodes. That means ``edge_bfs`` reports all edges while\n``bfs_edges`` only reports those traversed by a node-based BFS. Yet another\ndescription is that ``bfs_edges`` reports the edges traversed during BFS\nwhile ``edge_bfs`` reports all edges in the order they are explored.\n\nBased on the breadth-first search implementation in PADS [1]_\nby D. Eppstein, July 2004; with modifications to allow depth limits\nas described in [2]_.\n\nReferences\n----------\n.. [1] http://www.ics.uci.edu/~eppstein/PADS/BFS.py.\n.. [2] https://en.wikipedia.org/wiki/Depth-limited_search\n\nSee Also\n--------\nbfs_tree\n:func:`~networkx.algorithms.traversal.depth_first_search.dfs_edges`\n:func:`~networkx.algorithms.traversal.edgebfs.edge_bfs`"}, {"type": "function", "name": "networkx.bfs_labeled_edges", "documentation": "Iterate over edges in a breadth-first search (BFS) labeled by type.\n\nWe generate triple of the form (*u*, *v*, *d*), where (*u*, *v*) is the\nedge being explored in the breadth-first search and *d* is one of the\nstrings 'tree', 'forward', 'level', or 'reverse'.  A 'tree' edge is one in\nwhich *v* is first discovered and placed into the layer below *u*.  A\n'forward' edge is one in which *u* is on the layer above *v* and *v* has\nalready been discovered.  A 'level' edge is one in which both *u* and *v*\noccur on the same layer.  A 'reverse' edge is one in which *u* is on a layer\nbelow *v*.\n\nWe emit each edge exactly once.  In an undirected graph, 'reverse' edges do\nnot occur, because each is discovered either as a 'tree' or 'forward' edge.\n\nParameters\n----------\nG : NetworkX graph\n    A graph over which to find the layers using breadth-first search.\n\nsources : node in `G` or list of nodes in `G`\n    Starting nodes for single source or multiple sources breadth-first search\n\nYields\n------\nedges: generator\n   A generator of triples (*u*, *v*, *d*) where (*u*, *v*) is the edge being\n   explored and *d* is described above.\n\nExamples\n--------\n>>> G = nx.cycle_graph(4, create_using=nx.DiGraph)\n>>> list(nx.bfs_labeled_edges(G, 0))\n[(0, 1, 'tree'), (1, 2, 'tree'), (2, 3, 'tree'), (3, 0, 'reverse')]\n>>> G = nx.complete_graph(3)\n>>> list(nx.bfs_labeled_edges(G, 0))\n[(0, 1, 'tree'), (0, 2, 'tree'), (1, 2, 'level')]\n>>> list(nx.bfs_labeled_edges(G, [0, 1]))\n[(0, 1, 'level'), (0, 2, 'tree'), (1, 2, 'forward')]"}, {"type": "function", "name": "networkx.bfs_layers", "documentation": "Returns an iterator of all the layers in breadth-first search traversal.\n\nParameters\n----------\nG : NetworkX graph\n    A graph over which to find the layers using breadth-first search.\n\nsources : node in `G` or list of nodes in `G`\n    Specify starting nodes for single source or multiple sources breadth-first search\n\nYields\n------\nlayer: list of nodes\n    Yields list of nodes at the same distance from sources\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> dict(enumerate(nx.bfs_layers(G, [0, 4])))\n{0: [0, 4], 1: [1, 3], 2: [2]}\n>>> H = nx.Graph()\n>>> H.add_edges_from([(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)])\n>>> dict(enumerate(nx.bfs_layers(H, [1])))\n{0: [1], 1: [0, 3, 4], 2: [2], 3: [5, 6]}\n>>> dict(enumerate(nx.bfs_layers(H, [1, 6])))\n{0: [1, 6], 1: [0, 3, 4, 2], 2: [5]}"}, {"type": "function", "name": "networkx.bfs_layout", "documentation": "Position nodes according to breadth-first search algorithm.\n\nParameters\n----------\nG : NetworkX graph\n    A position will be assigned to every node in G.\n\nstart : node in `G`\n    Starting node for bfs\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.bfs_layout(G, 0)\n\nNotes\n-----\nThis algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings."}, {"type": "function", "name": "networkx.bfs_predecessors", "documentation": "Returns an iterator of predecessors in breadth-first-search from source.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n   Specify starting node for breadth-first search\n\ndepth_limit : int, optional(default=len(G))\n    Specify the maximum search depth\n\nsort_neighbors : function (default=None)\n    A function that takes an iterator over nodes as the input, and\n    returns an iterable of the same nodes with a custom ordering.\n    For example, `sorted` will sort the nodes in increasing order.\n\nReturns\n-------\npred: iterator\n    (node, predecessor) iterator where `predecessor` is the predecessor of\n    `node` in a breadth first search starting from `source`.\n\nExamples\n--------\n>>> G = nx.path_graph(3)\n>>> dict(nx.bfs_predecessors(G, 0))\n{1: 0, 2: 1}\n>>> H = nx.Graph()\n>>> H.add_edges_from([(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)])\n>>> dict(nx.bfs_predecessors(H, 0))\n{1: 0, 2: 0, 3: 1, 4: 1, 5: 2, 6: 2}\n>>> M = nx.Graph()\n>>> nx.add_path(M, [0, 1, 2, 3, 4, 5, 6])\n>>> nx.add_path(M, [2, 7, 8, 9, 10])\n>>> sorted(nx.bfs_predecessors(M, source=1, depth_limit=3))\n[(0, 1), (2, 1), (3, 2), (4, 3), (7, 2), (8, 7)]\n>>> N = nx.DiGraph()\n>>> nx.add_path(N, [0, 1, 2, 3, 4, 7])\n>>> nx.add_path(N, [3, 5, 6, 7])\n>>> sorted(nx.bfs_predecessors(N, source=2))\n[(3, 2), (4, 3), (5, 3), (6, 5), (7, 4)]\n\nNotes\n-----\nBased on http://www.ics.uci.edu/~eppstein/PADS/BFS.py\nby D. Eppstein, July 2004. The modifications\nto allow depth limits based on the Wikipedia article\n\"`Depth-limited-search`_\".\n\n.. _Depth-limited-search: https://en.wikipedia.org/wiki/Depth-limited_search\n\nSee Also\n--------\nbfs_tree\nbfs_edges\nedge_bfs"}, {"type": "function", "name": "networkx.bfs_successors", "documentation": "Returns an iterator of successors in breadth-first-search from source.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n   Specify starting node for breadth-first search\n\ndepth_limit : int, optional(default=len(G))\n    Specify the maximum search depth\n\nsort_neighbors : function (default=None)\n    A function that takes an iterator over nodes as the input, and\n    returns an iterable of the same nodes with a custom ordering.\n    For example, `sorted` will sort the nodes in increasing order.\n\nReturns\n-------\nsucc: iterator\n   (node, successors) iterator where `successors` is the non-empty list of\n   successors of `node` in a breadth first search from `source`.\n   To appear in the iterator, `node` must have successors.\n\nExamples\n--------\n>>> G = nx.path_graph(3)\n>>> dict(nx.bfs_successors(G, 0))\n{0: [1], 1: [2]}\n>>> H = nx.Graph()\n>>> H.add_edges_from([(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)])\n>>> dict(nx.bfs_successors(H, 0))\n{0: [1, 2], 1: [3, 4], 2: [5, 6]}\n>>> G = nx.Graph()\n>>> nx.add_path(G, [0, 1, 2, 3, 4, 5, 6])\n>>> nx.add_path(G, [2, 7, 8, 9, 10])\n>>> dict(nx.bfs_successors(G, source=1, depth_limit=3))\n{1: [0, 2], 2: [3, 7], 3: [4], 7: [8]}\n>>> G = nx.DiGraph()\n>>> nx.add_path(G, [0, 1, 2, 3, 4, 5])\n>>> dict(nx.bfs_successors(G, source=3))\n{3: [4], 4: [5]}\n\nNotes\n-----\nBased on http://www.ics.uci.edu/~eppstein/PADS/BFS.py\nby D. Eppstein, July 2004.The modifications\nto allow depth limits based on the Wikipedia article\n\"`Depth-limited-search`_\".\n\n.. _Depth-limited-search: https://en.wikipedia.org/wiki/Depth-limited_search\n\nSee Also\n--------\nbfs_tree\nbfs_edges\nedge_bfs"}, {"type": "function", "name": "networkx.bfs_tree", "documentation": "Returns an oriented tree constructed from of a breadth-first-search\nstarting at source.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n   Specify starting node for breadth-first search\n\nreverse : bool, optional\n   If True traverse a directed graph in the reverse direction\n\ndepth_limit : int, optional(default=len(G))\n    Specify the maximum search depth\n\nsort_neighbors : function (default=None)\n    A function that takes an iterator over nodes as the input, and\n    returns an iterable of the same nodes with a custom ordering.\n    For example, `sorted` will sort the nodes in increasing order.\n\nReturns\n-------\nT: NetworkX DiGraph\n   An oriented tree\n\nExamples\n--------\n>>> G = nx.path_graph(3)\n>>> list(nx.bfs_tree(G, 1).edges())\n[(1, 0), (1, 2)]\n>>> H = nx.Graph()\n>>> nx.add_path(H, [0, 1, 2, 3, 4, 5, 6])\n>>> nx.add_path(H, [2, 7, 8, 9, 10])\n>>> sorted(list(nx.bfs_tree(H, source=3, depth_limit=3).edges()))\n[(1, 0), (2, 1), (2, 7), (3, 2), (3, 4), (4, 5), (5, 6), (7, 8)]\n\n\nNotes\n-----\nBased on http://www.ics.uci.edu/~eppstein/PADS/BFS.py\nby D. Eppstein, July 2004. The modifications\nto allow depth limits based on the Wikipedia article\n\"`Depth-limited-search`_\".\n\n.. _Depth-limited-search: https://en.wikipedia.org/wiki/Depth-limited_search\n\nSee Also\n--------\ndfs_tree\nbfs_edges\nedge_bfs"}, {"type": "function", "name": "networkx.biconnected_component_edges", "documentation": "Returns a generator of lists of edges, one list for each biconnected\ncomponent of the input graph.\n\nBiconnected components are maximal subgraphs such that the removal of a\nnode (and all edges incident on that node) will not disconnect the\nsubgraph.  Note that nodes may be part of more than one biconnected\ncomponent.  Those nodes are articulation points, or cut vertices.\nHowever, each edge belongs to one, and only one, biconnected component.\n\nNotice that by convention a dyad is considered a biconnected component.\n\nParameters\n----------\nG : NetworkX Graph\n    An undirected graph.\n\nReturns\n-------\nedges : generator of lists\n    Generator of lists of edges, one list for each bicomponent.\n\nRaises\n------\nNetworkXNotImplemented\n    If the input graph is not undirected.\n\nExamples\n--------\n>>> G = nx.barbell_graph(4, 2)\n>>> print(nx.is_biconnected(G))\nFalse\n>>> bicomponents_edges = list(nx.biconnected_component_edges(G))\n>>> len(bicomponents_edges)\n5\n>>> G.add_edge(2, 8)\n>>> print(nx.is_biconnected(G))\nTrue\n>>> bicomponents_edges = list(nx.biconnected_component_edges(G))\n>>> len(bicomponents_edges)\n1\n\nSee Also\n--------\nis_biconnected,\nbiconnected_components,\narticulation_points,\n\nNotes\n-----\nThe algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node `n` is an articulation point if, and only\nif, there exists a subtree rooted at `n` such that there is no\nback edge from any successor of `n` that links to a predecessor of\n`n` in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.\n\nReferences\n----------\n.. [1] Hopcroft, J.; Tarjan, R. (1973).\n       \"Efficient algorithms for graph manipulation\".\n       Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272"}, {"type": "function", "name": "networkx.biconnected_components", "documentation": "Returns a generator of sets of nodes, one set for each biconnected\ncomponent of the graph\n\nBiconnected components are maximal subgraphs such that the removal of a\nnode (and all edges incident on that node) will not disconnect the\nsubgraph. Note that nodes may be part of more than one biconnected\ncomponent.  Those nodes are articulation points, or cut vertices.  The\nremoval of articulation points will increase the number of connected\ncomponents of the graph.\n\nNotice that by convention a dyad is considered a biconnected component.\n\nParameters\n----------\nG : NetworkX Graph\n    An undirected graph.\n\nReturns\n-------\nnodes : generator\n    Generator of sets of nodes, one set for each biconnected component.\n\nRaises\n------\nNetworkXNotImplemented\n    If the input graph is not undirected.\n\nExamples\n--------\n>>> G = nx.lollipop_graph(5, 1)\n>>> print(nx.is_biconnected(G))\nFalse\n>>> bicomponents = list(nx.biconnected_components(G))\n>>> len(bicomponents)\n2\n>>> G.add_edge(0, 5)\n>>> print(nx.is_biconnected(G))\nTrue\n>>> bicomponents = list(nx.biconnected_components(G))\n>>> len(bicomponents)\n1\n\nYou can generate a sorted list of biconnected components, largest\nfirst, using sort.\n\n>>> G.remove_edge(0, 5)\n>>> [len(c) for c in sorted(nx.biconnected_components(G), key=len, reverse=True)]\n[5, 2]\n\nIf you only want the largest connected component, it's more\nefficient to use max instead of sort.\n\n>>> Gc = max(nx.biconnected_components(G), key=len)\n\nTo create the components as subgraphs use:\n``(G.subgraph(c).copy() for c in biconnected_components(G))``\n\nSee Also\n--------\nis_biconnected\narticulation_points\nbiconnected_component_edges\nk_components : this function is a special case where k=2\nbridge_components : similar to this function, but is defined using\n    2-edge-connectivity instead of 2-node-connectivity.\n\nNotes\n-----\nThe algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node `n` is an articulation point if, and only\nif, there exists a subtree rooted at `n` such that there is no\nback edge from any successor of `n` that links to a predecessor of\n`n` in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.\n\nReferences\n----------\n.. [1] Hopcroft, J.; Tarjan, R. (1973).\n       \"Efficient algorithms for graph manipulation\".\n       Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272"}, {"type": "function", "name": "networkx.bidirectional_dijkstra", "documentation": "Dijkstra's algorithm for shortest paths using bidirectional search.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n    Starting node.\n\ntarget : node\n    Ending node.\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number or None to indicate a hidden edge.\n\nReturns\n-------\nlength, path : number and list\n    length is the distance from source to target.\n    path is a list of nodes on a path from source to target.\n\nRaises\n------\nNodeNotFound\n    If either `source` or `target` is not in `G`.\n\nNetworkXNoPath\n    If no path exists between source and target.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> length, path = nx.bidirectional_dijkstra(G, 0, 4)\n>>> print(length)\n4\n>>> print(path)\n[0, 1, 2, 3, 4]\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe weight function can be used to hide edges by returning None.\nSo ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\nwill find the shortest red path.\n\nIn practice  bidirectional Dijkstra is much more than twice as fast as\nordinary Dijkstra.\n\nOrdinary Dijkstra expands nodes in a sphere-like manner from the\nsource. The radius of this sphere will eventually be the length\nof the shortest path. Bidirectional Dijkstra will expand nodes\nfrom both the source and the target, making two spheres of half\nthis radius. Volume of the first sphere is `\\pi*r*r` while the\nothers are `2*\\pi*r/2*r/2`, making up half the volume.\n\nThis algorithm is not guaranteed to work if edge weights\nare negative or are floating point numbers\n(overflows and roundoff errors can cause problems).\n\nSee Also\n--------\nshortest_path\nshortest_path_length"}, {"type": "function", "name": "networkx.bidirectional_shortest_path", "documentation": "Returns a list of nodes in a shortest path between source and target.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node label\n   starting node for path\n\ntarget : node label\n   ending node for path\n\nReturns\n-------\npath: list\n   List of nodes in a path from source to target.\n\nRaises\n------\nNetworkXNoPath\n   If no path exists between source and target.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> nx.add_path(G, [0, 1, 2, 3, 0, 4, 5, 6, 7, 4])\n>>> nx.bidirectional_shortest_path(G, 2, 6)\n[2, 1, 0, 4, 5, 6]\n\nSee Also\n--------\nshortest_path\n\nNotes\n-----\nThis algorithm is used by shortest_path(G, source, target)."}, {"type": "function", "name": "networkx.binomial_graph", "documentation": "Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph\nor a binomial graph.\n\nThe $G_{n,p}$ model chooses each of the possible edges with probability $p$.\n\nParameters\n----------\nn : int\n    The number of nodes.\np : float\n    Probability for edge creation.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ndirected : bool, optional (default=False)\n    If True, this function returns a directed graph.\n\nSee Also\n--------\nfast_gnp_random_graph\n\nNotes\n-----\nThis algorithm [2]_ runs in $O(n^2)$ time.  For sparse graphs (that is, for\nsmall values of $p$), :func:`fast_gnp_random_graph` is a faster algorithm.\n\n:func:`binomial_graph` and :func:`erdos_renyi_graph` are\naliases for :func:`gnp_random_graph`.\n\n>>> nx.binomial_graph is nx.gnp_random_graph\nTrue\n>>> nx.erdos_renyi_graph is nx.gnp_random_graph\nTrue\n\nReferences\n----------\n.. [1] P. Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).\n.. [2] E. N. Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959)."}, {"type": "function", "name": "networkx.binomial_tree", "documentation": "Returns the Binomial Tree of order n.\n\nThe binomial tree of order 0 consists of a single node. A binomial tree of order k\nis defined recursively by linking two binomial trees of order k-1: the root of one is\nthe leftmost child of the root of the other.\n\n.. plot::\n\n    >>> nx.draw(nx.binomial_tree(3))\n\nParameters\n----------\nn : int\n    Order of the binomial tree.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : NetworkX graph\n    A binomial tree of $2^n$ nodes and $2^n - 1$ edges."}, {"type": "function", "name": "networkx.bipartite_layout", "documentation": "Position nodes in two straight lines.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\nnodes : list or container\n    Nodes in one node set of the bipartite graph.\n    This set will be placed on left or top.\n\nalign : string (default='vertical')\n    The alignment of nodes. Vertical or horizontal.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\naspect_ratio : number (default=4/3):\n    The ratio of the width to the height of the layout.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node.\n\nExamples\n--------\n>>> G = nx.bipartite.gnmk_random_graph(3, 5, 10, seed=123)\n>>> top = nx.bipartite.sets(G)[0]\n>>> pos = nx.bipartite_layout(G, top)\n\nNotes\n-----\nThis algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings."}, {"type": "function", "name": "networkx.boundary_expansion", "documentation": "Returns the boundary expansion of the set `S`.\n\nThe *boundary expansion* is the quotient of the size\nof the node boundary and the cardinality of *S*. [1]\n\nParameters\n----------\nG : NetworkX graph\n\nS : collection\n    A collection of nodes in `G`.\n\nReturns\n-------\nnumber\n    The boundary expansion of the set `S`.\n\nSee also\n--------\nedge_expansion\nmixing_expansion\nnode_expansion\n\nReferences\n----------\n.. [1] Vadhan, Salil P.\n       \"Pseudorandomness.\"\n       *Foundations and Trends in Theoretical Computer Science*\n       7.1\u20133 (2011): 1\u2013336.\n       <https://doi.org/10.1561/0400000010>"}, {"type": "function", "name": "networkx.bridges", "documentation": "Generate all bridges in a graph.\n\nA *bridge* in a graph is an edge whose removal causes the number of\nconnected components of the graph to increase.  Equivalently, a bridge is an\nedge that does not belong to any cycle. Bridges are also known as cut-edges,\nisthmuses, or cut arcs.\n\nParameters\n----------\nG : undirected graph\n\nroot : node (optional)\n   A node in the graph `G`. If specified, only the bridges in the\n   connected component containing this node will be returned.\n\nYields\n------\ne : edge\n   An edge in the graph whose removal disconnects the graph (or\n   causes the number of connected components to increase).\n\nRaises\n------\nNodeNotFound\n   If `root` is not in the graph `G`.\n\nNetworkXNotImplemented\n    If `G` is a directed graph.\n\nExamples\n--------\nThe barbell graph with parameter zero has a single bridge:\n\n>>> G = nx.barbell_graph(10, 0)\n>>> list(nx.bridges(G))\n[(9, 10)]\n\nNotes\n-----\nThis is an implementation of the algorithm described in [1]_.  An edge is a\nbridge if and only if it is not contained in any chain. Chains are found\nusing the :func:`networkx.chain_decomposition` function.\n\nThe algorithm described in [1]_ requires a simple graph. If the provided\ngraph is a multigraph, we convert it to a simple graph and verify that any\nbridges discovered by the chain decomposition algorithm are not multi-edges.\n\nIgnoring polylogarithmic factors, the worst-case time complexity is the\nsame as the :func:`networkx.chain_decomposition` function,\n$O(m + n)$, where $n$ is the number of nodes in the graph and $m$ is\nthe number of edges.\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29#Bridge-Finding_with_Chain_Decompositions"}, {"type": "function", "name": "networkx.bull_graph", "documentation": "Returns the Bull Graph\n\nThe Bull Graph has 5 nodes and 5 edges. It is a planar undirected\ngraph in the form of a triangle with two disjoint pendant edges [1]_\nThe name comes from the triangle and pendant edges representing\nrespectively the body and legs of a bull.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    A bull graph with 5 nodes\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Bull_graph."}, {"type": "function", "name": "networkx.capacity_scaling", "documentation": "Find a minimum cost flow satisfying all demands in digraph G.\n\nThis is a capacity scaling successive shortest augmenting path algorithm.\n\nG is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node.\n\nParameters\n----------\nG : NetworkX graph\n    DiGraph or MultiDiGraph on which a minimum cost flow satisfying all\n    demands is to be found.\n\ndemand : string\n    Nodes of the graph G are expected to have an attribute demand\n    that indicates how much flow a node wants to send (negative\n    demand) or receive (positive demand). Note that the sum of the\n    demands should be 0 otherwise the problem in not feasible. If\n    this attribute is not present, a node is considered to have 0\n    demand. Default value: 'demand'.\n\ncapacity : string\n    Edges of the graph G are expected to have an attribute capacity\n    that indicates how much flow the edge can support. If this\n    attribute is not present, the edge is considered to have\n    infinite capacity. Default value: 'capacity'.\n\nweight : string\n    Edges of the graph G are expected to have an attribute weight\n    that indicates the cost incurred by sending one unit of flow on\n    that edge. If not present, the weight is considered to be 0.\n    Default value: 'weight'.\n\nheap : class\n    Type of heap to be used in the algorithm. It should be a subclass of\n    :class:`MinHeap` or implement a compatible interface.\n\n    If a stock heap implementation is to be used, :class:`BinaryHeap` is\n    recommended over :class:`PairingHeap` for Python implementations without\n    optimized attribute accesses (e.g., CPython) despite a slower\n    asymptotic running time. For Python implementations with optimized\n    attribute accesses (e.g., PyPy), :class:`PairingHeap` provides better\n    performance. Default value: :class:`BinaryHeap`.\n\nReturns\n-------\nflowCost : integer\n    Cost of a minimum cost flow satisfying all demands.\n\nflowDict : dictionary\n    If G is a digraph, a dict-of-dicts keyed by nodes such that\n    flowDict[u][v] is the flow on edge (u, v).\n    If G is a MultiDiGraph, a dict-of-dicts-of-dicts keyed by nodes\n    so that flowDict[u][v][key] is the flow on edge (u, v, key).\n\nRaises\n------\nNetworkXError\n    This exception is raised if the input graph is not directed,\n    not connected.\n\nNetworkXUnfeasible\n    This exception is raised in the following situations:\n\n        * The sum of the demands is not zero. Then, there is no\n          flow satisfying all demands.\n        * There is no flow satisfying all demand.\n\nNetworkXUnbounded\n    This exception is raised if the digraph G has a cycle of\n    negative cost and infinite capacity. Then, the cost of a flow\n    satisfying all demands is unbounded below.\n\nNotes\n-----\nThis algorithm does not work if edge weights are floating-point numbers.\n\nSee also\n--------\n:meth:`network_simplex`\n\nExamples\n--------\nA simple example of a min cost flow problem.\n\n>>> G = nx.DiGraph()\n>>> G.add_node(\"a\", demand=-5)\n>>> G.add_node(\"d\", demand=5)\n>>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\n>>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\n>>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\n>>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\n>>> flowCost, flowDict = nx.capacity_scaling(G)\n>>> flowCost\n24\n>>> flowDict\n{'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\n\nIt is possible to change the name of the attributes used for the\nalgorithm.\n\n>>> G = nx.DiGraph()\n>>> G.add_node(\"p\", spam=-4)\n>>> G.add_node(\"q\", spam=2)\n>>> G.add_node(\"a\", spam=-2)\n>>> G.add_node(\"d\", spam=-1)\n>>> G.add_node(\"t\", spam=2)\n>>> G.add_node(\"w\", spam=3)\n>>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\n>>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\n>>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\n>>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\n>>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\n>>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\n>>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\n>>> flowCost, flowDict = nx.capacity_scaling(\n...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\n... )\n>>> flowCost\n37\n>>> flowDict\n{'p': {'q': 2, 'a': 2}, 'q': {'d': 1}, 'a': {'t': 4}, 'd': {'w': 2}, 't': {'q': 1, 'w': 1}, 'w': {}}"}, {"type": "function", "name": "networkx.cartesian_product", "documentation": "Returns the Cartesian product of G and H.\n\nThe Cartesian product $P$ of the graphs $G$ and $H$ has a node set that\nis the Cartesian product of the node sets, $V(P)=V(G) \\times V(H)$.\n$P$ has an edge $((u,v),(x,y))$ if and only if either $u$ is equal to $x$\nand both $v$ and $y$ are adjacent in $H$ or if $v$ is equal to $y$ and\nboth $u$ and $x$ are adjacent in $G$.\n\nParameters\n----------\nG, H: graphs\n Networkx graphs.\n\nReturns\n-------\nP: NetworkX graph\n The Cartesian product of G and H. P will be a multi-graph if either G\n or H is a multi-graph. Will be a directed if G and H are directed,\n and undirected if G and H are undirected.\n\nRaises\n------\nNetworkXError\n If G and H are not both directed or both undirected.\n\nNotes\n-----\nNode attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> H = nx.Graph()\n>>> G.add_node(0, a1=True)\n>>> H.add_node(\"a\", a2=\"Spam\")\n>>> P = nx.cartesian_product(G, H)\n>>> list(P)\n[(0, 'a')]\n\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph"}, {"type": "function", "name": "networkx.caveman_graph", "documentation": "Returns a caveman graph of `l` cliques of size `k`.\n\nParameters\n----------\nl : int\n  Number of cliques\nk : int\n  Size of cliques\n\nReturns\n-------\nG : NetworkX Graph\n  caveman graph\n\nNotes\n-----\nThis returns an undirected graph, it can be converted to a directed\ngraph using :func:`nx.to_directed`, or a multigraph using\n``nx.MultiGraph(nx.caveman_graph(l, k))``. Only the undirected version is\ndescribed in [1]_ and it is unclear which of the directed\ngeneralizations is most useful.\n\nExamples\n--------\n>>> G = nx.caveman_graph(3, 3)\n\nSee also\n--------\n\nconnected_caveman_graph\n\nReferences\n----------\n.. [1] Watts, D. J. 'Networks, Dynamics, and the Small-World Phenomenon.'\n   Amer. J. Soc. 105, 493-527, 1999."}, {"type": "function", "name": "networkx.cd_index", "documentation": "Compute the CD index for `node` within the graph `G`.\n\nCalculates the CD index for the given node of the graph,\nconsidering only its predecessors who have the `time` attribute\nsmaller than or equal to the `time` attribute of the `node`\nplus `time_delta`.\n\nParameters\n----------\nG : graph\n   A directed networkx graph whose nodes have `time` attributes and optionally\n   `weight` attributes (if a weight is not given, it is considered 1).\nnode : node\n   The node for which the CD index is calculated.\ntime_delta : numeric or timedelta\n   Amount of time after the `time` attribute of the `node`. The value of\n   `time_delta` must support comparison with the `time` node attribute. For\n   example, if the `time` attribute of the nodes are `datetime.datetime`\n   objects, then `time_delta` should be a `datetime.timedelta` object.\ntime : string (Optional, default is \"time\")\n    The name of the node attribute that will be used for the calculations.\nweight : string (Optional, default is None)\n    The name of the node attribute used as weight.\n\nReturns\n-------\nfloat\n   The CD index calculated for the node `node` within the graph `G`.\n\nRaises\n------\nNetworkXError\n   If not all nodes have a `time` attribute or\n   `time_delta` and `time` attribute types are not compatible or\n   `n` equals 0.\n\nNetworkXNotImplemented\n    If `G` is a non-directed graph or a multigraph.\n\nExamples\n--------\n>>> from datetime import datetime, timedelta\n>>> G = nx.DiGraph()\n>>> nodes = {\n...     1: {\"time\": datetime(2015, 1, 1)},\n...     2: {\"time\": datetime(2012, 1, 1), \"weight\": 4},\n...     3: {\"time\": datetime(2010, 1, 1)},\n...     4: {\"time\": datetime(2008, 1, 1)},\n...     5: {\"time\": datetime(2014, 1, 1)},\n... }\n>>> G.add_nodes_from([(n, nodes[n]) for n in nodes])\n>>> edges = [(1, 3), (1, 4), (2, 3), (3, 4), (3, 5)]\n>>> G.add_edges_from(edges)\n>>> delta = timedelta(days=5 * 365)\n>>> nx.cd_index(G, 3, time_delta=delta, time=\"time\")\n0.5\n>>> nx.cd_index(G, 3, time_delta=delta, time=\"time\", weight=\"weight\")\n0.12\n\nIntegers can also be used for the time values:\n>>> node_times = {1: 2015, 2: 2012, 3: 2010, 4: 2008, 5: 2014}\n>>> nx.set_node_attributes(G, node_times, \"new_time\")\n>>> nx.cd_index(G, 3, time_delta=4, time=\"new_time\")\n0.5\n>>> nx.cd_index(G, 3, time_delta=4, time=\"new_time\", weight=\"weight\")\n0.12\n\nNotes\n-----\nThis method implements the algorithm for calculating the CD index,\nas described in the paper by Funk and Owen-Smith [1]_. The CD index\nis used in order to check how consolidating or destabilizing a patent\nis, hence the nodes of the graph represent patents and the edges show\nthe citations between these patents. The mathematical model is given\nbelow:\n\n.. math::\n    CD_{t}=\\frac{1}{n_{t}}\\sum_{i=1}^{n}\\frac{-2f_{it}b_{it}+f_{it}}{w_{it}},\n\nwhere `f_{it}` equals 1 if `i` cites the focal patent else 0, `b_{it}` equals\n1 if `i` cites any of the focal patents successors else 0, `n_{t}` is the number\nof forward citations in `i` and `w_{it}` is a matrix of weight for patent `i`\nat time `t`.\n\nThe `datetime.timedelta` package can lead to off-by-one issues when converting\nfrom years to days. In the example above `timedelta(days=5 * 365)` looks like\n5 years, but it isn't because of leap year days. So it gives the same result\nas `timedelta(days=4 * 365)`. But using `timedelta(days=5 * 365 + 1)` gives\na 5 year delta **for this choice of years** but may not if the 5 year gap has\nmore than 1 leap year. To avoid these issues, use integers to represent years,\nor be very careful when you convert units of time.\n\nReferences\n----------\n.. [1] Funk, Russell J., and Jason Owen-Smith.\n       \"A dynamic network measure of technological change.\"\n       Management science 63, no. 3 (2017): 791-817.\n       http://russellfunk.org/cdindex/static/papers/funk_ms_2017.pdf"}, {"type": "function", "name": "networkx.center", "documentation": "Returns the center of the graph G.\n\nThe center is the set of nodes with eccentricity equal to radius.\n\nParameters\n----------\nG : NetworkX graph\n   A graph\n\ne : eccentricity dictionary, optional\n  A precomputed dictionary of eccentricities.\n\nweight : string, function, or None\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\n    If this is None, every edge has weight/distance/cost 1.\n\n    Weights stored as floating point values can lead to small round-off\n    errors in distances. Use integer weights to avoid this.\n\n    Weights should be positive, since they are distances.\n\nReturns\n-------\nc : list\n   List of nodes in center\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (1, 4), (3, 4), (3, 5), (4, 5)])\n>>> list(nx.center(G))\n[1, 3, 4]\n\nSee Also\n--------\nbarycenter\nperiphery"}, {"type": "function", "name": "networkx.chain_decomposition", "documentation": "Returns the chain decomposition of a graph.\n\nThe *chain decomposition* of a graph with respect a depth-first\nsearch tree is a set of cycles or paths derived from the set of\nfundamental cycles of the tree in the following manner. Consider\neach fundamental cycle with respect to the given tree, represented\nas a list of edges beginning with the nontree edge oriented away\nfrom the root of the tree. For each fundamental cycle, if it\noverlaps with any previous fundamental cycle, just take the initial\nnon-overlapping segment, which is a path instead of a cycle. Each\ncycle or path is called a *chain*. For more information, see [1]_.\n\nParameters\n----------\nG : undirected graph\n\nroot : node (optional)\n   A node in the graph `G`. If specified, only the chain\n   decomposition for the connected component containing this node\n   will be returned. This node indicates the root of the depth-first\n   search tree.\n\nYields\n------\nchain : list\n   A list of edges representing a chain. There is no guarantee on\n   the orientation of the edges in each chain (for example, if a\n   chain includes the edge joining nodes 1 and 2, the chain may\n   include either (1, 2) or (2, 1)).\n\nRaises\n------\nNodeNotFound\n   If `root` is not in the graph `G`.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (1, 4), (3, 4), (3, 5), (4, 5)])\n>>> list(nx.chain_decomposition(G))\n[[(4, 5), (5, 3), (3, 4)]]\n\nNotes\n-----\nThe worst-case running time of this implementation is linear in the\nnumber of nodes and number of edges [1]_.\n\nReferences\n----------\n.. [1] Jens M. Schmidt (2013). \"A simple test on 2-vertex-\n   and 2-edge-connectivity.\" *Information Processing Letters*,\n   113, 241\u2013244. Elsevier. <https://doi.org/10.1016/j.ipl.2013.01.016>"}, {"type": "function", "name": "networkx.check_planarity", "documentation": "Check if a graph is planar and return a counterexample or an embedding.\n\nA graph is planar iff it can be drawn in a plane without\nany edge intersections.\n\nParameters\n----------\nG : NetworkX graph\ncounterexample : bool\n    A Kuratowski subgraph (to proof non planarity) is only returned if set\n    to true.\n\nReturns\n-------\n(is_planar, certificate) : (bool, NetworkX graph) tuple\n    is_planar is true if the graph is planar.\n    If the graph is planar `certificate` is a PlanarEmbedding\n    otherwise it is a Kuratowski subgraph.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2)])\n>>> is_planar, P = nx.check_planarity(G)\n>>> print(is_planar)\nTrue\n\nWhen `G` is planar, a `PlanarEmbedding` instance is returned:\n\n>>> P.get_data()\n{0: [1, 2], 1: [0], 2: [0]}\n\nNotes\n-----\nA (combinatorial) embedding consists of cyclic orderings of the incident\nedges at each vertex. Given such an embedding there are multiple approaches\ndiscussed in literature to drawing the graph (subject to various\nconstraints, e.g. integer coordinates), see e.g. [2].\n\nThe planarity check algorithm and extraction of the combinatorial embedding\nis based on the Left-Right Planarity Test [1].\n\nA counterexample is only generated if the corresponding parameter is set,\nbecause the complexity of the counterexample generation is higher.\n\nSee also\n--------\nis_planar :\n    Check for planarity without creating a `PlanarEmbedding` or counterexample.\n\nReferences\n----------\n.. [1] Ulrik Brandes:\n    The Left-Right Planarity Test\n    2009\n    http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.217.9208\n.. [2] Takao Nishizeki, Md Saidur Rahman:\n    Planar graph drawing\n    Lecture Notes Series on Computing: Volume 12\n    2004"}, {"type": "function", "name": "networkx.chordal_cycle_graph", "documentation": "Returns the chordal cycle graph on `p` nodes.\n\nThe returned graph is a cycle graph on `p` nodes with chords joining each\nvertex `x` to its inverse modulo `p`. This graph is a (mildly explicit)\n3-regular expander [1]_.\n\n`p` *must* be a prime number.\n\nParameters\n----------\np : a prime number\n\n    The number of vertices in the graph. This also indicates where the\n    chordal edges in the cycle will be created.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : graph\n    The constructed undirected multigraph.\n\nRaises\n------\nNetworkXError\n\n    If `create_using` indicates directed or not a multigraph.\n\nReferences\n----------\n\n.. [1] Theorem 4.4.2 in A. Lubotzky. \"Discrete groups, expanding graphs and\n       invariant measures\", volume 125 of Progress in Mathematics.\n       Birkh\u00e4user Verlag, Basel, 1994."}, {"type": "function", "name": "networkx.chordal_graph_cliques", "documentation": "Returns all maximal cliques of a chordal graph.\n\nThe algorithm breaks the graph in connected components and performs a\nmaximum cardinality search in each component to get the cliques.\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nYields\n------\nfrozenset of nodes\n    Maximal cliques, each of which is a frozenset of\n    nodes in `G`. The order of cliques is arbitrary.\n\nRaises\n------\nNetworkXError\n    The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\n    The algorithm can only be applied to chordal graphs. If the input\n    graph is found to be non-chordal, a :exc:`NetworkXError` is raised.\n\nExamples\n--------\n>>> e = [\n...     (1, 2),\n...     (1, 3),\n...     (2, 3),\n...     (2, 4),\n...     (3, 4),\n...     (3, 5),\n...     (3, 6),\n...     (4, 5),\n...     (4, 6),\n...     (5, 6),\n...     (7, 8),\n... ]\n>>> G = nx.Graph(e)\n>>> G.add_node(9)\n>>> cliques = [c for c in chordal_graph_cliques(G)]\n>>> cliques[0]\nfrozenset({1, 2, 3})"}, {"type": "function", "name": "networkx.chordal_graph_treewidth", "documentation": "Returns the treewidth of the chordal graph G.\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nReturns\n-------\ntreewidth : int\n    The size of the largest clique in the graph minus one.\n\nRaises\n------\nNetworkXError\n    The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\n    The algorithm can only be applied to chordal graphs. If the input\n    graph is found to be non-chordal, a :exc:`NetworkXError` is raised.\n\nExamples\n--------\n>>> e = [\n...     (1, 2),\n...     (1, 3),\n...     (2, 3),\n...     (2, 4),\n...     (3, 4),\n...     (3, 5),\n...     (3, 6),\n...     (4, 5),\n...     (4, 6),\n...     (5, 6),\n...     (7, 8),\n... ]\n>>> G = nx.Graph(e)\n>>> G.add_node(9)\n>>> nx.chordal_graph_treewidth(G)\n3\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Tree_decomposition#Treewidth"}, {"type": "function", "name": "networkx.chordless_cycles", "documentation": "Find simple chordless cycles of a graph.\n\nA `simple cycle` is a closed path where no node appears twice.  In a simple\ncycle, a `chord` is an additional edge between two nodes in the cycle.  A\n`chordless cycle` is a simple cycle without chords.  Said differently, a\nchordless cycle is a cycle C in a graph G where the number of edges in the\ninduced graph G[C] is equal to the length of `C`.\n\nNote that some care must be taken in the case that G is not a simple graph\nnor a simple digraph.  Some authors limit the definition of chordless cycles\nto have a prescribed minimum length; we do not.\n\n    1. We interpret self-loops to be chordless cycles, except in multigraphs\n       with multiple loops in parallel.  Likewise, in a chordless cycle of\n       length greater than 1, there can be no nodes with self-loops.\n\n    2. We interpret directed two-cycles to be chordless cycles, except in\n       multi-digraphs when any edge in a two-cycle has a parallel copy.\n\n    3. We interpret parallel pairs of undirected edges as two-cycles, except\n       when a third (or more) parallel edge exists between the two nodes.\n\n    4. Generalizing the above, edges with parallel clones may not occur in\n       chordless cycles.\n\nIn a directed graph, two chordless cycles are distinct if they are not\ncyclic permutations of each other.  In an undirected graph, two chordless\ncycles are distinct if they are not cyclic permutations of each other nor of\nthe other's reversal.\n\nOptionally, the cycles are bounded in length.\n\nWe use an algorithm strongly inspired by that of Dias et al [1]_.  It has\nbeen modified in the following ways:\n\n    1. Recursion is avoided, per Python's limitations\n\n    2. The labeling function is not necessary, because the starting paths\n        are chosen (and deleted from the host graph) to prevent multiple\n        occurrences of the same path\n\n    3. The search is optionally bounded at a specified length\n\n    4. Support for directed graphs is provided by extending cycles along\n        forward edges, and blocking nodes along forward and reverse edges\n\n    5. Support for multigraphs is provided by omitting digons from the set\n        of forward edges\n\nParameters\n----------\nG : NetworkX DiGraph\n   A directed graph\n\nlength_bound : int or None, optional (default=None)\n   If length_bound is an int, generate all simple cycles of G with length at\n   most length_bound.  Otherwise, generate all simple cycles of G.\n\nYields\n------\nlist of nodes\n   Each cycle is represented by a list of nodes along the cycle.\n\nExamples\n--------\n>>> sorted(list(nx.chordless_cycles(nx.complete_graph(4))))\n[[1, 0, 2], [1, 0, 3], [2, 0, 3], [2, 1, 3]]\n\nNotes\n-----\nWhen length_bound is None, and the graph is simple, the time complexity is\n$O((n+e)(c+1))$ for $n$ nodes, $e$ edges and $c$ chordless cycles.\n\nRaises\n------\nValueError\n    when length_bound < 0.\n\nReferences\n----------\n.. [1] Efficient enumeration of chordless cycles\n   E. Dias and D. Castonguay and H. Longo and W.A.R. Jradi\n   https://arxiv.org/abs/1309.1051\n\nSee Also\n--------\nsimple_cycles"}, {"type": "function", "name": "networkx.chromatic_polynomial", "documentation": "Returns the chromatic polynomial of `G`\n\nThis function computes the chromatic polynomial via an iterative version of\nthe deletion-contraction algorithm.\n\nThe chromatic polynomial `X_G(x)` is a fundamental graph polynomial\ninvariant in one variable. Evaluating `X_G(k)` for an natural number `k`\nenumerates the proper k-colorings of `G`.\n\nThere are several equivalent definitions; here are three:\n\nDef 1 (explicit formula):\nFor `G` an undirected graph, `c(G)` the number of connected components of\n`G`, `E` the edge set of `G`, and `G(S)` the spanning subgraph of `G` with\nedge set `S` [1]_:\n\n.. math::\n\n    X_G(x) = \\sum_{S \\subseteq E} (-1)^{|S|} x^{c(G(S))}\n\n\nDef 2 (interpolating polynomial):\nFor `G` an undirected graph, `n(G)` the number of vertices of `G`, `k_0 = 0`,\nand `k_i` the number of distinct ways to color the vertices of `G` with `i`\nunique colors (for `i` a natural number at most `n(G)`), `X_G(x)` is the\nunique Lagrange interpolating polynomial of degree `n(G)` through the points\n`(0, k_0), (1, k_1), \\dots, (n(G), k_{n(G)})` [2]_.\n\n\nDef 3 (chromatic recurrence):\nFor `G` an undirected graph, `G-e` the graph obtained from `G` by deleting\nedge `e`, `G/e` the graph obtained from `G` by contracting edge `e`, `n(G)`\nthe number of vertices of `G`, and `e(G)` the number of edges of `G` [3]_:\n\n.. math::\n    X_G(x) = \\begin{cases}\n       x^{n(G)}, & \\text{if $e(G)=0$} \\\\\n       X_{G-e}(x) - X_{G/e}(x), & \\text{otherwise, for an arbitrary edge $e$}\n    \\end{cases}\n\nThis formulation is also known as the Fundamental Reduction Theorem [4]_.\n\n\nParameters\n----------\nG : NetworkX graph\n\nReturns\n-------\ninstance of `sympy.core.add.Add`\n    A Sympy expression representing the chromatic polynomial for `G`.\n\nExamples\n--------\n>>> C = nx.cycle_graph(5)\n>>> nx.chromatic_polynomial(C)\nx**5 - 5*x**4 + 10*x**3 - 10*x**2 + 4*x\n\n>>> G = nx.complete_graph(4)\n>>> nx.chromatic_polynomial(G)\nx**4 - 6*x**3 + 11*x**2 - 6*x\n\nNotes\n-----\nInterpretation of the coefficients is discussed in [5]_. Several special\ncases are listed in [2]_.\n\nThe chromatic polynomial is a specialization of the Tutte polynomial; in\nparticular, ``X_G(x) = T_G(x, 0)`` [6]_.\n\nThe chromatic polynomial may take negative arguments, though evaluations\nmay not have chromatic interpretations. For instance, ``X_G(-1)`` enumerates\nthe acyclic orientations of `G` [7]_.\n\nReferences\n----------\n.. [1] D. B. West,\n   \"Introduction to Graph Theory,\" p. 222\n.. [2] E. W. Weisstein\n   \"Chromatic Polynomial\"\n   MathWorld--A Wolfram Web Resource\n   https://mathworld.wolfram.com/ChromaticPolynomial.html\n.. [3] D. B. West,\n   \"Introduction to Graph Theory,\" p. 221\n.. [4] J. Zhang, J. Goodall,\n   \"An Introduction to Chromatic Polynomials\"\n   https://math.mit.edu/~apost/courses/18.204_2018/Julie_Zhang_paper.pdf\n.. [5] R. C. Read,\n   \"An Introduction to Chromatic Polynomials\"\n   Journal of Combinatorial Theory, 1968\n   https://math.berkeley.edu/~mrklug/ReadChromatic.pdf\n.. [6] W. T. Tutte,\n   \"Graph-polynomials\"\n   Advances in Applied Mathematics, 2004\n   https://www.sciencedirect.com/science/article/pii/S0196885803000411\n.. [7] R. P. Stanley,\n   \"Acyclic orientations of graphs\"\n   Discrete Mathematics, 2006\n   https://math.mit.edu/~rstan/pubs/pubfiles/18.pdf"}, {"type": "function", "name": "networkx.chvatal_graph", "documentation": "Returns the Chv\u00e1tal Graph\n\nThe Chv\u00e1tal Graph is an undirected graph with 12 nodes and 24 edges [1]_.\nIt has 370 distinct (directed) Hamiltonian cycles, giving a unique generalized\nLCF notation of order 4, two of order 6 , and 43 of order 1 [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    The Chv\u00e1tal graph with 12 nodes and 24 edges\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Chv%C3%A1tal_graph\n.. [2] https://mathworld.wolfram.com/ChvatalGraph.html"}, {"type": "function", "name": "networkx.circulant_graph", "documentation": "Returns the circulant graph $Ci_n(x_1, x_2, ..., x_m)$ with $n$ nodes.\n\nThe circulant graph $Ci_n(x_1, ..., x_m)$ consists of $n$ nodes $0, ..., n-1$\nsuch that node $i$ is connected to nodes $(i + x) \\mod n$ and $(i - x) \\mod n$\nfor all $x$ in $x_1, ..., x_m$. Thus $Ci_n(1)$ is a cycle graph.\n\n.. plot::\n\n    >>> nx.draw(nx.circulant_graph(10, [1]))\n\nParameters\n----------\nn : integer\n    The number of nodes in the graph.\noffsets : list of integers\n    A list of node offsets, $x_1$ up to $x_m$, as described above.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkX Graph of type create_using\n\nExamples\n--------\nMany well-known graph families are subfamilies of the circulant graphs;\nfor example, to create the cycle graph on n points, we connect every\nnode to nodes on either side (with offset plus or minus one). For n = 10,\n\n>>> G = nx.circulant_graph(10, [1])\n>>> edges = [\n...     (0, 9),\n...     (0, 1),\n...     (1, 2),\n...     (2, 3),\n...     (3, 4),\n...     (4, 5),\n...     (5, 6),\n...     (6, 7),\n...     (7, 8),\n...     (8, 9),\n... ]\n>>> sorted(edges) == sorted(G.edges())\nTrue\n\nSimilarly, we can create the complete graph\non 5 points with the set of offsets [1, 2]:\n\n>>> G = nx.circulant_graph(5, [1, 2])\n>>> edges = [\n...     (0, 1),\n...     (0, 2),\n...     (0, 3),\n...     (0, 4),\n...     (1, 2),\n...     (1, 3),\n...     (1, 4),\n...     (2, 3),\n...     (2, 4),\n...     (3, 4),\n... ]\n>>> sorted(edges) == sorted(G.edges())\nTrue"}, {"type": "function", "name": "networkx.circular_ladder_graph", "documentation": "Returns the circular ladder graph $CL_n$ of length n.\n\n$CL_n$ consists of two concentric n-cycles in which\neach of the n pairs of concentric nodes are joined by an edge.\n\nNode labels are the integers 0 to n-1\n\n.. plot::\n\n    >>> nx.draw(nx.circular_ladder_graph(5))"}, {"type": "function", "name": "networkx.circular_layout", "documentation": "Position nodes on a circle.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\ndim : int\n    Dimension of layout.\n    If dim>2, the remaining dimensions are set to zero\n    in the returned positions.\n    If dim<2, a ValueError is raised.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nRaises\n------\nValueError\n    If dim < 2\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.circular_layout(G)\n\nNotes\n-----\nThis algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings."}, {"type": "function", "name": "networkx.closeness_centrality", "documentation": "Compute closeness centrality for nodes.\n\nCloseness centrality [1]_ of a node `u` is the reciprocal of the\naverage shortest path distance to `u` over all `n-1` reachable nodes.\n\n.. math::\n\n    C(u) = \\frac{n - 1}{\\sum_{v=1}^{n-1} d(v, u)},\n\nwhere `d(v, u)` is the shortest-path distance between `v` and `u`,\nand `n-1` is the number of nodes reachable from `u`. Notice that the\ncloseness distance function computes the incoming distance to `u`\nfor directed graphs. To use outward distance, act on `G.reverse()`.\n\nNotice that higher values of closeness indicate higher centrality.\n\nWasserman and Faust propose an improved formula for graphs with\nmore than one connected component. The result is \"a ratio of the\nfraction of actors in the group who are reachable, to the average\ndistance\" from the reachable actors [2]_. You might think this\nscale factor is inverted but it is not. As is, nodes from small\ncomponents receive a smaller closeness value. Letting `N` denote\nthe number of nodes in the graph,\n\n.. math::\n\n    C_{WF}(u) = \\frac{n-1}{N-1} \\frac{n - 1}{\\sum_{v=1}^{n-1} d(v, u)},\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nu : node, optional\n  Return only the value for node u\n\ndistance : edge attribute key, optional (default=None)\n  Use the specified edge attribute as the edge distance in shortest\n  path calculations.  If `None` (the default) all edges have a distance of 1.\n  Absent edge attributes are assigned a distance of 1. Note that no check\n  is performed to ensure that edges have the provided attribute.\n\nwf_improved : bool, optional (default=True)\n  If True, scale by the fraction of nodes reachable. This gives the\n  Wasserman and Faust improved formula. For single component graphs\n  it is the same as the original formula.\n\nReturns\n-------\nnodes : dictionary\n  Dictionary of nodes with closeness centrality as the value.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n>>> nx.closeness_centrality(G)\n{0: 1.0, 1: 1.0, 2: 0.75, 3: 0.75}\n\nSee Also\n--------\nbetweenness_centrality, load_centrality, eigenvector_centrality,\ndegree_centrality, incremental_closeness_centrality\n\nNotes\n-----\nThe closeness centrality is normalized to `(n-1)/(|G|-1)` where\n`n` is the number of nodes in the connected part of graph\ncontaining the node.  If the graph is not completely connected,\nthis algorithm computes the closeness centrality for each\nconnected part separately scaled by that parts size.\n\nIf the 'distance' keyword is set to an edge attribute key then the\nshortest-path length will be computed using Dijkstra's algorithm with\nthat edge attribute as the edge weight.\n\nThe closeness centrality uses *inward* distance to a node, not outward.\nIf you want to use outword distances apply the function to `G.reverse()`\n\nIn NetworkX 2.2 and earlier a bug caused Dijkstra's algorithm to use the\noutward distance rather than the inward distance. If you use a 'distance'\nkeyword and a DiGraph, your results will change between v2.2 and v2.3.\n\nReferences\n----------\n.. [1] Linton C. Freeman: Centrality in networks: I.\n   Conceptual clarification. Social Networks 1:215-239, 1979.\n   https://doi.org/10.1016/0378-8733(78)90021-7\n.. [2] pg. 201 of Wasserman, S. and Faust, K.,\n   Social Network Analysis: Methods and Applications, 1994,\n   Cambridge University Press."}, {"type": "function", "name": "networkx.closeness_vitality", "documentation": "Returns the closeness vitality for nodes in the graph.\n\nThe *closeness vitality* of a node, defined in Section 3.6.2 of [1],\nis the change in the sum of distances between all node pairs when\nexcluding that node.\n\nParameters\n----------\nG : NetworkX graph\n    A strongly-connected graph.\n\nweight : string\n    The name of the edge attribute used as weight. This is passed\n    directly to the :func:`~networkx.wiener_index` function.\n\nnode : object\n    If specified, only the closeness vitality for this node will be\n    returned. Otherwise, a dictionary mapping each node to its\n    closeness vitality will be returned.\n\nOther parameters\n----------------\nwiener_index : number\n    If you have already computed the Wiener index of the graph\n    `G`, you can provide that value here. Otherwise, it will be\n    computed for you.\n\nReturns\n-------\ndictionary or float\n    If `node` is None, this function returns a dictionary\n    with nodes as keys and closeness vitality as the\n    value. Otherwise, it returns only the closeness vitality for the\n    specified `node`.\n\n    The closeness vitality of a node may be negative infinity if\n    removing that node would disconnect the graph.\n\nExamples\n--------\n>>> G = nx.cycle_graph(3)\n>>> nx.closeness_vitality(G)\n{0: 2.0, 1: 2.0, 2: 2.0}\n\nSee Also\n--------\ncloseness_centrality\n\nReferences\n----------\n.. [1] Ulrik Brandes, Thomas Erlebach (eds.).\n       *Network Analysis: Methodological Foundations*.\n       Springer, 2005.\n       <http://books.google.com/books?id=TTNhSm7HYrIC>"}, {"type": "function", "name": "networkx.clustering", "documentation": "Compute the clustering coefficient for nodes.\n\nFor unweighted graphs, the clustering of a node :math:`u`\nis the fraction of possible triangles through that node that exist,\n\n.. math::\n\n  c_u = \\frac{2 T(u)}{deg(u)(deg(u)-1)},\n\nwhere :math:`T(u)` is the number of triangles through node :math:`u` and\n:math:`deg(u)` is the degree of :math:`u`.\n\nFor weighted graphs, there are several ways to define clustering [1]_.\nthe one used here is defined\nas the geometric average of the subgraph edge weights [2]_,\n\n.. math::\n\n   c_u = \\frac{1}{deg(u)(deg(u)-1))}\n         \\sum_{vw} (\\hat{w}_{uv} \\hat{w}_{uw} \\hat{w}_{vw})^{1/3}.\n\nThe edge weights :math:`\\hat{w}_{uv}` are normalized by the maximum weight\nin the network :math:`\\hat{w}_{uv} = w_{uv}/\\max(w)`.\n\nThe value of :math:`c_u` is assigned to 0 if :math:`deg(u) < 2`.\n\nAdditionally, this weighted definition has been generalized to support negative edge weights [3]_.\n\nFor directed graphs, the clustering is similarly defined as the fraction\nof all possible directed triangles or geometric average of the subgraph\nedge weights for unweighted and weighted directed graph respectively [4]_.\n\n.. math::\n\n   c_u = \\frac{T(u)}{2(deg^{tot}(u)(deg^{tot}(u)-1) - 2deg^{\\leftrightarrow}(u))},\n\nwhere :math:`T(u)` is the number of directed triangles through node\n:math:`u`, :math:`deg^{tot}(u)` is the sum of in degree and out degree of\n:math:`u` and :math:`deg^{\\leftrightarrow}(u)` is the reciprocal degree of\n:math:`u`.\n\n\nParameters\n----------\nG : graph\n\nnodes : node, iterable of nodes, or None (default=None)\n    If a singleton node, return the number of triangles for that node.\n    If an iterable, compute the number of triangles for each of those nodes.\n    If `None` (the default) compute the number of triangles for all nodes in `G`.\n\nweight : string or None, optional (default=None)\n   The edge attribute that holds the numerical value used as a weight.\n   If None, then each edge has weight 1.\n\nReturns\n-------\nout : float, or dictionary\n   Clustering coefficient at specified nodes\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> print(nx.clustering(G, 0))\n1.0\n>>> print(nx.clustering(G))\n{0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}\n\nNotes\n-----\nSelf loops are ignored.\n\nReferences\n----------\n.. [1] Generalizations of the clustering coefficient to weighted\n   complex networks by J. Saram\u00e4ki, M. Kivel\u00e4, J.-P. Onnela,\n   K. Kaski, and J. Kert\u00e9sz, Physical Review E, 75 027105 (2007).\n   http://jponnela.com/web_documents/a9.pdf\n.. [2] Intensity and coherence of motifs in weighted complex\n   networks by J. P. Onnela, J. Saram\u00e4ki, J. Kert\u00e9sz, and K. Kaski,\n   Physical Review E, 71(6), 065103 (2005).\n.. [3] Generalization of Clustering Coefficients to Signed Correlation Networks\n   by G. Costantini and M. Perugini, PloS one, 9(2), e88669 (2014).\n.. [4] Clustering in complex directed networks by G. Fagiolo,\n   Physical Review E, 76(2), 026107 (2007)."}, {"type": "function", "name": "networkx.cn_soundarajan_hopcroft", "documentation": "Count the number of common neighbors of all node pairs in ebunch\n    using community information.\n\nFor two nodes $u$ and $v$, this function computes the number of\ncommon neighbors and bonus one for each common neighbor belonging to\nthe same community as $u$ and $v$. Mathematically,\n\n.. math::\n\n    |\\Gamma(u) \\cap \\Gamma(v)| + \\sum_{w \\in \\Gamma(u) \\cap \\Gamma(v)} f(w)\n\nwhere $f(w)$ equals 1 if $w$ belongs to the same community as $u$\nand $v$ or 0 otherwise and $\\Gamma(u)$ denotes the set of\nneighbors of $u$.\n\nParameters\n----------\nG : graph\n    A NetworkX undirected graph.\n\nebunch : iterable of node pairs, optional (default = None)\n    The score will be computed for each pair of nodes given in the\n    iterable. The pairs must be given as 2-tuples (u, v) where u\n    and v are nodes in the graph. If ebunch is None then all\n    nonexistent edges in the graph will be used.\n    Default value: None.\n\ncommunity : string, optional (default = 'community')\n    Nodes attribute name containing the community information.\n    G[u][community] identifies which community u belongs to. Each\n    node belongs to at most one community. Default value: 'community'.\n\nReturns\n-------\npiter : iterator\n    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\n    pair of nodes and p is their score.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is a `DiGraph`, a `Multigraph` or a `MultiDiGraph`.\n\nNetworkXAlgorithmError\n    If no community information is available for a node in `ebunch` or in `G` (if `ebunch` is `None`).\n\nNodeNotFound\n    If `ebunch` has a node that is not in `G`.\n\nExamples\n--------\n>>> G = nx.path_graph(3)\n>>> G.nodes[0][\"community\"] = 0\n>>> G.nodes[1][\"community\"] = 0\n>>> G.nodes[2][\"community\"] = 0\n>>> preds = nx.cn_soundarajan_hopcroft(G, [(0, 2)])\n>>> for u, v, p in preds:\n...     print(f\"({u}, {v}) -> {p}\")\n(0, 2) -> 2\n\nReferences\n----------\n.. [1] Sucheta Soundarajan and John Hopcroft.\n   Using community information to improve the precision of link\n   prediction methods.\n   In Proceedings of the 21st international conference companion on\n   World Wide Web (WWW '12 Companion). ACM, New York, NY, USA, 607-608.\n   http://doi.acm.org/10.1145/2187980.2188150"}, {"type": "function", "name": "networkx.combinatorial_embedding_to_pos", "documentation": "Assigns every node a (x, y) position based on the given embedding\n\nThe algorithm iteratively inserts nodes of the input graph in a certain\norder and rearranges previously inserted nodes so that the planar drawing\nstays valid. This is done efficiently by only maintaining relative\npositions during the node placements and calculating the absolute positions\nat the end. For more information see [1]_.\n\nParameters\n----------\nembedding : nx.PlanarEmbedding\n    This defines the order of the edges\n\nfully_triangulate : bool\n    If set to True the algorithm adds edges to a copy of the input\n    embedding and makes it chordal.\n\nReturns\n-------\npos : dict\n    Maps each node to a tuple that defines the (x, y) position\n\nReferences\n----------\n.. [1] M. Chrobak and T.H. Payne:\n    A Linear-time Algorithm for Drawing a Planar Graph on a Grid 1989\n    http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.6677"}, {"type": "function", "name": "networkx.common_neighbor_centrality", "documentation": "Return the CCPA score for each pair of nodes.\n\nCompute the Common Neighbor and Centrality based Parameterized Algorithm(CCPA)\nscore of all node pairs in ebunch.\n\nCCPA score of `u` and `v` is defined as\n\n.. math::\n\n    \\alpha \\cdot (|\\Gamma (u){\\cap }^{}\\Gamma (v)|)+(1-\\alpha )\\cdot \\frac{N}{{d}_{uv}}\n\nwhere $\\Gamma(u)$ denotes the set of neighbors of $u$, $\\Gamma(v)$ denotes the\nset of neighbors of $v$, $\\alpha$ is  parameter varies between [0,1], $N$ denotes\ntotal number of nodes in the Graph and ${d}_{uv}$ denotes shortest distance\nbetween $u$ and $v$.\n\nThis algorithm is based on two vital properties of nodes, namely the number\nof common neighbors and their centrality. Common neighbor refers to the common\nnodes between two nodes. Centrality refers to the prestige that a node enjoys\nin a network.\n\n.. seealso::\n\n    :func:`common_neighbors`\n\nParameters\n----------\nG : graph\n    NetworkX undirected graph.\n\nebunch : iterable of node pairs, optional (default = None)\n    Preferential attachment score will be computed for each pair of\n    nodes given in the iterable. The pairs must be given as\n    2-tuples (u, v) where u and v are nodes in the graph. If ebunch\n    is None then all nonexistent edges in the graph will be used.\n    Default value: None.\n\nalpha : Parameter defined for participation of Common Neighbor\n        and Centrality Algorithm share. Values for alpha should\n        normally be between 0 and 1. Default value set to 0.8\n        because author found better performance at 0.8 for all the\n        dataset.\n        Default value: 0.8\n\n\nReturns\n-------\npiter : iterator\n    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\n    pair of nodes and p is their Common Neighbor and Centrality based\n    Parameterized Algorithm(CCPA) score.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is a `DiGraph`, a `Multigraph` or a `MultiDiGraph`.\n\nNetworkXAlgorithmError\n    If self loops exsists in `ebunch` or in `G` (if `ebunch` is `None`).\n\nNodeNotFound\n    If `ebunch` has a node that is not in `G`.\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> preds = nx.common_neighbor_centrality(G, [(0, 1), (2, 3)])\n>>> for u, v, p in preds:\n...     print(f\"({u}, {v}) -> {p}\")\n(0, 1) -> 3.4000000000000004\n(2, 3) -> 3.4000000000000004\n\nReferences\n----------\n.. [1] Ahmad, I., Akhtar, M.U., Noor, S. et al.\n       Missing Link Prediction using Common Neighbor and Centrality based Parameterized Algorithm.\n       Sci Rep 10, 364 (2020).\n       https://doi.org/10.1038/s41598-019-57304-y"}, {"type": "function", "name": "networkx.common_neighbors", "documentation": "Returns the common neighbors of two nodes in a graph.\n\nParameters\n----------\nG : graph\n    A NetworkX undirected graph.\n\nu, v : nodes\n    Nodes in the graph.\n\nReturns\n-------\ncnbors : set\n    Set of common neighbors of u and v in the graph.\n\nRaises\n------\nNetworkXError\n    If u or v is not a node in the graph.\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> sorted(nx.common_neighbors(G, 0, 1))\n[2, 3, 4]"}, {"type": "function", "name": "networkx.communicability", "documentation": "Returns communicability between all pairs of nodes in G.\n\nThe communicability between pairs of nodes in G is the sum of\nwalks of different lengths starting at node u and ending at node v.\n\nParameters\n----------\nG: graph\n\nReturns\n-------\ncomm: dictionary of dictionaries\n    Dictionary of dictionaries keyed by nodes with communicability\n    as the value.\n\nRaises\n------\nNetworkXError\n   If the graph is not undirected and simple.\n\nSee Also\n--------\ncommunicability_exp:\n   Communicability between all pairs of nodes in G  using spectral\n   decomposition.\ncommunicability_betweenness_centrality:\n   Communicability betweenness centrality for each node in G.\n\nNotes\n-----\nThis algorithm uses a spectral decomposition of the adjacency matrix.\nLet G=(V,E) be a simple undirected graph.  Using the connection between\nthe powers  of the adjacency matrix and the number of walks in the graph,\nthe communicability  between nodes `u` and `v` based on the graph spectrum\nis [1]_\n\n.. math::\n    C(u,v)=\\sum_{j=1}^{n}\\phi_{j}(u)\\phi_{j}(v)e^{\\lambda_{j}},\n\nwhere `\\phi_{j}(u)` is the `u\\rm{th}` element of the `j\\rm{th}` orthonormal\neigenvector of the adjacency matrix associated with the eigenvalue\n`\\lambda_{j}`.\n\nReferences\n----------\n.. [1] Ernesto Estrada, Naomichi Hatano,\n   \"Communicability in complex networks\",\n   Phys. Rev. E 77, 036111 (2008).\n   https://arxiv.org/abs/0707.0756\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\n>>> c = nx.communicability(G)"}, {"type": "function", "name": "networkx.communicability_betweenness_centrality", "documentation": "Returns subgraph communicability for all pairs of nodes in G.\n\nCommunicability betweenness measure makes use of the number of walks\nconnecting every pair of nodes as the basis of a betweenness centrality\nmeasure.\n\nParameters\n----------\nG: graph\n\nReturns\n-------\nnodes : dictionary\n    Dictionary of nodes with communicability betweenness as the value.\n\nRaises\n------\nNetworkXError\n    If the graph is not undirected and simple.\n\nNotes\n-----\nLet `G=(V,E)` be a simple undirected graph with `n` nodes and `m` edges,\nand `A` denote the adjacency matrix of `G`.\n\nLet `G(r)=(V,E(r))` be the graph resulting from\nremoving all edges connected to node `r` but not the node itself.\n\nThe adjacency matrix for `G(r)` is `A+E(r)`,  where `E(r)` has nonzeros\nonly in row and column `r`.\n\nThe subraph betweenness of a node `r`  is [1]_\n\n.. math::\n\n     \\omega_{r} = \\frac{1}{C}\\sum_{p}\\sum_{q}\\frac{G_{prq}}{G_{pq}},\n     p\\neq q, q\\neq r,\n\nwhere\n`G_{prq}=(e^{A}_{pq} - (e^{A+E(r)})_{pq}`  is the number of walks\ninvolving node r,\n`G_{pq}=(e^{A})_{pq}` is the number of closed walks starting\nat node `p` and ending at node `q`,\nand `C=(n-1)^{2}-(n-1)` is a normalization factor equal to the\nnumber of terms in the sum.\n\nThe resulting `\\omega_{r}` takes values between zero and one.\nThe lower bound cannot be attained for a connected\ngraph, and the upper bound is attained in the star graph.\n\nReferences\n----------\n.. [1] Ernesto Estrada, Desmond J. Higham, Naomichi Hatano,\n   \"Communicability Betweenness in Complex Networks\"\n   Physica A 388 (2009) 764-774.\n   https://arxiv.org/abs/0905.4102\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\n>>> cbc = nx.communicability_betweenness_centrality(G)\n>>> print([f\"{node} {cbc[node]:0.2f}\" for node in sorted(cbc)])\n['0 0.03', '1 0.45', '2 0.51', '3 0.45', '4 0.40', '5 0.19', '6 0.03']"}, {"type": "function", "name": "networkx.communicability_exp", "documentation": "Returns communicability between all pairs of nodes in G.\n\nCommunicability between pair of node (u,v) of node in G is the sum of\nwalks of different lengths starting at node u and ending at node v.\n\nParameters\n----------\nG: graph\n\nReturns\n-------\ncomm: dictionary of dictionaries\n    Dictionary of dictionaries keyed by nodes with communicability\n    as the value.\n\nRaises\n------\nNetworkXError\n    If the graph is not undirected and simple.\n\nSee Also\n--------\ncommunicability:\n   Communicability between pairs of nodes in G.\ncommunicability_betweenness_centrality:\n   Communicability betweenness centrality for each node in G.\n\nNotes\n-----\nThis algorithm uses matrix exponentiation of the adjacency matrix.\n\nLet G=(V,E) be a simple undirected graph.  Using the connection between\nthe powers  of the adjacency matrix and the number of walks in the graph,\nthe communicability between nodes u and v is [1]_,\n\n.. math::\n    C(u,v) = (e^A)_{uv},\n\nwhere `A` is the adjacency matrix of G.\n\nReferences\n----------\n.. [1] Ernesto Estrada, Naomichi Hatano,\n   \"Communicability in complex networks\",\n   Phys. Rev. E 77, 036111 (2008).\n   https://arxiv.org/abs/0707.0756\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\n>>> c = nx.communicability_exp(G)"}, {"type": "function", "name": "networkx.complement", "documentation": "Returns the graph complement of G.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nReturns\n-------\nGC : A new graph.\n\nNotes\n-----\nNote that `complement` does not create self-loops and also\ndoes not produce parallel edges for MultiGraphs.\n\nGraph, node, and edge data are not propagated to the new graph.\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (3, 5)])\n>>> G_complement = nx.complement(G)\n>>> G_complement.edges()  # This shows the edges of the complemented graph\nEdgeView([(1, 4), (1, 5), (2, 4), (2, 5), (4, 5)])"}, {"type": "function", "name": "networkx.complete_bipartite_graph", "documentation": "Returns the complete bipartite graph `K_{n_1,n_2}`.\n\nThe graph is composed of two partitions with nodes 0 to (n1 - 1)\nin the first and nodes n1 to (n1 + n2 - 1) in the second.\nEach node in the first is connected to each node in the second.\n\nParameters\n----------\nn1, n2 : integer or iterable container of nodes\n    If integers, nodes are from `range(n1)` and `range(n1, n1 + n2)`.\n    If a container, the elements are the nodes.\ncreate_using : NetworkX graph instance, (default: nx.Graph)\n   Return graph of this type.\n\nNotes\n-----\nNodes are the integers 0 to `n1 + n2 - 1` unless either n1 or n2 are\ncontainers of nodes. If only one of n1 or n2 are integers, that\ninteger is replaced by `range` of that integer.\n\nThe nodes are assigned the attribute 'bipartite' with the value 0 or 1\nto indicate which bipartite set the node belongs to.\n\nThis function is not imported in the main namespace.\nTo use it use nx.bipartite.complete_bipartite_graph"}, {"type": "function", "name": "networkx.complete_graph", "documentation": "Return the complete graph `K_n` with n nodes.\n\nA complete graph on `n` nodes means that all pairs\nof distinct nodes have an edge connecting them.\n\n.. plot::\n\n    >>> nx.draw(nx.complete_graph(5))\n\nParameters\n----------\nn : int or iterable container of nodes\n    If n is an integer, nodes are from range(n).\n    If n is a container of nodes, those nodes appear in the graph.\n    Warning: n is not checked for duplicates and if present the\n    resulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nExamples\n--------\n>>> G = nx.complete_graph(9)\n>>> len(G)\n9\n>>> G.size()\n36\n>>> G = nx.complete_graph(range(11, 14))\n>>> list(G.nodes())\n[11, 12, 13]\n>>> G = nx.complete_graph(4, nx.DiGraph())\n>>> G.is_directed()\nTrue"}, {"type": "function", "name": "networkx.complete_multipartite_graph", "documentation": "Returns the complete multipartite graph with the specified subset sizes.\n\n.. plot::\n\n    >>> nx.draw(nx.complete_multipartite_graph(1, 2, 3))\n\nParameters\n----------\nsubset_sizes : tuple of integers or tuple of node iterables\n   The arguments can either all be integer number of nodes or they\n   can all be iterables of nodes. If integers, they represent the\n   number of nodes in each subset of the multipartite graph.\n   If iterables, each is used to create the nodes for that subset.\n   The length of subset_sizes is the number of subsets.\n\nReturns\n-------\nG : NetworkX Graph\n   Returns the complete multipartite graph with the specified subsets.\n\n   For each node, the node attribute 'subset' is an integer\n   indicating which subset contains the node.\n\nExamples\n--------\nCreating a complete tripartite graph, with subsets of one, two, and three\nnodes, respectively.\n\n    >>> G = nx.complete_multipartite_graph(1, 2, 3)\n    >>> [G.nodes[u][\"subset\"] for u in G]\n    [0, 1, 1, 2, 2, 2]\n    >>> list(G.edges(0))\n    [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]\n    >>> list(G.edges(2))\n    [(2, 0), (2, 3), (2, 4), (2, 5)]\n    >>> list(G.edges(4))\n    [(4, 0), (4, 1), (4, 2)]\n\n    >>> G = nx.complete_multipartite_graph(\"a\", \"bc\", \"def\")\n    >>> [G.nodes[u][\"subset\"] for u in sorted(G)]\n    [0, 1, 1, 2, 2, 2]\n\nNotes\n-----\nThis function generalizes several other graph builder functions.\n\n- If no subset sizes are given, this returns the null graph.\n- If a single subset size `n` is given, this returns the empty graph on\n  `n` nodes.\n- If two subset sizes `m` and `n` are given, this returns the complete\n  bipartite graph on `m + n` nodes.\n- If subset sizes `1` and `n` are given, this returns the star graph on\n  `n + 1` nodes.\n\nSee also\n--------\ncomplete_bipartite_graph"}, {"type": "function", "name": "networkx.complete_to_chordal_graph", "documentation": "Return a copy of G completed to a chordal graph\n\nAdds edges to a copy of G to create a chordal graph. A graph G=(V,E) is\ncalled chordal if for each cycle with length bigger than 3, there exist\ntwo non-adjacent nodes connected by an edge (called a chord).\n\nParameters\n----------\nG : NetworkX graph\n    Undirected graph\n\nReturns\n-------\nH : NetworkX graph\n    The chordal enhancement of G\nalpha : Dictionary\n        The elimination ordering of nodes of G\n\nNotes\n-----\nThere are different approaches to calculate the chordal\nenhancement of a graph. The algorithm used here is called\nMCS-M and gives at least minimal (local) triangulation of graph. Note\nthat this triangulation is not necessarily a global minimum.\n\nhttps://en.wikipedia.org/wiki/Chordal_graph\n\nReferences\n----------\n.. [1] Berry, Anne & Blair, Jean & Heggernes, Pinar & Peyton, Barry. (2004)\n       Maximum Cardinality Search for Computing Minimal Triangulations of\n       Graphs.  Algorithmica. 39. 287-298. 10.1007/s00453-004-1084-3.\n\nExamples\n--------\n>>> from networkx.algorithms.chordal import complete_to_chordal_graph\n>>> G = nx.wheel_graph(10)\n>>> H, alpha = complete_to_chordal_graph(G)"}, {"type": "function", "name": "networkx.compose", "documentation": "Compose graph G with H by combining nodes and edges into a single graph.\n\nThe node sets and edges sets do not need to be disjoint.\n\nComposing preserves the attributes of nodes and edges.\nAttribute values from H take precedent over attribute values from G.\n\nParameters\n----------\nG, H : graph\n   A NetworkX graph\n\nReturns\n-------\nC: A new graph with the same type as G\n\nSee Also\n--------\n:func:`~networkx.Graph.update`\nunion\ndisjoint_union\n\nNotes\n-----\nIt is recommended that G and H be either both directed or both undirected.\n\nFor MultiGraphs, the edges are identified by incident nodes AND edge-key.\nThis can cause surprises (i.e., edge `(1, 2)` may or may not be the same\nin two graphs) if you use MultiGraph without keeping track of edge keys.\n\nIf combining the attributes of common nodes is not desired, consider union(),\nwhich raises an exception for name collisions.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2)])\n>>> H = nx.Graph([(0, 1), (1, 2)])\n>>> R = nx.compose(G, H)\n>>> R.nodes\nNodeView((0, 1, 2))\n>>> R.edges\nEdgeView([(0, 1), (0, 2), (1, 2)])\n\nBy default, the attributes from `H` take precedent over attributes from `G`.\nIf you prefer another way of combining attributes, you can update them after the compose operation:\n\n>>> G = nx.Graph([(0, 1, {\"weight\": 2.0}), (3, 0, {\"weight\": 100.0})])\n>>> H = nx.Graph([(0, 1, {\"weight\": 10.0}), (1, 2, {\"weight\": -1.0})])\n>>> nx.set_node_attributes(G, {0: \"dark\", 1: \"light\", 3: \"black\"}, name=\"color\")\n>>> nx.set_node_attributes(H, {0: \"green\", 1: \"orange\", 2: \"yellow\"}, name=\"color\")\n>>> GcomposeH = nx.compose(G, H)\n\nNormally, color attribute values of nodes of GcomposeH come from H. We can workaround this as follows:\n\n>>> node_data = {\n...     n: G.nodes[n][\"color\"] + \" \" + H.nodes[n][\"color\"] for n in G.nodes & H.nodes\n... }\n>>> nx.set_node_attributes(GcomposeH, node_data, \"color\")\n>>> print(GcomposeH.nodes[0][\"color\"])\ndark green\n\n>>> print(GcomposeH.nodes[3][\"color\"])\nblack\n\nSimilarly, we can update edge attributes after the compose operation in a way we prefer:\n\n>>> edge_data = {\n...     e: G.edges[e][\"weight\"] * H.edges[e][\"weight\"] for e in G.edges & H.edges\n... }\n>>> nx.set_edge_attributes(GcomposeH, edge_data, \"weight\")\n>>> print(GcomposeH.edges[(0, 1)][\"weight\"])\n20.0\n\n>>> print(GcomposeH.edges[(3, 0)][\"weight\"])\n100.0"}, {"type": "function", "name": "networkx.compose_all", "documentation": "Returns the composition of all graphs.\n\nComposition is the simple union of the node sets and edge sets.\nThe node sets of the supplied graphs need not be disjoint.\n\nParameters\n----------\ngraphs : iterable\n   Iterable of NetworkX graphs\n\nReturns\n-------\nC : A graph with the same type as the first graph in list\n\nRaises\n------\nValueError\n   If `graphs` is an empty list.\n\nNetworkXError\n    In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs.\n\nExamples\n--------\n>>> G1 = nx.Graph([(1, 2), (2, 3)])\n>>> G2 = nx.Graph([(3, 4), (5, 6)])\n>>> C = nx.compose_all([G1, G2])\n>>> list(C.nodes())\n[1, 2, 3, 4, 5, 6]\n>>> list(C.edges())\n[(1, 2), (2, 3), (3, 4), (5, 6)]\n\nNotes\n-----\nFor operating on mixed type graphs, they should be converted to the same type.\n\nGraph, edge, and node attributes are propagated to the union graph.\nIf a graph attribute is present in multiple graphs, then the value\nfrom the last graph in the list with that attribute is used."}, {"type": "function", "name": "networkx.compute_v_structures", "documentation": "Iterate through the graph to compute all v-structures.\n\nV-structures are triples in the directed graph where\ntwo parent nodes point to the same child and the two parent nodes\nare not adjacent.\n\nParameters\n----------\nG : graph\n    A networkx DiGraph.\n\nReturns\n-------\nvstructs : iterator of tuples\n    The v structures within the graph. Each v structure is a 3-tuple with the\n    parent, collider, and other parent.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_edges_from([(1, 2), (0, 5), (3, 1), (2, 4), (3, 1), (4, 5), (1, 5)])\n>>> sorted(nx.compute_v_structures(G))\n[(0, 5, 1), (0, 5, 4), (1, 5, 4)]\n\nNotes\n-----\n`Wikipedia: Collider in causal graphs <https://en.wikipedia.org/wiki/Collider_(statistics)>`_"}, {"type": "function", "name": "networkx.condensation", "documentation": "Returns the condensation of G.\n\nThe condensation of G is the graph with each of the strongly connected\ncomponents contracted into a single node.\n\nParameters\n----------\nG : NetworkX DiGraph\n   A directed graph.\n\nscc:  list or generator (optional, default=None)\n   Strongly connected components. If provided, the elements in\n   `scc` must partition the nodes in `G`. If not provided, it will be\n   calculated as scc=nx.strongly_connected_components(G).\n\nReturns\n-------\nC : NetworkX DiGraph\n   The condensation graph C of G.  The node labels are integers\n   corresponding to the index of the component in the list of\n   strongly connected components of G.  C has a graph attribute named\n   'mapping' with a dictionary mapping the original nodes to the\n   nodes in C to which they belong.  Each node in C also has a node\n   attribute 'members' with the set of original nodes in G that\n   form the SCC that the node in C represents.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is undirected.\n\nExamples\n--------\nContracting two sets of strongly connected nodes into two distinct SCC\nusing the barbell graph.\n\n>>> G = nx.barbell_graph(4, 0)\n>>> G.remove_edge(3, 4)\n>>> G = nx.DiGraph(G)\n>>> H = nx.condensation(G)\n>>> H.nodes.data()\nNodeDataView({0: {'members': {0, 1, 2, 3}}, 1: {'members': {4, 5, 6, 7}}})\n>>> H.graph[\"mapping\"]\n{0: 0, 1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 1, 7: 1}\n\nContracting a complete graph into one single SCC.\n\n>>> G = nx.complete_graph(7, create_using=nx.DiGraph)\n>>> H = nx.condensation(G)\n>>> H.nodes\nNodeView((0,))\n>>> H.nodes.data()\nNodeDataView({0: {'members': {0, 1, 2, 3, 4, 5, 6}}})\n\nNotes\n-----\nAfter contracting all strongly connected components to a single node,\nthe resulting graph is a directed acyclic graph."}, {"type": "function", "name": "networkx.conductance", "documentation": "Returns the conductance of two sets of nodes.\n\nThe *conductance* is the quotient of the cut size and the smaller of\nthe volumes of the two sets. [1]\n\nParameters\n----------\nG : NetworkX graph\n\nS : collection\n    A collection of nodes in `G`.\n\nT : collection\n    A collection of nodes in `G`.\n\nweight : object\n    Edge attribute key to use as weight. If not specified, edges\n    have weight one.\n\nReturns\n-------\nnumber\n    The conductance between the two sets `S` and `T`.\n\nSee also\n--------\ncut_size\nedge_expansion\nnormalized_cut_size\nvolume\n\nReferences\n----------\n.. [1] David Gleich.\n       *Hierarchical Directed Spectral Graph Partitioning*.\n       <https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf>"}, {"type": "function", "name": "networkx.configuration_model", "documentation": "Returns a random graph with the given degree sequence.\n\nThe configuration model generates a random pseudograph (graph with\nparallel edges and self loops) by randomly assigning edges to\nmatch the given degree sequence.\n\nParameters\n----------\ndeg_sequence :  list of nonnegative integers\n    Each list entry corresponds to the degree of a node.\ncreate_using : NetworkX graph constructor, optional (default MultiGraph)\n    Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : MultiGraph\n    A graph with the specified degree sequence.\n    Nodes are labeled starting at 0 with an index\n    corresponding to the position in deg_sequence.\n\nRaises\n------\nNetworkXError\n    If the degree sequence does not have an even sum.\n\nSee Also\n--------\nis_graphical\n\nNotes\n-----\nAs described by Newman [1]_.\n\nA non-graphical degree sequence (not realizable by some simple\ngraph) is allowed since this function returns graphs with self\nloops and parallel edges.  An exception is raised if the degree\nsequence does not have an even sum.\n\nThis configuration model construction process can lead to\nduplicate edges and loops.  You can remove the self-loops and\nparallel edges (see below) which will likely result in a graph\nthat doesn't have the exact degree sequence specified.\n\nThe density of self-loops and parallel edges tends to decrease as\nthe number of nodes increases. However, typically the number of\nself-loops will approach a Poisson distribution with a nonzero mean,\nand similarly for the number of parallel edges.  Consider a node\nwith *k* stubs. The probability of being joined to another stub of\nthe same node is basically (*k* - *1*) / *N*, where *k* is the\ndegree and *N* is the number of nodes. So the probability of a\nself-loop scales like *c* / *N* for some constant *c*. As *N* grows,\nthis means we expect *c* self-loops. Similarly for parallel edges.\n\nReferences\n----------\n.. [1] M.E.J. Newman, \"The structure and function of complex networks\",\n   SIAM REVIEW 45-2, pp 167-256, 2003.\n\nExamples\n--------\nYou can create a degree sequence following a particular distribution\nby using the one of the distribution functions in\n:mod:`~networkx.utils.random_sequence` (or one of your own). For\nexample, to create an undirected multigraph on one hundred nodes\nwith degree sequence chosen from the power law distribution:\n\n>>> sequence = nx.random_powerlaw_tree_sequence(100, tries=5000)\n>>> G = nx.configuration_model(sequence)\n>>> len(G)\n100\n>>> actual_degrees = [d for v, d in G.degree()]\n>>> actual_degrees == sequence\nTrue\n\nThe returned graph is a multigraph, which may have parallel\nedges. To remove any parallel edges from the returned graph:\n\n>>> G = nx.Graph(G)\n\nSimilarly, to remove self-loops:\n\n>>> G.remove_edges_from(nx.selfloop_edges(G))"}, {"type": "function", "name": "networkx.connected_caveman_graph", "documentation": "Returns a connected caveman graph of `l` cliques of size `k`.\n\nThe connected caveman graph is formed by creating `n` cliques of size\n`k`, then a single edge in each clique is rewired to a node in an\nadjacent clique.\n\nParameters\n----------\nl : int\n  number of cliques\nk : int\n  size of cliques (k at least 2 or NetworkXError is raised)\n\nReturns\n-------\nG : NetworkX Graph\n  connected caveman graph\n\nRaises\n------\nNetworkXError\n    If the size of cliques `k` is smaller than 2.\n\nNotes\n-----\nThis returns an undirected graph, it can be converted to a directed\ngraph using :func:`nx.to_directed`, or a multigraph using\n``nx.MultiGraph(nx.caveman_graph(l, k))``. Only the undirected version is\ndescribed in [1]_ and it is unclear which of the directed\ngeneralizations is most useful.\n\nExamples\n--------\n>>> G = nx.connected_caveman_graph(3, 3)\n\nReferences\n----------\n.. [1] Watts, D. J. 'Networks, Dynamics, and the Small-World Phenomenon.'\n   Amer. J. Soc. 105, 493-527, 1999."}, {"type": "function", "name": "networkx.connected_components", "documentation": "Generate connected components.\n\nParameters\n----------\nG : NetworkX graph\n   An undirected graph\n\nReturns\n-------\ncomp : generator of sets\n   A generator of sets of nodes, one for each component of G.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is directed.\n\nExamples\n--------\nGenerate a sorted list of connected components, largest first.\n\n>>> G = nx.path_graph(4)\n>>> nx.add_path(G, [10, 11, 12])\n>>> [len(c) for c in sorted(nx.connected_components(G), key=len, reverse=True)]\n[4, 3]\n\nIf you only want the largest connected component, it's more\nefficient to use max instead of sort.\n\n>>> largest_cc = max(nx.connected_components(G), key=len)\n\nTo create the induced subgraph of each component use:\n\n>>> S = [G.subgraph(c).copy() for c in nx.connected_components(G)]\n\nSee Also\n--------\nstrongly_connected_components\nweakly_connected_components\n\nNotes\n-----\nFor undirected graphs only."}, {"type": "function", "name": "networkx.connected_double_edge_swap", "documentation": "Attempts the specified number of double-edge swaps in the graph `G`.\n\nA double-edge swap removes two randomly chosen edges `(u, v)` and `(x,\ny)` and creates the new edges `(u, x)` and `(v, y)`::\n\n u--v            u  v\n        becomes  |  |\n x--y            x  y\n\nIf either `(u, x)` or `(v, y)` already exist, then no swap is performed\nso the actual number of swapped edges is always *at most* `nswap`.\n\nParameters\n----------\nG : graph\n   An undirected graph\n\nnswap : integer (optional, default=1)\n   Number of double-edge swaps to perform\n\n_window_threshold : integer\n\n   The window size below which connectedness of the graph will be checked\n   after each swap.\n\n   The \"window\" in this function is a dynamically updated integer that\n   represents the number of swap attempts to make before checking if the\n   graph remains connected. It is an optimization used to decrease the\n   running time of the algorithm in exchange for increased complexity of\n   implementation.\n\n   If the window size is below this threshold, then the algorithm checks\n   after each swap if the graph remains connected by checking if there is a\n   path joining the two nodes whose edge was just removed. If the window\n   size is above this threshold, then the algorithm performs do all the\n   swaps in the window and only then check if the graph is still connected.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nint\n   The number of successful swaps\n\nRaises\n------\n\nNetworkXError\n\n   If the input graph is not connected, or if the graph has fewer than four\n   nodes.\n\nNotes\n-----\n\nThe initial graph `G` must be connected, and the resulting graph is\nconnected. The graph `G` is modified in place.\n\nReferences\n----------\n.. [1] C. Gkantsidis and M. Mihail and E. Zegura,\n       The Markov chain simulation method for generating connected\n       power law random graphs, 2003.\n       http://citeseer.ist.psu.edu/gkantsidis03markov.html"}, {"type": "function", "name": "networkx.connected_watts_strogatz_graph", "documentation": "Returns a connected Watts\u2013Strogatz small-world graph.\n\nAttempts to generate a connected graph by repeated generation of\nWatts\u2013Strogatz small-world graphs.  An exception is raised if the maximum\nnumber of tries is exceeded.\n\nParameters\n----------\nn : int\n    The number of nodes\nk : int\n    Each node is joined with its `k` nearest neighbors in a ring\n    topology.\np : float\n    The probability of rewiring each edge\ntries : int\n    Number of attempts to generate a connected graph.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nNotes\n-----\nFirst create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\nto its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\nThen shortcuts are created by replacing some edges as follows: for each\nedge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\nwith probability $p$ replace it with a new edge $(u, w)$ with uniformly\nrandom choice of existing node $w$.\nThe entire process is repeated until a connected graph results.\n\nSee Also\n--------\nnewman_watts_strogatz_graph\nwatts_strogatz_graph\n\nReferences\n----------\n.. [1] Duncan J. Watts and Steven H. Strogatz,\n   Collective dynamics of small-world networks,\n   Nature, 393, pp. 440--442, 1998."}, {"type": "function", "name": "networkx.constraint", "documentation": "Returns the constraint on all nodes in the graph ``G``.\n\nThe *constraint* is a measure of the extent to which a node *v* is\ninvested in those nodes that are themselves invested in the\nneighbors of *v*. Formally, the *constraint on v*, denoted `c(v)`,\nis defined by\n\n.. math::\n\n   c(v) = \\sum_{w \\in N(v) \\setminus \\{v\\}} \\ell(v, w)\n\nwhere $N(v)$ is the subset of the neighbors of `v` that are either\npredecessors or successors of `v` and $\\ell(v, w)$ is the local\nconstraint on `v` with respect to `w` [1]_. For the definition of local\nconstraint, see :func:`local_constraint`.\n\nParameters\n----------\nG : NetworkX graph\n    The graph containing ``v``. This can be either directed or undirected.\n\nnodes : container, optional\n    Container of nodes in the graph ``G`` to compute the constraint. If\n    None, the constraint of every node is computed.\n\nweight : None or string, optional\n  If None, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n\nReturns\n-------\ndict\n    Dictionary with nodes as keys and the constraint on the node as values.\n\nSee also\n--------\nlocal_constraint\n\nReferences\n----------\n.. [1] Burt, Ronald S.\n       \"Structural holes and good ideas\".\n       American Journal of Sociology (110): 349\u2013399."}, {"type": "function", "name": "networkx.contracted_edge", "documentation": "Returns the graph that results from contracting the specified edge.\n\nEdge contraction identifies the two endpoints of the edge as a single node\nincident to any edge that was incident to the original two nodes. A graph\nthat results from edge contraction is called a *minor* of the original\ngraph.\n\nParameters\n----------\nG : NetworkX graph\n   The graph whose edge will be contracted.\n\nedge : tuple\n   Must be a pair of nodes in `G`.\n\nself_loops : Boolean\n   If this is True, any edges (including `edge`) joining the\n   endpoints of `edge` in `G` become self-loops on the new node in the\n   returned graph.\n\ncopy : Boolean (default True)\n    If this is True, a the contraction will be performed on a copy of `G`,\n    otherwise the contraction will happen in place.\n\nReturns\n-------\nNetworkx graph\n   A new graph object of the same type as `G` (leaving `G` unmodified)\n   with endpoints of `edge` identified in a single node. The right node\n   of `edge` will be merged into the left one, so only the left one will\n   appear in the returned graph.\n\nRaises\n------\nValueError\n   If `edge` is not an edge in `G`.\n\nExamples\n--------\nAttempting to contract two nonadjacent nodes yields an error:\n\n>>> G = nx.cycle_graph(4)\n>>> nx.contracted_edge(G, (1, 3))\nTraceback (most recent call last):\n  ...\nValueError: Edge (1, 3) does not exist in graph G; cannot contract it\n\nContracting two adjacent nodes in the cycle graph on *n* nodes yields the\ncycle graph on *n - 1* nodes:\n\n>>> C5 = nx.cycle_graph(5)\n>>> C4 = nx.cycle_graph(4)\n>>> M = nx.contracted_edge(C5, (0, 1), self_loops=False)\n>>> nx.is_isomorphic(M, C4)\nTrue\n\nSee also\n--------\ncontracted_nodes\nquotient_graph"}, {"type": "function", "name": "networkx.contracted_nodes", "documentation": "Returns the graph that results from contracting `u` and `v`.\n\nNode contraction identifies the two nodes as a single node incident to any\nedge that was incident to the original two nodes.\n\nParameters\n----------\nG : NetworkX graph\n    The graph whose nodes will be contracted.\n\nu, v : nodes\n    Must be nodes in `G`.\n\nself_loops : Boolean\n    If this is True, any edges joining `u` and `v` in `G` become\n    self-loops on the new node in the returned graph.\n\ncopy : Boolean\n    If this is True (default True), make a copy of\n    `G` and return that instead of directly changing `G`.\n\n\nReturns\n-------\nNetworkx graph\n    If Copy is True,\n    A new graph object of the same type as `G` (leaving `G` unmodified)\n    with `u` and `v` identified in a single node. The right node `v`\n    will be merged into the node `u`, so only `u` will appear in the\n    returned graph.\n    If copy is False,\n    Modifies `G` with `u` and `v` identified in a single node.\n    The right node `v` will be merged into the node `u`, so\n    only `u` will appear in the returned graph.\n\nNotes\n-----\nFor multigraphs, the edge keys for the realigned edges may\nnot be the same as the edge keys for the old edges. This is\nnatural because edge keys are unique only within each pair of nodes.\n\nFor non-multigraphs where `u` and `v` are adjacent to a third node\n`w`, the edge (`v`, `w`) will be contracted into the edge (`u`,\n`w`) with its attributes stored into a \"contraction\" attribute.\n\nThis function is also available as `identified_nodes`.\n\nExamples\n--------\nContracting two nonadjacent nodes of the cycle graph on four nodes `C_4`\nyields the path graph (ignoring parallel edges):\n\n>>> G = nx.cycle_graph(4)\n>>> M = nx.contracted_nodes(G, 1, 3)\n>>> P3 = nx.path_graph(3)\n>>> nx.is_isomorphic(M, P3)\nTrue\n\n>>> G = nx.MultiGraph(P3)\n>>> M = nx.contracted_nodes(G, 0, 2)\n>>> M.edges\nMultiEdgeView([(0, 1, 0), (0, 1, 1)])\n\n>>> G = nx.Graph([(1, 2), (2, 2)])\n>>> H = nx.contracted_nodes(G, 1, 2, self_loops=False)\n>>> list(H.nodes())\n[1]\n>>> list(H.edges())\n[(1, 1)]\n\nIn a ``MultiDiGraph`` with a self loop, the in and out edges will\nbe treated separately as edges, so while contracting a node which\nhas a self loop the contraction will add multiple edges:\n\n>>> G = nx.MultiDiGraph([(1, 2), (2, 2)])\n>>> H = nx.contracted_nodes(G, 1, 2)\n>>> list(H.edges())  # edge 1->2, 2->2, 2<-2 from the original Graph G\n[(1, 1), (1, 1), (1, 1)]\n>>> H = nx.contracted_nodes(G, 1, 2, self_loops=False)\n>>> list(H.edges())  # edge 2->2, 2<-2 from the original Graph G\n[(1, 1), (1, 1)]\n\nSee Also\n--------\ncontracted_edge\nquotient_graph"}, {"type": "function", "name": "networkx.convert_node_labels_to_integers", "documentation": "Returns a copy of the graph G with the nodes relabeled using\nconsecutive integers.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nfirst_label : int, optional (default=0)\n   An integer specifying the starting offset in numbering nodes.\n   The new integer labels are numbered first_label, ..., n-1+first_label.\n\nordering : string\n   \"default\" : inherit node ordering from G.nodes()\n   \"sorted\"  : inherit node ordering from sorted(G.nodes())\n   \"increasing degree\" : nodes are sorted by increasing degree\n   \"decreasing degree\" : nodes are sorted by decreasing degree\n\nlabel_attribute : string, optional (default=None)\n   Name of node attribute to store old label.  If None no attribute\n   is created.\n\nNotes\n-----\nNode and edge attribute data are copied to the new (relabeled) graph.\n\nThere is no guarantee that the relabeling of nodes to integers will\ngive the same two integers for two (even identical graphs).\nUse the `ordering` argument to try to preserve the order.\n\nSee Also\n--------\nrelabel_nodes"}, {"type": "function", "name": "networkx.core_number", "documentation": "Returns the core number for each node.\n\nA k-core is a maximal subgraph that contains nodes of degree k or more.\n\nThe core number of a node is the largest value k of a k-core containing\nthat node.\n\nParameters\n----------\nG : NetworkX graph\n   An undirected or directed graph\n\nReturns\n-------\ncore_number : dictionary\n   A dictionary keyed by node to the core number.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is a multigraph or contains self loops.\n\nNotes\n-----\nFor directed graphs the node degree is defined to be the\nin-degree + out-degree.\n\nExamples\n--------\n>>> degrees = [0, 1, 2, 2, 2, 2, 3]\n>>> H = nx.havel_hakimi_graph(degrees)\n>>> nx.core_number(H)\n{0: 1, 1: 2, 2: 2, 3: 2, 4: 1, 5: 2, 6: 0}\n>>> G = nx.DiGraph()\n>>> G.add_edges_from([(1, 2), (2, 1), (2, 3), (2, 4), (3, 4), (4, 3)])\n>>> nx.core_number(G)\n{1: 2, 2: 2, 3: 2, 4: 2}\n\nReferences\n----------\n.. [1] An O(m) Algorithm for Cores Decomposition of Networks\n   Vladimir Batagelj and Matjaz Zaversnik, 2003.\n   https://arxiv.org/abs/cs.DS/0310049"}, {"type": "function", "name": "networkx.corona_product", "documentation": "Returns the Corona product of G and H.\n\nThe corona product of $G$ and $H$ is the graph $C = G \\circ H$ obtained by\ntaking one copy of $G$, called the center graph, $|V(G)|$ copies of $H$,\ncalled the outer graph, and making the $i$-th vertex of $G$ adjacent to\nevery vertex of the $i$-th copy of $H$, where $1 \u2264 i \u2264 |V(G)|$.\n\nParameters\n----------\nG, H: NetworkX graphs\n    The graphs to take the carona product of.\n    `G` is the center graph and `H` is the outer graph\n\nReturns\n-------\nC: NetworkX graph\n    The Corona product of G and H.\n\nRaises\n------\nNetworkXError\n    If G and H are not both directed or both undirected.\n\nExamples\n--------\n>>> G = nx.cycle_graph(4)\n>>> H = nx.path_graph(2)\n>>> C = nx.corona_product(G, H)\n>>> list(C)\n[0, 1, 2, 3, (0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)]\n>>> print(C)\nGraph with 12 nodes and 16 edges\n\nReferences\n----------\n[1] M. Tavakoli, F. Rahbarnia, and A. R. Ashrafi,\n    \"Studying the corona product of graphs under some graph invariants,\"\n    Transactions on Combinatorics, vol. 3, no. 3, pp. 43\u201349, Sep. 2014,\n    doi: 10.22108/toc.2014.5542.\n[2] A. Faraji, \"Corona Product in Graph Theory,\" Ali Faraji, May 11, 2021.\n    https://blog.alifaraji.ir/math/graph-theory/corona-product.html (accessed Dec. 07, 2021)."}, {"type": "function", "name": "networkx.cost_of_flow", "documentation": "Compute the cost of the flow given by flowDict on graph G.\n\nNote that this function does not check for the validity of the\nflow flowDict. This function will fail if the graph G and the\nflow don't have the same edge set.\n\nParameters\n----------\nG : NetworkX graph\n    DiGraph on which a minimum cost flow satisfying all demands is\n    to be found.\n\nweight : string\n    Edges of the graph G are expected to have an attribute weight\n    that indicates the cost incurred by sending one unit of flow on\n    that edge. If not present, the weight is considered to be 0.\n    Default value: 'weight'.\n\nflowDict : dictionary\n    Dictionary of dictionaries keyed by nodes such that\n    flowDict[u][v] is the flow edge (u, v).\n\nReturns\n-------\ncost : Integer, float\n    The total cost of the flow. This is given by the sum over all\n    edges of the product of the edge's flow and the edge's weight.\n\nSee also\n--------\nmax_flow_min_cost, min_cost_flow, min_cost_flow_cost, network_simplex\n\nNotes\n-----\nThis algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_node(\"a\", demand=-5)\n>>> G.add_node(\"d\", demand=5)\n>>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\n>>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\n>>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\n>>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\n>>> flowDict = nx.min_cost_flow(G)\n>>> flowDict\n{'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\n>>> nx.cost_of_flow(G, flowDict)\n24"}, {"type": "function", "name": "networkx.could_be_isomorphic", "documentation": "Returns False if graphs are definitely not isomorphic.\nTrue does NOT guarantee isomorphism.\n\nParameters\n----------\nG1, G2 : graphs\n   The two graphs G1 and G2 must be the same type.\n\nNotes\n-----\nChecks for matching degree, triangle, and number of cliques sequences.\nThe triangle sequence contains the number of triangles each node is part of.\nThe clique sequence contains for each node the number of maximal cliques\ninvolving that node."}, {"type": "function", "name": "networkx.create_empty_copy", "documentation": "Returns a copy of the graph G with all of the edges removed.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nwith_data :  bool (default=True)\n   Propagate Graph and Nodes data to the new graph.\n\nSee Also\n--------\nempty_graph"}, {"type": "function", "name": "networkx.cubical_graph", "documentation": "Returns the 3-regular Platonic Cubical Graph\n\nThe skeleton of the cube (the nodes and edges) form a graph, with 8\nnodes, and 12 edges. It is a special case of the hypercube graph.\nIt is one of 5 Platonic graphs, each a skeleton of its\nPlatonic solid [1]_.\nSuch graphs arise in parallel processing in computers.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    A cubical graph with 8 nodes and 12 edges\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Cube#Cubical_graph"}, {"type": "function", "name": "networkx.current_flow_betweenness_centrality", "documentation": "Compute current-flow betweenness centrality for nodes.\n\nCurrent-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths.\n\nCurrent-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2]_.\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nnormalized : bool, optional (default=True)\n  If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\n  n is the number of nodes in G.\n\nweight : string or None, optional (default=None)\n  Key for edge data used as the edge weight.\n  If None, then use 1 as each edge weight.\n  The weight reflects the capacity or the strength of the\n  edge.\n\ndtype : data type (float)\n  Default data type for internal matrices.\n  Set to np.float32 for lower memory consumption.\n\nsolver : string (default='full')\n   Type of linear solver to use for computing the flow matrix.\n   Options are \"full\" (uses most memory), \"lu\" (recommended), and\n   \"cg\" (uses least memory).\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with betweenness centrality as the value.\n\nSee Also\n--------\napproximate_current_flow_betweenness_centrality\nbetweenness_centrality\nedge_betweenness_centrality\nedge_current_flow_betweenness_centrality\n\nNotes\n-----\nCurrent-flow betweenness can be computed in  $O(I(n-1)+mn \\log n)$\ntime [1]_, where $I(n-1)$ is the time needed to compute the\ninverse Laplacian.  For a full matrix this is $O(n^3)$ but using\nsparse methods you can achieve $O(nm{\\sqrt k})$ where $k$ is the\nLaplacian matrix condition number.\n\nThe space required is $O(nw)$ where $w$ is the width of the sparse\nLaplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\n\nIf the edges have a 'weight' attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.\n\nReferences\n----------\n.. [1] Centrality Measures Based on Current Flow.\n   Ulrik Brandes and Daniel Fleischer,\n   Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n   LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n   https://doi.org/10.1007/978-3-540-31856-9_44\n\n.. [2] A measure of betweenness centrality based on random walks,\n   M. E. J. Newman, Social Networks 27, 39-54 (2005)."}, {"type": "function", "name": "networkx.current_flow_betweenness_centrality_subset", "documentation": "Compute current-flow betweenness centrality for subsets of nodes.\n\nCurrent-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths.\n\nCurrent-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2]_.\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nsources: list of nodes\n  Nodes to use as sources for current\n\ntargets: list of nodes\n  Nodes to use as sinks for current\n\nnormalized : bool, optional (default=True)\n  If True the betweenness values are normalized by b=b/(n-1)(n-2) where\n  n is the number of nodes in G.\n\nweight : string or None, optional (default=None)\n  Key for edge data used as the edge weight.\n  If None, then use 1 as each edge weight.\n  The weight reflects the capacity or the strength of the\n  edge.\n\ndtype: data type (float)\n  Default data type for internal matrices.\n  Set to np.float32 for lower memory consumption.\n\nsolver: string (default='lu')\n   Type of linear solver to use for computing the flow matrix.\n   Options are \"full\" (uses most memory), \"lu\" (recommended), and\n   \"cg\" (uses least memory).\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with betweenness centrality as the value.\n\nSee Also\n--------\napproximate_current_flow_betweenness_centrality\nbetweenness_centrality\nedge_betweenness_centrality\nedge_current_flow_betweenness_centrality\n\nNotes\n-----\nCurrent-flow betweenness can be computed in $O(I(n-1)+mn \\log n)$\ntime [1]_, where $I(n-1)$ is the time needed to compute the\ninverse Laplacian.  For a full matrix this is $O(n^3)$ but using\nsparse methods you can achieve $O(nm{\\sqrt k})$ where $k$ is the\nLaplacian matrix condition number.\n\nThe space required is $O(nw)$ where $w$ is the width of the sparse\nLaplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\n\nIf the edges have a 'weight' attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.\n\nReferences\n----------\n.. [1] Centrality Measures Based on Current Flow.\n   Ulrik Brandes and Daniel Fleischer,\n   Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n   LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n   https://doi.org/10.1007/978-3-540-31856-9_44\n\n.. [2] A measure of betweenness centrality based on random walks,\n   M. E. J. Newman, Social Networks 27, 39-54 (2005)."}, {"type": "function", "name": "networkx.current_flow_closeness_centrality", "documentation": "Compute current-flow closeness centrality for nodes.\n\nCurrent-flow closeness centrality is variant of closeness\ncentrality based on effective resistance between nodes in\na network. This metric is also known as information centrality.\n\nParameters\n----------\nG : graph\n  A NetworkX graph.\n\nweight : None or string, optional (default=None)\n  If None, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n  The weight reflects the capacity or the strength of the\n  edge.\n\ndtype: data type (default=float)\n  Default data type for internal matrices.\n  Set to np.float32 for lower memory consumption.\n\nsolver: string (default='lu')\n   Type of linear solver to use for computing the flow matrix.\n   Options are \"full\" (uses most memory), \"lu\" (recommended), and\n   \"cg\" (uses least memory).\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with current flow closeness centrality as the value.\n\nSee Also\n--------\ncloseness_centrality\n\nNotes\n-----\nThe algorithm is from Brandes [1]_.\n\nSee also [2]_ for the original definition of information centrality.\n\nReferences\n----------\n.. [1] Ulrik Brandes and Daniel Fleischer,\n   Centrality Measures Based on Current Flow.\n   Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n   LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n   https://doi.org/10.1007/978-3-540-31856-9_44\n\n.. [2] Karen Stephenson and Marvin Zelen:\n   Rethinking centrality: Methods and examples.\n   Social Networks 11(1):1-37, 1989.\n   https://doi.org/10.1016/0378-8733(89)90016-6"}, {"type": "function", "name": "networkx.cut_size", "documentation": "Returns the size of the cut between two sets of nodes.\n\nA *cut* is a partition of the nodes of a graph into two sets. The\n*cut size* is the sum of the weights of the edges \"between\" the two\nsets of nodes.\n\nParameters\n----------\nG : NetworkX graph\n\nS : collection\n    A collection of nodes in `G`.\n\nT : collection\n    A collection of nodes in `G`. If not specified, this is taken to\n    be the set complement of `S`.\n\nweight : object\n    Edge attribute key to use as weight. If not specified, edges\n    have weight one.\n\nReturns\n-------\nnumber\n    Total weight of all edges from nodes in set `S` to nodes in\n    set `T` (and, in the case of directed graphs, all edges from\n    nodes in `T` to nodes in `S`).\n\nExamples\n--------\nIn the graph with two cliques joined by a single edges, the natural\nbipartition of the graph into two blocks, one for each clique,\nyields a cut of weight one::\n\n    >>> G = nx.barbell_graph(3, 0)\n    >>> S = {0, 1, 2}\n    >>> T = {3, 4, 5}\n    >>> nx.cut_size(G, S, T)\n    1\n\nEach parallel edge in a multigraph is counted when determining the\ncut size::\n\n    >>> G = nx.MultiGraph([\"ab\", \"ab\"])\n    >>> S = {\"a\"}\n    >>> T = {\"b\"}\n    >>> nx.cut_size(G, S, T)\n    2\n\nNotes\n-----\nIn a multigraph, the cut size is the total weight of edges including\nmultiplicity."}, {"type": "function", "name": "networkx.cycle_basis", "documentation": "Returns a list of cycles which form a basis for cycles of G.\n\nA basis for cycles of a network is a minimal collection of\ncycles such that any cycle in the network can be written\nas a sum of cycles in the basis.  Here summation of cycles\nis defined as \"exclusive or\" of the edges. Cycle bases are\nuseful, e.g. when deriving equations for electric circuits\nusing Kirchhoff's Laws.\n\nParameters\n----------\nG : NetworkX Graph\nroot : node, optional\n   Specify starting node for basis.\n\nReturns\n-------\nA list of cycle lists.  Each cycle list is a list of nodes\nwhich forms a cycle (loop) in G.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> nx.add_cycle(G, [0, 1, 2, 3])\n>>> nx.add_cycle(G, [0, 3, 4, 5])\n>>> nx.cycle_basis(G, 0)\n[[3, 4, 5, 0], [1, 2, 3, 0]]\n\nNotes\n-----\nThis is adapted from algorithm CACM 491 [1]_.\n\nReferences\n----------\n.. [1] Paton, K. An algorithm for finding a fundamental set of\n   cycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518.\n\nSee Also\n--------\nsimple_cycles\nminimum_cycle_basis"}, {"type": "function", "name": "networkx.cycle_graph", "documentation": "Returns the cycle graph $C_n$ of cyclically connected nodes.\n\n$C_n$ is a path with its two end-nodes connected.\n\n.. plot::\n\n    >>> nx.draw(nx.cycle_graph(5))\n\nParameters\n----------\nn : int or iterable container of nodes\n    If n is an integer, nodes are from `range(n)`.\n    If n is a container of nodes, those nodes appear in the graph.\n    Warning: n is not checked for duplicates and if present the\n    resulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nNotes\n-----\nIf create_using is directed, the direction is in increasing order."}, {"type": "function", "name": "networkx.cytoscape_data", "documentation": "Returns data in Cytoscape JSON format (cyjs).\n\nParameters\n----------\nG : NetworkX Graph\n    The graph to convert to cytoscape format\nname : string\n    A string which is mapped to the 'name' node element in cyjs format.\n    Must not have the same value as `ident`.\nident : string\n    A string which is mapped to the 'id' node element in cyjs format.\n    Must not have the same value as `name`.\n\nReturns\n-------\ndata: dict\n    A dictionary with cyjs formatted data.\n\nRaises\n------\nNetworkXError\n    If the values for `name` and `ident` are identical.\n\nSee Also\n--------\ncytoscape_graph: convert a dictionary in cyjs format to a graph\n\nReferences\n----------\n.. [1] Cytoscape user's manual:\n   http://manual.cytoscape.org/en/stable/index.html\n\nExamples\n--------\n>>> G = nx.path_graph(2)\n>>> nx.cytoscape_data(G)  # doctest: +SKIP\n{'data': [],\n 'directed': False,\n 'multigraph': False,\n 'elements': {'nodes': [{'data': {'id': '0', 'value': 0, 'name': '0'}},\n   {'data': {'id': '1', 'value': 1, 'name': '1'}}],\n  'edges': [{'data': {'source': 0, 'target': 1}}]}}"}, {"type": "function", "name": "networkx.cytoscape_graph", "documentation": "Create a NetworkX graph from a dictionary in cytoscape JSON format.\n\nParameters\n----------\ndata : dict\n    A dictionary of data conforming to cytoscape JSON format.\nname : string\n    A string which is mapped to the 'name' node element in cyjs format.\n    Must not have the same value as `ident`.\nident : string\n    A string which is mapped to the 'id' node element in cyjs format.\n    Must not have the same value as `name`.\n\nReturns\n-------\ngraph : a NetworkX graph instance\n    The `graph` can be an instance of `Graph`, `DiGraph`, `MultiGraph`, or\n    `MultiDiGraph` depending on the input data.\n\nRaises\n------\nNetworkXError\n    If the `name` and `ident` attributes are identical.\n\nSee Also\n--------\ncytoscape_data: convert a NetworkX graph to a dict in cyjs format\n\nReferences\n----------\n.. [1] Cytoscape user's manual:\n   http://manual.cytoscape.org/en/stable/index.html\n\nExamples\n--------\n>>> data_dict = {\n...     \"data\": [],\n...     \"directed\": False,\n...     \"multigraph\": False,\n...     \"elements\": {\n...         \"nodes\": [\n...             {\"data\": {\"id\": \"0\", \"value\": 0, \"name\": \"0\"}},\n...             {\"data\": {\"id\": \"1\", \"value\": 1, \"name\": \"1\"}},\n...         ],\n...         \"edges\": [{\"data\": {\"source\": 0, \"target\": 1}}],\n...     },\n... }\n>>> G = nx.cytoscape_graph(data_dict)\n>>> G.name\n''\n>>> G.nodes()\nNodeView((0, 1))\n>>> G.nodes(data=True)[0]\n{'id': '0', 'value': 0, 'name': '0'}\n>>> G.edges(data=True)\nEdgeDataView([(0, 1, {'source': 0, 'target': 1})])"}, {"type": "function", "name": "networkx.d_separated", "documentation": "Return whether nodes sets ``x`` and ``y`` are d-separated by ``z``.\n\n.. deprecated:: 3.3\n\n    This function is deprecated and will be removed in NetworkX v3.5.\n    Please use `is_d_separator(G, x, y, z)`."}, {"type": "function", "name": "networkx.dag_longest_path", "documentation": "Returns the longest path in a directed acyclic graph (DAG).\n\nIf `G` has edges with `weight` attribute the edge data are used as\nweight values.\n\nParameters\n----------\nG : NetworkX DiGraph\n    A directed acyclic graph (DAG)\n\nweight : str, optional\n    Edge data key to use for weight\n\ndefault_weight : int, optional\n    The weight of edges that do not have a weight attribute\n\ntopo_order: list or tuple, optional\n    A topological order for `G` (if None, the function will compute one)\n\nReturns\n-------\nlist\n    Longest path\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is not directed\n\nExamples\n--------\n>>> DG = nx.DiGraph([(0, 1, {\"cost\": 1}), (1, 2, {\"cost\": 1}), (0, 2, {\"cost\": 42})])\n>>> list(nx.all_simple_paths(DG, 0, 2))\n[[0, 1, 2], [0, 2]]\n>>> nx.dag_longest_path(DG)\n[0, 1, 2]\n>>> nx.dag_longest_path(DG, weight=\"cost\")\n[0, 2]\n\nIn the case where multiple valid topological orderings exist, `topo_order`\ncan be used to specify a specific ordering:\n\n>>> DG = nx.DiGraph([(0, 1), (0, 2)])\n>>> sorted(nx.all_topological_sorts(DG))  # Valid topological orderings\n[[0, 1, 2], [0, 2, 1]]\n>>> nx.dag_longest_path(DG, topo_order=[0, 1, 2])\n[0, 1]\n>>> nx.dag_longest_path(DG, topo_order=[0, 2, 1])\n[0, 2]\n\nSee also\n--------\ndag_longest_path_length"}, {"type": "function", "name": "networkx.dag_longest_path_length", "documentation": "Returns the longest path length in a DAG\n\nParameters\n----------\nG : NetworkX DiGraph\n    A directed acyclic graph (DAG)\n\nweight : string, optional\n    Edge data key to use for weight\n\ndefault_weight : int, optional\n    The weight of edges that do not have a weight attribute\n\nReturns\n-------\nint\n    Longest path length\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is not directed\n\nExamples\n--------\n>>> DG = nx.DiGraph([(0, 1, {\"cost\": 1}), (1, 2, {\"cost\": 1}), (0, 2, {\"cost\": 42})])\n>>> list(nx.all_simple_paths(DG, 0, 2))\n[[0, 1, 2], [0, 2]]\n>>> nx.dag_longest_path_length(DG)\n2\n>>> nx.dag_longest_path_length(DG, weight=\"cost\")\n42\n\nSee also\n--------\ndag_longest_path"}, {"type": "function", "name": "networkx.dag_to_branching", "documentation": "Returns a branching representing all (overlapping) paths from\nroot nodes to leaf nodes in the given directed acyclic graph.\n\nAs described in :mod:`networkx.algorithms.tree.recognition`, a\n*branching* is a directed forest in which each node has at most one\nparent. In other words, a branching is a disjoint union of\n*arborescences*. For this function, each node of in-degree zero in\n`G` becomes a root of one of the arborescences, and there will be\none leaf node for each distinct path from that root to a leaf node\nin `G`.\n\nEach node `v` in `G` with *k* parents becomes *k* distinct nodes in\nthe returned branching, one for each parent, and the sub-DAG rooted\nat `v` is duplicated for each copy. The algorithm then recurses on\nthe children of each copy of `v`.\n\nParameters\n----------\nG : NetworkX graph\n    A directed acyclic graph.\n\nReturns\n-------\nDiGraph\n    The branching in which there is a bijection between root-to-leaf\n    paths in `G` (in which multiple paths may share the same leaf)\n    and root-to-leaf paths in the branching (in which there is a\n    unique path from a root to a leaf).\n\n    Each node has an attribute 'source' whose value is the original\n    node to which this node corresponds. No other graph, node, or\n    edge attributes are copied into this new graph.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is not directed, or if `G` is a multigraph.\n\nHasACycle\n    If `G` is not acyclic.\n\nExamples\n--------\nTo examine which nodes in the returned branching were produced by\nwhich original node in the directed acyclic graph, we can collect\nthe mapping from source node to new nodes into a dictionary. For\nexample, consider the directed diamond graph::\n\n    >>> from collections import defaultdict\n    >>> from operator import itemgetter\n    >>>\n    >>> G = nx.DiGraph(nx.utils.pairwise(\"abd\"))\n    >>> G.add_edges_from(nx.utils.pairwise(\"acd\"))\n    >>> B = nx.dag_to_branching(G)\n    >>>\n    >>> sources = defaultdict(set)\n    >>> for v, source in B.nodes(data=\"source\"):\n    ...     sources[source].add(v)\n    >>> len(sources[\"a\"])\n    1\n    >>> len(sources[\"d\"])\n    2\n\nTo copy node attributes from the original graph to the new graph,\nyou can use a dictionary like the one constructed in the above\nexample::\n\n    >>> for source, nodes in sources.items():\n    ...     for v in nodes:\n    ...         B.nodes[v].update(G.nodes[source])\n\nNotes\n-----\nThis function is not idempotent in the sense that the node labels in\nthe returned branching may be uniquely generated each time the\nfunction is invoked. In fact, the node labels may not be integers;\nin order to relabel the nodes to be more readable, you can use the\n:func:`networkx.convert_node_labels_to_integers` function.\n\nThe current implementation of this function uses\n:func:`networkx.prefix_tree`, so it is subject to the limitations of\nthat function."}, {"type": "function", "name": "networkx.davis_southern_women_graph", "documentation": "Returns Davis Southern women social network.\n\nThis is a bipartite graph.\n\nReferences\n----------\n.. [1] A. Davis, Gardner, B. B., Gardner, M. R., 1941. Deep South.\n    University of Chicago Press, Chicago, IL."}, {"type": "function", "name": "networkx.dedensify", "documentation": "Compresses neighborhoods around high-degree nodes\n\nReduces the number of edges to high-degree nodes by adding compressor nodes\nthat summarize multiple edges of the same type to high-degree nodes (nodes\nwith a degree greater than a given threshold).  Dedensification also has\nthe added benefit of reducing the number of edges around high-degree nodes.\nThe implementation currently supports graphs with a single edge type.\n\nParameters\n----------\nG: graph\n   A networkx graph\nthreshold: int\n   Minimum degree threshold of a node to be considered a high degree node.\n   The threshold must be greater than or equal to 2.\nprefix: str or None, optional (default: None)\n   An optional prefix for denoting compressor nodes\ncopy: bool, optional (default: True)\n   Indicates if dedensification should be done inplace\n\nReturns\n-------\ndedensified networkx graph : (graph, set)\n    2-tuple of the dedensified graph and set of compressor nodes\n\nNotes\n-----\nAccording to the algorithm in [1]_, removes edges in a graph by\ncompressing/decompressing the neighborhoods around high degree nodes by\nadding compressor nodes that summarize multiple edges of the same type\nto high-degree nodes.  Dedensification will only add a compressor node when\ndoing so will reduce the total number of edges in the given graph. This\nimplementation currently supports graphs with a single edge type.\n\nExamples\n--------\nDedensification will only add compressor nodes when doing so would result\nin fewer edges::\n\n    >>> original_graph = nx.DiGraph()\n    >>> original_graph.add_nodes_from(\n    ...     [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"A\", \"B\", \"C\"]\n    ... )\n    >>> original_graph.add_edges_from(\n    ...     [\n    ...         (\"1\", \"C\"), (\"1\", \"B\"),\n    ...         (\"2\", \"C\"), (\"2\", \"B\"), (\"2\", \"A\"),\n    ...         (\"3\", \"B\"), (\"3\", \"A\"), (\"3\", \"6\"),\n    ...         (\"4\", \"C\"), (\"4\", \"B\"), (\"4\", \"A\"),\n    ...         (\"5\", \"B\"), (\"5\", \"A\"),\n    ...         (\"6\", \"5\"),\n    ...         (\"A\", \"6\")\n    ...     ]\n    ... )\n    >>> c_graph, c_nodes = nx.dedensify(original_graph, threshold=2)\n    >>> original_graph.number_of_edges()\n    15\n    >>> c_graph.number_of_edges()\n    14\n\nA dedensified, directed graph can be \"densified\" to reconstruct the\noriginal graph::\n\n    >>> original_graph = nx.DiGraph()\n    >>> original_graph.add_nodes_from(\n    ...     [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"A\", \"B\", \"C\"]\n    ... )\n    >>> original_graph.add_edges_from(\n    ...     [\n    ...         (\"1\", \"C\"), (\"1\", \"B\"),\n    ...         (\"2\", \"C\"), (\"2\", \"B\"), (\"2\", \"A\"),\n    ...         (\"3\", \"B\"), (\"3\", \"A\"), (\"3\", \"6\"),\n    ...         (\"4\", \"C\"), (\"4\", \"B\"), (\"4\", \"A\"),\n    ...         (\"5\", \"B\"), (\"5\", \"A\"),\n    ...         (\"6\", \"5\"),\n    ...         (\"A\", \"6\")\n    ...     ]\n    ... )\n    >>> c_graph, c_nodes = nx.dedensify(original_graph, threshold=2)\n    >>> # re-densifies the compressed graph into the original graph\n    >>> for c_node in c_nodes:\n    ...     all_neighbors = set(nx.all_neighbors(c_graph, c_node))\n    ...     out_neighbors = set(c_graph.neighbors(c_node))\n    ...     for out_neighbor in out_neighbors:\n    ...         c_graph.remove_edge(c_node, out_neighbor)\n    ...     in_neighbors = all_neighbors - out_neighbors\n    ...     for in_neighbor in in_neighbors:\n    ...         c_graph.remove_edge(in_neighbor, c_node)\n    ...         for out_neighbor in out_neighbors:\n    ...             c_graph.add_edge(in_neighbor, out_neighbor)\n    ...     c_graph.remove_node(c_node)\n    ...\n    >>> nx.is_isomorphic(original_graph, c_graph)\n    True\n\nReferences\n----------\n.. [1] Maccioni, A., & Abadi, D. J. (2016, August).\n   Scalable pattern matching over compressed graphs via dedensification.\n   In Proceedings of the 22nd ACM SIGKDD International Conference on\n   Knowledge Discovery and Data Mining (pp. 1755-1764).\n   http://www.cs.umd.edu/~abadi/papers/graph-dedense.pdf"}, {"type": "function", "name": "networkx.degree", "documentation": "Returns a degree view of single node or of nbunch of nodes.\nIf nbunch is omitted, then return degrees of *all* nodes.\n\nThis function wraps the :func:`G.degree <networkx.Graph.degree>` property."}, {"type": "function", "name": "networkx.degree_assortativity_coefficient", "documentation": "Compute degree assortativity of graph.\n\nAssortativity measures the similarity of connections\nin the graph with respect to the node degree.\n\nParameters\n----------\nG : NetworkX graph\n\nx: string ('in','out')\n   The degree type for source node (directed graphs only).\n\ny: string ('in','out')\n   The degree type for target node (directed graphs only).\n\nweight: string or None, optional (default=None)\n   The edge attribute that holds the numerical value used\n   as a weight.  If None, then each edge has weight 1.\n   The degree is the sum of the edge weights adjacent to the node.\n\nnodes: list or iterable (optional)\n    Compute degree assortativity only for nodes in container.\n    The default is all nodes.\n\nReturns\n-------\nr : float\n   Assortativity of graph by degree.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> r = nx.degree_assortativity_coefficient(G)\n>>> print(f\"{r:3.1f}\")\n-0.5\n\nSee Also\n--------\nattribute_assortativity_coefficient\nnumeric_assortativity_coefficient\ndegree_mixing_dict\ndegree_mixing_matrix\n\nNotes\n-----\nThis computes Eq. (21) in Ref. [1]_ , where e is the joint\nprobability distribution (mixing matrix) of the degrees.  If G is\ndirected than the matrix e is the joint probability of the\nuser-specified degree type for the source and target.\n\nReferences\n----------\n.. [1] M. E. J. Newman, Mixing patterns in networks,\n   Physical Review E, 67 026126, 2003\n.. [2] Foster, J.G., Foster, D.V., Grassberger, P. & Paczuski, M.\n   Edge direction and the structure of networks, PNAS 107, 10815-20 (2010)."}, {"type": "function", "name": "networkx.degree_centrality", "documentation": "Compute the degree centrality for nodes.\n\nThe degree centrality for a node v is the fraction of nodes it\nis connected to.\n\nParameters\n----------\nG : graph\n  A networkx graph\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with degree centrality as the value.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n>>> nx.degree_centrality(G)\n{0: 1.0, 1: 1.0, 2: 0.6666666666666666, 3: 0.6666666666666666}\n\nSee Also\n--------\nbetweenness_centrality, load_centrality, eigenvector_centrality\n\nNotes\n-----\nThe degree centrality values are normalized by dividing by the maximum\npossible degree in a simple graph n-1 where n is the number of nodes in G.\n\nFor multigraphs or graphs with self loops the maximum degree might\nbe higher than n-1 and values of degree centrality greater than 1\nare possible."}, {"type": "function", "name": "networkx.degree_histogram", "documentation": "Returns a list of the frequency of each degree value.\n\nParameters\n----------\nG : Networkx graph\n   A graph\n\nReturns\n-------\nhist : list\n   A list of frequencies of degrees.\n   The degree values are the index in the list.\n\nNotes\n-----\nNote: the bins are width one, hence len(list) can be large\n(Order(number_of_edges))"}, {"type": "function", "name": "networkx.degree_mixing_dict", "documentation": "Returns dictionary representation of mixing matrix for degree.\n\nParameters\n----------\nG : graph\n    NetworkX graph object.\n\nx: string ('in','out')\n   The degree type for source node (directed graphs only).\n\ny: string ('in','out')\n   The degree type for target node (directed graphs only).\n\nweight: string or None, optional (default=None)\n   The edge attribute that holds the numerical value used\n   as a weight.  If None, then each edge has weight 1.\n   The degree is the sum of the edge weights adjacent to the node.\n\nnormalized : bool (default=False)\n    Return counts if False or probabilities if True.\n\nReturns\n-------\nd: dictionary\n   Counts or joint probability of occurrence of degree pairs."}, {"type": "function", "name": "networkx.degree_mixing_matrix", "documentation": "Returns mixing matrix for attribute.\n\nParameters\n----------\nG : graph\n   NetworkX graph object.\n\nx: string ('in','out')\n   The degree type for source node (directed graphs only).\n\ny: string ('in','out')\n   The degree type for target node (directed graphs only).\n\nnodes: list or iterable (optional)\n    Build the matrix using only nodes in container.\n    The default is all nodes.\n\nweight: string or None, optional (default=None)\n   The edge attribute that holds the numerical value used\n   as a weight.  If None, then each edge has weight 1.\n   The degree is the sum of the edge weights adjacent to the node.\n\nnormalized : bool (default=True)\n   Return counts if False or probabilities if True.\n\nmapping : dictionary, optional\n   Mapping from node degree to integer index in matrix.\n   If not specified, an arbitrary ordering will be used.\n\nReturns\n-------\nm: numpy array\n   Counts, or joint probability, of occurrence of node degree.\n\nNotes\n-----\nDefinitions of degree mixing matrix vary on whether the matrix\nshould include rows for degree values that don't arise. Here we\ndo not include such empty-rows. But you can force them to appear\nby inputting a `mapping` that includes those values. See examples.\n\nExamples\n--------\n>>> G = nx.star_graph(3)\n>>> mix_mat = nx.degree_mixing_matrix(G)\n>>> mix_mat\narray([[0. , 0.5],\n       [0.5, 0. ]])\n\nIf you want every possible degree to appear as a row, even if no nodes\nhave that degree, use `mapping` as follows,\n\n>>> max_degree = max(deg for n, deg in G.degree)\n>>> mapping = {x: x for x in range(max_degree + 1)}  # identity mapping\n>>> mix_mat = nx.degree_mixing_matrix(G, mapping=mapping)\n>>> mix_mat\narray([[0. , 0. , 0. , 0. ],\n       [0. , 0. , 0. , 0.5],\n       [0. , 0. , 0. , 0. ],\n       [0. , 0.5, 0. , 0. ]])"}, {"type": "function", "name": "networkx.degree_pearson_correlation_coefficient", "documentation": "Compute degree assortativity of graph.\n\nAssortativity measures the similarity of connections\nin the graph with respect to the node degree.\n\nThis is the same as degree_assortativity_coefficient but uses the\npotentially faster scipy.stats.pearsonr function.\n\nParameters\n----------\nG : NetworkX graph\n\nx: string ('in','out')\n   The degree type for source node (directed graphs only).\n\ny: string ('in','out')\n   The degree type for target node (directed graphs only).\n\nweight: string or None, optional (default=None)\n   The edge attribute that holds the numerical value used\n   as a weight.  If None, then each edge has weight 1.\n   The degree is the sum of the edge weights adjacent to the node.\n\nnodes: list or iterable (optional)\n    Compute pearson correlation of degrees only for specified nodes.\n    The default is all nodes.\n\nReturns\n-------\nr : float\n   Assortativity of graph by degree.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> r = nx.degree_pearson_correlation_coefficient(G)\n>>> print(f\"{r:3.1f}\")\n-0.5\n\nNotes\n-----\nThis calls scipy.stats.pearsonr.\n\nReferences\n----------\n.. [1] M. E. J. Newman, Mixing patterns in networks\n       Physical Review E, 67 026126, 2003\n.. [2] Foster, J.G., Foster, D.V., Grassberger, P. & Paczuski, M.\n   Edge direction and the structure of networks, PNAS 107, 10815-20 (2010)."}, {"type": "function", "name": "networkx.degree_sequence_tree", "documentation": "Make a tree for the given degree sequence.\n\nA tree has #nodes-#edges=1 so\nthe degree sequence must have\nlen(deg_sequence)-sum(deg_sequence)/2=1"}, {"type": "function", "name": "networkx.dense_gnm_random_graph", "documentation": "Returns a $G_{n,m}$ random graph.\n\nIn the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\nof all graphs with $n$ nodes and $m$ edges.\n\nThis algorithm should be faster than :func:`gnm_random_graph` for dense\ngraphs.\n\nParameters\n----------\nn : int\n    The number of nodes.\nm : int\n    The number of edges.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nSee Also\n--------\ngnm_random_graph\n\nNotes\n-----\nAlgorithm by Keith M. Briggs Mar 31, 2006.\nInspired by Knuth's Algorithm S (Selection sampling technique),\nin section 3.4.2 of [1]_.\n\nReferences\n----------\n.. [1] Donald E. Knuth, The Art of Computer Programming,\n    Volume 2/Seminumerical algorithms, Third Edition, Addison-Wesley, 1997."}, {"type": "function", "name": "networkx.density", "documentation": "Returns the density of a graph.\n\nThe density for undirected graphs is\n\n.. math::\n\n   d = \\frac{2m}{n(n-1)},\n\nand for directed graphs is\n\n.. math::\n\n   d = \\frac{m}{n(n-1)},\n\nwhere `n` is the number of nodes and `m`  is the number of edges in `G`.\n\nNotes\n-----\nThe density is 0 for a graph without edges and 1 for a complete graph.\nThe density of multigraphs can be higher than 1.\n\nSelf loops are counted in the total number of edges so graphs with self\nloops can have density higher than 1."}, {"type": "function", "name": "networkx.desargues_graph", "documentation": "Returns the Desargues Graph\n\nThe Desargues Graph is a non-planar, distance-transitive cubic graph\nwith 20 nodes and 30 edges [1]_.\nIt is a symmetric graph. It can be represented in LCF notation\nas [5,-5,9,-9]^5 [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Desargues Graph with 20 nodes and 30 edges\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Desargues_graph\n.. [2] https://mathworld.wolfram.com/DesarguesGraph.html"}, {"type": "function", "name": "networkx.descendants", "documentation": "Returns all nodes reachable from `source` in `G`.\n\nParameters\n----------\nG : NetworkX Graph\nsource : node in `G`\n\nReturns\n-------\nset()\n    The descendants of `source` in `G`\n\nRaises\n------\nNetworkXError\n    If node `source` is not in `G`.\n\nExamples\n--------\n>>> DG = nx.path_graph(5, create_using=nx.DiGraph)\n>>> sorted(nx.descendants(DG, 2))\n[3, 4]\n\nThe `source` node is not a descendant of itself, but can be included manually:\n\n>>> sorted(nx.descendants(DG, 2) | {2})\n[2, 3, 4]\n\nSee also\n--------\nancestors"}, {"type": "function", "name": "networkx.descendants_at_distance", "documentation": "Returns all nodes at a fixed `distance` from `source` in `G`.\n\nParameters\n----------\nG : NetworkX graph\n    A graph\nsource : node in `G`\ndistance : the distance of the wanted nodes from `source`\n\nReturns\n-------\nset()\n    The descendants of `source` in `G` at the given `distance` from `source`\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> nx.descendants_at_distance(G, 2, 2)\n{0, 4}\n>>> H = nx.DiGraph()\n>>> H.add_edges_from([(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)])\n>>> nx.descendants_at_distance(H, 0, 2)\n{3, 4, 5, 6}\n>>> nx.descendants_at_distance(H, 5, 0)\n{5}\n>>> nx.descendants_at_distance(H, 5, 1)\nset()"}, {"type": "function", "name": "networkx.dfs_edges", "documentation": "Iterate over edges in a depth-first-search (DFS).\n\nPerform a depth-first-search over the nodes of `G` and yield\nthe edges in order. This may not generate all edges in `G`\n(see `~networkx.algorithms.traversal.edgedfs.edge_dfs`).\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node, optional\n   Specify starting node for depth-first search and yield edges in\n   the component reachable from source.\n\ndepth_limit : int, optional (default=len(G))\n   Specify the maximum search depth.\n\nsort_neighbors : function (default=None)\n    A function that takes an iterator over nodes as the input, and\n    returns an iterable of the same nodes with a custom ordering.\n    For example, `sorted` will sort the nodes in increasing order.\n\nYields\n------\nedge: 2-tuple of nodes\n   Yields edges resulting from the depth-first-search.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> list(nx.dfs_edges(G, source=0))\n[(0, 1), (1, 2), (2, 3), (3, 4)]\n>>> list(nx.dfs_edges(G, source=0, depth_limit=2))\n[(0, 1), (1, 2)]\n\nNotes\n-----\nIf a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched.\n\nThe implementation of this function is adapted from David Eppstein's\ndepth-first search function in PADS [1]_, with modifications\nto allow depth limits based on the Wikipedia article\n\"Depth-limited search\" [2]_.\n\nSee Also\n--------\ndfs_preorder_nodes\ndfs_postorder_nodes\ndfs_labeled_edges\n:func:`~networkx.algorithms.traversal.edgedfs.edge_dfs`\n:func:`~networkx.algorithms.traversal.breadth_first_search.bfs_edges`\n\nReferences\n----------\n.. [1] http://www.ics.uci.edu/~eppstein/PADS\n.. [2] https://en.wikipedia.org/wiki/Depth-limited_search"}, {"type": "function", "name": "networkx.dfs_labeled_edges", "documentation": "Iterate over edges in a depth-first-search (DFS) labeled by type.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node, optional\n   Specify starting node for depth-first search and return edges in\n   the component reachable from source.\n\ndepth_limit : int, optional (default=len(G))\n   Specify the maximum search depth.\n\nsort_neighbors : function (default=None)\n    A function that takes an iterator over nodes as the input, and\n    returns an iterable of the same nodes with a custom ordering.\n    For example, `sorted` will sort the nodes in increasing order.\n\nReturns\n-------\nedges: generator\n   A generator of triples of the form (*u*, *v*, *d*), where (*u*,\n   *v*) is the edge being explored in the depth-first search and *d*\n   is one of the strings 'forward', 'nontree', 'reverse', or 'reverse-depth_limit'.\n   A 'forward' edge is one in which *u* has been visited but *v* has\n   not. A 'nontree' edge is one in which both *u* and *v* have been\n   visited but the edge is not in the DFS tree. A 'reverse' edge is\n   one in which both *u* and *v* have been visited and the edge is in\n   the DFS tree. When the `depth_limit` is reached via a 'forward' edge,\n   a 'reverse' edge is immediately generated rather than the subtree\n   being explored. To indicate this flavor of 'reverse' edge, the string\n   yielded is 'reverse-depth_limit'.\n\nExamples\n--------\n\nThe labels reveal the complete transcript of the depth-first search\nalgorithm in more detail than, for example, :func:`dfs_edges`::\n\n    >>> from pprint import pprint\n    >>>\n    >>> G = nx.DiGraph([(0, 1), (1, 2), (2, 1)])\n    >>> pprint(list(nx.dfs_labeled_edges(G, source=0)))\n    [(0, 0, 'forward'),\n     (0, 1, 'forward'),\n     (1, 2, 'forward'),\n     (2, 1, 'nontree'),\n     (1, 2, 'reverse'),\n     (0, 1, 'reverse'),\n     (0, 0, 'reverse')]\n\nNotes\n-----\nIf a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched.\n\nThe implementation of this function is adapted from David Eppstein's\ndepth-first search function in `PADS`_, with modifications\nto allow depth limits based on the Wikipedia article\n\"`Depth-limited search`_\".\n\n.. _PADS: http://www.ics.uci.edu/~eppstein/PADS\n.. _Depth-limited search: https://en.wikipedia.org/wiki/Depth-limited_search\n\nSee Also\n--------\ndfs_edges\ndfs_preorder_nodes\ndfs_postorder_nodes"}, {"type": "function", "name": "networkx.dfs_postorder_nodes", "documentation": "Generate nodes in a depth-first-search post-ordering starting at source.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node, optional\n   Specify starting node for depth-first search.\n\ndepth_limit : int, optional (default=len(G))\n   Specify the maximum search depth.\n\nsort_neighbors : function (default=None)\n    A function that takes an iterator over nodes as the input, and\n    returns an iterable of the same nodes with a custom ordering.\n    For example, `sorted` will sort the nodes in increasing order.\n\nReturns\n-------\nnodes: generator\n   A generator of nodes in a depth-first-search post-ordering.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> list(nx.dfs_postorder_nodes(G, source=0))\n[4, 3, 2, 1, 0]\n>>> list(nx.dfs_postorder_nodes(G, source=0, depth_limit=2))\n[1, 0]\n\nNotes\n-----\nIf a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched.\n\nThe implementation of this function is adapted from David Eppstein's\ndepth-first search function in `PADS`_, with modifications\nto allow depth limits based on the Wikipedia article\n\"`Depth-limited search`_\".\n\n.. _PADS: http://www.ics.uci.edu/~eppstein/PADS\n.. _Depth-limited search: https://en.wikipedia.org/wiki/Depth-limited_search\n\nSee Also\n--------\ndfs_edges\ndfs_preorder_nodes\ndfs_labeled_edges\n:func:`~networkx.algorithms.traversal.edgedfs.edge_dfs`\n:func:`~networkx.algorithms.traversal.breadth_first_search.bfs_tree`"}, {"type": "function", "name": "networkx.dfs_predecessors", "documentation": "Returns dictionary of predecessors in depth-first-search from source.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node, optional\n   Specify starting node for depth-first search.\n   Note that you will get predecessors for all nodes in the\n   component containing `source`. This input only specifies\n   where the DFS starts.\n\ndepth_limit : int, optional (default=len(G))\n   Specify the maximum search depth.\n\nsort_neighbors : function (default=None)\n    A function that takes an iterator over nodes as the input, and\n    returns an iterable of the same nodes with a custom ordering.\n    For example, `sorted` will sort the nodes in increasing order.\n\nReturns\n-------\npred: dict\n   A dictionary with nodes as keys and predecessor nodes as values.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.dfs_predecessors(G, source=0)\n{1: 0, 2: 1, 3: 2}\n>>> nx.dfs_predecessors(G, source=0, depth_limit=2)\n{1: 0, 2: 1}\n\nNotes\n-----\nIf a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched.\n\nThe implementation of this function is adapted from David Eppstein's\ndepth-first search function in `PADS`_, with modifications\nto allow depth limits based on the Wikipedia article\n\"`Depth-limited search`_\".\n\n.. _PADS: http://www.ics.uci.edu/~eppstein/PADS\n.. _Depth-limited search: https://en.wikipedia.org/wiki/Depth-limited_search\n\nSee Also\n--------\ndfs_preorder_nodes\ndfs_postorder_nodes\ndfs_labeled_edges\n:func:`~networkx.algorithms.traversal.edgedfs.edge_dfs`\n:func:`~networkx.algorithms.traversal.breadth_first_search.bfs_tree`"}, {"type": "function", "name": "networkx.dfs_preorder_nodes", "documentation": "Generate nodes in a depth-first-search pre-ordering starting at source.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node, optional\n   Specify starting node for depth-first search and return nodes in\n   the component reachable from source.\n\ndepth_limit : int, optional (default=len(G))\n   Specify the maximum search depth.\n\nsort_neighbors : function (default=None)\n    A function that takes an iterator over nodes as the input, and\n    returns an iterable of the same nodes with a custom ordering.\n    For example, `sorted` will sort the nodes in increasing order.\n\nReturns\n-------\nnodes: generator\n   A generator of nodes in a depth-first-search pre-ordering.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> list(nx.dfs_preorder_nodes(G, source=0))\n[0, 1, 2, 3, 4]\n>>> list(nx.dfs_preorder_nodes(G, source=0, depth_limit=2))\n[0, 1, 2]\n\nNotes\n-----\nIf a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched.\n\nThe implementation of this function is adapted from David Eppstein's\ndepth-first search function in `PADS`_, with modifications\nto allow depth limits based on the Wikipedia article\n\"`Depth-limited search`_\".\n\n.. _PADS: http://www.ics.uci.edu/~eppstein/PADS\n.. _Depth-limited search: https://en.wikipedia.org/wiki/Depth-limited_search\n\nSee Also\n--------\ndfs_edges\ndfs_postorder_nodes\ndfs_labeled_edges\n:func:`~networkx.algorithms.traversal.breadth_first_search.bfs_edges`"}, {"type": "function", "name": "networkx.dfs_successors", "documentation": "Returns dictionary of successors in depth-first-search from source.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node, optional\n   Specify starting node for depth-first search.\n   Note that you will get successors for all nodes in the\n   component containing `source`. This input only specifies\n   where the DFS starts.\n\ndepth_limit : int, optional (default=len(G))\n   Specify the maximum search depth.\n\nsort_neighbors : function (default=None)\n    A function that takes an iterator over nodes as the input, and\n    returns an iterable of the same nodes with a custom ordering.\n    For example, `sorted` will sort the nodes in increasing order.\n\nReturns\n-------\nsucc: dict\n   A dictionary with nodes as keys and list of successor nodes as values.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> nx.dfs_successors(G, source=0)\n{0: [1], 1: [2], 2: [3], 3: [4]}\n>>> nx.dfs_successors(G, source=0, depth_limit=2)\n{0: [1], 1: [2]}\n\nNotes\n-----\nIf a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched.\n\nThe implementation of this function is adapted from David Eppstein's\ndepth-first search function in `PADS`_, with modifications\nto allow depth limits based on the Wikipedia article\n\"`Depth-limited search`_\".\n\n.. _PADS: http://www.ics.uci.edu/~eppstein/PADS\n.. _Depth-limited search: https://en.wikipedia.org/wiki/Depth-limited_search\n\nSee Also\n--------\ndfs_preorder_nodes\ndfs_postorder_nodes\ndfs_labeled_edges\n:func:`~networkx.algorithms.traversal.edgedfs.edge_dfs`\n:func:`~networkx.algorithms.traversal.breadth_first_search.bfs_tree`"}, {"type": "function", "name": "networkx.dfs_tree", "documentation": "Returns oriented tree constructed from a depth-first-search from source.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node, optional\n   Specify starting node for depth-first search.\n\ndepth_limit : int, optional (default=len(G))\n   Specify the maximum search depth.\n\nsort_neighbors : function (default=None)\n    A function that takes an iterator over nodes as the input, and\n    returns an iterable of the same nodes with a custom ordering.\n    For example, `sorted` will sort the nodes in increasing order.\n\nReturns\n-------\nT : NetworkX DiGraph\n   An oriented tree\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> T = nx.dfs_tree(G, source=0, depth_limit=2)\n>>> list(T.edges())\n[(0, 1), (1, 2)]\n>>> T = nx.dfs_tree(G, source=0)\n>>> list(T.edges())\n[(0, 1), (1, 2), (2, 3), (3, 4)]\n\nSee Also\n--------\ndfs_preorder_nodes\ndfs_postorder_nodes\ndfs_labeled_edges\n:func:`~networkx.algorithms.traversal.edgedfs.edge_dfs`\n:func:`~networkx.algorithms.traversal.breadth_first_search.bfs_tree`"}, {"type": "function", "name": "networkx.diameter", "documentation": "Returns the diameter of the graph G.\n\nThe diameter is the maximum eccentricity.\n\nParameters\n----------\nG : NetworkX graph\n   A graph\n\ne : eccentricity dictionary, optional\n  A precomputed dictionary of eccentricities.\n\nweight : string, function, or None\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\n    If this is None, every edge has weight/distance/cost 1.\n\n    Weights stored as floating point values can lead to small round-off\n    errors in distances. Use integer weights to avoid this.\n\n    Weights should be positive, since they are distances.\n\nReturns\n-------\nd : integer\n   Diameter of graph\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (1, 4), (3, 4), (3, 5), (4, 5)])\n>>> nx.diameter(G)\n3\n\nSee Also\n--------\neccentricity"}, {"type": "function", "name": "networkx.diamond_graph", "documentation": "Returns the Diamond graph\n\nThe Diamond Graph is  planar undirected graph with 4 nodes and 5 edges.\nIt is also sometimes known as the double triangle graph or kite graph [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Diamond Graph with 4 nodes and 5 edges\n\nReferences\n----------\n.. [1] https://mathworld.wolfram.com/DiamondGraph.html"}, {"type": "function", "name": "networkx.difference", "documentation": "Returns a new graph that contains the edges that exist in G but not in H.\n\nThe node sets of H and G must be the same.\n\nParameters\n----------\nG,H : graph\n   A NetworkX graph. G and H must have the same node sets.\n\nReturns\n-------\nD : A new graph with the same type as G.\n\nNotes\n-----\nAttributes from the graph, nodes, and edges are not copied to the new\ngraph.  If you want a new graph of the difference of G and H with\nthe attributes (including edge data) from G use remove_nodes_from()\nas follows:\n\n>>> G = nx.path_graph(3)\n>>> H = nx.path_graph(5)\n>>> R = G.copy()\n>>> R.remove_nodes_from(n for n in G if n in H)\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (1, 2), (1, 3)])\n>>> H = nx.Graph([(0, 1), (1, 2), (0, 3)])\n>>> R = nx.difference(G, H)\n>>> R.nodes\nNodeView((0, 1, 2, 3))\n>>> R.edges\nEdgeView([(0, 2), (1, 3)])"}, {"type": "function", "name": "networkx.dijkstra_path", "documentation": "Returns the shortest weighted path from source to target in G.\n\nUses Dijkstra's Method to compute the shortest weighted path\nbetween two nodes in a graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n    Starting node\n\ntarget : node\n    Ending node\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number or None to indicate a hidden edge.\n\nReturns\n-------\npath : list\n    List of nodes in a shortest path.\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nNetworkXNoPath\n    If no path exists between source and target.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> print(nx.dijkstra_path(G, 0, 4))\n[0, 1, 2, 3, 4]\n\nFind edges of shortest path in Multigraph\n\n>>> G = nx.MultiDiGraph()\n>>> G.add_weighted_edges_from([(1, 2, 0.75), (1, 2, 0.5), (2, 3, 0.5), (1, 3, 1.5)])\n>>> nodes = nx.dijkstra_path(G, 1, 3)\n>>> edges = nx.utils.pairwise(nodes)\n>>> list(\n...     (u, v, min(G[u][v], key=lambda k: G[u][v][k].get(\"weight\", 1)))\n...     for u, v in edges\n... )\n[(1, 2, 1), (2, 3, 0)]\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe weight function can be used to hide edges by returning None.\nSo ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\nwill find the shortest red path.\n\nThe weight function can be used to include node weights.\n\n>>> def func(u, v, d):\n...     node_u_wt = G.nodes[u].get(\"node_weight\", 1)\n...     node_v_wt = G.nodes[v].get(\"node_weight\", 1)\n...     edge_wt = d.get(\"weight\", 1)\n...     return node_u_wt / 2 + node_v_wt / 2 + edge_wt\n\nIn this example we take the average of start and end node\nweights of an edge and add it to the weight of the edge.\n\nThe function :func:`single_source_dijkstra` computes both\npath and length-of-path if you need both, use that.\n\nSee Also\n--------\nbidirectional_dijkstra\nbellman_ford_path\nsingle_source_dijkstra"}, {"type": "function", "name": "networkx.dijkstra_path_length", "documentation": "Returns the shortest weighted path length in G from source to target.\n\nUses Dijkstra's Method to compute the shortest weighted path length\nbetween two nodes in a graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node label\n    starting node for path\n\ntarget : node label\n    ending node for path\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number or None to indicate a hidden edge.\n\nReturns\n-------\nlength : number\n    Shortest path length.\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nNetworkXNoPath\n    If no path exists between source and target.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> nx.dijkstra_path_length(G, 0, 4)\n4\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe weight function can be used to hide edges by returning None.\nSo ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\nwill find the shortest red path.\n\nThe function :func:`single_source_dijkstra` computes both\npath and length-of-path if you need both, use that.\n\nSee Also\n--------\nbidirectional_dijkstra\nbellman_ford_path_length\nsingle_source_dijkstra"}, {"type": "function", "name": "networkx.dijkstra_predecessor_and_distance", "documentation": "Compute weighted shortest path length and predecessors.\n\nUses Dijkstra's Method to obtain the shortest weighted paths\nand return dictionaries of predecessors for each node and\ndistance for each node from the `source`.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node label\n    Starting node for path\n\ncutoff : integer or float, optional\n    Length (sum of edge weights) at which the search is stopped.\n    If cutoff is provided, only return paths with summed weight <= cutoff.\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number or None to indicate a hidden edge.\n\nReturns\n-------\npred, distance : dictionaries\n    Returns two dictionaries representing a list of predecessors\n    of a node and the distance to each node.\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe list of predecessors contains more than one element only when\nthere are more than one shortest paths to the key node.\n\nExamples\n--------\n>>> G = nx.path_graph(5, create_using=nx.DiGraph())\n>>> pred, dist = nx.dijkstra_predecessor_and_distance(G, 0)\n>>> sorted(pred.items())\n[(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]\n>>> sorted(dist.items())\n[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\n\n>>> pred, dist = nx.dijkstra_predecessor_and_distance(G, 0, 1)\n>>> sorted(pred.items())\n[(0, []), (1, [0])]\n>>> sorted(dist.items())\n[(0, 0), (1, 1)]"}, {"type": "function", "name": "networkx.directed_combinatorial_laplacian_matrix", "documentation": "Return the directed combinatorial Laplacian matrix of G.\n\nThe graph directed combinatorial Laplacian is the matrix\n\n.. math::\n\n    L = \\Phi - \\frac{1}{2} \\left (\\Phi P + P^T \\Phi \\right)\n\nwhere `P` is the transition matrix of the graph and `\\Phi` a matrix\nwith the Perron vector of `P` in the diagonal and zeros elsewhere [1]_.\n\nDepending on the value of walk_type, `P` can be the transition matrix\ninduced by a random walk, a lazy random walk, or a random walk with\nteleportation (PageRank).\n\nParameters\n----------\nG : DiGraph\n   A NetworkX graph\n\nnodelist : list, optional\n   The rows and columns are ordered according to the nodes in nodelist.\n   If nodelist is None, then the ordering is produced by G.nodes().\n\nweight : string or None, optional (default='weight')\n   The edge data key used to compute each value in the matrix.\n   If None, then each edge has weight 1.\n\nwalk_type : string or None, optional (default=None)\n    One of ``\"random\"``, ``\"lazy\"``, or ``\"pagerank\"``. If ``walk_type=None``\n    (the default), then a value is selected according to the properties of `G`:\n    - ``walk_type=\"random\"`` if `G` is strongly connected and aperiodic\n    - ``walk_type=\"lazy\"`` if `G` is strongly connected but not aperiodic\n    - ``walk_type=\"pagerank\"`` for all other cases.\n\nalpha : real\n   (1 - alpha) is the teleportation probability used with pagerank\n\nReturns\n-------\nL : NumPy matrix\n  Combinatorial Laplacian of G.\n\nNotes\n-----\nOnly implemented for DiGraphs\n\nThe result is always a symmetric matrix.\n\nThis calculation uses the out-degree of the graph `G`. To use the\nin-degree for calculations instead, use `G.reverse(copy=False)` and\ntake the transpose.\n\nSee Also\n--------\nlaplacian_matrix\nnormalized_laplacian_matrix\ndirected_laplacian_matrix\n\nReferences\n----------\n.. [1] Fan Chung (2005).\n   Laplacians and the Cheeger inequality for directed graphs.\n   Annals of Combinatorics, 9(1), 2005"}, {"type": "function", "name": "networkx.directed_configuration_model", "documentation": "Returns a directed_random graph with the given degree sequences.\n\nThe configuration model generates a random directed pseudograph\n(graph with parallel edges and self loops) by randomly assigning\nedges to match the given degree sequences.\n\nParameters\n----------\nin_degree_sequence :  list of nonnegative integers\n   Each list entry corresponds to the in-degree of a node.\nout_degree_sequence :  list of nonnegative integers\n   Each list entry corresponds to the out-degree of a node.\ncreate_using : NetworkX graph constructor, optional (default MultiDiGraph)\n    Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : MultiDiGraph\n    A graph with the specified degree sequences.\n    Nodes are labeled starting at 0 with an index\n    corresponding to the position in deg_sequence.\n\nRaises\n------\nNetworkXError\n    If the degree sequences do not have the same sum.\n\nSee Also\n--------\nconfiguration_model\n\nNotes\n-----\nAlgorithm as described by Newman [1]_.\n\nA non-graphical degree sequence (not realizable by some simple\ngraph) is allowed since this function returns graphs with self\nloops and parallel edges.  An exception is raised if the degree\nsequences does not have the same sum.\n\nThis configuration model construction process can lead to\nduplicate edges and loops.  You can remove the self-loops and\nparallel edges (see below) which will likely result in a graph\nthat doesn't have the exact degree sequence specified.  This\n\"finite-size effect\" decreases as the size of the graph increases.\n\nReferences\n----------\n.. [1] Newman, M. E. J. and Strogatz, S. H. and Watts, D. J.\n   Random graphs with arbitrary degree distributions and their applications\n   Phys. Rev. E, 64, 026118 (2001)\n\nExamples\n--------\nOne can modify the in- and out-degree sequences from an existing\ndirected graph in order to create a new directed graph. For example,\nhere we modify the directed path graph:\n\n>>> D = nx.DiGraph([(0, 1), (1, 2), (2, 3)])\n>>> din = list(d for n, d in D.in_degree())\n>>> dout = list(d for n, d in D.out_degree())\n>>> din.append(1)\n>>> dout[0] = 2\n>>> # We now expect an edge from node 0 to a new node, node 3.\n... D = nx.directed_configuration_model(din, dout)\n\nThe returned graph is a directed multigraph, which may have parallel\nedges. To remove any parallel edges from the returned graph:\n\n>>> D = nx.DiGraph(D)\n\nSimilarly, to remove self-loops:\n\n>>> D.remove_edges_from(nx.selfloop_edges(D))"}, {"type": "function", "name": "networkx.directed_edge_swap", "documentation": "Swap three edges in a directed graph while keeping the node degrees fixed.\n\nA directed edge swap swaps three edges such that a -> b -> c -> d becomes\na -> c -> b -> d. This pattern of swapping allows all possible states with the\nsame in- and out-degree distribution in a directed graph to be reached.\n\nIf the swap would create parallel edges (e.g. if a -> c already existed in the\nprevious example), another attempt is made to find a suitable trio of edges.\n\nParameters\n----------\nG : DiGraph\n   A directed graph\n\nnswap : integer (optional, default=1)\n   Number of three-edge (directed) swaps to perform\n\nmax_tries : integer (optional, default=100)\n   Maximum number of attempts to swap edges\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : DiGraph\n   The graph after the edges are swapped.\n\nRaises\n------\nNetworkXError\n    If `G` is not directed, or\n    If nswap > max_tries, or\n    If there are fewer than 4 nodes or 3 edges in `G`.\nNetworkXAlgorithmError\n    If the number of swap attempts exceeds `max_tries` before `nswap` swaps are made\n\nNotes\n-----\nDoes not enforce any connectivity constraints.\n\nThe graph G is modified in place.\n\nA later swap is allowed to undo a previous swap.\n\nReferences\n----------\n.. [1] Erd\u0151s, P\u00e9ter L., et al. \u201cA Simple Havel-Hakimi Type Algorithm to Realize\n       Graphical Degree Sequences of Directed Graphs.\u201d ArXiv:0905.4913 [Math],\n       Jan. 2010. https://doi.org/10.48550/arXiv.0905.4913.\n       Published  2010 in Elec. J. Combinatorics (17(1)). R66.\n       http://www.combinatorics.org/Volume_17/PDF/v17i1r66.pdf\n.. [2] \u201cCombinatorics - Reaching All Possible Simple Directed Graphs with a given\n       Degree Sequence with 2-Edge Swaps.\u201d Mathematics Stack Exchange,\n       https://math.stackexchange.com/questions/22272/. Accessed 30 May 2022."}, {"type": "function", "name": "networkx.directed_havel_hakimi_graph", "documentation": "Returns a directed graph with the given degree sequences.\n\nParameters\n----------\nin_deg_sequence :  list of integers\n    Each list entry corresponds to the in-degree of a node.\nout_deg_sequence : list of integers\n    Each list entry corresponds to the out-degree of a node.\ncreate_using : NetworkX graph constructor, optional (default DiGraph)\n    Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : DiGraph\n    A graph with the specified degree sequences.\n    Nodes are labeled starting at 0 with an index\n    corresponding to the position in deg_sequence\n\nRaises\n------\nNetworkXError\n    If the degree sequences are not digraphical.\n\nSee Also\n--------\nconfiguration_model\n\nNotes\n-----\nAlgorithm as described by Kleitman and Wang [1]_.\n\nReferences\n----------\n.. [1] D.J. Kleitman and D.L. Wang\n   Algorithms for Constructing Graphs and Digraphs with Given Valences\n   and Factors Discrete Mathematics, 6(1), pp. 79-88 (1973)"}, {"type": "function", "name": "networkx.directed_joint_degree_graph", "documentation": "Generates a random simple directed graph with the joint degree.\n\nParameters\n----------\ndegree_seq :  list of tuples (of size 3)\n    degree sequence contains tuples of nodes with node id, in degree and\n    out degree.\nnkk  :  dictionary of dictionary of integers\n    directed joint degree dictionary, for nodes of out degree k (first\n    level of dict) and nodes of in degree l (second level of dict)\n    describes the number of edges.\nseed : hashable object, optional\n    Seed for random number generator.\n\nReturns\n-------\nG : Graph\n    A directed graph with the specified inputs.\n\nRaises\n------\nNetworkXError\n    If degree_seq and nkk are not realizable as a simple directed graph.\n\n\nNotes\n-----\nSimilarly to the undirected version:\nIn each iteration of the \"while loop\" the algorithm picks two disconnected\nnodes v and w, of degree k and l correspondingly,  for which nkk[k][l] has\nnot reached its target yet i.e. (for given k,l): n_edges_add < nkk[k][l].\nIt then adds edge (v,w) and always increases the number of edges in graph G\nby one.\n\nThe intelligence of the algorithm lies in the fact that  it is always\npossible to add an edge between disconnected nodes v and w, for which\nnkk[degree(v)][degree(w)] has not reached its target, even if one or both\nnodes do not have free stubs. If either node v or w does not have a free\nstub, we perform a \"neighbor switch\", an edge rewiring move that releases a\nfree stub while keeping nkk the same.\n\nThe difference for the directed version lies in the fact that neighbor\nswitches might not be able to rewire, but in these cases unsaturated nodes\ncan be reassigned to use instead, see [1] for detailed description and\nproofs.\n\nThe algorithm continues for E (number of edges in the graph) iterations of\nthe \"while loop\", at which point all entries of the given nkk[k][l] have\nreached their target values and the construction is complete.\n\nReferences\n----------\n[1] B. Tillman, A. Markopoulou, C. T. Butts & M. Gjoka,\n    \"Construction of Directed 2K Graphs\". In Proc. of KDD 2017.\n\nExamples\n--------\n>>> in_degrees = [0, 1, 1, 2]\n>>> out_degrees = [1, 1, 1, 1]\n>>> nkk = {1: {1: 2, 2: 2}}\n>>> G = nx.directed_joint_degree_graph(in_degrees, out_degrees, nkk)\n>>>"}, {"type": "function", "name": "networkx.directed_laplacian_matrix", "documentation": "Returns the directed Laplacian matrix of G.\n\nThe graph directed Laplacian is the matrix\n\n.. math::\n\n    L = I - \\frac{1}{2} \\left (\\Phi^{1/2} P \\Phi^{-1/2} + \\Phi^{-1/2} P^T \\Phi^{1/2} \\right )\n\nwhere `I` is the identity matrix, `P` is the transition matrix of the\ngraph, and `\\Phi` a matrix with the Perron vector of `P` in the diagonal and\nzeros elsewhere [1]_.\n\nDepending on the value of walk_type, `P` can be the transition matrix\ninduced by a random walk, a lazy random walk, or a random walk with\nteleportation (PageRank).\n\nParameters\n----------\nG : DiGraph\n   A NetworkX graph\n\nnodelist : list, optional\n   The rows and columns are ordered according to the nodes in nodelist.\n   If nodelist is None, then the ordering is produced by G.nodes().\n\nweight : string or None, optional (default='weight')\n   The edge data key used to compute each value in the matrix.\n   If None, then each edge has weight 1.\n\nwalk_type : string or None, optional (default=None)\n   One of ``\"random\"``, ``\"lazy\"``, or ``\"pagerank\"``. If ``walk_type=None``\n   (the default), then a value is selected according to the properties of `G`:\n   - ``walk_type=\"random\"`` if `G` is strongly connected and aperiodic\n   - ``walk_type=\"lazy\"`` if `G` is strongly connected but not aperiodic\n   - ``walk_type=\"pagerank\"`` for all other cases.\n\nalpha : real\n   (1 - alpha) is the teleportation probability used with pagerank\n\nReturns\n-------\nL : NumPy matrix\n  Normalized Laplacian of G.\n\nNotes\n-----\nOnly implemented for DiGraphs\n\nThe result is always a symmetric matrix.\n\nThis calculation uses the out-degree of the graph `G`. To use the\nin-degree for calculations instead, use `G.reverse(copy=False)` and\ntake the transpose.\n\nSee Also\n--------\nlaplacian_matrix\nnormalized_laplacian_matrix\ndirected_combinatorial_laplacian_matrix\n\nReferences\n----------\n.. [1] Fan Chung (2005).\n   Laplacians and the Cheeger inequality for directed graphs.\n   Annals of Combinatorics, 9(1), 2005"}, {"type": "function", "name": "networkx.directed_modularity_matrix", "documentation": "Returns the directed modularity matrix of G.\n\nThe modularity matrix is the matrix B = A - <A>, where A is the adjacency\nmatrix and <A> is the expected adjacency matrix, assuming that the graph\nis described by the configuration model.\n\nMore specifically, the element B_ij of B is defined as\n\n.. math::\n    B_{ij} = A_{ij} - k_i^{out} k_j^{in} / m\n\nwhere :math:`k_i^{in}` is the in degree of node i, and :math:`k_j^{out}` is the out degree\nof node j, with m the number of edges in the graph. When weight is set\nto a name of an attribute edge, Aij, k_i, k_j and m are computed using\nits value.\n\nParameters\n----------\nG : DiGraph\n   A NetworkX DiGraph\n\nnodelist : list, optional\n   The rows and columns are ordered according to the nodes in nodelist.\n   If nodelist is None, then the ordering is produced by G.nodes().\n\nweight : string or None, optional (default=None)\n   The edge attribute that holds the numerical value used for\n   the edge weight.  If None then all edge weights are 1.\n\nReturns\n-------\nB : Numpy array\n  The modularity matrix of G.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_edges_from(\n...     (\n...         (1, 2),\n...         (1, 3),\n...         (3, 1),\n...         (3, 2),\n...         (3, 5),\n...         (4, 5),\n...         (4, 6),\n...         (5, 4),\n...         (5, 6),\n...         (6, 4),\n...     )\n... )\n>>> B = nx.directed_modularity_matrix(G)\n\n\nNotes\n-----\nNetworkX defines the element A_ij of the adjacency matrix as 1 if there\nis a link going from node i to node j. Leicht and Newman use the opposite\ndefinition. This explains the different expression for B_ij.\n\nSee Also\n--------\nto_numpy_array\nmodularity_spectrum\nadjacency_matrix\nmodularity_matrix\n\nReferences\n----------\n.. [1] E. A. Leicht, M. E. J. Newman,\n    \"Community structure in directed networks\",\n    Phys. Rev Lett., vol. 100, no. 11, p. 118703, 2008."}, {"type": "function", "name": "networkx.disjoint_union", "documentation": "Combine graphs G and H. The nodes are assumed to be unique (disjoint).\n\nThis algorithm automatically relabels nodes to avoid name collisions.\n\nParameters\n----------\nG,H : graph\n   A NetworkX graph\n\nReturns\n-------\nU : A union graph with the same type as G.\n\nSee Also\n--------\nunion\ncompose\n:func:`~networkx.Graph.update`\n\nNotes\n-----\nA new graph is created, of the same class as G.  It is recommended\nthat G and H be either both directed or both undirected.\n\nThe nodes of G are relabeled 0 to len(G)-1, and the nodes of H are\nrelabeled len(G) to len(G)+len(H)-1.\n\nRenumbering forces G and H to be disjoint, so no exception is ever raised for a name collision.\nTo preserve the check for common nodes, use union().\n\nEdge and node attributes are propagated from G and H to the union graph.\nGraph attributes are also propagated, but if they are present in both G and H,\nthen the value from H is used.\n\nTo combine graphs that have common nodes, consider compose(G, H)\nor the method, Graph.update().\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (1, 2)])\n>>> H = nx.Graph([(0, 3), (1, 2), (2, 3)])\n>>> G.nodes[0][\"key1\"] = 5\n>>> H.nodes[0][\"key2\"] = 10\n>>> U = nx.disjoint_union(G, H)\n>>> U.nodes(data=True)\nNodeDataView({0: {'key1': 5}, 1: {}, 2: {}, 3: {'key2': 10}, 4: {}, 5: {}, 6: {}})\n>>> U.edges\nEdgeView([(0, 1), (0, 2), (1, 2), (3, 4), (4, 6), (5, 6)])"}, {"type": "function", "name": "networkx.disjoint_union_all", "documentation": "Returns the disjoint union of all graphs.\n\nThis operation forces distinct integer node labels starting with 0\nfor the first graph in the list and numbering consecutively.\n\nParameters\n----------\ngraphs : iterable\n   Iterable of NetworkX graphs\n\nReturns\n-------\nU : A graph with the same type as the first graph in list\n\nRaises\n------\nValueError\n   If `graphs` is an empty list.\n\nNetworkXError\n    In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs.\n\nExamples\n--------\n>>> G1 = nx.Graph([(1, 2), (2, 3)])\n>>> G2 = nx.Graph([(4, 5), (5, 6)])\n>>> U = nx.disjoint_union_all([G1, G2])\n>>> list(U.nodes())\n[0, 1, 2, 3, 4, 5]\n>>> list(U.edges())\n[(0, 1), (1, 2), (3, 4), (4, 5)]\n\nNotes\n-----\nFor operating on mixed type graphs, they should be converted to the same type.\n\nGraph, edge, and node attributes are propagated to the union graph.\nIf a graph attribute is present in multiple graphs, then the value\nfrom the last graph in the list with that attribute is used."}, {"type": "function", "name": "networkx.dispersion", "documentation": "Calculate dispersion between `u` and `v` in `G`.\n\nA link between two actors (`u` and `v`) has a high dispersion when their\nmutual ties (`s` and `t`) are not well connected with each other.\n\nParameters\n----------\nG : graph\n    A NetworkX graph.\nu : node, optional\n    The source for the dispersion score (e.g. ego node of the network).\nv : node, optional\n    The target of the dispersion score if specified.\nnormalized : bool\n    If True (default) normalize by the embeddedness of the nodes (u and v).\nalpha, b, c : float\n    Parameters for the normalization procedure. When `normalized` is True,\n    the dispersion value is normalized by::\n\n        result = ((dispersion + b) ** alpha) / (embeddedness + c)\n\n    as long as the denominator is nonzero.\n\nReturns\n-------\nnodes : dictionary\n    If u (v) is specified, returns a dictionary of nodes with dispersion\n    score for all \"target\" (\"source\") nodes. If neither u nor v is\n    specified, returns a dictionary of dictionaries for all nodes 'u' in the\n    graph with a dispersion score for each node 'v'.\n\nNotes\n-----\nThis implementation follows Lars Backstrom and Jon Kleinberg [1]_. Typical\nusage would be to run dispersion on the ego network $G_u$ if $u$ were\nspecified.  Running :func:`dispersion` with neither $u$ nor $v$ specified\ncan take some time to complete.\n\nReferences\n----------\n.. [1] Romantic Partnerships and the Dispersion of Social Ties:\n    A Network Analysis of Relationship Status on Facebook.\n    Lars Backstrom, Jon Kleinberg.\n    https://arxiv.org/pdf/1310.6753v1.pdf"}, {"type": "function", "name": "networkx.dodecahedral_graph", "documentation": "Returns the Platonic Dodecahedral graph.\n\nThe dodecahedral graph has 20 nodes and 30 edges. The skeleton of the\ndodecahedron forms a graph. It is one of 5 Platonic graphs [1]_.\nIt can be described in LCF notation as:\n``[10, 7, 4, -4, -7, 10, -4, 7, -7, 4]^2`` [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Dodecahedral Graph with 20 nodes and 30 edges\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Regular_dodecahedron#Dodecahedral_graph\n.. [2] https://mathworld.wolfram.com/DodecahedralGraph.html"}, {"type": "function", "name": "networkx.dominance_frontiers", "documentation": "Returns the dominance frontiers of all nodes of a directed graph.\n\nParameters\n----------\nG : a DiGraph or MultiDiGraph\n    The graph where dominance is to be computed.\n\nstart : node\n    The start node of dominance computation.\n\nReturns\n-------\ndf : dict keyed by nodes\n    A dict containing the dominance frontiers of each node reachable from\n    `start` as lists.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is undirected.\n\nNetworkXError\n    If `start` is not in `G`.\n\nExamples\n--------\n>>> G = nx.DiGraph([(1, 2), (1, 3), (2, 5), (3, 4), (4, 5)])\n>>> sorted((u, sorted(df)) for u, df in nx.dominance_frontiers(G, 1).items())\n[(1, []), (2, [5]), (3, [5]), (4, [5]), (5, [])]\n\nReferences\n----------\n.. [1] K. D. Cooper, T. J. Harvey, and K. Kennedy.\n       A simple, fast dominance algorithm.\n       Software Practice & Experience, 4:110, 2001."}, {"type": "function", "name": "networkx.dominating_set", "documentation": "Finds a dominating set for the graph G.\n\nA *dominating set* for a graph with node set *V* is a subset *D* of\n*V* such that every node not in *D* is adjacent to at least one\nmember of *D* [1]_.\n\nParameters\n----------\nG : NetworkX graph\n\nstart_with : node (default=None)\n    Node to use as a starting point for the algorithm.\n\nReturns\n-------\nD : set\n    A dominating set for G.\n\nNotes\n-----\nThis function is an implementation of algorithm 7 in [2]_ which\nfinds some dominating set, not necessarily the smallest one.\n\nSee also\n--------\nis_dominating_set\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Dominating_set\n\n.. [2] Abdol-Hossein Esfahanian. Connectivity Algorithms.\n    http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf"}, {"type": "function", "name": "networkx.dorogovtsev_goltsev_mendes_graph", "documentation": "Returns the hierarchically constructed Dorogovtsev-Goltsev-Mendes graph.\n\nThe Dorogovtsev-Goltsev-Mendes [1]_ procedure produces a scale-free graph\ndeterministically with the following properties for a given `n`:\n- Total number of nodes = ``3 * (3**n + 1) / 2``\n- Total number of edges = ``3 ** (n + 1)``\n\n.. plot::\n\n    >>> nx.draw(nx.dorogovtsev_goltsev_mendes_graph(3))\n\nParameters\n----------\nn : integer\n   The generation number.\n\ncreate_using : NetworkX Graph, optional\n   Graph type to be returned. Directed graphs and multi graphs are not\n   supported.\n\nReturns\n-------\nG : NetworkX Graph\n\nExamples\n--------\n>>> G = nx.dorogovtsev_goltsev_mendes_graph(3)\n>>> G.number_of_nodes()\n15\n>>> G.number_of_edges()\n27\n>>> nx.is_planar(G)\nTrue\n\nReferences\n----------\n.. [1] S. N. Dorogovtsev, A. V. Goltsev and J. F. F. Mendes,\n    \"Pseudofractal scale-free web\", Physical Review E 65, 066122, 2002.\n    https://arxiv.org/pdf/cond-mat/0112143.pdf"}, {"type": "function", "name": "networkx.double_edge_swap", "documentation": "Swap two edges in the graph while keeping the node degrees fixed.\n\nA double-edge swap removes two randomly chosen edges u-v and x-y\nand creates the new edges u-x and v-y::\n\n u--v            u  v\n        becomes  |  |\n x--y            x  y\n\nIf either the edge u-x or v-y already exist no swap is performed\nand another attempt is made to find a suitable edge pair.\n\nParameters\n----------\nG : graph\n   An undirected graph\n\nnswap : integer (optional, default=1)\n   Number of double-edge swaps to perform\n\nmax_tries : integer (optional)\n   Maximum number of attempts to swap edges\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : graph\n   The graph after double edge swaps.\n\nRaises\n------\nNetworkXError\n    If `G` is directed, or\n    If `nswap` > `max_tries`, or\n    If there are fewer than 4 nodes or 2 edges in `G`.\nNetworkXAlgorithmError\n    If the number of swap attempts exceeds `max_tries` before `nswap` swaps are made\n\nNotes\n-----\nDoes not enforce any connectivity constraints.\n\nThe graph G is modified in place."}, {"type": "function", "name": "networkx.draw", "documentation": "Draw the graph G with Matplotlib.\n\nDraw the graph as a simple representation with no node\nlabels or edge labels and using the full Matplotlib figure area\nand no axis labels by default.  See draw_networkx() for more\nfull-featured drawing that allows title, axis labels etc.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\npos : dictionary, optional\n    A dictionary with nodes as keys and positions as values.\n    If not specified a spring layout positioning will be computed.\n    See :py:mod:`networkx.drawing.layout` for functions that\n    compute node positions.\n\nax : Matplotlib Axes object, optional\n    Draw the graph in specified Matplotlib axes.\n\nkwds : optional keywords\n    See networkx.draw_networkx() for a description of optional keywords.\n\nExamples\n--------\n>>> G = nx.dodecahedral_graph()\n>>> nx.draw(G)\n>>> nx.draw(G, pos=nx.spring_layout(G))  # use spring layout\n\nSee Also\n--------\ndraw_networkx\ndraw_networkx_nodes\ndraw_networkx_edges\ndraw_networkx_labels\ndraw_networkx_edge_labels\n\nNotes\n-----\nThis function has the same name as pylab.draw and pyplot.draw\nso beware when using `from networkx import *`\n\nsince you might overwrite the pylab.draw function.\n\nWith pyplot use\n\n>>> import matplotlib.pyplot as plt\n>>> G = nx.dodecahedral_graph()\n>>> nx.draw(G)  # networkx draw()\n>>> plt.draw()  # pyplot draw()\n\nAlso see the NetworkX drawing examples at\nhttps://networkx.org/documentation/latest/auto_examples/index.html"}, {"type": "function", "name": "networkx.draw_circular", "documentation": "Draw the graph `G` with a circular layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.circular_layout(G), **kwargs)\n\nParameters\n----------\nG : graph\n    A networkx graph\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\nNotes\n-----\nThe layout is computed each time this function is called. For\nrepeated drawing it is much more efficient to call\n`~networkx.drawing.layout.circular_layout` directly and reuse the result::\n\n    >>> G = nx.complete_graph(5)\n    >>> pos = nx.circular_layout(G)\n    >>> nx.draw(G, pos=pos)  # Draw the original graph\n    >>> # Draw a subgraph, reusing the same node positions\n    >>> nx.draw(G.subgraph([0, 1, 2]), pos=pos, node_color=\"red\")\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> nx.draw_circular(G)\n\nSee Also\n--------\n:func:`~networkx.drawing.layout.circular_layout`"}, {"type": "function", "name": "networkx.draw_kamada_kawai", "documentation": "Draw the graph `G` with a Kamada-Kawai force-directed layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.kamada_kawai_layout(G), **kwargs)\n\nParameters\n----------\nG : graph\n    A networkx graph\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\nNotes\n-----\nThe layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call\n`~networkx.drawing.layout.kamada_kawai_layout` directly and reuse the\nresult::\n\n    >>> G = nx.complete_graph(5)\n    >>> pos = nx.kamada_kawai_layout(G)\n    >>> nx.draw(G, pos=pos)  # Draw the original graph\n    >>> # Draw a subgraph, reusing the same node positions\n    >>> nx.draw(G.subgraph([0, 1, 2]), pos=pos, node_color=\"red\")\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> nx.draw_kamada_kawai(G)\n\nSee Also\n--------\n:func:`~networkx.drawing.layout.kamada_kawai_layout`"}, {"type": "function", "name": "networkx.draw_networkx", "documentation": "Draw the graph G using Matplotlib.\n\nDraw the graph with Matplotlib with options for node positions,\nlabeling, titles, and many other drawing features.\nSee draw() for simple drawing without labels or axes.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\npos : dictionary, optional\n    A dictionary with nodes as keys and positions as values.\n    If not specified a spring layout positioning will be computed.\n    See :py:mod:`networkx.drawing.layout` for functions that\n    compute node positions.\n\narrows : bool or None, optional (default=None)\n    If `None`, directed graphs draw arrowheads with\n    `~matplotlib.patches.FancyArrowPatch`, while undirected graphs draw edges\n    via `~matplotlib.collections.LineCollection` for speed.\n    If `True`, draw arrowheads with FancyArrowPatches (bendable and stylish).\n    If `False`, draw edges using LineCollection (linear and fast).\n    For directed graphs, if True draw arrowheads.\n    Note: Arrows will be the same color as edges.\n\narrowstyle : str (default='-\\|>' for directed graphs)\n    For directed graphs, choose the style of the arrowsheads.\n    For undirected graphs default to '-'\n\n    See `matplotlib.patches.ArrowStyle` for more options.\n\narrowsize : int or list (default=10)\n    For directed graphs, choose the size of the arrow head's length and\n    width. A list of values can be passed in to assign a different size for arrow head's length and width.\n    See `matplotlib.patches.FancyArrowPatch` for attribute `mutation_scale`\n    for more info.\n\nwith_labels :  bool (default=True)\n    Set to True to draw labels on the nodes.\n\nax : Matplotlib Axes object, optional\n    Draw the graph in the specified Matplotlib axes.\n\nnodelist : list (default=list(G))\n    Draw only specified nodes\n\nedgelist : list (default=list(G.edges()))\n    Draw only specified edges\n\nnode_size : scalar or array (default=300)\n    Size of nodes.  If an array is specified it must be the\n    same length as nodelist.\n\nnode_color : color or array of colors (default='#1f78b4')\n    Node color. Can be a single color or a sequence of colors with the same\n    length as nodelist. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1. If numeric values are specified they will be\n    mapped to colors using the cmap and vmin,vmax parameters. See\n    matplotlib.scatter for more details.\n\nnode_shape :  string (default='o')\n    The shape of the node.  Specification is as matplotlib.scatter\n    marker, one of 'so^>v<dph8'.\n\nalpha : float or None (default=None)\n    The node and edge transparency\n\ncmap : Matplotlib colormap, optional\n    Colormap for mapping intensities of nodes\n\nvmin,vmax : float, optional\n    Minimum and maximum for node colormap scaling\n\nlinewidths : scalar or sequence (default=1.0)\n    Line width of symbol border\n\nwidth : float or array of floats (default=1.0)\n    Line width of edges\n\nedge_color : color or array of colors (default='k')\n    Edge color. Can be a single color or a sequence of colors with the same\n    length as edgelist. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1. If numeric values are specified they will be\n    mapped to colors using the edge_cmap and edge_vmin,edge_vmax parameters.\n\nedge_cmap : Matplotlib colormap, optional\n    Colormap for mapping intensities of edges\n\nedge_vmin,edge_vmax : floats, optional\n    Minimum and maximum for edge colormap scaling\n\nstyle : string (default=solid line)\n    Edge line style e.g.: '-', '--', '-.', ':'\n    or words like 'solid' or 'dashed'.\n    (See `matplotlib.patches.FancyArrowPatch`: `linestyle`)\n\nlabels : dictionary (default=None)\n    Node labels in a dictionary of text labels keyed by node\n\nfont_size : int (default=12 for nodes, 10 for edges)\n    Font size for text labels\n\nfont_color : color (default='k' black)\n    Font color string. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1.\n\nfont_weight : string (default='normal')\n    Font weight\n\nfont_family : string (default='sans-serif')\n    Font family\n\nlabel : string, optional\n    Label for graph legend\n\nhide_ticks : bool, optional\n    Hide ticks of axes. When `True` (the default), ticks and ticklabels\n    are removed from the axes. To set ticks and tick labels to the pyplot default,\n    use ``hide_ticks=False``.\n\nkwds : optional keywords\n    See networkx.draw_networkx_nodes(), networkx.draw_networkx_edges(), and\n    networkx.draw_networkx_labels() for a description of optional keywords.\n\nNotes\n-----\nFor directed graphs, arrows  are drawn at the head end.  Arrows can be\nturned off with keyword arrows=False.\n\nExamples\n--------\n>>> G = nx.dodecahedral_graph()\n>>> nx.draw(G)\n>>> nx.draw(G, pos=nx.spring_layout(G))  # use spring layout\n\n>>> import matplotlib.pyplot as plt\n>>> limits = plt.axis(\"off\")  # turn off axis\n\nAlso see the NetworkX drawing examples at\nhttps://networkx.org/documentation/latest/auto_examples/index.html\n\nSee Also\n--------\ndraw\ndraw_networkx_nodes\ndraw_networkx_edges\ndraw_networkx_labels\ndraw_networkx_edge_labels"}, {"type": "function", "name": "networkx.draw_networkx_edge_labels", "documentation": "Draw edge labels.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\npos : dictionary\n    A dictionary with nodes as keys and positions as values.\n    Positions should be sequences of length 2.\n\nedge_labels : dictionary (default=None)\n    Edge labels in a dictionary of labels keyed by edge two-tuple.\n    Only labels for the keys in the dictionary are drawn.\n\nlabel_pos : float (default=0.5)\n    Position of edge label along edge (0=head, 0.5=center, 1=tail)\n\nfont_size : int (default=10)\n    Font size for text labels\n\nfont_color : color (default='k' black)\n    Font color string. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1.\n\nfont_weight : string (default='normal')\n    Font weight\n\nfont_family : string (default='sans-serif')\n    Font family\n\nalpha : float or None (default=None)\n    The text transparency\n\nbbox : Matplotlib bbox, optional\n    Specify text box properties (e.g. shape, color etc.) for edge labels.\n    Default is {boxstyle='round', ec=(1.0, 1.0, 1.0), fc=(1.0, 1.0, 1.0)}.\n\nhorizontalalignment : string (default='center')\n    Horizontal alignment {'center', 'right', 'left'}\n\nverticalalignment : string (default='center')\n    Vertical alignment {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n\nax : Matplotlib Axes object, optional\n    Draw the graph in the specified Matplotlib axes.\n\nrotate : bool (default=True)\n    Rotate edge labels to lie parallel to edges\n\nclip_on : bool (default=True)\n    Turn on clipping of edge labels at axis boundaries\n\nnode_size : scalar or array (default=300)\n    Size of nodes.  If an array it must be the same length as nodelist.\n\nnodelist : list, optional (default=G.nodes())\n   This provides the node order for the `node_size` array (if it is an array).\n\nconnectionstyle : string or iterable of strings (default=\"arc3\")\n    Pass the connectionstyle parameter to create curved arc of rounding\n    radius rad. For example, connectionstyle='arc3,rad=0.2'.\n    See `matplotlib.patches.ConnectionStyle` and\n    `matplotlib.patches.FancyArrowPatch` for more info.\n    If Iterable, index indicates i'th edge key of MultiGraph\n\nhide_ticks : bool, optional\n    Hide ticks of axes. When `True` (the default), ticks and ticklabels\n    are removed from the axes. To set ticks and tick labels to the pyplot default,\n    use ``hide_ticks=False``.\n\nReturns\n-------\ndict\n    `dict` of labels keyed by edge\n\nExamples\n--------\n>>> G = nx.dodecahedral_graph()\n>>> edge_labels = nx.draw_networkx_edge_labels(G, pos=nx.spring_layout(G))\n\nAlso see the NetworkX drawing examples at\nhttps://networkx.org/documentation/latest/auto_examples/index.html\n\nSee Also\n--------\ndraw\ndraw_networkx\ndraw_networkx_nodes\ndraw_networkx_edges\ndraw_networkx_labels"}, {"type": "function", "name": "networkx.draw_networkx_edges", "documentation": "Draw the edges of the graph G.\n\nThis draws only the edges of the graph G.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\npos : dictionary\n    A dictionary with nodes as keys and positions as values.\n    Positions should be sequences of length 2.\n\nedgelist : collection of edge tuples (default=G.edges())\n    Draw only specified edges\n\nwidth : float or array of floats (default=1.0)\n    Line width of edges\n\nedge_color : color or array of colors (default='k')\n    Edge color. Can be a single color or a sequence of colors with the same\n    length as edgelist. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1. If numeric values are specified they will be\n    mapped to colors using the edge_cmap and edge_vmin,edge_vmax parameters.\n\nstyle : string or array of strings (default='solid')\n    Edge line style e.g.: '-', '--', '-.', ':'\n    or words like 'solid' or 'dashed'.\n    Can be a single style or a sequence of styles with the same\n    length as the edge list.\n    If less styles than edges are given the styles will cycle.\n    If more styles than edges are given the styles will be used sequentially\n    and not be exhausted.\n    Also, `(offset, onoffseq)` tuples can be used as style instead of a strings.\n    (See `matplotlib.patches.FancyArrowPatch`: `linestyle`)\n\nalpha : float or array of floats (default=None)\n    The edge transparency.  This can be a single alpha value,\n    in which case it will be applied to all specified edges. Otherwise,\n    if it is an array, the elements of alpha will be applied to the colors\n    in order (cycling through alpha multiple times if necessary).\n\nedge_cmap : Matplotlib colormap, optional\n    Colormap for mapping intensities of edges\n\nedge_vmin,edge_vmax : floats, optional\n    Minimum and maximum for edge colormap scaling\n\nax : Matplotlib Axes object, optional\n    Draw the graph in the specified Matplotlib axes.\n\narrows : bool or None, optional (default=None)\n    If `None`, directed graphs draw arrowheads with\n    `~matplotlib.patches.FancyArrowPatch`, while undirected graphs draw edges\n    via `~matplotlib.collections.LineCollection` for speed.\n    If `True`, draw arrowheads with FancyArrowPatches (bendable and stylish).\n    If `False`, draw edges using LineCollection (linear and fast).\n\n    Note: Arrowheads will be the same color as edges.\n\narrowstyle : str (default='-\\|>' for directed graphs)\n    For directed graphs and `arrows==True` defaults to '-\\|>',\n    For undirected graphs default to '-'.\n\n    See `matplotlib.patches.ArrowStyle` for more options.\n\narrowsize : int (default=10)\n    For directed graphs, choose the size of the arrow head's length and\n    width. See `matplotlib.patches.FancyArrowPatch` for attribute\n    `mutation_scale` for more info.\n\nconnectionstyle : string or iterable of strings (default=\"arc3\")\n    Pass the connectionstyle parameter to create curved arc of rounding\n    radius rad. For example, connectionstyle='arc3,rad=0.2'.\n    See `matplotlib.patches.ConnectionStyle` and\n    `matplotlib.patches.FancyArrowPatch` for more info.\n    If Iterable, index indicates i'th edge key of MultiGraph\n\nnode_size : scalar or array (default=300)\n    Size of nodes. Though the nodes are not drawn with this function, the\n    node size is used in determining edge positioning.\n\nnodelist : list, optional (default=G.nodes())\n   This provides the node order for the `node_size` array (if it is an array).\n\nnode_shape :  string (default='o')\n    The marker used for nodes, used in determining edge positioning.\n    Specification is as a `matplotlib.markers` marker, e.g. one of 'so^>v<dph8'.\n\nlabel : None or string\n    Label for legend\n\nmin_source_margin : int (default=0)\n    The minimum margin (gap) at the beginning of the edge at the source.\n\nmin_target_margin : int (default=0)\n    The minimum margin (gap) at the end of the edge at the target.\n\nhide_ticks : bool, optional\n    Hide ticks of axes. When `True` (the default), ticks and ticklabels\n    are removed from the axes. To set ticks and tick labels to the pyplot default,\n    use ``hide_ticks=False``.\n\nReturns\n-------\n matplotlib.collections.LineCollection or a list of matplotlib.patches.FancyArrowPatch\n    If ``arrows=True``, a list of FancyArrowPatches is returned.\n    If ``arrows=False``, a LineCollection is returned.\n    If ``arrows=None`` (the default), then a LineCollection is returned if\n    `G` is undirected, otherwise returns a list of FancyArrowPatches.\n\nNotes\n-----\nFor directed graphs, arrows are drawn at the head end.  Arrows can be\nturned off with keyword arrows=False or by passing an arrowstyle without\nan arrow on the end.\n\nBe sure to include `node_size` as a keyword argument; arrows are\ndrawn considering the size of nodes.\n\nSelf-loops are always drawn with `~matplotlib.patches.FancyArrowPatch`\nregardless of the value of `arrows` or whether `G` is directed.\nWhen ``arrows=False`` or ``arrows=None`` and `G` is undirected, the\nFancyArrowPatches corresponding to the self-loops are not explicitly\nreturned. They should instead be accessed via the ``Axes.patches``\nattribute (see examples).\n\nExamples\n--------\n>>> G = nx.dodecahedral_graph()\n>>> edges = nx.draw_networkx_edges(G, pos=nx.spring_layout(G))\n\n>>> G = nx.DiGraph()\n>>> G.add_edges_from([(1, 2), (1, 3), (2, 3)])\n>>> arcs = nx.draw_networkx_edges(G, pos=nx.spring_layout(G))\n>>> alphas = [0.3, 0.4, 0.5]\n>>> for i, arc in enumerate(arcs):  # change alpha values of arcs\n...     arc.set_alpha(alphas[i])\n\nThe FancyArrowPatches corresponding to self-loops are not always\nreturned, but can always be accessed via the ``patches`` attribute of the\n`matplotlib.Axes` object.\n\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots()\n>>> G = nx.Graph([(0, 1), (0, 0)])  # Self-loop at node 0\n>>> edge_collection = nx.draw_networkx_edges(G, pos=nx.circular_layout(G), ax=ax)\n>>> self_loop_fap = ax.patches[0]\n\nAlso see the NetworkX drawing examples at\nhttps://networkx.org/documentation/latest/auto_examples/index.html\n\nSee Also\n--------\ndraw\ndraw_networkx\ndraw_networkx_nodes\ndraw_networkx_labels\ndraw_networkx_edge_labels"}, {"type": "function", "name": "networkx.draw_networkx_labels", "documentation": "Draw node labels on the graph G.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\npos : dictionary\n    A dictionary with nodes as keys and positions as values.\n    Positions should be sequences of length 2.\n\nlabels : dictionary (default={n: n for n in G})\n    Node labels in a dictionary of text labels keyed by node.\n    Node-keys in labels should appear as keys in `pos`.\n    If needed use: `{n:lab for n,lab in labels.items() if n in pos}`\n\nfont_size : int (default=12)\n    Font size for text labels\n\nfont_color : color (default='k' black)\n    Font color string. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1.\n\nfont_weight : string (default='normal')\n    Font weight\n\nfont_family : string (default='sans-serif')\n    Font family\n\nalpha : float or None (default=None)\n    The text transparency\n\nbbox : Matplotlib bbox, (default is Matplotlib's ax.text default)\n    Specify text box properties (e.g. shape, color etc.) for node labels.\n\nhorizontalalignment : string (default='center')\n    Horizontal alignment {'center', 'right', 'left'}\n\nverticalalignment : string (default='center')\n    Vertical alignment {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n\nax : Matplotlib Axes object, optional\n    Draw the graph in the specified Matplotlib axes.\n\nclip_on : bool (default=True)\n    Turn on clipping of node labels at axis boundaries\n\nhide_ticks : bool, optional\n    Hide ticks of axes. When `True` (the default), ticks and ticklabels\n    are removed from the axes. To set ticks and tick labels to the pyplot default,\n    use ``hide_ticks=False``.\n\nReturns\n-------\ndict\n    `dict` of labels keyed on the nodes\n\nExamples\n--------\n>>> G = nx.dodecahedral_graph()\n>>> labels = nx.draw_networkx_labels(G, pos=nx.spring_layout(G))\n\nAlso see the NetworkX drawing examples at\nhttps://networkx.org/documentation/latest/auto_examples/index.html\n\nSee Also\n--------\ndraw\ndraw_networkx\ndraw_networkx_nodes\ndraw_networkx_edges\ndraw_networkx_edge_labels"}, {"type": "function", "name": "networkx.draw_networkx_nodes", "documentation": "Draw the nodes of the graph G.\n\nThis draws only the nodes of the graph G.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\npos : dictionary\n    A dictionary with nodes as keys and positions as values.\n    Positions should be sequences of length 2.\n\nax : Matplotlib Axes object, optional\n    Draw the graph in the specified Matplotlib axes.\n\nnodelist : list (default list(G))\n    Draw only specified nodes\n\nnode_size : scalar or array (default=300)\n    Size of nodes.  If an array it must be the same length as nodelist.\n\nnode_color : color or array of colors (default='#1f78b4')\n    Node color. Can be a single color or a sequence of colors with the same\n    length as nodelist. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1. If numeric values are specified they will be\n    mapped to colors using the cmap and vmin,vmax parameters. See\n    matplotlib.scatter for more details.\n\nnode_shape :  string (default='o')\n    The shape of the node.  Specification is as matplotlib.scatter\n    marker, one of 'so^>v<dph8'.\n\nalpha : float or array of floats (default=None)\n    The node transparency.  This can be a single alpha value,\n    in which case it will be applied to all the nodes of color. Otherwise,\n    if it is an array, the elements of alpha will be applied to the colors\n    in order (cycling through alpha multiple times if necessary).\n\ncmap : Matplotlib colormap (default=None)\n    Colormap for mapping intensities of nodes\n\nvmin,vmax : floats or None (default=None)\n    Minimum and maximum for node colormap scaling\n\nlinewidths : [None | scalar | sequence] (default=1.0)\n    Line width of symbol border\n\nedgecolors : [None | scalar | sequence] (default = node_color)\n    Colors of node borders. Can be a single color or a sequence of colors with the\n    same length as nodelist. Color can be string or rgb (or rgba) tuple of floats\n    from 0-1. If numeric values are specified they will be mapped to colors\n    using the cmap and vmin,vmax parameters. See `~matplotlib.pyplot.scatter` for more details.\n\nlabel : [None | string]\n    Label for legend\n\nmargins : float or 2-tuple, optional\n    Sets the padding for axis autoscaling. Increase margin to prevent\n    clipping for nodes that are near the edges of an image. Values should\n    be in the range ``[0, 1]``. See :meth:`matplotlib.axes.Axes.margins`\n    for details. The default is `None`, which uses the Matplotlib default.\n\nhide_ticks : bool, optional\n    Hide ticks of axes. When `True` (the default), ticks and ticklabels\n    are removed from the axes. To set ticks and tick labels to the pyplot default,\n    use ``hide_ticks=False``.\n\nReturns\n-------\nmatplotlib.collections.PathCollection\n    `PathCollection` of the nodes.\n\nExamples\n--------\n>>> G = nx.dodecahedral_graph()\n>>> nodes = nx.draw_networkx_nodes(G, pos=nx.spring_layout(G))\n\nAlso see the NetworkX drawing examples at\nhttps://networkx.org/documentation/latest/auto_examples/index.html\n\nSee Also\n--------\ndraw\ndraw_networkx\ndraw_networkx_edges\ndraw_networkx_labels\ndraw_networkx_edge_labels"}, {"type": "function", "name": "networkx.draw_planar", "documentation": "Draw a planar networkx graph `G` with planar layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.planar_layout(G), **kwargs)\n\nParameters\n----------\nG : graph\n    A planar networkx graph\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\nRaises\n------\nNetworkXException\n    When `G` is not planar\n\nNotes\n-----\nThe layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call\n`~networkx.drawing.layout.planar_layout` directly and reuse the result::\n\n    >>> G = nx.path_graph(5)\n    >>> pos = nx.planar_layout(G)\n    >>> nx.draw(G, pos=pos)  # Draw the original graph\n    >>> # Draw a subgraph, reusing the same node positions\n    >>> nx.draw(G.subgraph([0, 1, 2]), pos=pos, node_color=\"red\")\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.draw_planar(G)\n\nSee Also\n--------\n:func:`~networkx.drawing.layout.planar_layout`"}, {"type": "function", "name": "networkx.draw_random", "documentation": "Draw the graph `G` with a random layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.random_layout(G), **kwargs)\n\nParameters\n----------\nG : graph\n    A networkx graph\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\nNotes\n-----\nThe layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call\n`~networkx.drawing.layout.random_layout` directly and reuse the result::\n\n    >>> G = nx.complete_graph(5)\n    >>> pos = nx.random_layout(G)\n    >>> nx.draw(G, pos=pos)  # Draw the original graph\n    >>> # Draw a subgraph, reusing the same node positions\n    >>> nx.draw(G.subgraph([0, 1, 2]), pos=pos, node_color=\"red\")\n\nExamples\n--------\n>>> G = nx.lollipop_graph(4, 3)\n>>> nx.draw_random(G)\n\nSee Also\n--------\n:func:`~networkx.drawing.layout.random_layout`"}, {"type": "function", "name": "networkx.draw_shell", "documentation": "Draw networkx graph `G` with shell layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.shell_layout(G, nlist=nlist), **kwargs)\n\nParameters\n----------\nG : graph\n    A networkx graph\n\nnlist : list of list of nodes, optional\n    A list containing lists of nodes representing the shells.\n    Default is `None`, meaning all nodes are in a single shell.\n    See `~networkx.drawing.layout.shell_layout` for details.\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\nNotes\n-----\nThe layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call\n`~networkx.drawing.layout.shell_layout` directly and reuse the result::\n\n    >>> G = nx.complete_graph(5)\n    >>> pos = nx.shell_layout(G)\n    >>> nx.draw(G, pos=pos)  # Draw the original graph\n    >>> # Draw a subgraph, reusing the same node positions\n    >>> nx.draw(G.subgraph([0, 1, 2]), pos=pos, node_color=\"red\")\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> shells = [[0], [1, 2, 3]]\n>>> nx.draw_shell(G, nlist=shells)\n\nSee Also\n--------\n:func:`~networkx.drawing.layout.shell_layout`"}, {"type": "function", "name": "networkx.draw_spectral", "documentation": "Draw the graph `G` with a spectral 2D layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.spectral_layout(G), **kwargs)\n\nFor more information about how node positions are determined, see\n`~networkx.drawing.layout.spectral_layout`.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\nNotes\n-----\nThe layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call\n`~networkx.drawing.layout.spectral_layout` directly and reuse the result::\n\n    >>> G = nx.complete_graph(5)\n    >>> pos = nx.spectral_layout(G)\n    >>> nx.draw(G, pos=pos)  # Draw the original graph\n    >>> # Draw a subgraph, reusing the same node positions\n    >>> nx.draw(G.subgraph([0, 1, 2]), pos=pos, node_color=\"red\")\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> nx.draw_spectral(G)\n\nSee Also\n--------\n:func:`~networkx.drawing.layout.spectral_layout`"}, {"type": "function", "name": "networkx.draw_spring", "documentation": "Draw the graph `G` with a spring layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.spring_layout(G), **kwargs)\n\nParameters\n----------\nG : graph\n    A networkx graph\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\nNotes\n-----\n`~networkx.drawing.layout.spring_layout` is also the default layout for\n`draw`, so this function is equivalent to `draw`.\n\nThe layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call\n`~networkx.drawing.layout.spring_layout` directly and reuse the result::\n\n    >>> G = nx.complete_graph(5)\n    >>> pos = nx.spring_layout(G)\n    >>> nx.draw(G, pos=pos)  # Draw the original graph\n    >>> # Draw a subgraph, reusing the same node positions\n    >>> nx.draw(G.subgraph([0, 1, 2]), pos=pos, node_color=\"red\")\n\nExamples\n--------\n>>> G = nx.path_graph(20)\n>>> nx.draw_spring(G)\n\nSee Also\n--------\ndraw\n:func:`~networkx.drawing.layout.spring_layout`"}, {"type": "function", "name": "networkx.dual_barabasi_albert_graph", "documentation": "Returns a random graph using dual Barab\u00e1si\u2013Albert preferential attachment\n\nA graph of $n$ nodes is grown by attaching new nodes each with either $m_1$\nedges (with probability $p$) or $m_2$ edges (with probability $1-p$) that\nare preferentially attached to existing nodes with high degree.\n\nParameters\n----------\nn : int\n    Number of nodes\nm1 : int\n    Number of edges to link each new node to existing nodes with probability $p$\nm2 : int\n    Number of edges to link each new node to existing nodes with probability $1-p$\np : float\n    The probability of attaching $m_1$ edges (as opposed to $m_2$ edges)\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ninitial_graph : Graph or None (default)\n    Initial network for Barab\u00e1si\u2013Albert algorithm.\n    A copy of `initial_graph` is used.\n    It should be connected for most use cases.\n    If None, starts from an star graph on max(m1, m2) + 1 nodes.\n\nReturns\n-------\nG : Graph\n\nRaises\n------\nNetworkXError\n    If `m1` and `m2` do not satisfy ``1 <= m1,m2 < n``, or\n    `p` does not satisfy ``0 <= p <= 1``, or\n    the initial graph number of nodes m0 does not satisfy m1, m2 <= m0 <= n.\n\nReferences\n----------\n.. [1] N. Moshiri \"The dual-Barabasi-Albert model\", arXiv:1810.10538."}, {"type": "function", "name": "networkx.duplication_divergence_graph", "documentation": "Returns an undirected graph using the duplication-divergence model.\n\nA graph of `n` nodes is created by duplicating the initial nodes\nand retaining edges incident to the original nodes with a retention\nprobability `p`.\n\nParameters\n----------\nn : int\n    The desired number of nodes in the graph.\np : float\n    The probability for retaining the edge of the replicated node.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : Graph\n\nRaises\n------\nNetworkXError\n    If `p` is not a valid probability.\n    If `n` is less than 2.\n\nNotes\n-----\nThis algorithm appears in [1].\n\nThis implementation disallows the possibility of generating\ndisconnected graphs.\n\nReferences\n----------\n.. [1] I. Ispolatov, P. L. Krapivsky, A. Yuryev,\n   \"Duplication-divergence model of protein interaction network\",\n   Phys. Rev. E, 71, 061911, 2005."}, {"type": "function", "name": "networkx.eccentricity", "documentation": "Returns the eccentricity of nodes in G.\n\nThe eccentricity of a node v is the maximum distance from v to\nall other nodes in G.\n\nParameters\n----------\nG : NetworkX graph\n   A graph\n\nv : node, optional\n   Return value of specified node\n\nsp : dict of dicts, optional\n   All pairs shortest path lengths as a dictionary of dictionaries\n\nweight : string, function, or None (default=None)\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\n    If this is None, every edge has weight/distance/cost 1.\n\n    Weights stored as floating point values can lead to small round-off\n    errors in distances. Use integer weights to avoid this.\n\n    Weights should be positive, since they are distances.\n\nReturns\n-------\necc : dictionary\n   A dictionary of eccentricity values keyed by node.\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (1, 4), (3, 4), (3, 5), (4, 5)])\n>>> dict(nx.eccentricity(G))\n{1: 2, 2: 3, 3: 2, 4: 2, 5: 3}\n\n>>> dict(nx.eccentricity(G, v=[1, 5]))  # This returns the eccentricity of node 1 & 5\n{1: 2, 5: 3}"}, {"type": "function", "name": "networkx.edge_betweenness_centrality", "documentation": "Compute betweenness centrality for edges.\n\nBetweenness centrality of an edge $e$ is the sum of the\nfraction of all-pairs shortest paths that pass through $e$\n\n.. math::\n\n   c_B(e) =\\sum_{s,t \\in V} \\frac{\\sigma(s, t|e)}{\\sigma(s, t)}\n\nwhere $V$ is the set of nodes, $\\sigma(s, t)$ is the number of\nshortest $(s, t)$-paths, and $\\sigma(s, t|e)$ is the number of\nthose paths passing through edge $e$ [2]_.\n\nParameters\n----------\nG : graph\n  A NetworkX graph.\n\nk : int, optional (default=None)\n  If k is not None use k node samples to estimate betweenness.\n  The value of k <= n where n is the number of nodes in the graph.\n  Higher values give better approximation.\n\nnormalized : bool, optional\n  If True the betweenness values are normalized by $2/(n(n-1))$\n  for graphs, and $1/(n(n-1))$ for directed graphs where $n$\n  is the number of nodes in G.\n\nweight : None or string, optional (default=None)\n  If None, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n  Weights are used to calculate weighted shortest paths, so they are\n  interpreted as distances.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n    Note that this is only used if k is not None.\n\nReturns\n-------\nedges : dictionary\n   Dictionary of edges with betweenness centrality as the value.\n\nSee Also\n--------\nbetweenness_centrality\nedge_load\n\nNotes\n-----\nThe algorithm is from Ulrik Brandes [1]_.\n\nFor weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\n\nReferences\n----------\n.. [1]  A Faster Algorithm for Betweenness Centrality. Ulrik Brandes,\n   Journal of Mathematical Sociology 25(2):163-177, 2001.\n   https://doi.org/10.1080/0022250X.2001.9990249\n.. [2] Ulrik Brandes: On Variants of Shortest-Path Betweenness\n   Centrality and their Generic Computation.\n   Social Networks 30(2):136-145, 2008.\n   https://doi.org/10.1016/j.socnet.2007.11.001"}, {"type": "function", "name": "networkx.edge_betweenness_centrality_subset", "documentation": "Compute betweenness centrality for edges for a subset of nodes.\n\n.. math::\n\n   c_B(v) =\\sum_{s\\in S,t \\in T} \\frac{\\sigma(s, t|e)}{\\sigma(s, t)}\n\nwhere $S$ is the set of sources, $T$ is the set of targets,\n$\\sigma(s, t)$ is the number of shortest $(s, t)$-paths,\nand $\\sigma(s, t|e)$ is the number of those paths\npassing through edge $e$ [2]_.\n\nParameters\n----------\nG : graph\n  A networkx graph.\n\nsources: list of nodes\n  Nodes to use as sources for shortest paths in betweenness\n\ntargets: list of nodes\n  Nodes to use as targets for shortest paths in betweenness\n\nnormalized : bool, optional\n  If True the betweenness values are normalized by `2/(n(n-1))`\n  for graphs, and `1/(n(n-1))` for directed graphs where `n`\n  is the number of nodes in G.\n\nweight : None or string, optional (default=None)\n  If None, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n  Weights are used to calculate weighted shortest paths, so they are\n  interpreted as distances.\n\nReturns\n-------\nedges : dictionary\n   Dictionary of edges with Betweenness centrality as the value.\n\nSee Also\n--------\nbetweenness_centrality\nedge_load\n\nNotes\n-----\nThe basic algorithm is from [1]_.\n\nFor weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\n\nThe normalization might seem a little strange but it is the same\nas in edge_betweenness_centrality() and is designed to make\nedge_betweenness_centrality(G) be the same as\nedge_betweenness_centrality_subset(G,sources=G.nodes(),targets=G.nodes()).\n\nReferences\n----------\n.. [1] Ulrik Brandes, A Faster Algorithm for Betweenness Centrality.\n   Journal of Mathematical Sociology 25(2):163-177, 2001.\n   https://doi.org/10.1080/0022250X.2001.9990249\n.. [2] Ulrik Brandes: On Variants of Shortest-Path Betweenness\n   Centrality and their Generic Computation.\n   Social Networks 30(2):136-145, 2008.\n   https://doi.org/10.1016/j.socnet.2007.11.001"}, {"type": "function", "name": "networkx.edge_bfs", "documentation": "A directed, breadth-first-search of edges in `G`, beginning at `source`.\n\nYield the edges of G in a breadth-first-search order continuing until\nall edges are generated.\n\nParameters\n----------\nG : graph\n    A directed/undirected graph/multigraph.\n\nsource : node, list of nodes\n    The node from which the traversal begins. If None, then a source\n    is chosen arbitrarily and repeatedly until all edges from each node in\n    the graph are searched.\n\norientation : None | 'original' | 'reverse' | 'ignore' (default: None)\n    For directed graphs and directed multigraphs, edge traversals need not\n    respect the original orientation of the edges.\n    When set to 'reverse' every edge is traversed in the reverse direction.\n    When set to 'ignore', every edge is treated as undirected.\n    When set to 'original', every edge is treated as directed.\n    In all three cases, the yielded edge tuples add a last entry to\n    indicate the direction in which that edge was traversed.\n    If orientation is None, the yielded edge has no direction indicated.\n    The direction is respected, but not reported.\n\nYields\n------\nedge : directed edge\n    A directed edge indicating the path taken by the breadth-first-search.\n    For graphs, `edge` is of the form `(u, v)` where `u` and `v`\n    are the tail and head of the edge as determined by the traversal.\n    For multigraphs, `edge` is of the form `(u, v, key)`, where `key` is\n    the key of the edge. When the graph is directed, then `u` and `v`\n    are always in the order of the actual directed edge.\n    If orientation is not None then the edge tuple is extended to include\n    the direction of traversal ('forward' or 'reverse') on that edge.\n\nExamples\n--------\n>>> nodes = [0, 1, 2, 3]\n>>> edges = [(0, 1), (1, 0), (1, 0), (2, 0), (2, 1), (3, 1)]\n\n>>> list(nx.edge_bfs(nx.Graph(edges), nodes))\n[(0, 1), (0, 2), (1, 2), (1, 3)]\n\n>>> list(nx.edge_bfs(nx.DiGraph(edges), nodes))\n[(0, 1), (1, 0), (2, 0), (2, 1), (3, 1)]\n\n>>> list(nx.edge_bfs(nx.MultiGraph(edges), nodes))\n[(0, 1, 0), (0, 1, 1), (0, 1, 2), (0, 2, 0), (1, 2, 0), (1, 3, 0)]\n\n>>> list(nx.edge_bfs(nx.MultiDiGraph(edges), nodes))\n[(0, 1, 0), (1, 0, 0), (1, 0, 1), (2, 0, 0), (2, 1, 0), (3, 1, 0)]\n\n>>> list(nx.edge_bfs(nx.DiGraph(edges), nodes, orientation=\"ignore\"))\n[(0, 1, 'forward'), (1, 0, 'reverse'), (2, 0, 'reverse'), (2, 1, 'reverse'), (3, 1, 'reverse')]\n\n>>> list(nx.edge_bfs(nx.MultiDiGraph(edges), nodes, orientation=\"ignore\"))\n[(0, 1, 0, 'forward'), (1, 0, 0, 'reverse'), (1, 0, 1, 'reverse'), (2, 0, 0, 'reverse'), (2, 1, 0, 'reverse'), (3, 1, 0, 'reverse')]\n\nNotes\n-----\nThe goal of this function is to visit edges. It differs from the more\nfamiliar breadth-first-search of nodes, as provided by\n:func:`networkx.algorithms.traversal.breadth_first_search.bfs_edges`, in\nthat it does not stop once every node has been visited. In a directed graph\nwith edges [(0, 1), (1, 2), (2, 1)], the edge (2, 1) would not be visited\nif not for the functionality provided by this function.\n\nThe naming of this function is very similar to bfs_edges. The difference\nis that 'edge_bfs' yields edges even if they extend back to an already\nexplored node while 'bfs_edges' yields the edges of the tree that results\nfrom a breadth-first-search (BFS) so no edges are reported if they extend\nto already explored nodes. That means 'edge_bfs' reports all edges while\n'bfs_edges' only report those traversed by a node-based BFS. Yet another\ndescription is that 'bfs_edges' reports the edges traversed during BFS\nwhile 'edge_bfs' reports all edges in the order they are explored.\n\nSee Also\n--------\nbfs_edges\nbfs_tree\nedge_dfs"}, {"type": "function", "name": "networkx.edge_boundary", "documentation": "Returns the edge boundary of `nbunch1`.\n\nThe *edge boundary* of a set *S* with respect to a set *T* is the\nset of edges (*u*, *v*) such that *u* is in *S* and *v* is in *T*.\nIf *T* is not specified, it is assumed to be the set of all nodes\nnot in *S*.\n\nParameters\n----------\nG : NetworkX graph\n\nnbunch1 : iterable\n    Iterable of nodes in the graph representing the set of nodes\n    whose edge boundary will be returned. (This is the set *S* from\n    the definition above.)\n\nnbunch2 : iterable\n    Iterable of nodes representing the target (or \"exterior\") set of\n    nodes. (This is the set *T* from the definition above.) If not\n    specified, this is assumed to be the set of all nodes in `G`\n    not in `nbunch1`.\n\nkeys : bool\n    This parameter has the same meaning as in\n    :meth:`MultiGraph.edges`.\n\ndata : bool or object\n    This parameter has the same meaning as in\n    :meth:`MultiGraph.edges`.\n\ndefault : object\n    This parameter has the same meaning as in\n    :meth:`MultiGraph.edges`.\n\nReturns\n-------\niterator\n    An iterator over the edges in the boundary of `nbunch1` with\n    respect to `nbunch2`. If `keys`, `data`, or `default`\n    are specified and `G` is a multigraph, then edges are returned\n    with keys and/or data, as in :meth:`MultiGraph.edges`.\n\nExamples\n--------\n>>> G = nx.wheel_graph(6)\n\nWhen nbunch2=None:\n\n>>> list(nx.edge_boundary(G, (1, 3)))\n[(1, 0), (1, 2), (1, 5), (3, 0), (3, 2), (3, 4)]\n\nWhen nbunch2 is given:\n\n>>> list(nx.edge_boundary(G, (1, 3), (2, 0)))\n[(1, 0), (1, 2), (3, 0), (3, 2)]\n\nNotes\n-----\nAny element of `nbunch` that is not in the graph `G` will be\nignored.\n\n`nbunch1` and `nbunch2` are usually meant to be disjoint, but in\nthe interest of speed and generality, that is not required here."}, {"type": "function", "name": "networkx.edge_connectivity", "documentation": "Returns the edge connectivity of the graph or digraph G.\n\nThe edge connectivity is equal to the minimum number of edges that\nmust be removed to disconnect G or render it trivial. If source\nand target nodes are provided, this function returns the local edge\nconnectivity: the minimum number of edges that must be removed to\nbreak all paths from source to target in G.\n\nParameters\n----------\nG : NetworkX graph\n    Undirected or directed graph\n\ns : node\n    Source node. Optional. Default value: None.\n\nt : node\n    Target node. Optional. Default value: None.\n\nflow_func : function\n    A function for computing the maximum flow among a pair of nodes.\n    The function has to accept at least three parameters: a Digraph,\n    a source node, and a target node. And return a residual network\n    that follows NetworkX conventions (see :meth:`maximum_flow` for\n    details). If flow_func is None, the default maximum flow function\n    (:meth:`edmonds_karp`) is used. See below for details. The\n    choice of the default function may change from version\n    to version and should not be relied on. Default value: None.\n\ncutoff : integer, float, or None (default: None)\n    If specified, the maximum flow algorithm will terminate when the\n    flow value reaches or exceeds the cutoff. This only works for flows\n    that support the cutoff parameter (most do) and is ignored otherwise.\n\nReturns\n-------\nK : integer\n    Edge connectivity for G, or local edge connectivity if source\n    and target were provided\n\nExamples\n--------\n>>> # Platonic icosahedral graph is 5-edge-connected\n>>> G = nx.icosahedral_graph()\n>>> nx.edge_connectivity(G)\n5\n\nYou can use alternative flow algorithms for the underlying\nmaximum flow computation. In dense networks the algorithm\n:meth:`shortest_augmenting_path` will usually perform better\nthan the default :meth:`edmonds_karp`, which is faster for\nsparse networks with highly skewed degree distributions.\nAlternative flow functions have to be explicitly imported\nfrom the flow package.\n\n>>> from networkx.algorithms.flow import shortest_augmenting_path\n>>> nx.edge_connectivity(G, flow_func=shortest_augmenting_path)\n5\n\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns the value of local edge connectivity.\n\n>>> nx.edge_connectivity(G, 3, 7)\n5\n\nIf you need to perform several local computations among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. See\n:meth:`local_edge_connectivity` for details.\n\nNotes\n-----\nThis is a flow based implementation of global edge connectivity.\nFor undirected graphs the algorithm works by finding a 'small'\ndominating set of nodes of G (see algorithm 7 in [1]_ ) and\ncomputing local maximum flow (see :meth:`local_edge_connectivity`)\nbetween an arbitrary node in the dominating set and the rest of\nnodes in it. This is an implementation of algorithm 6 in [1]_ .\nFor directed graphs, the algorithm does n calls to the maximum\nflow function. This is an implementation of algorithm 8 in [1]_ .\n\nSee also\n--------\n:meth:`local_edge_connectivity`\n:meth:`local_node_connectivity`\n:meth:`node_connectivity`\n:meth:`maximum_flow`\n:meth:`edmonds_karp`\n:meth:`preflow_push`\n:meth:`shortest_augmenting_path`\n:meth:`k_edge_components`\n:meth:`k_edge_subgraphs`\n\nReferences\n----------\n.. [1] Abdol-Hossein Esfahanian. Connectivity Algorithms.\n    http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf"}, {"type": "function", "name": "networkx.edge_current_flow_betweenness_centrality", "documentation": "Compute current-flow betweenness centrality for edges.\n\nCurrent-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths.\n\nCurrent-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2]_.\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nnormalized : bool, optional (default=True)\n  If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\n  n is the number of nodes in G.\n\nweight : string or None, optional (default=None)\n  Key for edge data used as the edge weight.\n  If None, then use 1 as each edge weight.\n  The weight reflects the capacity or the strength of the\n  edge.\n\ndtype : data type (default=float)\n  Default data type for internal matrices.\n  Set to np.float32 for lower memory consumption.\n\nsolver : string (default='full')\n   Type of linear solver to use for computing the flow matrix.\n   Options are \"full\" (uses most memory), \"lu\" (recommended), and\n   \"cg\" (uses least memory).\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of edge tuples with betweenness centrality as the value.\n\nRaises\n------\nNetworkXError\n    The algorithm does not support DiGraphs.\n    If the input graph is an instance of DiGraph class, NetworkXError\n    is raised.\n\nSee Also\n--------\nbetweenness_centrality\nedge_betweenness_centrality\ncurrent_flow_betweenness_centrality\n\nNotes\n-----\nCurrent-flow betweenness can be computed in $O(I(n-1)+mn \\log n)$\ntime [1]_, where $I(n-1)$ is the time needed to compute the\ninverse Laplacian.  For a full matrix this is $O(n^3)$ but using\nsparse methods you can achieve $O(nm{\\sqrt k})$ where $k$ is the\nLaplacian matrix condition number.\n\nThe space required is $O(nw)$ where $w$ is the width of the sparse\nLaplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\n\nIf the edges have a 'weight' attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.\n\nReferences\n----------\n.. [1] Centrality Measures Based on Current Flow.\n   Ulrik Brandes and Daniel Fleischer,\n   Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n   LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n   https://doi.org/10.1007/978-3-540-31856-9_44\n\n.. [2] A measure of betweenness centrality based on random walks,\n   M. E. J. Newman, Social Networks 27, 39-54 (2005)."}, {"type": "function", "name": "networkx.edge_current_flow_betweenness_centrality_subset", "documentation": "Compute current-flow betweenness centrality for edges using subsets\nof nodes.\n\nCurrent-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths.\n\nCurrent-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2]_.\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nsources: list of nodes\n  Nodes to use as sources for current\n\ntargets: list of nodes\n  Nodes to use as sinks for current\n\nnormalized : bool, optional (default=True)\n  If True the betweenness values are normalized by b=b/(n-1)(n-2) where\n  n is the number of nodes in G.\n\nweight : string or None, optional (default=None)\n  Key for edge data used as the edge weight.\n  If None, then use 1 as each edge weight.\n  The weight reflects the capacity or the strength of the\n  edge.\n\ndtype: data type (float)\n  Default data type for internal matrices.\n  Set to np.float32 for lower memory consumption.\n\nsolver: string (default='lu')\n   Type of linear solver to use for computing the flow matrix.\n   Options are \"full\" (uses most memory), \"lu\" (recommended), and\n   \"cg\" (uses least memory).\n\nReturns\n-------\nnodes : dict\n   Dictionary of edge tuples with betweenness centrality as the value.\n\nSee Also\n--------\nbetweenness_centrality\nedge_betweenness_centrality\ncurrent_flow_betweenness_centrality\n\nNotes\n-----\nCurrent-flow betweenness can be computed in $O(I(n-1)+mn \\log n)$\ntime [1]_, where $I(n-1)$ is the time needed to compute the\ninverse Laplacian.  For a full matrix this is $O(n^3)$ but using\nsparse methods you can achieve $O(nm{\\sqrt k})$ where $k$ is the\nLaplacian matrix condition number.\n\nThe space required is $O(nw)$ where $w$ is the width of the sparse\nLaplacian matrix.  Worse case is $w=n$ for $O(n^2)$.\n\nIf the edges have a 'weight' attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.\n\nReferences\n----------\n.. [1] Centrality Measures Based on Current Flow.\n   Ulrik Brandes and Daniel Fleischer,\n   Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n   LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n   https://doi.org/10.1007/978-3-540-31856-9_44\n\n.. [2] A measure of betweenness centrality based on random walks,\n   M. E. J. Newman, Social Networks 27, 39-54 (2005)."}, {"type": "function", "name": "networkx.edge_dfs", "documentation": "A directed, depth-first-search of edges in `G`, beginning at `source`.\n\nYield the edges of G in a depth-first-search order continuing until\nall edges are generated.\n\nParameters\n----------\nG : graph\n    A directed/undirected graph/multigraph.\n\nsource : node, list of nodes\n    The node from which the traversal begins. If None, then a source\n    is chosen arbitrarily and repeatedly until all edges from each node in\n    the graph are searched.\n\norientation : None | 'original' | 'reverse' | 'ignore' (default: None)\n    For directed graphs and directed multigraphs, edge traversals need not\n    respect the original orientation of the edges.\n    When set to 'reverse' every edge is traversed in the reverse direction.\n    When set to 'ignore', every edge is treated as undirected.\n    When set to 'original', every edge is treated as directed.\n    In all three cases, the yielded edge tuples add a last entry to\n    indicate the direction in which that edge was traversed.\n    If orientation is None, the yielded edge has no direction indicated.\n    The direction is respected, but not reported.\n\nYields\n------\nedge : directed edge\n    A directed edge indicating the path taken by the depth-first traversal.\n    For graphs, `edge` is of the form `(u, v)` where `u` and `v`\n    are the tail and head of the edge as determined by the traversal.\n    For multigraphs, `edge` is of the form `(u, v, key)`, where `key` is\n    the key of the edge. When the graph is directed, then `u` and `v`\n    are always in the order of the actual directed edge.\n    If orientation is not None then the edge tuple is extended to include\n    the direction of traversal ('forward' or 'reverse') on that edge.\n\nExamples\n--------\n>>> nodes = [0, 1, 2, 3]\n>>> edges = [(0, 1), (1, 0), (1, 0), (2, 1), (3, 1)]\n\n>>> list(nx.edge_dfs(nx.Graph(edges), nodes))\n[(0, 1), (1, 2), (1, 3)]\n\n>>> list(nx.edge_dfs(nx.DiGraph(edges), nodes))\n[(0, 1), (1, 0), (2, 1), (3, 1)]\n\n>>> list(nx.edge_dfs(nx.MultiGraph(edges), nodes))\n[(0, 1, 0), (1, 0, 1), (0, 1, 2), (1, 2, 0), (1, 3, 0)]\n\n>>> list(nx.edge_dfs(nx.MultiDiGraph(edges), nodes))\n[(0, 1, 0), (1, 0, 0), (1, 0, 1), (2, 1, 0), (3, 1, 0)]\n\n>>> list(nx.edge_dfs(nx.DiGraph(edges), nodes, orientation=\"ignore\"))\n[(0, 1, 'forward'), (1, 0, 'forward'), (2, 1, 'reverse'), (3, 1, 'reverse')]\n\n>>> list(nx.edge_dfs(nx.MultiDiGraph(edges), nodes, orientation=\"ignore\"))\n[(0, 1, 0, 'forward'), (1, 0, 0, 'forward'), (1, 0, 1, 'reverse'), (2, 1, 0, 'reverse'), (3, 1, 0, 'reverse')]\n\nNotes\n-----\nThe goal of this function is to visit edges. It differs from the more\nfamiliar depth-first traversal of nodes, as provided by\n:func:`~networkx.algorithms.traversal.depth_first_search.dfs_edges`, in\nthat it does not stop once every node has been visited. In a directed graph\nwith edges [(0, 1), (1, 2), (2, 1)], the edge (2, 1) would not be visited\nif not for the functionality provided by this function.\n\nSee Also\n--------\n:func:`~networkx.algorithms.traversal.depth_first_search.dfs_edges`"}, {"type": "function", "name": "networkx.edge_disjoint_paths", "documentation": "Returns the edges disjoint paths between source and target.\n\nEdge disjoint paths are paths that do not share any edge. The\nnumber of edge disjoint paths between source and target is equal\nto their edge connectivity.\n\nParameters\n----------\nG : NetworkX graph\n\ns : node\n    Source node for the flow.\n\nt : node\n    Sink node for the flow.\n\nflow_func : function\n    A function for computing the maximum flow among a pair of nodes.\n    The function has to accept at least three parameters: a Digraph,\n    a source node, and a target node. And return a residual network\n    that follows NetworkX conventions (see :meth:`maximum_flow` for\n    details). If flow_func is None, the default maximum flow function\n    (:meth:`edmonds_karp`) is used. The choice of the default function\n    may change from version to version and should not be relied on.\n    Default value: None.\n\ncutoff : integer or None (default: None)\n    Maximum number of paths to yield. If specified, the maximum flow\n    algorithm will terminate when the flow value reaches or exceeds the\n    cutoff. This only works for flows that support the cutoff parameter\n    (most do) and is ignored otherwise.\n\nauxiliary : NetworkX DiGraph\n    Auxiliary digraph to compute flow based edge connectivity. It has\n    to have a graph attribute called mapping with a dictionary mapping\n    node names in G and in the auxiliary digraph. If provided\n    it will be reused instead of recreated. Default value: None.\n\nresidual : NetworkX DiGraph\n    Residual network to compute maximum flow. If provided it will be\n    reused instead of recreated. Default value: None.\n\nReturns\n-------\npaths : generator\n    A generator of edge independent paths.\n\nRaises\n------\nNetworkXNoPath\n    If there is no path between source and target.\n\nNetworkXError\n    If source or target are not in the graph G.\n\nSee also\n--------\n:meth:`node_disjoint_paths`\n:meth:`edge_connectivity`\n:meth:`maximum_flow`\n:meth:`edmonds_karp`\n:meth:`preflow_push`\n:meth:`shortest_augmenting_path`\n\nExamples\n--------\nWe use in this example the platonic icosahedral graph, which has node\nedge connectivity 5, thus there are 5 edge disjoint paths between any\npair of nodes.\n\n>>> G = nx.icosahedral_graph()\n>>> len(list(nx.edge_disjoint_paths(G, 0, 6)))\n5\n\n\nIf you need to compute edge disjoint paths on several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for edge connectivity, and the residual\nnetwork for the underlying maximum flow computation.\n\nExample of how to compute edge disjoint paths among all pairs of\nnodes of the platonic icosahedral graph reusing the data\nstructures.\n\n>>> import itertools\n>>> # You also have to explicitly import the function for\n>>> # building the auxiliary digraph from the connectivity package\n>>> from networkx.algorithms.connectivity import build_auxiliary_edge_connectivity\n>>> H = build_auxiliary_edge_connectivity(G)\n>>> # And the function for building the residual network from the\n>>> # flow package\n>>> from networkx.algorithms.flow import build_residual_network\n>>> # Note that the auxiliary digraph has an edge attribute named capacity\n>>> R = build_residual_network(H, \"capacity\")\n>>> result = {n: {} for n in G}\n>>> # Reuse the auxiliary digraph and the residual network by passing them\n>>> # as arguments\n>>> for u, v in itertools.combinations(G, 2):\n...     k = len(list(nx.edge_disjoint_paths(G, u, v, auxiliary=H, residual=R)))\n...     result[u][v] = k\n>>> all(result[u][v] == 5 for u, v in itertools.combinations(G, 2))\nTrue\n\nYou can also use alternative flow algorithms for computing edge disjoint\npaths. For instance, in dense networks the algorithm\n:meth:`shortest_augmenting_path` will usually perform better than\nthe default :meth:`edmonds_karp` which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\n\n>>> from networkx.algorithms.flow import shortest_augmenting_path\n>>> len(list(nx.edge_disjoint_paths(G, 0, 6, flow_func=shortest_augmenting_path)))\n5\n\nNotes\n-----\nThis is a flow based implementation of edge disjoint paths. We compute\nthe maximum flow between source and target on an auxiliary directed\nnetwork. The saturated edges in the residual network after running the\nmaximum flow algorithm correspond to edge disjoint paths between source\nand target in the original network. This function handles both directed\nand undirected graphs, and can use all flow algorithms from NetworkX flow\npackage."}, {"type": "function", "name": "networkx.edge_expansion", "documentation": "Returns the edge expansion between two node sets.\n\nThe *edge expansion* is the quotient of the cut size and the smaller\nof the cardinalities of the two sets. [1]\n\nParameters\n----------\nG : NetworkX graph\n\nS : collection\n    A collection of nodes in `G`.\n\nT : collection\n    A collection of nodes in `G`.\n\nweight : object\n    Edge attribute key to use as weight. If not specified, edges\n    have weight one.\n\nReturns\n-------\nnumber\n    The edge expansion between the two sets `S` and `T`.\n\nSee also\n--------\nboundary_expansion\nmixing_expansion\nnode_expansion\n\nReferences\n----------\n.. [1] Fan Chung.\n       *Spectral Graph Theory*.\n       (CBMS Regional Conference Series in Mathematics, No. 92),\n       American Mathematical Society, 1997, ISBN 0-8218-0315-8\n       <http://www.math.ucsd.edu/~fan/research/revised.html>"}, {"type": "function", "name": "networkx.edge_load_centrality", "documentation": "Compute edge load.\n\nWARNING: This concept of edge load has not been analysed\nor discussed outside of NetworkX that we know of.\nIt is based loosely on load_centrality in the sense that\nit counts the number of shortest paths which cross each edge.\nThis function is for demonstration and testing purposes.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\ncutoff : bool, optional (default=False)\n    If specified, only consider paths of length <= cutoff.\n\nReturns\n-------\nA dict keyed by edge 2-tuple to the number of shortest paths\nwhich use that edge. Where more than one path is shortest\nthe count is divided equally among paths."}, {"type": "function", "name": "networkx.edge_subgraph", "documentation": "Returns a view of the subgraph induced by the specified edges.\n\nThe induced subgraph contains each edge in `edges` and each\nnode incident to any of those edges.\n\nParameters\n----------\nG : NetworkX Graph\nedges : iterable\n    An iterable of edges. Edges not present in `G` are ignored.\n\nReturns\n-------\nsubgraph : SubGraph View\n    A read-only edge-induced subgraph of `G`.\n    Changes to `G` are reflected in the view.\n\nNotes\n-----\nTo create a mutable subgraph with its own copies of nodes\nedges and attributes use `subgraph.copy()` or `Graph(subgraph)`\n\nIf you create a subgraph of a subgraph recursively you can end up\nwith a chain of subgraphs that becomes very slow with about 15\nnested subgraph views. Luckily the edge_subgraph filter nests\nnicely so you can use the original graph as G in this function\nto avoid chains. We do not rule out chains programmatically so\nthat odd cases like an `edge_subgraph` of a `restricted_view`\ncan be created.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> H = G.edge_subgraph([(0, 1), (3, 4)])\n>>> list(H.nodes)\n[0, 1, 3, 4]\n>>> list(H.edges)\n[(0, 1), (3, 4)]"}, {"type": "function", "name": "networkx.edges", "documentation": "Returns an edge view of edges incident to nodes in nbunch.\n\nReturn all edges if nbunch is unspecified or nbunch=None.\n\nFor digraphs, edges=out_edges\n\nThis function wraps the :func:`G.edges <networkx.Graph.edges>` property."}, {"type": "function", "name": "networkx.effective_graph_resistance", "documentation": "Returns the Effective graph resistance of G.\n\nAlso known as the Kirchhoff index.\n\nThe effective graph resistance is defined as the sum\nof the resistance distance of every node pair in G [1]_.\n\nIf weight is not provided, then a weight of 1 is used for all edges.\n\nThe effective graph resistance of a disconnected graph is infinite.\n\nParameters\n----------\nG : NetworkX graph\n   A graph\n\nweight : string or None, optional (default=None)\n   The edge data key used to compute the effective graph resistance.\n   If None, then each edge has weight 1.\n\ninvert_weight : boolean (default=True)\n    Proper calculation of resistance distance requires building the\n    Laplacian matrix with the reciprocal of the weight. Not required\n    if the weight is already inverted. Weight cannot be zero.\n\nReturns\n-------\nRG : float\n    The effective graph resistance of `G`.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is a directed graph.\n\nNetworkXError\n    If `G` does not contain any nodes.\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (1, 4), (3, 4), (3, 5), (4, 5)])\n>>> round(nx.effective_graph_resistance(G), 10)\n10.25\n\nNotes\n-----\nThe implementation is based on Theorem 2.2 in [2]_. Self-loops are ignored.\nMulti-edges are contracted in one edge with weight equal to the harmonic sum of the weights.\n\nReferences\n----------\n.. [1] Wolfram\n   \"Kirchhoff Index.\"\n   https://mathworld.wolfram.com/KirchhoffIndex.html\n.. [2] W. Ellens, F. M. Spieksma, P. Van Mieghem, A. Jamakovic, R. E. Kooij.\n    Effective graph resistance.\n    Lin. Alg. Appl. 435:2491-2506, 2011."}, {"type": "function", "name": "networkx.effective_size", "documentation": "Returns the effective size of all nodes in the graph ``G``.\n\nThe *effective size* of a node's ego network is based on the concept\nof redundancy. A person's ego network has redundancy to the extent\nthat her contacts are connected to each other as well. The\nnonredundant part of a person's relationships is the effective\nsize of her ego network [1]_.  Formally, the effective size of a\nnode $u$, denoted $e(u)$, is defined by\n\n.. math::\n\n   e(u) = \\sum_{v \\in N(u) \\setminus \\{u\\}}\n   \\left(1 - \\sum_{w \\in N(v)} p_{uw} m_{vw}\\right)\n\nwhere $N(u)$ is the set of neighbors of $u$ and $p_{uw}$ is the\nnormalized mutual weight of the (directed or undirected) edges\njoining $u$ and $v$, for each vertex $u$ and $v$ [1]_. And $m_{vw}$\nis the mutual weight of $v$ and $w$ divided by $v$ highest mutual\nweight with any of its neighbors. The *mutual weight* of $u$ and $v$\nis the sum of the weights of edges joining them (edge weights are\nassumed to be one if the graph is unweighted).\n\nFor the case of unweighted and undirected graphs, Borgatti proposed\na simplified formula to compute effective size [2]_\n\n.. math::\n\n   e(u) = n - \\frac{2t}{n}\n\nwhere `t` is the number of ties in the ego network (not including\nties to ego) and `n` is the number of nodes (excluding ego).\n\nParameters\n----------\nG : NetworkX graph\n    The graph containing ``v``. Directed graphs are treated like\n    undirected graphs when computing neighbors of ``v``.\n\nnodes : container, optional\n    Container of nodes in the graph ``G`` to compute the effective size.\n    If None, the effective size of every node is computed.\n\nweight : None or string, optional\n  If None, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n\nReturns\n-------\ndict\n    Dictionary with nodes as keys and the effective size of the node as values.\n\nNotes\n-----\nBurt also defined the related concept of *efficiency* of a node's ego\nnetwork, which is its effective size divided by the degree of that\nnode [1]_. So you can easily compute efficiency:\n\n>>> G = nx.DiGraph()\n>>> G.add_edges_from([(0, 1), (0, 2), (1, 0), (2, 1)])\n>>> esize = nx.effective_size(G)\n>>> efficiency = {n: v / G.degree(n) for n, v in esize.items()}\n\nSee also\n--------\nconstraint\n\nReferences\n----------\n.. [1] Burt, Ronald S.\n       *Structural Holes: The Social Structure of Competition.*\n       Cambridge: Harvard University Press, 1995.\n\n.. [2] Borgatti, S.\n       \"Structural Holes: Unpacking Burt's Redundancy Measures\"\n       CONNECTIONS 20(1):35-38.\n       http://www.analytictech.com/connections/v20(1)/holes.htm"}, {"type": "function", "name": "networkx.efficiency", "documentation": "Returns the efficiency of a pair of nodes in a graph.\n\nThe *efficiency* of a pair of nodes is the multiplicative inverse of the\nshortest path distance between the nodes [1]_. Returns 0 if no path\nbetween nodes.\n\nParameters\n----------\nG : :class:`networkx.Graph`\n    An undirected graph for which to compute the average local efficiency.\nu, v : node\n    Nodes in the graph ``G``.\n\nReturns\n-------\nfloat\n    Multiplicative inverse of the shortest path distance between the nodes.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n>>> nx.efficiency(G, 2, 3)  # this gives efficiency for node 2 and 3\n0.5\n\nNotes\n-----\nEdge weights are ignored when computing the shortest path distances.\n\nSee also\n--------\nlocal_efficiency\nglobal_efficiency\n\nReferences\n----------\n.. [1] Latora, Vito, and Massimo Marchiori.\n       \"Efficient behavior of small-world networks.\"\n       *Physical Review Letters* 87.19 (2001): 198701.\n       <https://doi.org/10.1103/PhysRevLett.87.198701>"}, {"type": "function", "name": "networkx.ego_graph", "documentation": "Returns induced subgraph of neighbors centered at node n within\na given radius.\n\nParameters\n----------\nG : graph\n  A NetworkX Graph or DiGraph\n\nn : node\n  A single node\n\nradius : number, optional\n  Include all neighbors of distance<=radius from n.\n\ncenter : bool, optional\n  If False, do not include center node in graph\n\nundirected : bool, optional\n  If True use both in- and out-neighbors of directed graphs.\n\ndistance : key, optional\n  Use specified edge data key as distance.  For example, setting\n  distance='weight' will use the edge weight to measure the\n  distance from the node n.\n\nNotes\n-----\nFor directed graphs D this produces the \"out\" neighborhood\nor successors.  If you want the neighborhood of predecessors\nfirst reverse the graph with D.reverse().  If you want both\ndirections use the keyword argument undirected=True.\n\nNode, edge, and graph attributes are copied to the returned subgraph."}, {"type": "function", "name": "networkx.eigenvector_centrality", "documentation": "Compute the eigenvector centrality for the graph G.\n\nEigenvector centrality computes the centrality for a node by adding\nthe centrality of its predecessors. The centrality for node $i$ is the\n$i$-th element of a left eigenvector associated with the eigenvalue $\\lambda$\nof maximum modulus that is positive. Such an eigenvector $x$ is\ndefined up to a multiplicative constant by the equation\n\n.. math::\n\n     \\lambda x^T = x^T A,\n\nwhere $A$ is the adjacency matrix of the graph G. By definition of\nrow-column product, the equation above is equivalent to\n\n.. math::\n\n    \\lambda x_i = \\sum_{j\\to i}x_j.\n\nThat is, adding the eigenvector centralities of the predecessors of\n$i$ one obtains the eigenvector centrality of $i$ multiplied by\n$\\lambda$. In the case of undirected graphs, $x$ also solves the familiar\nright-eigenvector equation $Ax = \\lambda x$.\n\nBy virtue of the Perron\u2013Frobenius theorem [1]_, if G is strongly\nconnected there is a unique eigenvector $x$, and all its entries\nare strictly positive.\n\nIf G is not strongly connected there might be several left\neigenvectors associated with $\\lambda$, and some of their elements\nmight be zero.\n\nParameters\n----------\nG : graph\n  A networkx graph.\n\nmax_iter : integer, optional (default=100)\n  Maximum number of power iterations.\n\ntol : float, optional (default=1.0e-6)\n  Error tolerance (in Euclidean norm) used to check convergence in\n  power iteration.\n\nnstart : dictionary, optional (default=None)\n  Starting value of power iteration for each node. Must have a nonzero\n  projection on the desired eigenvector for the power method to converge.\n  If None, this implementation uses an all-ones vector, which is a safe\n  choice.\n\nweight : None or string, optional (default=None)\n  If None, all edge weights are considered equal. Otherwise holds the\n  name of the edge attribute used as weight. In this measure the\n  weight is interpreted as the connection strength.\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with eigenvector centrality as the value. The\n   associated vector has unit Euclidean norm and the values are\n   nonegative.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> centrality = nx.eigenvector_centrality(G)\n>>> sorted((v, f\"{c:0.2f}\") for v, c in centrality.items())\n[(0, '0.37'), (1, '0.60'), (2, '0.60'), (3, '0.37')]\n\nRaises\n------\nNetworkXPointlessConcept\n    If the graph G is the null graph.\n\nNetworkXError\n    If each value in `nstart` is zero.\n\nPowerIterationFailedConvergence\n    If the algorithm fails to converge to the specified tolerance\n    within the specified number of iterations of the power iteration\n    method.\n\nSee Also\n--------\neigenvector_centrality_numpy\n:func:`~networkx.algorithms.link_analysis.pagerank_alg.pagerank`\n:func:`~networkx.algorithms.link_analysis.hits_alg.hits`\n\nNotes\n-----\nEigenvector centrality was introduced by Landau [2]_ for chess\ntournaments. It was later rediscovered by Wei [3]_ and then\npopularized by Kendall [4]_ in the context of sport ranking. Berge\nintroduced a general definition for graphs based on social connections\n[5]_. Bonacich [6]_ reintroduced again eigenvector centrality and made\nit popular in link analysis.\n\nThis function computes the left dominant eigenvector, which corresponds\nto adding the centrality of predecessors: this is the usual approach.\nTo add the centrality of successors first reverse the graph with\n``G.reverse()``.\n\nThe implementation uses power iteration [7]_ to compute a dominant\neigenvector starting from the provided vector `nstart`. Convergence is\nguaranteed as long as `nstart` has a nonzero projection on a dominant\neigenvector, which certainly happens using the default value.\n\nThe method stops when the change in the computed vector between two\niterations is smaller than an error tolerance of ``G.number_of_nodes()\n* tol`` or after ``max_iter`` iterations, but in the second case it\nraises an exception.\n\nThis implementation uses $(A + I)$ rather than the adjacency matrix\n$A$ because the change preserves eigenvectors, but it shifts the\nspectrum, thus guaranteeing convergence even for networks with\nnegative eigenvalues of maximum modulus.\n\nReferences\n----------\n.. [1] Abraham Berman and Robert J. Plemmons.\n   \"Nonnegative Matrices in the Mathematical Sciences.\"\n   Classics in Applied Mathematics. SIAM, 1994.\n\n.. [2] Edmund Landau.\n   \"Zur relativen Wertbemessung der Turnierresultate.\"\n   Deutsches Wochenschach, 11:366\u2013369, 1895.\n\n.. [3] Teh-Hsing Wei.\n   \"The Algebraic Foundations of Ranking Theory.\"\n   PhD thesis, University of Cambridge, 1952.\n\n.. [4] Maurice G. Kendall.\n   \"Further contributions to the theory of paired comparisons.\"\n   Biometrics, 11(1):43\u201362, 1955.\n   https://www.jstor.org/stable/3001479\n\n.. [5] Claude Berge\n   \"Th\u00e9orie des graphes et ses applications.\"\n   Dunod, Paris, France, 1958.\n\n.. [6] Phillip Bonacich.\n   \"Technique for analyzing overlapping memberships.\"\n   Sociological Methodology, 4:176\u2013185, 1972.\n   https://www.jstor.org/stable/270732\n\n.. [7] Power iteration:: https://en.wikipedia.org/wiki/Power_iteration"}, {"type": "function", "name": "networkx.eigenvector_centrality_numpy", "documentation": "Compute the eigenvector centrality for the graph G.\n\nEigenvector centrality computes the centrality for a node by adding\nthe centrality of its predecessors. The centrality for node $i$ is the\n$i$-th element of a left eigenvector associated with the eigenvalue $\\lambda$\nof maximum modulus that is positive. Such an eigenvector $x$ is\ndefined up to a multiplicative constant by the equation\n\n.. math::\n\n     \\lambda x^T = x^T A,\n\nwhere $A$ is the adjacency matrix of the graph G. By definition of\nrow-column product, the equation above is equivalent to\n\n.. math::\n\n    \\lambda x_i = \\sum_{j\\to i}x_j.\n\nThat is, adding the eigenvector centralities of the predecessors of\n$i$ one obtains the eigenvector centrality of $i$ multiplied by\n$\\lambda$. In the case of undirected graphs, $x$ also solves the familiar\nright-eigenvector equation $Ax = \\lambda x$.\n\nBy virtue of the Perron\u2013Frobenius theorem [1]_, if G is strongly\nconnected there is a unique eigenvector $x$, and all its entries\nare strictly positive.\n\nIf G is not strongly connected there might be several left\neigenvectors associated with $\\lambda$, and some of their elements\nmight be zero.\n\nParameters\n----------\nG : graph\n  A networkx graph.\n\nmax_iter : integer, optional (default=50)\n  Maximum number of Arnoldi update iterations allowed.\n\ntol : float, optional (default=0)\n  Relative accuracy for eigenvalues (stopping criterion).\n  The default value of 0 implies machine precision.\n\nweight : None or string, optional (default=None)\n  If None, all edge weights are considered equal. Otherwise holds the\n  name of the edge attribute used as weight. In this measure the\n  weight is interpreted as the connection strength.\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with eigenvector centrality as the value. The\n   associated vector has unit Euclidean norm and the values are\n   nonegative.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> centrality = nx.eigenvector_centrality_numpy(G)\n>>> print([f\"{node} {centrality[node]:0.2f}\" for node in centrality])\n['0 0.37', '1 0.60', '2 0.60', '3 0.37']\n\nRaises\n------\nNetworkXPointlessConcept\n    If the graph G is the null graph.\n\nArpackNoConvergence\n    When the requested convergence is not obtained. The currently\n    converged eigenvalues and eigenvectors can be found as\n    eigenvalues and eigenvectors attributes of the exception object.\n\nSee Also\n--------\n:func:`scipy.sparse.linalg.eigs`\neigenvector_centrality\n:func:`~networkx.algorithms.link_analysis.pagerank_alg.pagerank`\n:func:`~networkx.algorithms.link_analysis.hits_alg.hits`\n\nNotes\n-----\nEigenvector centrality was introduced by Landau [2]_ for chess\ntournaments. It was later rediscovered by Wei [3]_ and then\npopularized by Kendall [4]_ in the context of sport ranking. Berge\nintroduced a general definition for graphs based on social connections\n[5]_. Bonacich [6]_ reintroduced again eigenvector centrality and made\nit popular in link analysis.\n\nThis function computes the left dominant eigenvector, which corresponds\nto adding the centrality of predecessors: this is the usual approach.\nTo add the centrality of successors first reverse the graph with\n``G.reverse()``.\n\nThis implementation uses the\n:func:`SciPy sparse eigenvalue solver<scipy.sparse.linalg.eigs>` (ARPACK)\nto find the largest eigenvalue/eigenvector pair using Arnoldi iterations\n[7]_.\n\nReferences\n----------\n.. [1] Abraham Berman and Robert J. Plemmons.\n   \"Nonnegative Matrices in the Mathematical Sciences.\"\n   Classics in Applied Mathematics. SIAM, 1994.\n\n.. [2] Edmund Landau.\n   \"Zur relativen Wertbemessung der Turnierresultate.\"\n   Deutsches Wochenschach, 11:366\u2013369, 1895.\n\n.. [3] Teh-Hsing Wei.\n   \"The Algebraic Foundations of Ranking Theory.\"\n   PhD thesis, University of Cambridge, 1952.\n\n.. [4] Maurice G. Kendall.\n   \"Further contributions to the theory of paired comparisons.\"\n   Biometrics, 11(1):43\u201362, 1955.\n   https://www.jstor.org/stable/3001479\n\n.. [5] Claude Berge\n   \"Th\u00e9orie des graphes et ses applications.\"\n   Dunod, Paris, France, 1958.\n\n.. [6] Phillip Bonacich.\n   \"Technique for analyzing overlapping memberships.\"\n   Sociological Methodology, 4:176\u2013185, 1972.\n   https://www.jstor.org/stable/270732\n\n.. [7] Arnoldi iteration:: https://en.wikipedia.org/wiki/Arnoldi_iteration"}, {"type": "function", "name": "networkx.empty_graph", "documentation": "Returns the empty graph with n nodes and zero edges.\n\n.. plot::\n\n    >>> nx.draw(nx.empty_graph(5))\n\nParameters\n----------\nn : int or iterable container of nodes (default = 0)\n    If n is an integer, nodes are from `range(n)`.\n    If n is a container of nodes, those nodes appear in the graph.\ncreate_using : Graph Instance, Constructor or None\n    Indicator of type of graph to return.\n    If a Graph-type instance, then clear and use it.\n    If None, use the `default` constructor.\n    If a constructor, call it to create an empty graph.\ndefault : Graph constructor (optional, default = nx.Graph)\n    The constructor to use if create_using is None.\n    If None, then nx.Graph is used.\n    This is used when passing an unknown `create_using` value\n    through your home-grown function to `empty_graph` and\n    you want a default constructor other than nx.Graph.\n\nExamples\n--------\n>>> G = nx.empty_graph(10)\n>>> G.number_of_nodes()\n10\n>>> G.number_of_edges()\n0\n>>> G = nx.empty_graph(\"ABC\")\n>>> G.number_of_nodes()\n3\n>>> sorted(G)\n['A', 'B', 'C']\n\nNotes\n-----\nThe variable create_using should be a Graph Constructor or a\n\"graph\"-like object. Constructors, e.g. `nx.Graph` or `nx.MultiGraph`\nwill be used to create the returned graph. \"graph\"-like objects\nwill be cleared (nodes and edges will be removed) and refitted as\nan empty \"graph\" with nodes specified in n. This capability\nis useful for specifying the class-nature of the resulting empty\n\"graph\" (i.e. Graph, DiGraph, MyWeirdGraphClass, etc.).\n\nThe variable create_using has three main uses:\nFirstly, the variable create_using can be used to create an\nempty digraph, multigraph, etc.  For example,\n\n>>> n = 10\n>>> G = nx.empty_graph(n, create_using=nx.DiGraph)\n\nwill create an empty digraph on n nodes.\n\nSecondly, one can pass an existing graph (digraph, multigraph,\netc.) via create_using. For example, if G is an existing graph\n(resp. digraph, multigraph, etc.), then empty_graph(n, create_using=G)\nwill empty G (i.e. delete all nodes and edges using G.clear())\nand then add n nodes and zero edges, and return the modified graph.\n\nThirdly, when constructing your home-grown graph creation function\nyou can use empty_graph to construct the graph by passing a user\ndefined create_using to empty_graph. In this case, if you want the\ndefault constructor to be other than nx.Graph, specify `default`.\n\n>>> def mygraph(n, create_using=None):\n...     G = nx.empty_graph(n, create_using, nx.MultiGraph)\n...     G.add_edges_from([(0, 1), (0, 1)])\n...     return G\n>>> G = mygraph(3)\n>>> G.is_multigraph()\nTrue\n>>> G = mygraph(3, nx.Graph)\n>>> G.is_multigraph()\nFalse\n\nSee also create_empty_copy(G)."}, {"type": "function", "name": "networkx.enumerate_all_cliques", "documentation": "Returns all cliques in an undirected graph.\n\nThis function returns an iterator over cliques, each of which is a\nlist of nodes. The iteration is ordered by cardinality of the\ncliques: first all cliques of size one, then all cliques of size\ntwo, etc.\n\nParameters\n----------\nG : NetworkX graph\n    An undirected graph.\n\nReturns\n-------\niterator\n    An iterator over cliques, each of which is a list of nodes in\n    `G`. The cliques are ordered according to size.\n\nNotes\n-----\nTo obtain a list of all cliques, use\n`list(enumerate_all_cliques(G))`. However, be aware that in the\nworst-case, the length of this list can be exponential in the number\nof nodes in the graph (for example, when the graph is the complete\ngraph). This function avoids storing all cliques in memory by only\nkeeping current candidate node lists in memory during its search.\n\nThe implementation is adapted from the algorithm by Zhang, et\nal. (2005) [1]_ to output all cliques discovered.\n\nThis algorithm ignores self-loops and parallel edges, since cliques\nare not conventionally defined with such edges.\n\nReferences\n----------\n.. [1] Yun Zhang, Abu-Khzam, F.N., Baldwin, N.E., Chesler, E.J.,\n       Langston, M.A., Samatova, N.F.,\n       \"Genome-Scale Computational Approaches to Memory-Intensive\n       Applications in Systems Biology\".\n       *Supercomputing*, 2005. Proceedings of the ACM/IEEE SC 2005\n       Conference, pp. 12, 12--18 Nov. 2005.\n       <https://doi.org/10.1109/SC.2005.29>."}, {"type": "function", "name": "networkx.equitable_color", "documentation": "Provides an equitable coloring for nodes of `G`.\n\nAttempts to color a graph using `num_colors` colors, where no neighbors of\na node can have same color as the node itself and the number of nodes with\neach color differ by at most 1. `num_colors` must be greater than the\nmaximum degree of `G`. The algorithm is described in [1]_ and has\ncomplexity O(num_colors * n**2).\n\nParameters\n----------\nG : networkX graph\n   The nodes of this graph will be colored.\n\nnum_colors : number of colors to use\n   This number must be at least one more than the maximum degree of nodes\n   in the graph.\n\nReturns\n-------\nA dictionary with keys representing nodes and values representing\ncorresponding coloring.\n\nExamples\n--------\n>>> G = nx.cycle_graph(4)\n>>> nx.coloring.equitable_color(G, num_colors=3)  # doctest: +SKIP\n{0: 2, 1: 1, 2: 2, 3: 0}\n\nRaises\n------\nNetworkXAlgorithmError\n    If `num_colors` is not at least the maximum degree of the graph `G`\n\nReferences\n----------\n.. [1] Kierstead, H. A., Kostochka, A. V., Mydlarz, M., & Szemer\u00e9di, E.\n    (2010). A fast algorithm for equitable coloring. Combinatorica, 30(2),\n    217-224."}, {"type": "function", "name": "networkx.equivalence_classes", "documentation": "Returns equivalence classes of `relation` when applied to `iterable`.\n\nThe equivalence classes, or blocks, consist of objects from `iterable`\nwhich are all equivalent. They are defined to be equivalent if the\n`relation` function returns `True` when passed any two objects from that\nclass, and `False` otherwise. To define an equivalence relation the\nfunction must be reflexive, symmetric and transitive.\n\nParameters\n----------\niterable : list, tuple, or set\n    An iterable of elements/nodes.\n\nrelation : function\n    A Boolean-valued function that implements an equivalence relation\n    (reflexive, symmetric, transitive binary relation) on the elements\n    of `iterable` - it must take two elements and return `True` if\n    they are related, or `False` if not.\n\nReturns\n-------\nset of frozensets\n    A set of frozensets representing the partition induced by the equivalence\n    relation function `relation` on the elements of `iterable`. Each\n    member set in the return set represents an equivalence class, or\n    block, of the partition.\n\n    Duplicate elements will be ignored so it makes the most sense for\n    `iterable` to be a :class:`set`.\n\nNotes\n-----\nThis function does not check that `relation` represents an equivalence\nrelation. You can check that your equivalence classes provide a partition\nusing `is_partition`.\n\nExamples\n--------\nLet `X` be the set of integers from `0` to `9`, and consider an equivalence\nrelation `R` on `X` of congruence modulo `3`: this means that two integers\n`x` and `y` in `X` are equivalent under `R` if they leave the same\nremainder when divided by `3`, i.e. `(x - y) mod 3 = 0`.\n\nThe equivalence classes of this relation are `{0, 3, 6, 9}`, `{1, 4, 7}`,\n`{2, 5, 8}`: `0`, `3`, `6`, `9` are all divisible by `3` and leave zero\nremainder; `1`, `4`, `7` leave remainder `1`; while `2`, `5` and `8` leave\nremainder `2`. We can see this by calling `equivalence_classes` with\n`X` and a function implementation of `R`.\n\n>>> X = set(range(10))\n>>> def mod3(x, y):\n...     return (x - y) % 3 == 0\n>>> equivalence_classes(X, mod3)  # doctest: +SKIP\n{frozenset({1, 4, 7}), frozenset({8, 2, 5}), frozenset({0, 9, 3, 6})}"}, {"type": "function", "name": "networkx.erdos_renyi_graph", "documentation": "Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph\nor a binomial graph.\n\nThe $G_{n,p}$ model chooses each of the possible edges with probability $p$.\n\nParameters\n----------\nn : int\n    The number of nodes.\np : float\n    Probability for edge creation.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ndirected : bool, optional (default=False)\n    If True, this function returns a directed graph.\n\nSee Also\n--------\nfast_gnp_random_graph\n\nNotes\n-----\nThis algorithm [2]_ runs in $O(n^2)$ time.  For sparse graphs (that is, for\nsmall values of $p$), :func:`fast_gnp_random_graph` is a faster algorithm.\n\n:func:`binomial_graph` and :func:`erdos_renyi_graph` are\naliases for :func:`gnp_random_graph`.\n\n>>> nx.binomial_graph is nx.gnp_random_graph\nTrue\n>>> nx.erdos_renyi_graph is nx.gnp_random_graph\nTrue\n\nReferences\n----------\n.. [1] P. Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).\n.. [2] E. N. Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959)."}, {"type": "function", "name": "networkx.estrada_index", "documentation": "Returns the Estrada index of a the graph G.\n\nThe Estrada Index is a topological index of folding or 3D \"compactness\" ([1]_).\n\nParameters\n----------\nG: graph\n\nReturns\n-------\nestrada index: float\n\nRaises\n------\nNetworkXError\n    If the graph is not undirected and simple.\n\nNotes\n-----\nLet `G=(V,E)` be a simple undirected graph with `n` nodes  and let\n`\\lambda_{1}\\leq\\lambda_{2}\\leq\\cdots\\lambda_{n}`\nbe a non-increasing ordering of the eigenvalues of its adjacency\nmatrix `A`. The Estrada index is ([1]_, [2]_)\n\n.. math::\n    EE(G)=\\sum_{j=1}^n e^{\\lambda _j}.\n\nReferences\n----------\n.. [1] E. Estrada, \"Characterization of 3D molecular structure\",\n   Chem. Phys. Lett. 319, 713 (2000).\n   https://doi.org/10.1016/S0009-2614(00)00158-5\n.. [2] Jos\u00e9 Antonio de la Pe\u00f1aa, Ivan Gutman, Juan Rada,\n   \"Estimating the Estrada index\",\n   Linear Algebra and its Applications. 427, 1 (2007).\n   https://doi.org/10.1016/j.laa.2007.06.020\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (1, 2), (1, 5), (5, 4), (2, 4), (2, 3), (4, 3), (3, 6)])\n>>> ei = nx.estrada_index(G)\n>>> print(f\"{ei:0.5}\")\n20.55"}, {"type": "function", "name": "networkx.eulerian_circuit", "documentation": "Returns an iterator over the edges of an Eulerian circuit in `G`.\n\nAn *Eulerian circuit* is a closed walk that includes each edge of a\ngraph exactly once.\n\nParameters\n----------\nG : NetworkX graph\n   A graph, either directed or undirected.\n\nsource : node, optional\n   Starting node for circuit.\n\nkeys : bool\n   If False, edges generated by this function will be of the form\n   ``(u, v)``. Otherwise, edges will be of the form ``(u, v, k)``.\n   This option is ignored unless `G` is a multigraph.\n\nReturns\n-------\nedges : iterator\n   An iterator over edges in the Eulerian circuit.\n\nRaises\n------\nNetworkXError\n   If the graph is not Eulerian.\n\nSee Also\n--------\nis_eulerian\n\nNotes\n-----\nThis is a linear time implementation of an algorithm adapted from [1]_.\n\nFor general information about Euler tours, see [2]_.\n\nReferences\n----------\n.. [1] J. Edmonds, E. L. Johnson.\n   Matching, Euler tours and the Chinese postman.\n   Mathematical programming, Volume 5, Issue 1 (1973), 111-114.\n.. [2] https://en.wikipedia.org/wiki/Eulerian_path\n\nExamples\n--------\nTo get an Eulerian circuit in an undirected graph::\n\n    >>> G = nx.complete_graph(3)\n    >>> list(nx.eulerian_circuit(G))\n    [(0, 2), (2, 1), (1, 0)]\n    >>> list(nx.eulerian_circuit(G, source=1))\n    [(1, 2), (2, 0), (0, 1)]\n\nTo get the sequence of vertices in an Eulerian circuit::\n\n    >>> [u for u, v in nx.eulerian_circuit(G)]\n    [0, 2, 1]"}, {"type": "function", "name": "networkx.eulerian_path", "documentation": "Return an iterator over the edges of an Eulerian path in `G`.\n\nParameters\n----------\nG : NetworkX Graph\n    The graph in which to look for an eulerian path.\nsource : node or None (default: None)\n    The node at which to start the search. None means search over all\n    starting nodes.\nkeys : Bool (default: False)\n    Indicates whether to yield edge 3-tuples (u, v, edge_key).\n    The default yields edge 2-tuples\n\nYields\n------\nEdge tuples along the eulerian path.\n\nWarning: If `source` provided is not the start node of an Euler path\nwill raise error even if an Euler Path exists."}, {"type": "function", "name": "networkx.eulerize", "documentation": "Transforms a graph into an Eulerian graph.\n\nIf `G` is Eulerian the result is `G` as a MultiGraph, otherwise the result is a smallest\n(in terms of the number of edges) multigraph whose underlying simple graph is `G`.\n\nParameters\n----------\nG : NetworkX graph\n   An undirected graph\n\nReturns\n-------\nG : NetworkX multigraph\n\nRaises\n------\nNetworkXError\n   If the graph is not connected.\n\nSee Also\n--------\nis_eulerian\neulerian_circuit\n\nReferences\n----------\n.. [1] J. Edmonds, E. L. Johnson.\n   Matching, Euler tours and the Chinese postman.\n   Mathematical programming, Volume 5, Issue 1 (1973), 111-114.\n.. [2] https://en.wikipedia.org/wiki/Eulerian_path\n.. [3] http://web.math.princeton.edu/math_alive/5/Notes1.pdf\n\nExamples\n--------\n    >>> G = nx.complete_graph(10)\n    >>> H = nx.eulerize(G)\n    >>> nx.is_eulerian(H)\n    True"}, {"type": "function", "name": "networkx.expected_degree_graph", "documentation": "Returns a random graph with given expected degrees.\n\nGiven a sequence of expected degrees $W=(w_0,w_1,\\ldots,w_{n-1})$\nof length $n$ this algorithm assigns an edge between node $u$ and\nnode $v$ with probability\n\n.. math::\n\n   p_{uv} = \\frac{w_u w_v}{\\sum_k w_k} .\n\nParameters\n----------\nw : list\n    The list of expected degrees.\nselfloops: bool (default=True)\n    Set to False to remove the possibility of self-loop edges.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nGraph\n\nExamples\n--------\n>>> z = [10 for i in range(100)]\n>>> G = nx.expected_degree_graph(z)\n\nNotes\n-----\nThe nodes have integer labels corresponding to index of expected degrees\ninput sequence.\n\nThe complexity of this algorithm is $\\mathcal{O}(n+m)$ where $n$ is the\nnumber of nodes and $m$ is the expected number of edges.\n\nThe model in [1]_ includes the possibility of self-loop edges.\nSet selfloops=False to produce a graph without self loops.\n\nFor finite graphs this model doesn't produce exactly the given\nexpected degree sequence.  Instead the expected degrees are as\nfollows.\n\nFor the case without self loops (selfloops=False),\n\n.. math::\n\n   E[deg(u)] = \\sum_{v \\ne u} p_{uv}\n            = w_u \\left( 1 - \\frac{w_u}{\\sum_k w_k} \\right) .\n\n\nNetworkX uses the standard convention that a self-loop edge counts 2\nin the degree of a node, so with self loops (selfloops=True),\n\n.. math::\n\n   E[deg(u)] =  \\sum_{v \\ne u} p_{uv}  + 2 p_{uu}\n            = w_u \\left( 1 + \\frac{w_u}{\\sum_k w_k} \\right) .\n\nReferences\n----------\n.. [1] Fan Chung and L. Lu, Connected components in random graphs with\n   given expected degree sequences, Ann. Combinatorics, 6,\n   pp. 125-145, 2002.\n.. [2] Joel Miller and Aric Hagberg,\n   Efficient generation of networks with given expected degrees,\n   in Algorithms and Models for the Web-Graph (WAW 2011),\n   Alan Frieze, Paul Horn, and Pawe\u0142 Pra\u0142at (Eds), LNCS 6732,\n   pp. 115-126, 2011."}, {"type": "function", "name": "networkx.extended_barabasi_albert_graph", "documentation": "Returns an extended Barab\u00e1si\u2013Albert model graph.\n\nAn extended Barab\u00e1si\u2013Albert model graph is a random graph constructed\nusing preferential attachment. The extended model allows new edges,\nrewired edges or new nodes. Based on the probabilities $p$ and $q$\nwith $p + q < 1$, the growing behavior of the graph is determined as:\n\n1) With $p$ probability, $m$ new edges are added to the graph,\nstarting from randomly chosen existing nodes and attached preferentially at the other end.\n\n2) With $q$ probability, $m$ existing edges are rewired\nby randomly choosing an edge and rewiring one end to a preferentially chosen node.\n\n3) With $(1 - p - q)$ probability, $m$ new nodes are added to the graph\nwith edges attached preferentially.\n\nWhen $p = q = 0$, the model behaves just like the Barab\u00e1si\u2013Alber model.\n\nParameters\n----------\nn : int\n    Number of nodes\nm : int\n    Number of edges with which a new node attaches to existing nodes\np : float\n    Probability value for adding an edge between existing nodes. p + q < 1\nq : float\n    Probability value of rewiring of existing edges. p + q < 1\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : Graph\n\nRaises\n------\nNetworkXError\n    If `m` does not satisfy ``1 <= m < n`` or ``1 >= p + q``\n\nReferences\n----------\n.. [1] Albert, R., & Barab\u00e1si, A. L. (2000)\n   Topology of evolving networks: local events and universality\n   Physical review letters, 85(24), 5234."}, {"type": "function", "name": "networkx.fast_could_be_isomorphic", "documentation": "Returns False if graphs are definitely not isomorphic.\n\nTrue does NOT guarantee isomorphism.\n\nParameters\n----------\nG1, G2 : graphs\n   The two graphs G1 and G2 must be the same type.\n\nNotes\n-----\nChecks for matching degree and triangle sequences. The triangle\nsequence contains the number of triangles each node is part of."}, {"type": "function", "name": "networkx.fast_gnp_random_graph", "documentation": "Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph or\na binomial graph.\n\nParameters\n----------\nn : int\n    The number of nodes.\np : float\n    Probability for edge creation.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ndirected : bool, optional (default=False)\n    If True, this function returns a directed graph.\n\nNotes\n-----\nThe $G_{n,p}$ graph algorithm chooses each of the $[n (n - 1)] / 2$\n(undirected) or $n (n - 1)$ (directed) possible edges with probability $p$.\n\nThis algorithm [1]_ runs in $O(n + m)$ time, where `m` is the expected number of\nedges, which equals $p n (n - 1) / 2$. This should be faster than\n:func:`gnp_random_graph` when $p$ is small and the expected number of edges\nis small (that is, the graph is sparse).\n\nSee Also\n--------\ngnp_random_graph\n\nReferences\n----------\n.. [1] Vladimir Batagelj and Ulrik Brandes,\n   \"Efficient generation of large random networks\",\n   Phys. Rev. E, 71, 036113, 2005."}, {"type": "function", "name": "networkx.faster_could_be_isomorphic", "documentation": "Returns False if graphs are definitely not isomorphic.\n\nTrue does NOT guarantee isomorphism.\n\nParameters\n----------\nG1, G2 : graphs\n   The two graphs G1 and G2 must be the same type.\n\nNotes\n-----\nChecks for matching degree sequences."}, {"type": "function", "name": "networkx.fiedler_vector", "documentation": "Returns the Fiedler vector of a connected undirected graph.\n\nThe Fiedler vector of a connected undirected graph is the eigenvector\ncorresponding to the second smallest eigenvalue of the Laplacian matrix\nof the graph.\n\nParameters\n----------\nG : NetworkX graph\n    An undirected graph.\n\nweight : object, optional (default: None)\n    The data key used to determine the weight of each edge. If None, then\n    each edge has unit weight.\n\nnormalized : bool, optional (default: False)\n    Whether the normalized Laplacian matrix is used.\n\ntol : float, optional (default: 1e-8)\n    Tolerance of relative residual in eigenvalue computation.\n\nmethod : string, optional (default: 'tracemin_pcg')\n    Method of eigenvalue computation. It must be one of the tracemin\n    options shown below (TraceMIN), 'lanczos' (Lanczos iteration)\n    or 'lobpcg' (LOBPCG).\n\n    The TraceMIN algorithm uses a linear system solver. The following\n    values allow specifying the solver to be used.\n\n    =============== ========================================\n    Value           Solver\n    =============== ========================================\n    'tracemin_pcg'  Preconditioned conjugate gradient method\n    'tracemin_lu'   LU factorization\n    =============== ========================================\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nfiedler_vector : NumPy array of floats.\n    Fiedler vector.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is directed.\n\nNetworkXError\n    If G has less than two nodes or is not connected.\n\nNotes\n-----\nEdge weights are interpreted by their absolute values. For MultiGraph's,\nweights of parallel edges are summed. Zero-weighted edges are ignored.\n\nSee Also\n--------\nlaplacian_matrix\n\nExamples\n--------\nGiven a connected graph the signs of the values in the Fiedler vector can be\nused to partition the graph into two components.\n\n>>> G = nx.barbell_graph(5, 0)\n>>> nx.fiedler_vector(G, normalized=True, seed=1)\narray([-0.32864129, -0.32864129, -0.32864129, -0.32864129, -0.26072899,\n        0.26072899,  0.32864129,  0.32864129,  0.32864129,  0.32864129])\n\nThe connected components are the two 5-node cliques of the barbell graph."}, {"type": "function", "name": "networkx.find_asteroidal_triple", "documentation": "Find an asteroidal triple in the given graph.\n\nAn asteroidal triple is a triple of non-adjacent vertices such that\nthere exists a path between any two of them which avoids the closed\nneighborhood of the third. It checks all independent triples of vertices\nand whether they are an asteroidal triple or not. This is done with the\nhelp of a data structure called a component structure.\nA component structure encodes information about which vertices belongs to\nthe same connected component when the closed neighborhood of a given vertex\nis removed from the graph. The algorithm used to check is the trivial\none, outlined in [1]_, which has a runtime of\n:math:`O(|V||\\overline{E} + |V||E|)`, where the second term is the\ncreation of the component structure.\n\nParameters\n----------\nG : NetworkX Graph\n    The graph to check whether is AT-free or not\n\nReturns\n-------\nlist or None\n    An asteroidal triple is returned as a list of nodes. If no asteroidal\n    triple exists, i.e. the graph is AT-free, then None is returned.\n    The returned value depends on the certificate parameter. The default\n    option is a bool which is True if the graph is AT-free, i.e. the\n    given graph contains no asteroidal triples, and False otherwise, i.e.\n    if the graph contains at least one asteroidal triple.\n\nNotes\n-----\nThe component structure and the algorithm is described in [1]_. The current\nimplementation implements the trivial algorithm for simple graphs.\n\nReferences\n----------\n.. [1] Ekkehard K\u00f6hler,\n   \"Recognizing Graphs without asteroidal triples\",\n   Journal of Discrete Algorithms 2, pages 439-452, 2004.\n   https://www.sciencedirect.com/science/article/pii/S157086670400019X"}, {"type": "function", "name": "networkx.find_cliques", "documentation": "Returns all maximal cliques in an undirected graph.\n\nFor each node *n*, a *maximal clique for n* is a largest complete\nsubgraph containing *n*. The largest maximal clique is sometimes\ncalled the *maximum clique*.\n\nThis function returns an iterator over cliques, each of which is a\nlist of nodes. It is an iterative implementation, so should not\nsuffer from recursion depth issues.\n\nThis function accepts a list of `nodes` and only the maximal cliques\ncontaining all of these `nodes` are returned. It can considerably speed up\nthe running time if some specific cliques are desired.\n\nParameters\n----------\nG : NetworkX graph\n    An undirected graph.\n\nnodes : list, optional (default=None)\n    If provided, only yield *maximal cliques* containing all nodes in `nodes`.\n    If `nodes` isn't a clique itself, a ValueError is raised.\n\nReturns\n-------\niterator\n    An iterator over maximal cliques, each of which is a list of\n    nodes in `G`. If `nodes` is provided, only the maximal cliques\n    containing all the nodes in `nodes` are returned. The order of\n    cliques is arbitrary.\n\nRaises\n------\nValueError\n    If `nodes` is not a clique.\n\nExamples\n--------\n>>> from pprint import pprint  # For nice dict formatting\n>>> G = nx.karate_club_graph()\n>>> sum(1 for c in nx.find_cliques(G))  # The number of maximal cliques in G\n36\n>>> max(nx.find_cliques(G), key=len)  # The largest maximal clique in G\n[0, 1, 2, 3, 13]\n\nThe size of the largest maximal clique is known as the *clique number* of\nthe graph, which can be found directly with:\n\n>>> max(len(c) for c in nx.find_cliques(G))\n5\n\nOne can also compute the number of maximal cliques in `G` that contain a given\nnode. The following produces a dictionary keyed by node whose\nvalues are the number of maximal cliques in `G` that contain the node:\n\n>>> pprint({n: sum(1 for c in nx.find_cliques(G) if n in c) for n in G})\n{0: 13,\n 1: 6,\n 2: 7,\n 3: 3,\n 4: 2,\n 5: 3,\n 6: 3,\n 7: 1,\n 8: 3,\n 9: 2,\n 10: 2,\n 11: 1,\n 12: 1,\n 13: 2,\n 14: 1,\n 15: 1,\n 16: 1,\n 17: 1,\n 18: 1,\n 19: 2,\n 20: 1,\n 21: 1,\n 22: 1,\n 23: 3,\n 24: 2,\n 25: 2,\n 26: 1,\n 27: 3,\n 28: 2,\n 29: 2,\n 30: 2,\n 31: 4,\n 32: 9,\n 33: 14}\n\nOr, similarly, the maximal cliques in `G` that contain a given node.\nFor example, the 4 maximal cliques that contain node 31:\n\n>>> [c for c in nx.find_cliques(G) if 31 in c]\n[[0, 31], [33, 32, 31], [33, 28, 31], [24, 25, 31]]\n\nSee Also\n--------\nfind_cliques_recursive\n    A recursive version of the same algorithm.\n\nNotes\n-----\nTo obtain a list of all maximal cliques, use\n`list(find_cliques(G))`. However, be aware that in the worst-case,\nthe length of this list can be exponential in the number of nodes in\nthe graph. This function avoids storing all cliques in memory by\nonly keeping current candidate node lists in memory during its search.\n\nThis implementation is based on the algorithm published by Bron and\nKerbosch (1973) [1]_, as adapted by Tomita, Tanaka and Takahashi\n(2006) [2]_ and discussed in Cazals and Karande (2008) [3]_. It\nessentially unrolls the recursion used in the references to avoid\nissues of recursion stack depth (for a recursive implementation, see\n:func:`find_cliques_recursive`).\n\nThis algorithm ignores self-loops and parallel edges, since cliques\nare not conventionally defined with such edges.\n\nReferences\n----------\n.. [1] Bron, C. and Kerbosch, J.\n   \"Algorithm 457: finding all cliques of an undirected graph\".\n   *Communications of the ACM* 16, 9 (Sep. 1973), 575--577.\n   <http://portal.acm.org/citation.cfm?doid=362342.362367>\n\n.. [2] Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi,\n   \"The worst-case time complexity for generating all maximal\n   cliques and computational experiments\",\n   *Theoretical Computer Science*, Volume 363, Issue 1,\n   Computing and Combinatorics,\n   10th Annual International Conference on\n   Computing and Combinatorics (COCOON 2004), 25 October 2006, Pages 28--42\n   <https://doi.org/10.1016/j.tcs.2006.06.015>\n\n.. [3] F. Cazals, C. Karande,\n   \"A note on the problem of reporting maximal cliques\",\n   *Theoretical Computer Science*,\n   Volume 407, Issues 1--3, 6 November 2008, Pages 564--568,\n   <https://doi.org/10.1016/j.tcs.2008.05.010>"}, {"type": "function", "name": "networkx.find_cliques_recursive", "documentation": "Returns all maximal cliques in a graph.\n\nFor each node *v*, a *maximal clique for v* is a largest complete\nsubgraph containing *v*. The largest maximal clique is sometimes\ncalled the *maximum clique*.\n\nThis function returns an iterator over cliques, each of which is a\nlist of nodes. It is a recursive implementation, so may suffer from\nrecursion depth issues, but is included for pedagogical reasons.\nFor a non-recursive implementation, see :func:`find_cliques`.\n\nThis function accepts a list of `nodes` and only the maximal cliques\ncontaining all of these `nodes` are returned. It can considerably speed up\nthe running time if some specific cliques are desired.\n\nParameters\n----------\nG : NetworkX graph\n\nnodes : list, optional (default=None)\n    If provided, only yield *maximal cliques* containing all nodes in `nodes`.\n    If `nodes` isn't a clique itself, a ValueError is raised.\n\nReturns\n-------\niterator\n    An iterator over maximal cliques, each of which is a list of\n    nodes in `G`. If `nodes` is provided, only the maximal cliques\n    containing all the nodes in `nodes` are yielded. The order of\n    cliques is arbitrary.\n\nRaises\n------\nValueError\n    If `nodes` is not a clique.\n\nSee Also\n--------\nfind_cliques\n    An iterative version of the same algorithm. See docstring for examples.\n\nNotes\n-----\nTo obtain a list of all maximal cliques, use\n`list(find_cliques_recursive(G))`. However, be aware that in the\nworst-case, the length of this list can be exponential in the number\nof nodes in the graph. This function avoids storing all cliques in memory\nby only keeping current candidate node lists in memory during its search.\n\nThis implementation is based on the algorithm published by Bron and\nKerbosch (1973) [1]_, as adapted by Tomita, Tanaka and Takahashi\n(2006) [2]_ and discussed in Cazals and Karande (2008) [3]_. For a\nnon-recursive implementation, see :func:`find_cliques`.\n\nThis algorithm ignores self-loops and parallel edges, since cliques\nare not conventionally defined with such edges.\n\nReferences\n----------\n.. [1] Bron, C. and Kerbosch, J.\n   \"Algorithm 457: finding all cliques of an undirected graph\".\n   *Communications of the ACM* 16, 9 (Sep. 1973), 575--577.\n   <http://portal.acm.org/citation.cfm?doid=362342.362367>\n\n.. [2] Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi,\n   \"The worst-case time complexity for generating all maximal\n   cliques and computational experiments\",\n   *Theoretical Computer Science*, Volume 363, Issue 1,\n   Computing and Combinatorics,\n   10th Annual International Conference on\n   Computing and Combinatorics (COCOON 2004), 25 October 2006, Pages 28--42\n   <https://doi.org/10.1016/j.tcs.2006.06.015>\n\n.. [3] F. Cazals, C. Karande,\n   \"A note on the problem of reporting maximal cliques\",\n   *Theoretical Computer Science*,\n   Volume 407, Issues 1--3, 6 November 2008, Pages 564--568,\n   <https://doi.org/10.1016/j.tcs.2008.05.010>"}, {"type": "function", "name": "networkx.find_cycle", "documentation": "Returns a cycle found via depth-first traversal.\n\nThe cycle is a list of edges indicating the cyclic path.\nOrientation of directed edges is controlled by `orientation`.\n\nParameters\n----------\nG : graph\n    A directed/undirected graph/multigraph.\n\nsource : node, list of nodes\n    The node from which the traversal begins. If None, then a source\n    is chosen arbitrarily and repeatedly until all edges from each node in\n    the graph are searched.\n\norientation : None | 'original' | 'reverse' | 'ignore' (default: None)\n    For directed graphs and directed multigraphs, edge traversals need not\n    respect the original orientation of the edges.\n    When set to 'reverse' every edge is traversed in the reverse direction.\n    When set to 'ignore', every edge is treated as undirected.\n    When set to 'original', every edge is treated as directed.\n    In all three cases, the yielded edge tuples add a last entry to\n    indicate the direction in which that edge was traversed.\n    If orientation is None, the yielded edge has no direction indicated.\n    The direction is respected, but not reported.\n\nReturns\n-------\nedges : directed edges\n    A list of directed edges indicating the path taken for the loop.\n    If no cycle is found, then an exception is raised.\n    For graphs, an edge is of the form `(u, v)` where `u` and `v`\n    are the tail and head of the edge as determined by the traversal.\n    For multigraphs, an edge is of the form `(u, v, key)`, where `key` is\n    the key of the edge. When the graph is directed, then `u` and `v`\n    are always in the order of the actual directed edge.\n    If orientation is not None then the edge tuple is extended to include\n    the direction of traversal ('forward' or 'reverse') on that edge.\n\nRaises\n------\nNetworkXNoCycle\n    If no cycle was found.\n\nExamples\n--------\nIn this example, we construct a DAG and find, in the first call, that there\nare no directed cycles, and so an exception is raised. In the second call,\nwe ignore edge orientations and find that there is an undirected cycle.\nNote that the second call finds a directed cycle while effectively\ntraversing an undirected graph, and so, we found an \"undirected cycle\".\nThis means that this DAG structure does not form a directed tree (which\nis also known as a polytree).\n\n>>> G = nx.DiGraph([(0, 1), (0, 2), (1, 2)])\n>>> nx.find_cycle(G, orientation=\"original\")\nTraceback (most recent call last):\n    ...\nnetworkx.exception.NetworkXNoCycle: No cycle found.\n>>> list(nx.find_cycle(G, orientation=\"ignore\"))\n[(0, 1, 'forward'), (1, 2, 'forward'), (0, 2, 'reverse')]\n\nSee Also\n--------\nsimple_cycles"}, {"type": "function", "name": "networkx.find_induced_nodes", "documentation": "Returns the set of induced nodes in the path from s to t.\n\nParameters\n----------\nG : graph\n  A chordal NetworkX graph\ns : node\n    Source node to look for induced nodes\nt : node\n    Destination node to look for induced nodes\ntreewidth_bound: float\n    Maximum treewidth acceptable for the graph H. The search\n    for induced nodes will end as soon as the treewidth_bound is exceeded.\n\nReturns\n-------\ninduced_nodes : Set of nodes\n    The set of induced nodes in the path from s to t in G\n\nRaises\n------\nNetworkXError\n    The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\n    If the input graph is an instance of one of these classes, a\n    :exc:`NetworkXError` is raised.\n    The algorithm can only be applied to chordal graphs. If the input\n    graph is found to be non-chordal, a :exc:`NetworkXError` is raised.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G = nx.generators.classic.path_graph(10)\n>>> induced_nodes = nx.find_induced_nodes(G, 1, 9, 2)\n>>> sorted(induced_nodes)\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nNotes\n-----\nG must be a chordal graph and (s,t) an edge that is not in G.\n\nIf a treewidth_bound is provided, the search for induced nodes will end\nas soon as the treewidth_bound is exceeded.\n\nThe algorithm is inspired by Algorithm 4 in [1]_.\nA formal definition of induced node can also be found on that reference.\n\nSelf Loops are ignored\n\nReferences\n----------\n.. [1] Learning Bounded Treewidth Bayesian Networks.\n   Gal Elidan, Stephen Gould; JMLR, 9(Dec):2699--2731, 2008.\n   http://jmlr.csail.mit.edu/papers/volume9/elidan08a/elidan08a.pdf"}, {"type": "function", "name": "networkx.find_minimal_d_separator", "documentation": "Returns a minimal d-separating set between `x` and `y` if possible\n\nA d-separating set in a DAG is a set of nodes that blocks all\npaths between the two sets of nodes, `x` and `y`. This function\nconstructs a d-separating set that is \"minimal\", meaning no nodes can\nbe removed without it losing the d-separating property for `x` and `y`.\nIf no d-separating sets exist for `x` and `y`, this returns `None`.\n\nIn a DAG there may be more than one minimal d-separator between two\nsets of nodes. Minimal d-separators are not always unique. This function\nreturns one minimal d-separator, or `None` if no d-separator exists.\n\nUses the algorithm presented in [1]_. The complexity of the algorithm\nis :math:`O(m)`, where :math:`m` stands for the number of edges in\nthe subgraph of G consisting of only the ancestors of `x` and `y`.\nFor full details, see [1]_.\n\nParameters\n----------\nG : graph\n    A networkx DAG.\nx : set | node\n    A node or set of nodes in the graph.\ny : set | node\n    A node or set of nodes in the graph.\nincluded : set | node | None\n    A node or set of nodes which must be included in the found separating set,\n    default is None, which means the empty set.\nrestricted : set | node | None\n    Restricted node or set of nodes to consider. Only these nodes can be in\n    the found separating set, default is None meaning all nodes in ``G``.\n\nReturns\n-------\nz : set | None\n    The minimal d-separating set, if at least one d-separating set exists,\n    otherwise None.\n\nRaises\n------\nNetworkXError\n    Raises a :exc:`NetworkXError` if the input graph is not a DAG\n    or if node sets `x`, `y`, and `included` are not disjoint.\n\nNodeNotFound\n    If any of the input nodes are not found in the graph,\n    a :exc:`NodeNotFound` exception is raised.\n\nReferences\n----------\n.. [1] van der Zander, Benito, and Maciej Li\u015bkiewicz. \"Finding\n    minimal d-separators in linear time and applications.\" In\n    Uncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020."}, {"type": "function", "name": "networkx.find_negative_cycle", "documentation": "Returns a cycle with negative total weight if it exists.\n\nBellman-Ford is used to find shortest_paths. That algorithm\nstops if there exists a negative cycle. This algorithm\npicks up from there and returns the found negative cycle.\n\nThe cycle consists of a list of nodes in the cycle order. The last\nnode equals the first to make it a cycle.\nYou can look up the edge weights in the original graph. In the case\nof multigraphs the relevant edge is the minimal weight edge between\nthe nodes in the 2-tuple.\n\nIf the graph has no negative cycle, a NetworkXError is raised.\n\nParameters\n----------\nG : NetworkX graph\n\nsource: node label\n    The search for the negative cycle will start from this node.\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_weighted_edges_from([(0, 1, 2), (1, 2, 2), (2, 0, 1), (1, 4, 2), (4, 0, -5)])\n>>> nx.find_negative_cycle(G, 0)\n[4, 0, 1, 4]\n\nReturns\n-------\ncycle : list\n    A list of nodes in the order of the cycle found. The last node\n    equals the first to indicate a cycle.\n\nRaises\n------\nNetworkXError\n    If no negative cycle is found."}, {"type": "function", "name": "networkx.florentine_families_graph", "documentation": "Returns Florentine families graph.\n\nReferences\n----------\n.. [1] Ronald L. Breiger and Philippa E. Pattison\n   Cumulated social roles: The duality of persons and their algebras,1\n   Social Networks, Volume 8, Issue 3, September 1986, Pages 215-256"}, {"type": "function", "name": "networkx.flow_hierarchy", "documentation": "Returns the flow hierarchy of a directed network.\n\nFlow hierarchy is defined as the fraction of edges not participating\nin cycles in a directed graph [1]_.\n\nParameters\n----------\nG : DiGraph or MultiDiGraph\n   A directed graph\n\nweight : string, optional (default=None)\n   Attribute to use for edge weights. If None the weight defaults to 1.\n\nReturns\n-------\nh : float\n   Flow hierarchy value\n\nNotes\n-----\nThe algorithm described in [1]_ computes the flow hierarchy through\nexponentiation of the adjacency matrix.  This function implements an\nalternative approach that finds strongly connected components.\nAn edge is in a cycle if and only if it is in a strongly connected\ncomponent, which can be found in $O(m)$ time using Tarjan's algorithm.\n\nReferences\n----------\n.. [1] Luo, J.; Magee, C.L. (2011),\n   Detecting evolving patterns of self-organizing networks by flow\n   hierarchy measurement, Complexity, Volume 16 Issue 6 53-61.\n   DOI: 10.1002/cplx.20368\n   http://web.mit.edu/~cmagee/www/documents/28-DetectingEvolvingPatterns_FlowHierarchy.pdf"}, {"type": "function", "name": "networkx.floyd_warshall", "documentation": "Find all-pairs shortest path lengths using Floyd's algorithm.\n\nParameters\n----------\nG : NetworkX graph\n\nweight: string, optional (default= 'weight')\n   Edge data key corresponding to the edge weight.\n\n\nReturns\n-------\ndistance : dict\n   A dictionary,  keyed by source and target, of shortest paths distances\n   between nodes.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_weighted_edges_from([(0, 1, 5), (1, 2, 2), (2, 3, -3), (1, 3, 10), (3, 2, 8)])\n>>> fw = nx.floyd_warshall(G, weight=\"weight\")\n>>> results = {a: dict(b) for a, b in fw.items()}\n>>> print(results)\n{0: {0: 0, 1: 5, 2: 7, 3: 4}, 1: {1: 0, 2: 2, 3: -1, 0: inf}, 2: {2: 0, 3: -3, 0: inf, 1: inf}, 3: {3: 0, 2: 8, 0: inf, 1: inf}}\n\nNotes\n-----\nFloyd's algorithm is appropriate for finding shortest paths\nin dense graphs or graphs with negative weights when Dijkstra's algorithm\nfails.  This algorithm can still fail if there are negative cycles.\nIt has running time $O(n^3)$ with running space of $O(n^2)$.\n\nSee Also\n--------\nfloyd_warshall_predecessor_and_distance\nfloyd_warshall_numpy\nall_pairs_shortest_path\nall_pairs_shortest_path_length"}, {"type": "function", "name": "networkx.floyd_warshall_numpy", "documentation": "Find all-pairs shortest path lengths using Floyd's algorithm.\n\nThis algorithm for finding shortest paths takes advantage of\nmatrix representations of a graph and works well for dense\ngraphs where all-pairs shortest path lengths are desired.\nThe results are returned as a NumPy array, distance[i, j],\nwhere i and j are the indexes of two nodes in nodelist.\nThe entry distance[i, j] is the distance along a shortest\npath from i to j. If no path exists the distance is Inf.\n\nParameters\n----------\nG : NetworkX graph\n\nnodelist : list, optional (default=G.nodes)\n   The rows and columns are ordered by the nodes in nodelist.\n   If nodelist is None then the ordering is produced by G.nodes.\n   Nodelist should include all nodes in G.\n\nweight: string, optional (default='weight')\n   Edge data key corresponding to the edge weight.\n\nReturns\n-------\ndistance : 2D numpy.ndarray\n    A numpy array of shortest path distances between nodes.\n    If there is no path between two nodes the value is Inf.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_weighted_edges_from([(0, 1, 5), (1, 2, 2), (2, 3, -3), (1, 3, 10), (3, 2, 8)])\n>>> nx.floyd_warshall_numpy(G)\narray([[ 0.,  5.,  7.,  4.],\n       [inf,  0.,  2., -1.],\n       [inf, inf,  0., -3.],\n       [inf, inf,  8.,  0.]])\n\nNotes\n-----\nFloyd's algorithm is appropriate for finding shortest paths in\ndense graphs or graphs with negative weights when Dijkstra's\nalgorithm fails. This algorithm can still fail if there are negative\ncycles. It has running time $O(n^3)$ with running space of $O(n^2)$.\n\nRaises\n------\nNetworkXError\n    If nodelist is not a list of the nodes in G."}, {"type": "function", "name": "networkx.floyd_warshall_predecessor_and_distance", "documentation": "Find all-pairs shortest path lengths using Floyd's algorithm.\n\nParameters\n----------\nG : NetworkX graph\n\nweight: string, optional (default= 'weight')\n   Edge data key corresponding to the edge weight.\n\nReturns\n-------\npredecessor,distance : dictionaries\n   Dictionaries, keyed by source and target, of predecessors and distances\n   in the shortest path.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_weighted_edges_from(\n...     [\n...         (\"s\", \"u\", 10),\n...         (\"s\", \"x\", 5),\n...         (\"u\", \"v\", 1),\n...         (\"u\", \"x\", 2),\n...         (\"v\", \"y\", 1),\n...         (\"x\", \"u\", 3),\n...         (\"x\", \"v\", 5),\n...         (\"x\", \"y\", 2),\n...         (\"y\", \"s\", 7),\n...         (\"y\", \"v\", 6),\n...     ]\n... )\n>>> predecessors, _ = nx.floyd_warshall_predecessor_and_distance(G)\n>>> print(nx.reconstruct_path(\"s\", \"v\", predecessors))\n['s', 'x', 'u', 'v']\n\nNotes\n-----\nFloyd's algorithm is appropriate for finding shortest paths\nin dense graphs or graphs with negative weights when Dijkstra's algorithm\nfails.  This algorithm can still fail if there are negative cycles.\nIt has running time $O(n^3)$ with running space of $O(n^2)$.\n\nSee Also\n--------\nfloyd_warshall\nfloyd_warshall_numpy\nall_pairs_shortest_path\nall_pairs_shortest_path_length"}, {"type": "function", "name": "networkx.forest_str", "documentation": "Creates a nice utf8 representation of a forest\n\nThis function has been superseded by\n:func:`nx.readwrite.text.generate_network_text`, which should be used\ninstead.\n\nParameters\n----------\ngraph : nx.DiGraph | nx.Graph\n    Graph to represent (must be a tree, forest, or the empty graph)\n\nwith_labels : bool\n    If True will use the \"label\" attribute of a node to display if it\n    exists otherwise it will use the node value itself. Defaults to True.\n\nsources : List\n    Mainly relevant for undirected forests, specifies which nodes to list\n    first. If unspecified the root nodes of each tree will be used for\n    directed forests; for undirected forests this defaults to the nodes\n    with the smallest degree.\n\nwrite : callable\n    Function to use to write to, if None new lines are appended to\n    a list and returned. If set to the `print` function, lines will\n    be written to stdout as they are generated. If specified,\n    this function will return None. Defaults to None.\n\nascii_only : Boolean\n    If True only ASCII characters are used to construct the visualization\n\nReturns\n-------\nstr | None :\n    utf8 representation of the tree / forest\n\nExamples\n--------\n>>> graph = nx.balanced_tree(r=2, h=3, create_using=nx.DiGraph)\n>>> print(nx.forest_str(graph))\n\u2559\u2500\u2500 0\n    \u251c\u2500\u257c 1\n    \u2502   \u251c\u2500\u257c 3\n    \u2502   \u2502   \u251c\u2500\u257c 7\n    \u2502   \u2502   \u2514\u2500\u257c 8\n    \u2502   \u2514\u2500\u257c 4\n    \u2502       \u251c\u2500\u257c 9\n    \u2502       \u2514\u2500\u257c 10\n    \u2514\u2500\u257c 2\n        \u251c\u2500\u257c 5\n        \u2502   \u251c\u2500\u257c 11\n        \u2502   \u2514\u2500\u257c 12\n        \u2514\u2500\u257c 6\n            \u251c\u2500\u257c 13\n            \u2514\u2500\u257c 14\n\n\n>>> graph = nx.balanced_tree(r=1, h=2, create_using=nx.Graph)\n>>> print(nx.forest_str(graph))\n\u2559\u2500\u2500 0\n    \u2514\u2500\u2500 1\n        \u2514\u2500\u2500 2\n\n>>> print(nx.forest_str(graph, ascii_only=True))\n+-- 0\n    L-- 1\n        L-- 2"}, {"type": "function", "name": "networkx.freeze", "documentation": "Modify graph to prevent further change by adding or removing\nnodes or edges.\n\nNode and edge data can still be modified.\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> G = nx.freeze(G)\n>>> try:\n...     G.add_edge(4, 5)\n... except nx.NetworkXError as err:\n...     print(str(err))\nFrozen graph can't be modified\n\nNotes\n-----\nTo \"unfreeze\" a graph you must make a copy by creating a new graph object:\n\n>>> graph = nx.path_graph(4)\n>>> frozen_graph = nx.freeze(graph)\n>>> unfrozen_graph = nx.Graph(frozen_graph)\n>>> nx.is_frozen(unfrozen_graph)\nFalse\n\nSee Also\n--------\nis_frozen"}, {"type": "function", "name": "networkx.from_dict_of_dicts", "documentation": "Returns a graph from a dictionary of dictionaries.\n\nParameters\n----------\nd : dictionary of dictionaries\n  A dictionary of dictionaries adjacency representation.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n\nmultigraph_input : bool (default False)\n   When True, the dict `d` is assumed\n   to be a dict-of-dict-of-dict-of-dict structure keyed by\n   node to neighbor to edge keys to edge data for multi-edges.\n   Otherwise this routine assumes dict-of-dict-of-dict keyed by\n   node to neighbor to edge data.\n\nExamples\n--------\n>>> dod = {0: {1: {\"weight\": 1}}}  # single edge (0,1)\n>>> G = nx.from_dict_of_dicts(dod)\n\nor\n\n>>> G = nx.Graph(dod)  # use Graph constructor"}, {"type": "function", "name": "networkx.from_dict_of_lists", "documentation": "Returns a graph from a dictionary of lists.\n\nParameters\n----------\nd : dictionary of lists\n  A dictionary of lists adjacency representation.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n\nExamples\n--------\n>>> dol = {0: [1]}  # single edge (0,1)\n>>> G = nx.from_dict_of_lists(dol)\n\nor\n\n>>> G = nx.Graph(dol)  # use Graph constructor"}, {"type": "function", "name": "networkx.from_edgelist", "documentation": "Returns a graph from a list of edges.\n\nParameters\n----------\nedgelist : list or iterator\n  Edge tuples\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n\nExamples\n--------\n>>> edgelist = [(0, 1)]  # single edge (0,1)\n>>> G = nx.from_edgelist(edgelist)\n\nor\n\n>>> G = nx.Graph(edgelist)  # use Graph constructor"}, {"type": "function", "name": "networkx.from_graph6_bytes", "documentation": "Read a simple undirected graph in graph6 format from bytes.\n\nParameters\n----------\nbytes_in : bytes\n   Data in graph6 format, without a trailing newline.\n\nReturns\n-------\nG : Graph\n\nRaises\n------\nNetworkXError\n    If bytes_in is unable to be parsed in graph6 format\n\nValueError\n    If any character ``c`` in bytes_in does not satisfy\n    ``63 <= ord(c) < 127``.\n\nExamples\n--------\n>>> G = nx.from_graph6_bytes(b\"A_\")\n>>> sorted(G.edges())\n[(0, 1)]\n\nSee Also\n--------\nread_graph6, write_graph6\n\nReferences\n----------\n.. [1] Graph6 specification\n       <http://users.cecs.anu.edu.au/~bdm/data/formats.html>"}, {"type": "function", "name": "networkx.from_nested_tuple", "documentation": "Returns the rooted tree corresponding to the given nested tuple.\n\nThe nested tuple representation of a tree is defined\nrecursively. The tree with one node and no edges is represented by\nthe empty tuple, ``()``. A tree with ``k`` subtrees is represented\nby a tuple of length ``k`` in which each element is the nested tuple\nrepresentation of a subtree.\n\nParameters\n----------\nsequence : tuple\n    A nested tuple representing a rooted tree.\n\nsensible_relabeling : bool\n    Whether to relabel the nodes of the tree so that nodes are\n    labeled in increasing order according to their breadth-first\n    search order from the root node.\n\nReturns\n-------\nNetworkX graph\n    The tree corresponding to the given nested tuple, whose root\n    node is node 0. If ``sensible_labeling`` is ``True``, nodes will\n    be labeled in breadth-first search order starting from the root\n    node.\n\nNotes\n-----\nThis function is *not* the inverse of :func:`to_nested_tuple`; the\nonly guarantee is that the rooted trees are isomorphic.\n\nSee also\n--------\nto_nested_tuple\nfrom_prufer_sequence\n\nExamples\n--------\nSensible relabeling ensures that the nodes are labeled from the root\nstarting at 0::\n\n    >>> balanced = (((), ()), ((), ()))\n    >>> T = nx.from_nested_tuple(balanced, sensible_relabeling=True)\n    >>> edges = [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)]\n    >>> all((u, v) in T.edges() or (v, u) in T.edges() for (u, v) in edges)\n    True"}, {"type": "function", "name": "networkx.from_numpy_array", "documentation": "Returns a graph from a 2D NumPy array.\n\nThe 2D NumPy array is interpreted as an adjacency matrix for the graph.\n\nParameters\n----------\nA : a 2D numpy.ndarray\n    An adjacency matrix representation of a graph\n\nparallel_edges : Boolean\n    If this is True, `create_using` is a multigraph, and `A` is an\n    integer array, then entry *(i, j)* in the array is interpreted as the\n    number of parallel edges joining vertices *i* and *j* in the graph.\n    If it is False, then the entries in the array are interpreted as\n    the weight of a single edge joining the vertices.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nedge_attr : String, optional (default=\"weight\")\n    The attribute to which the array values are assigned on each edge. If\n    it is None, edge attributes will not be assigned.\n\nNotes\n-----\nFor directed graphs, explicitly mention create_using=nx.DiGraph,\nand entry i,j of A corresponds to an edge from i to j.\n\nIf `create_using` is :class:`networkx.MultiGraph` or\n:class:`networkx.MultiDiGraph`, `parallel_edges` is True, and the\nentries of `A` are of type :class:`int`, then this function returns a\nmultigraph (of the same type as `create_using`) with parallel edges.\n\nIf `create_using` indicates an undirected multigraph, then only the edges\nindicated by the upper triangle of the array `A` will be added to the\ngraph.\n\nIf `edge_attr` is Falsy (False or None), edge attributes will not be\nassigned, and the array data will be treated like a binary mask of\nedge presence or absence. Otherwise, the attributes will be assigned\nas follows:\n\nIf the NumPy array has a single data type for each array entry it\nwill be converted to an appropriate Python data type.\n\nIf the NumPy array has a user-specified compound data type the names\nof the data fields will be used as attribute keys in the resulting\nNetworkX graph.\n\nSee Also\n--------\nto_numpy_array\n\nExamples\n--------\nSimple integer weights on edges:\n\n>>> import numpy as np\n>>> A = np.array([[1, 1], [2, 1]])\n>>> G = nx.from_numpy_array(A)\n>>> G.edges(data=True)\nEdgeDataView([(0, 0, {'weight': 1}), (0, 1, {'weight': 2}), (1, 1, {'weight': 1})])\n\nIf `create_using` indicates a multigraph and the array has only integer\nentries and `parallel_edges` is False, then the entries will be treated\nas weights for edges joining the nodes (without creating parallel edges):\n\n>>> A = np.array([[1, 1], [1, 2]])\n>>> G = nx.from_numpy_array(A, create_using=nx.MultiGraph)\n>>> G[1][1]\nAtlasView({0: {'weight': 2}})\n\nIf `create_using` indicates a multigraph and the array has only integer\nentries and `parallel_edges` is True, then the entries will be treated\nas the number of parallel edges joining those two vertices:\n\n>>> A = np.array([[1, 1], [1, 2]])\n>>> temp = nx.MultiGraph()\n>>> G = nx.from_numpy_array(A, parallel_edges=True, create_using=temp)\n>>> G[1][1]\nAtlasView({0: {'weight': 1}, 1: {'weight': 1}})\n\nUser defined compound data type on edges:\n\n>>> dt = [(\"weight\", float), (\"cost\", int)]\n>>> A = np.array([[(1.0, 2)]], dtype=dt)\n>>> G = nx.from_numpy_array(A)\n>>> G.edges()\nEdgeView([(0, 0)])\n>>> G[0][0][\"cost\"]\n2\n>>> G[0][0][\"weight\"]\n1.0"}, {"type": "function", "name": "networkx.from_pandas_adjacency", "documentation": "Returns a graph from Pandas DataFrame.\n\nThe Pandas DataFrame is interpreted as an adjacency matrix for the graph.\n\nParameters\n----------\ndf : Pandas DataFrame\n  An adjacency matrix representation of a graph\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nNotes\n-----\nFor directed graphs, explicitly mention create_using=nx.DiGraph,\nand entry i,j of df corresponds to an edge from i to j.\n\nIf `df` has a single data type for each entry it will be converted to an\nappropriate Python data type.\n\nIf you have node attributes stored in a separate dataframe `df_nodes`,\nyou can load those attributes to the graph `G` using the following code:\n\n```\ndf_nodes = pd.DataFrame({\"node_id\": [1, 2, 3], \"attribute1\": [\"A\", \"B\", \"C\"]})\nG.add_nodes_from((n, dict(d)) for n, d in df_nodes.iterrows())\n```\n\nIf `df` has a user-specified compound data type the names\nof the data fields will be used as attribute keys in the resulting\nNetworkX graph.\n\nSee Also\n--------\nto_pandas_adjacency\n\nExamples\n--------\nSimple integer weights on edges:\n\n>>> import pandas as pd\n>>> pd.options.display.max_columns = 20\n>>> df = pd.DataFrame([[1, 1], [2, 1]])\n>>> df\n   0  1\n0  1  1\n1  2  1\n>>> G = nx.from_pandas_adjacency(df)\n>>> G.name = \"Graph from pandas adjacency matrix\"\n>>> print(G)\nGraph named 'Graph from pandas adjacency matrix' with 2 nodes and 3 edges"}, {"type": "function", "name": "networkx.from_pandas_edgelist", "documentation": "Returns a graph from Pandas DataFrame containing an edge list.\n\nThe Pandas DataFrame should contain at least two columns of node names and\nzero or more columns of edge attributes. Each row will be processed as one\nedge instance.\n\nNote: This function iterates over DataFrame.values, which is not\nguaranteed to retain the data type across columns in the row. This is only\na problem if your row is entirely numeric and a mix of ints and floats. In\nthat case, all values will be returned as floats. See the\nDataFrame.iterrows documentation for an example.\n\nParameters\n----------\ndf : Pandas DataFrame\n    An edge list representation of a graph\n\nsource : str or int\n    A valid column name (string or integer) for the source nodes (for the\n    directed case).\n\ntarget : str or int\n    A valid column name (string or integer) for the target nodes (for the\n    directed case).\n\nedge_attr : str or int, iterable, True, or None\n    A valid column name (str or int) or iterable of column names that are\n    used to retrieve items and add them to the graph as edge attributes.\n    If `True`, all of the remaining columns will be added.\n    If `None`, no edge attributes are added to the graph.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n\nedge_key : str or None, optional (default=None)\n    A valid column name for the edge keys (for a MultiGraph). The values in\n    this column are used for the edge keys when adding edges if create_using\n    is a multigraph.\n\nIf you have node attributes stored in a separate dataframe `df_nodes`,\nyou can load those attributes to the graph `G` using the following code:\n\n```\ndf_nodes = pd.DataFrame({\"node_id\": [1, 2, 3], \"attribute1\": [\"A\", \"B\", \"C\"]})\nG.add_nodes_from((n, dict(d)) for n, d in df_nodes.iterrows())\n```\n\nSee Also\n--------\nto_pandas_edgelist\n\nExamples\n--------\nSimple integer weights on edges:\n\n>>> import pandas as pd\n>>> pd.options.display.max_columns = 20\n>>> import numpy as np\n>>> rng = np.random.RandomState(seed=5)\n>>> ints = rng.randint(1, 11, size=(3, 2))\n>>> a = [\"A\", \"B\", \"C\"]\n>>> b = [\"D\", \"A\", \"E\"]\n>>> df = pd.DataFrame(ints, columns=[\"weight\", \"cost\"])\n>>> df[0] = a\n>>> df[\"b\"] = b\n>>> df[[\"weight\", \"cost\", 0, \"b\"]]\n   weight  cost  0  b\n0       4     7  A  D\n1       7     1  B  A\n2      10     9  C  E\n>>> G = nx.from_pandas_edgelist(df, 0, \"b\", [\"weight\", \"cost\"])\n>>> G[\"E\"][\"C\"][\"weight\"]\n10\n>>> G[\"E\"][\"C\"][\"cost\"]\n9\n>>> edges = pd.DataFrame(\n...     {\n...         \"source\": [0, 1, 2],\n...         \"target\": [2, 2, 3],\n...         \"weight\": [3, 4, 5],\n...         \"color\": [\"red\", \"blue\", \"blue\"],\n...     }\n... )\n>>> G = nx.from_pandas_edgelist(edges, edge_attr=True)\n>>> G[0][2][\"color\"]\n'red'\n\nBuild multigraph with custom keys:\n\n>>> edges = pd.DataFrame(\n...     {\n...         \"source\": [0, 1, 2, 0],\n...         \"target\": [2, 2, 3, 2],\n...         \"my_edge_key\": [\"A\", \"B\", \"C\", \"D\"],\n...         \"weight\": [3, 4, 5, 6],\n...         \"color\": [\"red\", \"blue\", \"blue\", \"blue\"],\n...     }\n... )\n>>> G = nx.from_pandas_edgelist(\n...     edges,\n...     edge_key=\"my_edge_key\",\n...     edge_attr=[\"weight\", \"color\"],\n...     create_using=nx.MultiGraph(),\n... )\n>>> G[0][2]\nAtlasView({'A': {'weight': 3, 'color': 'red'}, 'D': {'weight': 6, 'color': 'blue'}})"}, {"type": "function", "name": "networkx.from_prufer_sequence", "documentation": "Returns the tree corresponding to the given Pr\u00fcfer sequence.\n\nA *Pr\u00fcfer sequence* is a list of *n* - 2 numbers between 0 and\n*n* - 1, inclusive. The tree corresponding to a given Pr\u00fcfer\nsequence can be recovered by repeatedly joining a node in the\nsequence with a node with the smallest potential degree according to\nthe sequence.\n\nParameters\n----------\nsequence : list\n    A Pr\u00fcfer sequence, which is a list of *n* - 2 integers between\n    zero and *n* - 1, inclusive.\n\nReturns\n-------\nNetworkX graph\n    The tree corresponding to the given Pr\u00fcfer sequence.\n\nRaises\n------\nNetworkXError\n    If the Pr\u00fcfer sequence is not valid.\n\nNotes\n-----\nThere is a bijection from labeled trees to Pr\u00fcfer sequences. This\nfunction is the inverse of the :func:`from_prufer_sequence` function.\n\nSometimes Pr\u00fcfer sequences use nodes labeled from 1 to *n* instead\nof from 0 to *n* - 1. This function requires nodes to be labeled in\nthe latter form. You can use :func:`networkx.relabel_nodes` to\nrelabel the nodes of your tree to the appropriate format.\n\nThis implementation is from [1]_ and has a running time of\n$O(n)$.\n\nReferences\n----------\n.. [1] Wang, Xiaodong, Lei Wang, and Yingjie Wu.\n       \"An optimal algorithm for Prufer codes.\"\n       *Journal of Software Engineering and Applications* 2.02 (2009): 111.\n       <https://doi.org/10.4236/jsea.2009.22016>\n\nSee also\n--------\nfrom_nested_tuple\nto_prufer_sequence\n\nExamples\n--------\nThere is a bijection between Pr\u00fcfer sequences and labeled trees, so\nthis function is the inverse of the :func:`to_prufer_sequence`\nfunction:\n\n>>> edges = [(0, 3), (1, 3), (2, 3), (3, 4), (4, 5)]\n>>> tree = nx.Graph(edges)\n>>> sequence = nx.to_prufer_sequence(tree)\n>>> sequence\n[3, 3, 3, 4]\n>>> tree2 = nx.from_prufer_sequence(sequence)\n>>> list(tree2.edges()) == edges\nTrue"}, {"type": "function", "name": "networkx.from_scipy_sparse_array", "documentation": "Creates a new graph from an adjacency matrix given as a SciPy sparse\narray.\n\nParameters\n----------\nA: scipy.sparse array\n  An adjacency matrix representation of a graph\n\nparallel_edges : Boolean\n  If this is True, `create_using` is a multigraph, and `A` is an\n  integer matrix, then entry *(i, j)* in the matrix is interpreted as the\n  number of parallel edges joining vertices *i* and *j* in the graph.\n  If it is False, then the entries in the matrix are interpreted as\n  the weight of a single edge joining the vertices.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nedge_attribute: string\n   Name of edge attribute to store matrix numeric value. The data will\n   have the same type as the matrix entry (int, float, (real,imag)).\n\nNotes\n-----\nFor directed graphs, explicitly mention create_using=nx.DiGraph,\nand entry i,j of A corresponds to an edge from i to j.\n\nIf `create_using` is :class:`networkx.MultiGraph` or\n:class:`networkx.MultiDiGraph`, `parallel_edges` is True, and the\nentries of `A` are of type :class:`int`, then this function returns a\nmultigraph (constructed from `create_using`) with parallel edges.\nIn this case, `edge_attribute` will be ignored.\n\nIf `create_using` indicates an undirected multigraph, then only the edges\nindicated by the upper triangle of the matrix `A` will be added to the\ngraph.\n\nExamples\n--------\n>>> import scipy as sp\n>>> A = sp.sparse.eye(2, 2, 1)\n>>> G = nx.from_scipy_sparse_array(A)\n\nIf `create_using` indicates a multigraph and the matrix has only integer\nentries and `parallel_edges` is False, then the entries will be treated\nas weights for edges joining the nodes (without creating parallel edges):\n\n>>> A = sp.sparse.csr_array([[1, 1], [1, 2]])\n>>> G = nx.from_scipy_sparse_array(A, create_using=nx.MultiGraph)\n>>> G[1][1]\nAtlasView({0: {'weight': 2}})\n\nIf `create_using` indicates a multigraph and the matrix has only integer\nentries and `parallel_edges` is True, then the entries will be treated\nas the number of parallel edges joining those two vertices:\n\n>>> A = sp.sparse.csr_array([[1, 1], [1, 2]])\n>>> G = nx.from_scipy_sparse_array(A, parallel_edges=True, create_using=nx.MultiGraph)\n>>> G[1][1]\nAtlasView({0: {'weight': 1}, 1: {'weight': 1}})"}, {"type": "function", "name": "networkx.from_sparse6_bytes", "documentation": "Read an undirected graph in sparse6 format from string.\n\nParameters\n----------\nstring : string\n   Data in sparse6 format\n\nReturns\n-------\nG : Graph\n\nRaises\n------\nNetworkXError\n    If the string is unable to be parsed in sparse6 format\n\nExamples\n--------\n>>> G = nx.from_sparse6_bytes(b\":A_\")\n>>> sorted(G.edges())\n[(0, 1), (0, 1), (0, 1)]\n\nSee Also\n--------\nread_sparse6, write_sparse6\n\nReferences\n----------\n.. [1] Sparse6 specification\n       <https://users.cecs.anu.edu.au/~bdm/data/formats.html>"}, {"type": "function", "name": "networkx.frucht_graph", "documentation": "Returns the Frucht Graph.\n\nThe Frucht Graph is the smallest cubical graph whose\nautomorphism group consists only of the identity element [1]_.\nIt has 12 nodes and 18 edges and no nontrivial symmetries.\nIt is planar and Hamiltonian [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Frucht Graph with 12 nodes and 18 edges\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Frucht_graph\n.. [2] https://mathworld.wolfram.com/FruchtGraph.html"}, {"type": "function", "name": "networkx.fruchterman_reingold_layout", "documentation": "Position nodes using Fruchterman-Reingold force-directed algorithm.\n\nThe algorithm simulates a force-directed representation of the network\ntreating edges as springs holding nodes close, while treating nodes\nas repelling objects, sometimes called an anti-gravity force.\nSimulation continues until the positions are close to an equilibrium.\n\nThere are some hard-coded values: minimal distance between\nnodes (0.01) and \"temperature\" of 0.1 to ensure nodes don't fly away.\nDuring the simulation, `k` helps determine the distance between nodes,\nthough `scale` and `center` determine the size and place after\nrescaling occurs at the end of the simulation.\n\nFixing some nodes doesn't allow them to move in the simulation.\nIt also turns off the rescaling feature at the simulation's end.\nIn addition, setting `scale` to `None` turns off rescaling.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\nk : float (default=None)\n    Optimal distance between nodes.  If None the distance is set to\n    1/sqrt(n) where n is the number of nodes.  Increase this value\n    to move nodes farther apart.\n\npos : dict or None  optional (default=None)\n    Initial positions for nodes as a dictionary with node as keys\n    and values as a coordinate list or tuple.  If None, then use\n    random initial positions.\n\nfixed : list or None  optional (default=None)\n    Nodes to keep fixed at initial position.\n    Nodes not in ``G.nodes`` are ignored.\n    ValueError raised if `fixed` specified and `pos` not.\n\niterations : int  optional (default=50)\n    Maximum number of iterations taken\n\nthreshold: float optional (default = 1e-4)\n    Threshold for relative error in node position changes.\n    The iteration stops if the error is below this threshold.\n\nweight : string or None   optional (default='weight')\n    The edge attribute that holds the numerical value used for\n    the edge weight.  Larger means a stronger attractive force.\n    If None, then all edge weights are 1.\n\nscale : number or None (default: 1)\n    Scale factor for positions. Not used unless `fixed is None`.\n    If scale is None, no rescaling is performed.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n    Not used unless `fixed is None`.\n\ndim : int\n    Dimension of layout.\n\nseed : int, RandomState instance or None  optional (default=None)\n    Set the random state for deterministic node layouts.\n    If int, `seed` is the seed used by the random number generator,\n    if numpy.random.RandomState instance, `seed` is the random\n    number generator,\n    if None, the random number generator is the RandomState instance used\n    by numpy.random.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.spring_layout(G)\n\n# The same using longer but equivalent function name\n>>> pos = nx.fruchterman_reingold_layout(G)"}, {"type": "function", "name": "networkx.full_join", "documentation": "Returns the full join of graphs G and H.\n\nFull join is the union of G and H in which all edges between\nG and H are added.\nThe node sets of G and H must be disjoint,\notherwise an exception is raised.\n\nParameters\n----------\nG, H : graph\n   A NetworkX graph\n\nrename : tuple , default=(None, None)\n   Node names of G and H can be changed by specifying the tuple\n   rename=('G-','H-') (for example).  Node \"u\" in G is then renamed\n   \"G-u\" and \"v\" in H is renamed \"H-v\".\n\nReturns\n-------\nU : The full join graph with the same type as G.\n\nNotes\n-----\nIt is recommended that G and H be either both directed or both undirected.\n\nIf G is directed, then edges from G to H are added as well as from H to G.\n\nNote that full_join() does not produce parallel edges for MultiGraphs.\n\nThe full join operation of graphs G and H is the same as getting\ntheir complement, performing a disjoint union, and finally getting\nthe complement of the resulting graph.\n\nGraph, edge, and node attributes are propagated from G and H\nto the union graph.  If a graph attribute is present in both\nG and H the value from H is used.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2)])\n>>> H = nx.Graph([(3, 4)])\n>>> R = nx.full_join(G, H, rename=(\"G\", \"H\"))\n>>> R.nodes\nNodeView(('G0', 'G1', 'G2', 'H3', 'H4'))\n>>> R.edges\nEdgeView([('G0', 'G1'), ('G0', 'G2'), ('G0', 'H3'), ('G0', 'H4'), ('G1', 'H3'), ('G1', 'H4'), ('G2', 'H3'), ('G2', 'H4'), ('H3', 'H4')])\n\nSee Also\n--------\nunion\ndisjoint_union"}, {"type": "function", "name": "networkx.full_rary_tree", "documentation": "Creates a full r-ary tree of `n` nodes.\n\nSometimes called a k-ary, n-ary, or m-ary tree.\n\"... all non-leaf nodes have exactly r children and all levels\nare full except for some rightmost position of the bottom level\n(if a leaf at the bottom level is missing, then so are all of the\nleaves to its right.\" [1]_\n\n.. plot::\n\n    >>> nx.draw(nx.full_rary_tree(2, 10))\n\nParameters\n----------\nr : int\n    branching factor of the tree\nn : int\n    Number of nodes in the tree\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    An r-ary tree with n nodes\n\nReferences\n----------\n.. [1] An introduction to data structures and algorithms,\n       James Andrew Storer,  Birkhauser Boston 2001, (page 225)."}, {"type": "function", "name": "networkx.gaussian_random_partition_graph", "documentation": "Generate a Gaussian random partition graph.\n\nA Gaussian random partition graph is created by creating k partitions\neach with a size drawn from a normal distribution with mean s and variance\ns/v. Nodes are connected within clusters with probability p_in and\nbetween clusters with probability p_out[1]\n\nParameters\n----------\nn : int\n  Number of nodes in the graph\ns : float\n  Mean cluster size\nv : float\n  Shape parameter. The variance of cluster size distribution is s/v.\np_in : float\n  Probability of intra cluster connection.\np_out : float\n  Probability of inter cluster connection.\ndirected : boolean, optional default=False\n  Whether to create a directed graph or not\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : NetworkX Graph or DiGraph\n  gaussian random partition graph\n\nRaises\n------\nNetworkXError\n  If s is > n\n  If p_in or p_out is not in [0,1]\n\nNotes\n-----\nNote the number of partitions is dependent on s,v and n, and that the\nlast partition may be considerably smaller, as it is sized to simply\nfill out the nodes [1]\n\nSee Also\n--------\nrandom_partition_graph\n\nExamples\n--------\n>>> G = nx.gaussian_random_partition_graph(100, 10, 10, 0.25, 0.1)\n>>> len(G)\n100\n\nReferences\n----------\n.. [1] Ulrik Brandes, Marco Gaertler, Dorothea Wagner,\n   Experiments on Graph Clustering Algorithms,\n   In the proceedings of the 11th Europ. Symp. Algorithms, 2003."}, {"type": "function", "name": "networkx.general_random_intersection_graph", "documentation": "Returns a random intersection graph with independent probabilities\nfor connections between node and attribute sets.\n\nParameters\n----------\nn : int\n    The number of nodes in the first bipartite set (nodes)\nm : int\n    The number of nodes in the second bipartite set (attributes)\np : list of floats of length m\n    Probabilities for connecting nodes to each attribute\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nSee Also\n--------\ngnp_random_graph, uniform_random_intersection_graph\n\nReferences\n----------\n.. [1] Nikoletseas, S. E., Raptopoulos, C., and Spirakis, P. G.\n   The existence and efficient construction of large independent sets\n   in general random intersection graphs. In ICALP (2004), J. D\u00b4\u0131az,\n   J. Karhum\u00a8aki, A. Lepist\u00a8o, and D. Sannella, Eds., vol. 3142\n   of Lecture Notes in Computer Science, Springer, pp. 1029\u20131040."}, {"type": "function", "name": "networkx.generalized_degree", "documentation": "Compute the generalized degree for nodes.\n\nFor each node, the generalized degree shows how many edges of given\ntriangle multiplicity the node is connected to. The triangle multiplicity\nof an edge is the number of triangles an edge participates in. The\ngeneralized degree of node :math:`i` can be written as a vector\n:math:`\\mathbf{k}_i=(k_i^{(0)}, \\dotsc, k_i^{(N-2)})` where\n:math:`k_i^{(j)}` is the number of edges attached to node :math:`i` that\nparticipate in :math:`j` triangles.\n\nParameters\n----------\nG : graph\n\nnodes : container of nodes, optional (default=all nodes in G)\n   Compute the generalized degree for nodes in this container.\n\nReturns\n-------\nout : Counter, or dictionary of Counters\n   Generalized degree of specified nodes. The Counter is keyed by edge\n   triangle multiplicity.\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> print(nx.generalized_degree(G, 0))\nCounter({3: 4})\n>>> print(nx.generalized_degree(G))\n{0: Counter({3: 4}), 1: Counter({3: 4}), 2: Counter({3: 4}), 3: Counter({3: 4}), 4: Counter({3: 4})}\n\nTo recover the number of triangles attached to a node:\n\n>>> k1 = nx.generalized_degree(G, 0)\n>>> sum([k * v for k, v in k1.items()]) / 2 == nx.triangles(G, 0)\nTrue\n\nNotes\n-----\nSelf loops are ignored.\n\nIn a network of N nodes, the highest triangle multiplicity an edge can have\nis N-2.\n\nThe return value does not include a `zero` entry if no edges of a\nparticular triangle multiplicity are present.\n\nThe number of triangles node :math:`i` is attached to can be recovered from\nthe generalized degree :math:`\\mathbf{k}_i=(k_i^{(0)}, \\dotsc,\nk_i^{(N-2)})` by :math:`(k_i^{(1)}+2k_i^{(2)}+\\dotsc +(N-2)k_i^{(N-2)})/2`.\n\nReferences\n----------\n.. [1] Networks with arbitrary edge multiplicities by V. Zlati\u0107,\n    D. Garlaschelli and G. Caldarelli, EPL (Europhysics Letters),\n    Volume 97, Number 2 (2012).\n    https://iopscience.iop.org/article/10.1209/0295-5075/97/28005"}, {"type": "function", "name": "networkx.generate_adjlist", "documentation": "Generate a single line of the graph G in adjacency list format.\n\nParameters\n----------\nG : NetworkX graph\n\ndelimiter : string, optional\n   Separator for node labels\n\nReturns\n-------\nlines : string\n    Lines of data in adjlist format.\n\nExamples\n--------\n>>> G = nx.lollipop_graph(4, 3)\n>>> for line in nx.generate_adjlist(G):\n...     print(line)\n0 1 2 3\n1 2 3\n2 3\n3 4\n4 5\n5 6\n6\n\nSee Also\n--------\nwrite_adjlist, read_adjlist\n\nNotes\n-----\nThe default `delimiter=\" \"` will result in unexpected results if node names contain\nwhitespace characters. To avoid this problem, specify an alternate delimiter when spaces are\nvalid in node names.\n\nNB: This option is not available for data that isn't user-generated."}, {"type": "function", "name": "networkx.generate_edgelist", "documentation": "Generate a single line of the graph G in edge list format.\n\nParameters\n----------\nG : NetworkX graph\n\ndelimiter : string, optional\n   Separator for node labels\n\ndata : bool or list of keys\n   If False generate no edge data.  If True use a dictionary\n   representation of edge data.  If a list of keys use a list of data\n   values corresponding to the keys.\n\nReturns\n-------\nlines : string\n    Lines of data in adjlist format.\n\nExamples\n--------\n>>> G = nx.lollipop_graph(4, 3)\n>>> G[1][2][\"weight\"] = 3\n>>> G[3][4][\"capacity\"] = 12\n>>> for line in nx.generate_edgelist(G, data=False):\n...     print(line)\n0 1\n0 2\n0 3\n1 2\n1 3\n2 3\n3 4\n4 5\n5 6\n\n>>> for line in nx.generate_edgelist(G):\n...     print(line)\n0 1 {}\n0 2 {}\n0 3 {}\n1 2 {'weight': 3}\n1 3 {}\n2 3 {}\n3 4 {'capacity': 12}\n4 5 {}\n5 6 {}\n\n>>> for line in nx.generate_edgelist(G, data=[\"weight\"]):\n...     print(line)\n0 1\n0 2\n0 3\n1 2 3\n1 3\n2 3\n3 4\n4 5\n5 6\n\nSee Also\n--------\nwrite_adjlist, read_adjlist"}, {"type": "function", "name": "networkx.generate_gexf", "documentation": "Generate lines of GEXF format representation of G.\n\n\"GEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics\" [1]_.\n\nParameters\n----------\nG : graph\nA NetworkX graph\nencoding : string (optional, default: 'utf-8')\nEncoding for text data.\nprettyprint : bool (optional, default: True)\nIf True use line breaks and indenting in output XML.\nversion : string (default: 1.2draft)\nVersion of GEFX File Format (see http://gexf.net/schema.html)\nSupported values: \"1.1draft\", \"1.2draft\"\n\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> linefeed = chr(10)  # linefeed=\n\n>>> s = linefeed.join(nx.generate_gexf(G))\n>>> for line in nx.generate_gexf(G):  # doctest: +SKIP\n...     print(line)\n\nNotes\n-----\nThis implementation does not support mixed graphs (directed and undirected\nedges together).\n\nThe node id attribute is set to be the string of the node label.\nIf you want to specify an id use set it as node data, e.g.\nnode['a']['id']=1 to set the id of node 'a' to 1.\n\nReferences\n----------\n.. [1] GEXF File Format, https://gephi.org/gexf/format/"}, {"type": "function", "name": "networkx.generate_gml", "documentation": "Generate a single entry of the graph `G` in GML format.\n\nParameters\n----------\nG : NetworkX graph\n    The graph to be converted to GML.\n\nstringizer : callable, optional\n    A `stringizer` which converts non-int/non-float/non-dict values into\n    strings. If it cannot convert a value into a string, it should raise a\n    `ValueError` to indicate that. Default value: None.\n\nReturns\n-------\nlines: generator of strings\n    Lines of GML data. Newlines are not appended.\n\nRaises\n------\nNetworkXError\n    If `stringizer` cannot convert a value into a string, or the value to\n    convert is not a string while `stringizer` is None.\n\nSee Also\n--------\nliteral_stringizer\n\nNotes\n-----\nGraph attributes named 'directed', 'multigraph', 'node' or\n'edge', node attributes named 'id' or 'label', edge attributes\nnamed 'source' or 'target' (or 'key' if `G` is a multigraph)\nare ignored because these attribute names are used to encode the graph\nstructure.\n\nGML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a `stringizer`/`destringizer`, the code is capable of\nwriting `int`/`float`/`str`/`dict`/`list` data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan `str` you need to explicitly supply a `stringizer`/`destringizer`.\n\nFor additional documentation on the GML file format, please see the\n`GML url <https://web.archive.org/web/20190207140002/http://www.fim.uni-passau.de/index.php?id=17297&L=1>`_.\n\nSee the module docstring :mod:`networkx.readwrite.gml` for more details.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_node(\"1\")\n>>> print(\"\\n\".join(nx.generate_gml(G)))\ngraph [\n  node [\n    id 0\n    label \"1\"\n  ]\n]\n>>> G = nx.MultiGraph([(\"a\", \"b\"), (\"a\", \"b\")])\n>>> print(\"\\n\".join(nx.generate_gml(G)))\ngraph [\n  multigraph 1\n  node [\n    id 0\n    label \"a\"\n  ]\n  node [\n    id 1\n    label \"b\"\n  ]\n  edge [\n    source 0\n    target 1\n    key 0\n  ]\n  edge [\n    source 0\n    target 1\n    key 1\n  ]\n]"}, {"type": "function", "name": "networkx.generate_graphml", "documentation": "Generate GraphML lines for G\n\nParameters\n----------\nG : graph\n   A networkx graph\nencoding : string (optional)\n   Encoding for text data.\nprettyprint : bool (optional)\n   If True use line breaks and indenting in output XML.\nnamed_key_ids : bool (optional)\n   If True use attr.name as value for key elements' id attribute.\nedge_id_from_attribute : dict key (optional)\n    If provided, the graphml edge id is set by looking up the corresponding\n    edge data attribute keyed by this parameter. If `None` or the key does not exist in edge data,\n    the edge id is set by the edge key if `G` is a MultiGraph, else the edge id is left unset.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> linefeed = chr(10)  # linefeed = \n\n>>> s = linefeed.join(nx.generate_graphml(G))\n>>> for line in nx.generate_graphml(G):  # doctest: +SKIP\n...     print(line)\n\nNotes\n-----\nThis implementation does not support mixed graphs (directed and unidirected\nedges together) hyperedges, nested graphs, or ports."}, {"type": "function", "name": "networkx.generate_multiline_adjlist", "documentation": "Generate a single line of the graph G in multiline adjacency list format.\n\nParameters\n----------\nG : NetworkX graph\n\ndelimiter : string, optional\n   Separator for node labels\n\nReturns\n-------\nlines : string\n    Lines of data in multiline adjlist format.\n\nExamples\n--------\n>>> G = nx.lollipop_graph(4, 3)\n>>> for line in nx.generate_multiline_adjlist(G):\n...     print(line)\n0 3\n1 {}\n2 {}\n3 {}\n1 2\n2 {}\n3 {}\n2 1\n3 {}\n3 1\n4 {}\n4 1\n5 {}\n5 1\n6 {}\n6 0\n\nSee Also\n--------\nwrite_multiline_adjlist, read_multiline_adjlist"}, {"type": "function", "name": "networkx.generate_network_text", "documentation": "Generate lines in the \"network text\" format\n\nThis works via a depth-first traversal of the graph and writing a line for\neach unique node encountered. Non-tree edges are written to the right of\neach node, and connection to a non-tree edge is indicated with an ellipsis.\nThis representation works best when the input graph is a forest, but any\ngraph can be represented.\n\nThis notation is original to networkx, although it is simple enough that it\nmay be known in existing literature. See #5602 for details. The procedure\nis summarized as follows:\n\n1. Given a set of source nodes (which can be specified, or automatically\ndiscovered via finding the (strongly) connected components and choosing one\nnode with minimum degree from each), we traverse the graph in depth first\norder.\n\n2. Each reachable node will be printed exactly once on it's own line.\n\n3. Edges are indicated in one of four ways:\n\n    a. a parent \"L-style\" connection on the upper left. This corresponds to\n    a traversal in the directed DFS tree.\n\n    b. a backref \"<-style\" connection shown directly on the right. For\n    directed graphs, these are drawn for any incoming edges to a node that\n    is not a parent edge. For undirected graphs, these are drawn for only\n    the non-parent edges that have already been represented (The edges that\n    have not been represented will be handled in the recursive case).\n\n    c. a child \"L-style\" connection on the lower right. Drawing of the\n    children are handled recursively.\n\n    d. if ``vertical_chains`` is true, and a parent node only has one child\n    a \"vertical-style\" edge is drawn between them.\n\n4. The children of each node (wrt the directed DFS tree) are drawn\nunderneath and to the right of it. In the case that a child node has already\nbeen drawn the connection is replaced with an ellipsis (\"...\") to indicate\nthat there is one or more connections represented elsewhere.\n\n5. If a maximum depth is specified, an edge to nodes past this maximum\ndepth will be represented by an ellipsis.\n\n6. If a a node has a truthy \"collapse\" value, then we do not traverse past\nthat node.\n\nParameters\n----------\ngraph : nx.DiGraph | nx.Graph\n    Graph to represent\n\nwith_labels : bool | str\n    If True will use the \"label\" attribute of a node to display if it\n    exists otherwise it will use the node value itself. If given as a\n    string, then that attribute name will be used instead of \"label\".\n    Defaults to True.\n\nsources : List\n    Specifies which nodes to start traversal from. Note: nodes that are not\n    reachable from one of these sources may not be shown. If unspecified,\n    the minimal set of nodes needed to reach all others will be used.\n\nmax_depth : int | None\n    The maximum depth to traverse before stopping. Defaults to None.\n\nascii_only : Boolean\n    If True only ASCII characters are used to construct the visualization\n\nvertical_chains : Boolean\n    If True, chains of nodes will be drawn vertically when possible.\n\nYields\n------\nstr : a line of generated text\n\nExamples\n--------\n>>> graph = nx.path_graph(10)\n>>> graph.add_node(\"A\")\n>>> graph.add_node(\"B\")\n>>> graph.add_node(\"C\")\n>>> graph.add_node(\"D\")\n>>> graph.add_edge(9, \"A\")\n>>> graph.add_edge(9, \"B\")\n>>> graph.add_edge(9, \"C\")\n>>> graph.add_edge(\"C\", \"D\")\n>>> graph.add_edge(\"C\", \"E\")\n>>> graph.add_edge(\"C\", \"F\")\n>>> nx.write_network_text(graph)\n\u2559\u2500\u2500 0\n    \u2514\u2500\u2500 1\n        \u2514\u2500\u2500 2\n            \u2514\u2500\u2500 3\n                \u2514\u2500\u2500 4\n                    \u2514\u2500\u2500 5\n                        \u2514\u2500\u2500 6\n                            \u2514\u2500\u2500 7\n                                \u2514\u2500\u2500 8\n                                    \u2514\u2500\u2500 9\n                                        \u251c\u2500\u2500 A\n                                        \u251c\u2500\u2500 B\n                                        \u2514\u2500\u2500 C\n                                            \u251c\u2500\u2500 D\n                                            \u251c\u2500\u2500 E\n                                            \u2514\u2500\u2500 F\n>>> nx.write_network_text(graph, vertical_chains=True)\n\u2559\u2500\u2500 0\n    \u2502\n    1\n    \u2502\n    2\n    \u2502\n    3\n    \u2502\n    4\n    \u2502\n    5\n    \u2502\n    6\n    \u2502\n    7\n    \u2502\n    8\n    \u2502\n    9\n    \u251c\u2500\u2500 A\n    \u251c\u2500\u2500 B\n    \u2514\u2500\u2500 C\n        \u251c\u2500\u2500 D\n        \u251c\u2500\u2500 E\n        \u2514\u2500\u2500 F"}, {"type": "function", "name": "networkx.generate_pajek", "documentation": "Generate lines in Pajek graph format.\n\nParameters\n----------\nG : graph\n   A Networkx graph\n\nReferences\n----------\nSee http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm\nfor format information."}, {"type": "function", "name": "networkx.generate_random_paths", "documentation": "Randomly generate `sample_size` paths of length `path_length`.\n\nParameters\n----------\nG : NetworkX graph\n    A NetworkX graph\nsample_size : integer\n    The number of paths to generate. This is ``R`` in [1]_.\npath_length : integer (default = 5)\n    The maximum size of the path to randomly generate.\n    This is ``T`` in [1]_. According to the paper, ``T >= 5`` is\n    recommended.\nindex_map : dictionary, optional\n    If provided, this will be populated with the inverted\n    index of nodes mapped to the set of generated random path\n    indices within ``paths``.\nweight : string or None, optional (default=\"weight\")\n    The name of an edge attribute that holds the numerical value\n    used as a weight. If None then each edge has weight 1.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\npaths : generator of lists\n    Generator of `sample_size` paths each with length `path_length`.\n\nExamples\n--------\nNote that the return value is the list of paths:\n\n>>> G = nx.star_graph(3)\n>>> random_path = nx.generate_random_paths(G, 2)\n\nBy passing a dictionary into `index_map`, it will build an\ninverted index mapping of nodes to the paths in which that node is present:\n\n>>> G = nx.star_graph(3)\n>>> index_map = {}\n>>> random_path = nx.generate_random_paths(G, 3, index_map=index_map)\n>>> paths_containing_node_0 = [\n...     random_path[path_idx] for path_idx in index_map.get(0, [])\n... ]\n\nReferences\n----------\n.. [1] Zhang, J., Tang, J., Ma, C., Tong, H., Jing, Y., & Li, J.\n       Panther: Fast top-k similarity search on large networks.\n       In Proceedings of the ACM SIGKDD International Conference\n       on Knowledge Discovery and Data Mining (Vol. 2015-August, pp. 1445\u20131454).\n       Association for Computing Machinery. https://doi.org/10.1145/2783258.2783267."}, {"type": "function", "name": "networkx.generic_bfs_edges", "documentation": "Iterate over edges in a breadth-first search.\n\nThe breadth-first search begins at `source` and enqueues the\nneighbors of newly visited nodes specified by the `neighbors`\nfunction.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n    Starting node for the breadth-first search; this function\n    iterates over only those edges in the component reachable from\n    this node.\n\nneighbors : function\n    A function that takes a newly visited node of the graph as input\n    and returns an *iterator* (not just a list) of nodes that are\n    neighbors of that node with custom ordering. If not specified, this is\n    just the ``G.neighbors`` method, but in general it can be any function\n    that returns an iterator over some or all of the neighbors of a\n    given node, in any order.\n\ndepth_limit : int, optional(default=len(G))\n    Specify the maximum search depth.\n\nsort_neighbors : Callable (default=None)\n\n    .. deprecated:: 3.2\n\n       The sort_neighbors parameter is deprecated and will be removed in\n       version 3.4. A custom (e.g. sorted) ordering of neighbors can be\n       specified with the `neighbors` parameter.\n\n    A function that takes an iterator over nodes as the input, and\n    returns an iterable of the same nodes with a custom ordering.\n    For example, `sorted` will sort the nodes in increasing order.\n\nYields\n------\nedge\n    Edges in the breadth-first search starting from `source`.\n\nExamples\n--------\n>>> G = nx.path_graph(7)\n>>> list(nx.generic_bfs_edges(G, source=0))\n[(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]\n>>> list(nx.generic_bfs_edges(G, source=2))\n[(2, 1), (2, 3), (1, 0), (3, 4), (4, 5), (5, 6)]\n>>> list(nx.generic_bfs_edges(G, source=2, depth_limit=2))\n[(2, 1), (2, 3), (1, 0), (3, 4)]\n\nThe `neighbors` param can be used to specify the visitation order of each\nnode's neighbors generically. In the following example, we modify the default\nneighbor to return *odd* nodes first:\n\n>>> def odd_first(n):\n...     return sorted(G.neighbors(n), key=lambda x: x % 2, reverse=True)\n\n>>> G = nx.star_graph(5)\n>>> list(nx.generic_bfs_edges(G, source=0))  # Default neighbor ordering\n[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]\n>>> list(nx.generic_bfs_edges(G, source=0, neighbors=odd_first))\n[(0, 1), (0, 3), (0, 5), (0, 2), (0, 4)]\n\nNotes\n-----\nThis implementation is from `PADS`_, which was in the public domain\nwhen it was first accessed in July, 2004.  The modifications\nto allow depth limits are based on the Wikipedia article\n\"`Depth-limited-search`_\".\n\n.. _PADS: http://www.ics.uci.edu/~eppstein/PADS/BFS.py\n.. _Depth-limited-search: https://en.wikipedia.org/wiki/Depth-limited_search"}, {"type": "function", "name": "networkx.geographical_threshold_graph", "documentation": "Returns a geographical threshold graph.\n\nThe geographical threshold graph model places $n$ nodes uniformly at\nrandom in a rectangular domain.  Each node $u$ is assigned a weight\n$w_u$. Two nodes $u$ and $v$ are joined by an edge if\n\n.. math::\n\n   (w_u + w_v)p_{dist}(r) \\ge \\theta\n\nwhere `r` is the distance between `u` and `v`, `p_dist` is any function of\n`r`, and :math:`\\theta` as the threshold parameter. `p_dist` is used to\ngive weight to the distance between nodes when deciding whether or not\nthey should be connected. The larger `p_dist` is, the more prone nodes\nseparated by `r` are to be connected, and vice versa.\n\nParameters\n----------\nn : int or iterable\n    Number of nodes or iterable of nodes\ntheta: float\n    Threshold value\ndim : int, optional\n    Dimension of graph\npos : dict\n    Node positions as a dictionary of tuples keyed by node.\nweight : dict\n    Node weights as a dictionary of numbers keyed by node.\nmetric : function\n    A metric on vectors of numbers (represented as lists or\n    tuples). This must be a function that accepts two lists (or\n    tuples) as input and yields a number as output. The function\n    must also satisfy the four requirements of a `metric`_.\n    Specifically, if $d$ is the function and $x$, $y$,\n    and $z$ are vectors in the graph, then $d$ must satisfy\n\n    1. $d(x, y) \\ge 0$,\n    2. $d(x, y) = 0$ if and only if $x = y$,\n    3. $d(x, y) = d(y, x)$,\n    4. $d(x, z) \\le d(x, y) + d(y, z)$.\n\n    If this argument is not specified, the Euclidean distance metric is\n    used.\n\n    .. _metric: https://en.wikipedia.org/wiki/Metric_%28mathematics%29\np_dist : function, optional\n    Any function used to give weight to the distance between nodes when\n    deciding whether or not they should be connected. `p_dist` was\n    originally conceived as a probability density function giving the\n    probability of connecting two nodes that are of metric distance `r`\n    apart. The implementation here allows for more arbitrary definitions\n    of `p_dist` that do not need to correspond to valid probability\n    density functions. The :mod:`scipy.stats` package has many\n    probability density functions implemented and tools for custom\n    probability density definitions, and passing the ``.pdf`` method of\n    scipy.stats distributions can be used here. If ``p_dist=None``\n    (the default), the exponential function :math:`r^{-2}` is used.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\npos_name : string, default=\"pos\"\n    The name of the node attribute which represents the position\n    in 2D coordinates of the node in the returned graph.\nweight_name : string, default=\"weight\"\n    The name of the node attribute which represents the weight\n    of the node in the returned graph.\n\nReturns\n-------\nGraph\n    A random geographic threshold graph, undirected and without\n    self-loops.\n\n    Each node has a node attribute ``pos`` that stores the\n    position of that node in Euclidean space as provided by the\n    ``pos`` keyword argument or, if ``pos`` was not provided, as\n    generated by this function. Similarly, each node has a node\n    attribute ``weight`` that stores the weight of that node as\n    provided or as generated.\n\nExamples\n--------\nSpecify an alternate distance metric using the ``metric`` keyword\nargument. For example, to use the `taxicab metric`_ instead of the\ndefault `Euclidean metric`_::\n\n    >>> dist = lambda x, y: sum(abs(a - b) for a, b in zip(x, y))\n    >>> G = nx.geographical_threshold_graph(10, 0.1, metric=dist)\n\n.. _taxicab metric: https://en.wikipedia.org/wiki/Taxicab_geometry\n.. _Euclidean metric: https://en.wikipedia.org/wiki/Euclidean_distance\n\nNotes\n-----\nIf weights are not specified they are assigned to nodes by drawing randomly\nfrom the exponential distribution with rate parameter $\\lambda=1$.\nTo specify weights from a different distribution, use the `weight` keyword\nargument::\n\n>>> import random\n>>> n = 20\n>>> w = {i: random.expovariate(5.0) for i in range(n)}\n>>> G = nx.geographical_threshold_graph(20, 50, weight=w)\n\nIf node positions are not specified they are randomly assigned from the\nuniform distribution.\n\nReferences\n----------\n.. [1] Masuda, N., Miwa, H., Konno, N.:\n   Geographical threshold graphs with small-world and scale-free\n   properties.\n   Physical Review E 71, 036108 (2005)\n.. [2]  Milan Bradonji\u0107, Aric Hagberg and Allon G. Percus,\n   Giant component and connectivity in geographical threshold graphs,\n   in Algorithms and Models for the Web-Graph (WAW 2007),\n   Antony Bonato and Fan Chung (Eds), pp. 209--216, 2007"}, {"type": "function", "name": "networkx.geometric_edges", "documentation": "Returns edge list of node pairs within `radius` of each other.\n\nParameters\n----------\nG : networkx graph\n    The graph from which to generate the edge list. The nodes in `G` should\n    have an attribute ``pos`` corresponding to the node position, which is\n    used to compute the distance to other nodes.\nradius : scalar\n    The distance threshold. Edges are included in the edge list if the\n    distance between the two nodes is less than `radius`.\npos_name : string, default=\"pos\"\n    The name of the node attribute which represents the position of each\n    node in 2D coordinates. Every node in the Graph must have this attribute.\np : scalar, default=2\n    The `Minkowski distance metric\n    <https://en.wikipedia.org/wiki/Minkowski_distance>`_ used to compute\n    distances. The default value is 2, i.e. Euclidean distance.\n\nReturns\n-------\nedges : list\n    List of edges whose distances are less than `radius`\n\nNotes\n-----\nRadius uses Minkowski distance metric `p`.\nIf scipy is available, `scipy.spatial.cKDTree` is used to speed computation.\n\nExamples\n--------\nCreate a graph with nodes that have a \"pos\" attribute representing 2D\ncoordinates.\n\n>>> G = nx.Graph()\n>>> G.add_nodes_from(\n...     [\n...         (0, {\"pos\": (0, 0)}),\n...         (1, {\"pos\": (3, 0)}),\n...         (2, {\"pos\": (8, 0)}),\n...     ]\n... )\n>>> nx.geometric_edges(G, radius=1)\n[]\n>>> nx.geometric_edges(G, radius=4)\n[(0, 1)]\n>>> nx.geometric_edges(G, radius=6)\n[(0, 1), (1, 2)]\n>>> nx.geometric_edges(G, radius=9)\n[(0, 1), (0, 2), (1, 2)]"}, {"type": "function", "name": "networkx.geometric_soft_configuration_graph", "documentation": "Returns a random graph from the geometric soft configuration model.\n\nThe $\\mathbb{S}^1$ model [1]_ is the geometric soft configuration model\nwhich is able to explain many fundamental features of real networks such as\nsmall-world property, heteregenous degree distributions, high level of\nclustering, and self-similarity.\n\nIn the geometric soft configuration model, a node $i$ is assigned two hidden\nvariables: a hidden degree $\\kappa_i$, quantifying its popularity, influence,\nor importance, and an angular position $\\theta_i$ in a circle abstracting the\nsimilarity space, where angular distances between nodes are a proxy for their\nsimilarity. Focusing on the angular position, this model is often called\nthe $\\mathbb{S}^1$ model (a one-dimensional sphere). The circle's radius is\nadjusted to $R = N/2\\pi$, where $N$ is the number of nodes, so that the density\nis set to 1 without loss of generality.\n\nThe connection probability between any pair of nodes increases with\nthe product of their hidden degrees (i.e., their combined popularities),\nand decreases with the angular distance between the two nodes.\nSpecifically, nodes $i$ and $j$ are connected with the probability\n\n$p_{ij} = \\frac{1}{1 + \\frac{d_{ij}^\\beta}{\\left(\\mu \\kappa_i \\kappa_j\\right)^{\\max(1, \\beta)}}}$\n\nwhere $d_{ij} = R\\Delta\\theta_{ij}$ is the arc length of the circle between\nnodes $i$ and $j$ separated by an angular distance $\\Delta\\theta_{ij}$.\nParameters $\\mu$ and $\\beta$ (also called inverse temperature) control the\naverage degree and the clustering coefficient, respectively.\n\nIt can be shown [2]_ that the model undergoes a structural phase transition\nat $\\beta=1$ so that for $\\beta<1$ networks are unclustered in the thermodynamic\nlimit (when $N\\to \\infty$) whereas for $\\beta>1$ the ensemble generates\nnetworks with finite clustering coefficient.\n\nThe $\\mathbb{S}^1$ model can be expressed as a purely geometric model\n$\\mathbb{H}^2$ in the hyperbolic plane [3]_ by mapping the hidden degree of\neach node into a radial coordinate as\n\n$r_i = \\hat{R} - \\frac{2 \\max(1, \\beta)}{\\beta \\zeta} \\ln \\left(\\frac{\\kappa_i}{\\kappa_0}\\right)$\n\nwhere $\\hat{R}$ is the radius of the hyperbolic disk and $\\zeta$ is the curvature,\n\n$\\hat{R} = \\frac{2}{\\zeta} \\ln \\left(\\frac{N}{\\pi}\\right)\n- \\frac{2\\max(1, \\beta)}{\\beta \\zeta} \\ln (\\mu \\kappa_0^2)$\n\nThe connection probability then reads\n\n$p_{ij} = \\frac{1}{1 + \\exp\\left({\\frac{\\beta\\zeta}{2} (x_{ij} - \\hat{R})}\\right)}$\n\nwhere\n\n$x_{ij} = r_i + r_j + \\frac{2}{\\zeta} \\ln \\frac{\\Delta\\theta_{ij}}{2}$\n\nis a good approximation of the hyperbolic distance between two nodes separated\nby an angular distance $\\Delta\\theta_{ij}$ with radial coordinates $r_i$ and $r_j$.\nFor $\\beta > 1$, the curvature $\\zeta = 1$, for $\\beta < 1$, $\\zeta = \\beta^{-1}$.\n\n\nParameters\n----------\nEither `n`, `gamma`, `mean_degree` are provided or `kappas`. The values of\n`n`, `gamma`, `mean_degree` (if provided) are used to construct a random\nkappa-dict keyed by node with values sampled from a power-law distribution.\n\nbeta : positive number\n    Inverse temperature, controlling the clustering coefficient.\nn : int (default: None)\n    Size of the network (number of nodes).\n    If not provided, `kappas` must be provided and holds the nodes.\ngamma : float (default: None)\n    Exponent of the power-law distribution for hidden degrees `kappas`.\n    If not provided, `kappas` must be provided directly.\nmean_degree : float (default: None)\n    The mean degree in the network.\n    If not provided, `kappas` must be provided directly.\nkappas : dict (default: None)\n    A dict keyed by node to its hidden degree value.\n    If not provided, random values are computed based on a power-law\n    distribution using `n`, `gamma` and `mean_degree`.\nseed : int, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nGraph\n    A random geometric soft configuration graph (undirected with no self-loops).\n    Each node has three node-attributes:\n\n    - ``kappa`` that represents the hidden degree.\n\n    - ``theta`` the position in the similarity space ($\\mathbb{S}^1$) which is\n      also the angular position in the hyperbolic plane.\n\n    - ``radius`` the radial position in the hyperbolic plane\n      (based on the hidden degree).\n\n\nExamples\n--------\nGenerate a network with specified parameters:\n\n>>> G = nx.geometric_soft_configuration_graph(beta=1.5, n=100, gamma=2.7, mean_degree=5)\n\nCreate a geometric soft configuration graph with 100 nodes. The $\\beta$ parameter\nis set to 1.5 and the exponent of the powerlaw distribution of the hidden\ndegrees is 2.7 with mean value of 5.\n\nGenerate a network with predefined hidden degrees:\n\n>>> kappas = {i: 10 for i in range(100)}\n>>> G = nx.geometric_soft_configuration_graph(beta=2.5, kappas=kappas)\n\nCreate a geometric soft configuration graph with 100 nodes. The $\\beta$ parameter\nis set to 2.5 and all nodes with hidden degree $\\kappa=10$.\n\n\nReferences\n----------\n.. [1] Serrano, M. \u00c1., Krioukov, D., & Bogu\u00f1\u00e1, M. (2008). Self-similarity\n   of complex networks and hidden metric spaces. Physical review letters, 100(7), 078701.\n\n.. [2] van der Kolk, J., Serrano, M. \u00c1., & Bogu\u00f1\u00e1, M. (2022). An anomalous\n   topological phase transition in spatial random graphs. Communications Physics, 5(1), 245.\n\n.. [3] Krioukov, D., Papadopoulos, F., Kitsak, M., Vahdat, A., & Bogun\u00e1, M. (2010).\n   Hyperbolic geometry of complex networks. Physical Review E, 82(3), 036106."}, {"type": "function", "name": "networkx.get_edge_attributes", "documentation": "Get edge attributes from graph\n\nParameters\n----------\nG : NetworkX Graph\n\nname : string\n   Attribute name\n\ndefault: object (default=None)\n   Default value of the edge attribute if there is no value set for that\n   edge in graph. If `None` then edges without this attribute are not\n   included in the returned dict.\n\nReturns\n-------\nDictionary of attributes keyed by edge. For (di)graphs, the keys are\n2-tuples of the form: (u, v). For multi(di)graphs, the keys are 3-tuples of\nthe form: (u, v, key).\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> nx.add_path(G, [1, 2, 3], color=\"red\")\n>>> color = nx.get_edge_attributes(G, \"color\")\n>>> color[(1, 2)]\n'red'\n>>> G.add_edge(3, 4)\n>>> color = nx.get_edge_attributes(G, \"color\", default=\"yellow\")\n>>> color[(3, 4)]\n'yellow'"}, {"type": "function", "name": "networkx.get_node_attributes", "documentation": "Get node attributes from graph\n\nParameters\n----------\nG : NetworkX Graph\n\nname : string\n   Attribute name\n\ndefault: object (default=None)\n   Default value of the node attribute if there is no value set for that\n   node in graph. If `None` then nodes without this attribute are not\n   included in the returned dict.\n\nReturns\n-------\nDictionary of attributes keyed by node.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_nodes_from([1, 2, 3], color=\"red\")\n>>> color = nx.get_node_attributes(G, \"color\")\n>>> color[1]\n'red'\n>>> G.add_node(4)\n>>> color = nx.get_node_attributes(G, \"color\", default=\"yellow\")\n>>> color[4]\n'yellow'"}, {"type": "function", "name": "networkx.girth", "documentation": "Returns the girth of the graph.\n\nThe girth of a graph is the length of its shortest cycle, or infinity if\nthe graph is acyclic. The algorithm follows the description given on the\nWikipedia page [1]_, and runs in time O(mn) on a graph with m edges and n\nnodes.\n\nParameters\n----------\nG : NetworkX Graph\n\nReturns\n-------\nint or math.inf\n\nExamples\n--------\nAll examples below (except P_5) can easily be checked using Wikipedia,\nwhich has a page for each of these famous graphs.\n\n>>> nx.girth(nx.chvatal_graph())\n4\n>>> nx.girth(nx.tutte_graph())\n4\n>>> nx.girth(nx.petersen_graph())\n5\n>>> nx.girth(nx.heawood_graph())\n6\n>>> nx.girth(nx.pappus_graph())\n6\n>>> nx.girth(nx.path_graph(5))\ninf\n\nReferences\n----------\n.. [1] `Wikipedia: Girth <https://en.wikipedia.org/wiki/Girth_(graph_theory)>`_"}, {"type": "function", "name": "networkx.global_efficiency", "documentation": "Returns the average global efficiency of the graph.\n\nThe *efficiency* of a pair of nodes in a graph is the multiplicative\ninverse of the shortest path distance between the nodes. The *average\nglobal efficiency* of a graph is the average efficiency of all pairs of\nnodes [1]_.\n\nParameters\n----------\nG : :class:`networkx.Graph`\n    An undirected graph for which to compute the average global efficiency.\n\nReturns\n-------\nfloat\n    The average global efficiency of the graph.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n>>> round(nx.global_efficiency(G), 12)\n0.916666666667\n\nNotes\n-----\nEdge weights are ignored when computing the shortest path distances.\n\nSee also\n--------\nlocal_efficiency\n\nReferences\n----------\n.. [1] Latora, Vito, and Massimo Marchiori.\n       \"Efficient behavior of small-world networks.\"\n       *Physical Review Letters* 87.19 (2001): 198701.\n       <https://doi.org/10.1103/PhysRevLett.87.198701>"}, {"type": "function", "name": "networkx.global_parameters", "documentation": "Returns global parameters for a given intersection array.\n\nGiven a distance-regular graph G with integers b_i, c_i,i = 0,....,d\nsuch that for any 2 vertices x,y in G at a distance i=d(x,y), there\nare exactly c_i neighbors of y at a distance of i-1 from x and b_i\nneighbors of y at a distance of i+1 from x.\n\nThus, a distance regular graph has the global parameters,\n[[c_0,a_0,b_0],[c_1,a_1,b_1],......,[c_d,a_d,b_d]] for the\nintersection array  [b_0,b_1,.....b_{d-1};c_1,c_2,.....c_d]\nwhere a_i+b_i+c_i=k , k= degree of every vertex.\n\nParameters\n----------\nb : list\n\nc : list\n\nReturns\n-------\niterable\n   An iterable over three tuples.\n\nExamples\n--------\n>>> G = nx.dodecahedral_graph()\n>>> b, c = nx.intersection_array(G)\n>>> list(nx.global_parameters(b, c))\n[(0, 0, 3), (1, 0, 2), (1, 1, 1), (1, 1, 1), (2, 0, 1), (3, 0, 0)]\n\nReferences\n----------\n.. [1] Weisstein, Eric W. \"Global Parameters.\"\n   From MathWorld--A Wolfram Web Resource.\n   http://mathworld.wolfram.com/GlobalParameters.html\n\nSee Also\n--------\nintersection_array"}, {"type": "function", "name": "networkx.global_reaching_centrality", "documentation": "Returns the global reaching centrality of a directed graph.\n\nThe *global reaching centrality* of a weighted directed graph is the\naverage over all nodes of the difference between the local reaching\ncentrality of the node and the greatest local reaching centrality of\nany node in the graph [1]_. For more information on the local\nreaching centrality, see :func:`local_reaching_centrality`.\nInformally, the local reaching centrality is the proportion of the\ngraph that is reachable from the neighbors of the node.\n\nParameters\n----------\nG : DiGraph\n    A networkx DiGraph.\n\nweight : None or string, optional (default=None)\n    Attribute to use for edge weights. If ``None``, each edge weight\n    is assumed to be one. A higher weight implies a stronger\n    connection between nodes and a *shorter* path length.\n\nnormalized : bool, optional (default=True)\n    Whether to normalize the edge weights by the total sum of edge\n    weights.\n\nReturns\n-------\nh : float\n    The global reaching centrality of the graph.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_edge(1, 2)\n>>> G.add_edge(1, 3)\n>>> nx.global_reaching_centrality(G)\n1.0\n>>> G.add_edge(3, 2)\n>>> nx.global_reaching_centrality(G)\n0.75\n\nSee also\n--------\nlocal_reaching_centrality\n\nReferences\n----------\n.. [1] Mones, Enys, Lilla Vicsek, and Tam\u00e1s Vicsek.\n       \"Hierarchy Measure for Complex Networks.\"\n       *PLoS ONE* 7.3 (2012): e33799.\n       https://doi.org/10.1371/journal.pone.0033799"}, {"type": "function", "name": "networkx.gn_graph", "documentation": "Returns the growing network (GN) digraph with `n` nodes.\n\nThe GN graph is built by adding nodes one at a time with a link to one\npreviously added node.  The target node for the link is chosen with\nprobability based on degree.  The default attachment kernel is a linear\nfunction of the degree of a node.\n\nThe graph is always a (directed) tree.\n\nParameters\n----------\nn : int\n    The number of nodes for the generated graph.\nkernel : function\n    The attachment kernel.\ncreate_using : NetworkX graph constructor, optional (default DiGraph)\n    Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nExamples\n--------\nTo create the undirected GN graph, use the :meth:`~DiGraph.to_directed`\nmethod::\n\n>>> D = nx.gn_graph(10)  # the GN graph\n>>> G = D.to_undirected()  # the undirected version\n\nTo specify an attachment kernel, use the `kernel` keyword argument::\n\n>>> D = nx.gn_graph(10, kernel=lambda x: x**1.5)  # A_k = k^1.5\n\nReferences\n----------\n.. [1] P. L. Krapivsky and S. Redner,\n       Organization of Growing Random Networks,\n       Phys. Rev. E, 63, 066123, 2001."}, {"type": "function", "name": "networkx.gnc_graph", "documentation": "Returns the growing network with copying (GNC) digraph with `n` nodes.\n\nThe GNC graph is built by adding nodes one at a time with a link to one\npreviously added node (chosen uniformly at random) and to all of that\nnode's successors.\n\nParameters\n----------\nn : int\n    The number of nodes for the generated graph.\ncreate_using : NetworkX graph constructor, optional (default DiGraph)\n    Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReferences\n----------\n.. [1] P. L. Krapivsky and S. Redner,\n       Network Growth by Copying,\n       Phys. Rev. E, 71, 036118, 2005k.},"}, {"type": "function", "name": "networkx.gnm_random_graph", "documentation": "Returns a $G_{n,m}$ random graph.\n\nIn the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\nof all graphs with $n$ nodes and $m$ edges.\n\nThis algorithm should be faster than :func:`dense_gnm_random_graph` for\nsparse graphs.\n\nParameters\n----------\nn : int\n    The number of nodes.\nm : int\n    The number of edges.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ndirected : bool, optional (default=False)\n    If True return a directed graph\n\nSee also\n--------\ndense_gnm_random_graph"}, {"type": "function", "name": "networkx.gnp_random_graph", "documentation": "Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph\nor a binomial graph.\n\nThe $G_{n,p}$ model chooses each of the possible edges with probability $p$.\n\nParameters\n----------\nn : int\n    The number of nodes.\np : float\n    Probability for edge creation.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ndirected : bool, optional (default=False)\n    If True, this function returns a directed graph.\n\nSee Also\n--------\nfast_gnp_random_graph\n\nNotes\n-----\nThis algorithm [2]_ runs in $O(n^2)$ time.  For sparse graphs (that is, for\nsmall values of $p$), :func:`fast_gnp_random_graph` is a faster algorithm.\n\n:func:`binomial_graph` and :func:`erdos_renyi_graph` are\naliases for :func:`gnp_random_graph`.\n\n>>> nx.binomial_graph is nx.gnp_random_graph\nTrue\n>>> nx.erdos_renyi_graph is nx.gnp_random_graph\nTrue\n\nReferences\n----------\n.. [1] P. Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).\n.. [2] E. N. Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959)."}, {"type": "function", "name": "networkx.gnr_graph", "documentation": "Returns the growing network with redirection (GNR) digraph with `n`\nnodes and redirection probability `p`.\n\nThe GNR graph is built by adding nodes one at a time with a link to one\npreviously added node.  The previous target node is chosen uniformly at\nrandom.  With probability `p` the link is instead \"redirected\" to the\nsuccessor node of the target.\n\nThe graph is always a (directed) tree.\n\nParameters\n----------\nn : int\n    The number of nodes for the generated graph.\np : float\n    The redirection probability.\ncreate_using : NetworkX graph constructor, optional (default DiGraph)\n    Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nExamples\n--------\nTo create the undirected GNR graph, use the :meth:`~DiGraph.to_directed`\nmethod::\n\n>>> D = nx.gnr_graph(10, 0.5)  # the GNR graph\n>>> G = D.to_undirected()  # the undirected version\n\nReferences\n----------\n.. [1] P. L. Krapivsky and S. Redner,\n       Organization of Growing Random Networks,\n       Phys. Rev. E, 63, 066123, 2001."}, {"type": "function", "name": "networkx.goldberg_radzik", "documentation": "Compute shortest path lengths and predecessors on shortest paths\nin weighted graphs.\n\nThe algorithm has a running time of $O(mn)$ where $n$ is the number of\nnodes and $m$ is the number of edges.  It is slower than Dijkstra but\ncan handle negative edge weights.\n\nParameters\n----------\nG : NetworkX graph\n    The algorithm works for all types of graphs, including directed\n    graphs and multigraphs.\n\nsource: node label\n    Starting node for path\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\nReturns\n-------\npred, dist : dictionaries\n    Returns two dictionaries keyed by node to predecessor in the\n    path and to the distance from the source respectively.\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nNetworkXUnbounded\n    If the (di)graph contains a negative (di)cycle, the\n    algorithm raises an exception to indicate the presence of the\n    negative (di)cycle.  Note: any negative weight edge in an\n    undirected graph is a negative cycle.\n\n    As of NetworkX v3.2, a zero weight cycle is no longer\n    incorrectly reported as a negative weight cycle.\n\n\nExamples\n--------\n>>> G = nx.path_graph(5, create_using=nx.DiGraph())\n>>> pred, dist = nx.goldberg_radzik(G, 0)\n>>> sorted(pred.items())\n[(0, None), (1, 0), (2, 1), (3, 2), (4, 3)]\n>>> sorted(dist.items())\n[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\n\n>>> G = nx.cycle_graph(5, create_using=nx.DiGraph())\n>>> G[1][2][\"weight\"] = -7\n>>> nx.goldberg_radzik(G, 0)\nTraceback (most recent call last):\n    ...\nnetworkx.exception.NetworkXUnbounded: Negative cycle detected.\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe dictionaries returned only have keys for nodes reachable from\nthe source.\n\nIn the case where the (di)graph is not connected, if a component\nnot containing the source contains a negative (di)cycle, it\nwill not be detected."}, {"type": "function", "name": "networkx.gomory_hu_tree", "documentation": "Returns the Gomory-Hu tree of an undirected graph G.\n\nA Gomory-Hu tree of an undirected graph with capacities is a\nweighted tree that represents the minimum s-t cuts for all s-t\npairs in the graph.\n\nIt only requires `n-1` minimum cut computations instead of the\nobvious `n(n-1)/2`. The tree represents all s-t cuts as the\nminimum cut value among any pair of nodes is the minimum edge\nweight in the shortest path between the two nodes in the\nGomory-Hu tree.\n\nThe Gomory-Hu tree also has the property that removing the\nedge with the minimum weight in the shortest path between\nany two nodes leaves two connected components that form\na partition of the nodes in G that defines the minimum s-t\ncut.\n\nSee Examples section below for details.\n\nParameters\n----------\nG : NetworkX graph\n    Undirected graph\n\ncapacity : string\n    Edges of the graph G are expected to have an attribute capacity\n    that indicates how much flow the edge can support. If this\n    attribute is not present, the edge is considered to have\n    infinite capacity. Default value: 'capacity'.\n\nflow_func : function\n    Function to perform the underlying flow computations. Default value\n    :func:`edmonds_karp`. This function performs better in sparse graphs\n    with right tailed degree distributions.\n    :func:`shortest_augmenting_path` will perform better in denser\n    graphs.\n\nReturns\n-------\nTree : NetworkX graph\n    A NetworkX graph representing the Gomory-Hu tree of the input graph.\n\nRaises\n------\nNetworkXNotImplemented\n    Raised if the input graph is directed.\n\nNetworkXError\n    Raised if the input graph is an empty Graph.\n\nExamples\n--------\n>>> G = nx.karate_club_graph()\n>>> nx.set_edge_attributes(G, 1, \"capacity\")\n>>> T = nx.gomory_hu_tree(G)\n>>> # The value of the minimum cut between any pair\n... # of nodes in G is the minimum edge weight in the\n... # shortest path between the two nodes in the\n... # Gomory-Hu tree.\n... def minimum_edge_weight_in_shortest_path(T, u, v):\n...     path = nx.shortest_path(T, u, v, weight=\"weight\")\n...     return min((T[u][v][\"weight\"], (u, v)) for (u, v) in zip(path, path[1:]))\n>>> u, v = 0, 33\n>>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\n>>> cut_value\n10\n>>> nx.minimum_cut_value(G, u, v)\n10\n>>> # The Gomory-Hu tree also has the property that removing the\n... # edge with the minimum weight in the shortest path between\n... # any two nodes leaves two connected components that form\n... # a partition of the nodes in G that defines the minimum s-t\n... # cut.\n... cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\n>>> T.remove_edge(*edge)\n>>> U, V = list(nx.connected_components(T))\n>>> # Thus U and V form a partition that defines a minimum cut\n... # between u and v in G. You can compute the edge cut set,\n... # that is, the set of edges that if removed from G will\n... # disconnect u from v in G, with this information:\n... cutset = set()\n>>> for x, nbrs in ((n, G[n]) for n in U):\n...     cutset.update((x, y) for y in nbrs if y in V)\n>>> # Because we have set the capacities of all edges to 1\n... # the cutset contains ten edges\n... len(cutset)\n10\n>>> # You can use any maximum flow algorithm for the underlying\n... # flow computations using the argument flow_func\n... from networkx.algorithms import flow\n>>> T = nx.gomory_hu_tree(G, flow_func=flow.boykov_kolmogorov)\n>>> cut_value, edge = minimum_edge_weight_in_shortest_path(T, u, v)\n>>> cut_value\n10\n>>> nx.minimum_cut_value(G, u, v, flow_func=flow.boykov_kolmogorov)\n10\n\nNotes\n-----\nThis implementation is based on Gusfield approach [1]_ to compute\nGomory-Hu trees, which does not require node contractions and has\nthe same computational complexity than the original method.\n\nSee also\n--------\n:func:`minimum_cut`\n:func:`maximum_flow`\n\nReferences\n----------\n.. [1] Gusfield D: Very simple methods for all pairs network flow analysis.\n       SIAM J Comput 19(1):143-155, 1990."}, {"type": "function", "name": "networkx.google_matrix", "documentation": "Returns the Google matrix of the graph.\n\nParameters\n----------\nG : graph\n  A NetworkX graph.  Undirected graphs will be converted to a directed\n  graph with two directed edges for each undirected edge.\n\nalpha : float\n  The damping factor.\n\npersonalization: dict, optional\n  The \"personalization vector\" consisting of a dictionary with a\n  key some subset of graph nodes and personalization value each of those.\n  At least one personalization value must be non-zero.\n  If not specified, a nodes personalization value will be zero.\n  By default, a uniform distribution is used.\n\nnodelist : list, optional\n  The rows and columns are ordered according to the nodes in nodelist.\n  If nodelist is None, then the ordering is produced by G.nodes().\n\nweight : key, optional\n  Edge data key to use as weight.  If None weights are set to 1.\n\ndangling: dict, optional\n  The outedges to be assigned to any \"dangling\" nodes, i.e., nodes without\n  any outedges. The dict key is the node the outedge points to and the dict\n  value is the weight of that outedge. By default, dangling nodes are given\n  outedges according to the personalization vector (uniform if not\n  specified) This must be selected to result in an irreducible transition\n  matrix (see notes below). It may be common to have the dangling dict to\n  be the same as the personalization dict.\n\nReturns\n-------\nA : 2D NumPy ndarray\n   Google matrix of the graph\n\nNotes\n-----\nThe array returned represents the transition matrix that describes the\nMarkov chain used in PageRank. For PageRank to converge to a unique\nsolution (i.e., a unique stationary distribution in a Markov chain), the\ntransition matrix must be irreducible. In other words, it must be that\nthere exists a path between every pair of nodes in the graph, or else there\nis the potential of \"rank sinks.\"\n\nThis implementation works with Multi(Di)Graphs. For multigraphs the\nweight between two nodes is set to be the sum of all edge weights\nbetween those nodes.\n\nSee Also\n--------\npagerank"}, {"type": "function", "name": "networkx.graph_atlas", "documentation": "Returns graph number `i` from the Graph Atlas.\n\nFor more information, see :func:`.graph_atlas_g`.\n\nParameters\n----------\ni : int\n    The index of the graph from the atlas to get. The graph at index\n    0 is assumed to be the null graph.\n\nReturns\n-------\nlist\n    A list of :class:`~networkx.Graph` objects, the one at index *i*\n    corresponding to the graph *i* in the Graph Atlas.\n\nSee also\n--------\ngraph_atlas_g\n\nNotes\n-----\nThe time required by this function increases linearly with the\nargument `i`, since it reads a large file sequentially in order to\ngenerate the graph [1]_.\n\nReferences\n----------\n.. [1] Ronald C. Read and Robin J. Wilson, *An Atlas of Graphs*.\n       Oxford University Press, 1998."}, {"type": "function", "name": "networkx.graph_atlas_g", "documentation": "Returns the list of all graphs with up to seven nodes named in the\nGraph Atlas.\n\nThe graphs are listed in increasing order by\n\n1. number of nodes,\n2. number of edges,\n3. degree sequence (for example 111223 < 112222),\n4. number of automorphisms,\n\nin that order, with three exceptions as described in the *Notes*\nsection below. This causes the list to correspond with the index of\nthe graphs in the Graph Atlas [atlas]_, with the first graph,\n``G[0]``, being the null graph.\n\nReturns\n-------\nlist\n    A list of :class:`~networkx.Graph` objects, the one at index *i*\n    corresponding to the graph *i* in the Graph Atlas.\n\nSee also\n--------\ngraph_atlas\n\nNotes\n-----\nThis function may be expensive in both time and space, since it\nreads a large file sequentially in order to populate the list.\n\nAlthough the NetworkX atlas functions match the order of graphs\ngiven in the \"Atlas of Graphs\" book, there are (at least) three\nerrors in the ordering described in the book. The following three\npairs of nodes violate the lexicographically nondecreasing sorted\ndegree sequence rule:\n\n- graphs 55 and 56 with degree sequences 001111 and 000112,\n- graphs 1007 and 1008 with degree sequences 3333444 and 3333336,\n- graphs 1012 and 1213 with degree sequences 1244555 and 1244456.\n\nReferences\n----------\n.. [atlas] Ronald C. Read and Robin J. Wilson,\n           *An Atlas of Graphs*.\n           Oxford University Press, 1998."}, {"type": "function", "name": "networkx.graph_edit_distance", "documentation": "Returns GED (graph edit distance) between graphs G1 and G2.\n\nGraph edit distance is a graph similarity measure analogous to\nLevenshtein distance for strings.  It is defined as minimum cost\nof edit path (sequence of node and edge edit operations)\ntransforming graph G1 to graph isomorphic to G2.\n\nParameters\n----------\nG1, G2: graphs\n    The two graphs G1 and G2 must be of the same type.\n\nnode_match : callable\n    A function that returns True if node n1 in G1 and n2 in G2\n    should be considered equal during matching.\n\n    The function will be called like\n\n       node_match(G1.nodes[n1], G2.nodes[n2]).\n\n    That is, the function will receive the node attribute\n    dictionaries for n1 and n2 as inputs.\n\n    Ignored if node_subst_cost is specified.  If neither\n    node_match nor node_subst_cost are specified then node\n    attributes are not considered.\n\nedge_match : callable\n    A function that returns True if the edge attribute dictionaries\n    for the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\n    be considered equal during matching.\n\n    The function will be called like\n\n       edge_match(G1[u1][v1], G2[u2][v2]).\n\n    That is, the function will receive the edge attribute\n    dictionaries of the edges under consideration.\n\n    Ignored if edge_subst_cost is specified.  If neither\n    edge_match nor edge_subst_cost are specified then edge\n    attributes are not considered.\n\nnode_subst_cost, node_del_cost, node_ins_cost : callable\n    Functions that return the costs of node substitution, node\n    deletion, and node insertion, respectively.\n\n    The functions will be called like\n\n       node_subst_cost(G1.nodes[n1], G2.nodes[n2]),\n       node_del_cost(G1.nodes[n1]),\n       node_ins_cost(G2.nodes[n2]).\n\n    That is, the functions will receive the node attribute\n    dictionaries as inputs.  The functions are expected to return\n    positive numeric values.\n\n    Function node_subst_cost overrides node_match if specified.\n    If neither node_match nor node_subst_cost are specified then\n    default node substitution cost of 0 is used (node attributes\n    are not considered during matching).\n\n    If node_del_cost is not specified then default node deletion\n    cost of 1 is used.  If node_ins_cost is not specified then\n    default node insertion cost of 1 is used.\n\nedge_subst_cost, edge_del_cost, edge_ins_cost : callable\n    Functions that return the costs of edge substitution, edge\n    deletion, and edge insertion, respectively.\n\n    The functions will be called like\n\n       edge_subst_cost(G1[u1][v1], G2[u2][v2]),\n       edge_del_cost(G1[u1][v1]),\n       edge_ins_cost(G2[u2][v2]).\n\n    That is, the functions will receive the edge attribute\n    dictionaries as inputs.  The functions are expected to return\n    positive numeric values.\n\n    Function edge_subst_cost overrides edge_match if specified.\n    If neither edge_match nor edge_subst_cost are specified then\n    default edge substitution cost of 0 is used (edge attributes\n    are not considered during matching).\n\n    If edge_del_cost is not specified then default edge deletion\n    cost of 1 is used.  If edge_ins_cost is not specified then\n    default edge insertion cost of 1 is used.\n\nroots : 2-tuple\n    Tuple where first element is a node in G1 and the second\n    is a node in G2.\n    These nodes are forced to be matched in the comparison to\n    allow comparison between rooted graphs.\n\nupper_bound : numeric\n    Maximum edit distance to consider.  Return None if no edit\n    distance under or equal to upper_bound exists.\n\ntimeout : numeric\n    Maximum number of seconds to execute.\n    After timeout is met, the current best GED is returned.\n\nExamples\n--------\n>>> G1 = nx.cycle_graph(6)\n>>> G2 = nx.wheel_graph(7)\n>>> nx.graph_edit_distance(G1, G2)\n7.0\n\n>>> G1 = nx.star_graph(5)\n>>> G2 = nx.star_graph(5)\n>>> nx.graph_edit_distance(G1, G2, roots=(0, 0))\n0.0\n>>> nx.graph_edit_distance(G1, G2, roots=(1, 0))\n8.0\n\nSee Also\n--------\noptimal_edit_paths, optimize_graph_edit_distance,\n\nis_isomorphic: test for graph edit distance of 0\n\nReferences\n----------\n.. [1] Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\n   Martineau. An Exact Graph Edit Distance Algorithm for Solving\n   Pattern Recognition Problems. 4th International Conference on\n   Pattern Recognition Applications and Methods 2015, Jan 2015,\n   Lisbon, Portugal. 2015,\n   <10.5220/0005209202710278>. <hal-01168816>\n   https://hal.archives-ouvertes.fr/hal-01168816"}, {"type": "function", "name": "networkx.greedy_color", "documentation": "Color a graph using various strategies of greedy graph coloring.\n\nAttempts to color a graph using as few colors as possible, where no\nneighbors of a node can have same color as the node itself. The\ngiven strategy determines the order in which nodes are colored.\n\nThe strategies are described in [1]_, and smallest-last is based on\n[2]_.\n\nParameters\n----------\nG : NetworkX graph\n\nstrategy : string or function(G, colors)\n   A function (or a string representing a function) that provides\n   the coloring strategy, by returning nodes in the ordering they\n   should be colored. ``G`` is the graph, and ``colors`` is a\n   dictionary of the currently assigned colors, keyed by nodes. The\n   function must return an iterable over all the nodes in ``G``.\n\n   If the strategy function is an iterator generator (that is, a\n   function with ``yield`` statements), keep in mind that the\n   ``colors`` dictionary will be updated after each ``yield``, since\n   this function chooses colors greedily.\n\n   If ``strategy`` is a string, it must be one of the following,\n   each of which represents one of the built-in strategy functions.\n\n   * ``'largest_first'``\n   * ``'random_sequential'``\n   * ``'smallest_last'``\n   * ``'independent_set'``\n   * ``'connected_sequential_bfs'``\n   * ``'connected_sequential_dfs'``\n   * ``'connected_sequential'`` (alias for the previous strategy)\n   * ``'saturation_largest_first'``\n   * ``'DSATUR'`` (alias for the previous strategy)\n\ninterchange: bool\n   Will use the color interchange algorithm described by [3]_ if set\n   to ``True``.\n\n   Note that ``saturation_largest_first`` and ``independent_set``\n   do not work with interchange. Furthermore, if you use\n   interchange with your own strategy function, you cannot rely\n   on the values in the ``colors`` argument.\n\nReturns\n-------\nA dictionary with keys representing nodes and values representing\ncorresponding coloring.\n\nExamples\n--------\n>>> G = nx.cycle_graph(4)\n>>> d = nx.coloring.greedy_color(G, strategy=\"largest_first\")\n>>> d in [{0: 0, 1: 1, 2: 0, 3: 1}, {0: 1, 1: 0, 2: 1, 3: 0}]\nTrue\n\nRaises\n------\nNetworkXPointlessConcept\n    If ``strategy`` is ``saturation_largest_first`` or\n    ``independent_set`` and ``interchange`` is ``True``.\n\nReferences\n----------\n.. [1] Adrian Kosowski, and Krzysztof Manuszewski,\n   Classical Coloring of Graphs, Graph Colorings, 2-19, 2004.\n   ISBN 0-8218-3458-4.\n.. [2] David W. Matula, and Leland L. Beck, \"Smallest-last\n   ordering and clustering and graph coloring algorithms.\" *J. ACM* 30,\n   3 (July 1983), 417\u2013427. <https://doi.org/10.1145/2402.322385>\n.. [3] Maciej M. Sys\u0142o, Narsingh Deo, Janusz S. Kowalik,\n   Discrete Optimization Algorithms with Pascal Programs, 415-424, 1983.\n   ISBN 0-486-45353-7."}, {"type": "function", "name": "networkx.grid_2d_graph", "documentation": "Returns the two-dimensional grid graph.\n\nThe grid graph has each node connected to its four nearest neighbors.\n\nParameters\n----------\nm, n : int or iterable container of nodes\n    If an integer, nodes are from `range(n)`.\n    If a container, elements become the coordinate of the nodes.\n\nperiodic : bool or iterable\n    If `periodic` is True, both dimensions are periodic. If False, none\n    are periodic.  If `periodic` is iterable, it should yield 2 bool\n    values indicating whether the 1st and 2nd axes, respectively, are\n    periodic.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkX graph\n    The (possibly periodic) grid graph of the specified dimensions."}, {"type": "function", "name": "networkx.grid_graph", "documentation": "Returns the *n*-dimensional grid graph.\n\nThe dimension *n* is the length of the list `dim` and the size in\neach dimension is the value of the corresponding list element.\n\nParameters\n----------\ndim : list or tuple of numbers or iterables of nodes\n    'dim' is a tuple or list with, for each dimension, either a number\n    that is the size of that dimension or an iterable of nodes for\n    that dimension. The dimension of the grid_graph is the length\n    of `dim`.\n\nperiodic : bool or iterable\n    If `periodic` is True, all dimensions are periodic. If False all\n    dimensions are not periodic. If `periodic` is iterable, it should\n    yield `dim` bool values each of which indicates whether the\n    corresponding axis is periodic.\n\nReturns\n-------\nNetworkX graph\n    The (possibly periodic) grid graph of the specified dimensions.\n\nExamples\n--------\nTo produce a 2 by 3 by 4 grid graph, a graph on 24 nodes:\n\n>>> from networkx import grid_graph\n>>> G = grid_graph(dim=(2, 3, 4))\n>>> len(G)\n24\n>>> G = grid_graph(dim=(range(7, 9), range(3, 6)))\n>>> len(G)\n6"}, {"type": "function", "name": "networkx.group_betweenness_centrality", "documentation": "Compute the group betweenness centrality for a group of nodes.\n\nGroup betweenness centrality of a group of nodes $C$ is the sum of the\nfraction of all-pairs shortest paths that pass through any vertex in $C$\n\n.. math::\n\n   c_B(v) =\\sum_{s,t \\in V} \\frac{\\sigma(s, t|v)}{\\sigma(s, t)}\n\nwhere $V$ is the set of nodes, $\\sigma(s, t)$ is the number of\nshortest $(s, t)$-paths, and $\\sigma(s, t|C)$ is the number of\nthose paths passing through some node in group $C$. Note that\n$(s, t)$ are not members of the group ($V-C$ is the set of nodes\nin $V$ that are not in $C$).\n\nParameters\n----------\nG : graph\n  A NetworkX graph.\n\nC : list or set or list of lists or list of sets\n  A group or a list of groups containing nodes which belong to G, for which group betweenness\n  centrality is to be calculated.\n\nnormalized : bool, optional (default=True)\n  If True, group betweenness is normalized by `1/((|V|-|C|)(|V|-|C|-1))`\n  where `|V|` is the number of nodes in G and `|C|` is the number of nodes in C.\n\nweight : None or string, optional (default=None)\n  If None, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n  The weight of an edge is treated as the length or distance between the two sides.\n\nendpoints : bool, optional (default=False)\n  If True include the endpoints in the shortest path counts.\n\nRaises\n------\nNodeNotFound\n   If node(s) in C are not present in G.\n\nReturns\n-------\nbetweenness : list of floats or float\n   If C is a single group then return a float. If C is a list with\n   several groups then return a list of group betweenness centralities.\n\nSee Also\n--------\nbetweenness_centrality\n\nNotes\n-----\nGroup betweenness centrality is described in [1]_ and its importance discussed in [3]_.\nThe initial implementation of the algorithm is mentioned in [2]_. This function uses\nan improved algorithm presented in [4]_.\n\nThe number of nodes in the group must be a maximum of n - 2 where `n`\nis the total number of nodes in the graph.\n\nFor weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\n\nThe total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nbetween \"u\" and \"v\" are counted as two possible paths (one each\ndirection) while undirected paths between \"u\" and \"v\" are counted\nas one path. Said another way, the sum in the expression above is\nover all ``s != t`` for directed graphs and for ``s < t`` for undirected graphs.\n\n\nReferences\n----------\n.. [1] M G Everett and S P Borgatti:\n   The Centrality of Groups and Classes.\n   Journal of Mathematical Sociology. 23(3): 181-201. 1999.\n   http://www.analytictech.com/borgatti/group_centrality.htm\n.. [2] Ulrik Brandes:\n   On Variants of Shortest-Path Betweenness\n   Centrality and their Generic Computation.\n   Social Networks 30(2):136-145, 2008.\n   http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.9610&rep=rep1&type=pdf\n.. [3] Sourav Medya et. al.:\n   Group Centrality Maximization via Network Design.\n   SIAM International Conference on Data Mining, SDM 2018, 126\u2013134.\n   https://sites.cs.ucsb.edu/~arlei/pubs/sdm18.pdf\n.. [4] Rami Puzis, Yuval Elovici, and Shlomi Dolev.\n   \"Fast algorithm for successive computation of group betweenness centrality.\"\n   https://journals.aps.org/pre/pdf/10.1103/PhysRevE.76.056709"}, {"type": "function", "name": "networkx.group_closeness_centrality", "documentation": "Compute the group closeness centrality for a group of nodes.\n\nGroup closeness centrality of a group of nodes $S$ is a measure\nof how close the group is to the other nodes in the graph.\n\n.. math::\n\n   c_{close}(S) = \\frac{|V-S|}{\\sum_{v \\in V-S} d_{S, v}}\n\n   d_{S, v} = min_{u \\in S} (d_{u, v})\n\nwhere $V$ is the set of nodes, $d_{S, v}$ is the distance of\nthe group $S$ from $v$ defined as above. ($V-S$ is the set of nodes\nin $V$ that are not in $S$).\n\nParameters\n----------\nG : graph\n   A NetworkX graph.\n\nS : list or set\n   S is a group of nodes which belong to G, for which group closeness\n   centrality is to be calculated.\n\nweight : None or string, optional (default=None)\n   If None, all edge weights are considered equal.\n   Otherwise holds the name of the edge attribute used as weight.\n   The weight of an edge is treated as the length or distance between the two sides.\n\nRaises\n------\nNodeNotFound\n   If node(s) in S are not present in G.\n\nReturns\n-------\ncloseness : float\n   Group closeness centrality of the group S.\n\nSee Also\n--------\ncloseness_centrality\n\nNotes\n-----\nThe measure was introduced in [1]_.\nThe formula implemented here is described in [2]_.\n\nHigher values of closeness indicate greater centrality.\n\nIt is assumed that 1 / 0 is 0 (required in the case of directed graphs,\nor when a shortest path length is 0).\n\nThe number of nodes in the group must be a maximum of n - 1 where `n`\nis the total number of nodes in the graph.\n\nFor directed graphs, the incoming distance is utilized here. To use the\noutward distance, act on `G.reverse()`.\n\nFor weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\n\nReferences\n----------\n.. [1] M G Everett and S P Borgatti:\n   The Centrality of Groups and Classes.\n   Journal of Mathematical Sociology. 23(3): 181-201. 1999.\n   http://www.analytictech.com/borgatti/group_centrality.htm\n.. [2] J. Zhao et. al.:\n   Measuring and Maximizing Group Closeness Centrality over\n   Disk Resident Graphs.\n   WWWConference Proceedings, 2014. 689-694.\n   https://doi.org/10.1145/2567948.2579356"}, {"type": "function", "name": "networkx.group_degree_centrality", "documentation": "Compute the group degree centrality for a group of nodes.\n\nGroup degree centrality of a group of nodes $S$ is the fraction\nof non-group members connected to group members.\n\nParameters\n----------\nG : graph\n   A NetworkX graph.\n\nS : list or set\n   S is a group of nodes which belong to G, for which group degree\n   centrality is to be calculated.\n\nRaises\n------\nNetworkXError\n   If node(s) in S are not in G.\n\nReturns\n-------\ncentrality : float\n   Group degree centrality of the group S.\n\nSee Also\n--------\ndegree_centrality\ngroup_in_degree_centrality\ngroup_out_degree_centrality\n\nNotes\n-----\nThe measure was introduced in [1]_.\n\nThe number of nodes in the group must be a maximum of n - 1 where `n`\nis the total number of nodes in the graph.\n\nReferences\n----------\n.. [1] M G Everett and S P Borgatti:\n   The Centrality of Groups and Classes.\n   Journal of Mathematical Sociology. 23(3): 181-201. 1999.\n   http://www.analytictech.com/borgatti/group_centrality.htm"}, {"type": "function", "name": "networkx.group_in_degree_centrality", "documentation": "Compute the group in-degree centrality for a group of nodes.\n\nGroup in-degree centrality of a group of nodes $S$ is the fraction\nof non-group members connected to group members by incoming edges.\n\nParameters\n----------\nG : graph\n   A NetworkX graph.\n\nS : list or set\n   S is a group of nodes which belong to G, for which group in-degree\n   centrality is to be calculated.\n\nReturns\n-------\ncentrality : float\n   Group in-degree centrality of the group S.\n\nRaises\n------\nNetworkXNotImplemented\n   If G is undirected.\n\nNodeNotFound\n   If node(s) in S are not in G.\n\nSee Also\n--------\ndegree_centrality\ngroup_degree_centrality\ngroup_out_degree_centrality\n\nNotes\n-----\nThe number of nodes in the group must be a maximum of n - 1 where `n`\nis the total number of nodes in the graph.\n\n`G.neighbors(i)` gives nodes with an outward edge from i, in a DiGraph,\nso for group in-degree centrality, the reverse graph is used."}, {"type": "function", "name": "networkx.group_out_degree_centrality", "documentation": "Compute the group out-degree centrality for a group of nodes.\n\nGroup out-degree centrality of a group of nodes $S$ is the fraction\nof non-group members connected to group members by outgoing edges.\n\nParameters\n----------\nG : graph\n   A NetworkX graph.\n\nS : list or set\n   S is a group of nodes which belong to G, for which group in-degree\n   centrality is to be calculated.\n\nReturns\n-------\ncentrality : float\n   Group out-degree centrality of the group S.\n\nRaises\n------\nNetworkXNotImplemented\n   If G is undirected.\n\nNodeNotFound\n   If node(s) in S are not in G.\n\nSee Also\n--------\ndegree_centrality\ngroup_degree_centrality\ngroup_in_degree_centrality\n\nNotes\n-----\nThe number of nodes in the group must be a maximum of n - 1 where `n`\nis the total number of nodes in the graph.\n\n`G.neighbors(i)` gives nodes with an outward edge from i, in a DiGraph,\nso for group out-degree centrality, the graph itself is used."}, {"type": "function", "name": "networkx.gutman_index", "documentation": "Returns the Gutman Index for the graph `G`.\n\nThe *Gutman Index* measures the topology of networks, especially for molecule\nnetworks of atoms connected by bonds [1]_. It is also called the Schultz Index\nof the second kind [2]_.\n\nConsider an undirected graph `G` with node set ``V``.\nThe Gutman Index of a graph is the sum over all (unordered) pairs of nodes\nof nodes ``(u, v)``, with distance ``dist(u, v)`` and degrees ``deg(u)``\nand ``deg(v)``, of ``dist(u, v) * deg(u) * deg(v)``\n\nParameters\n----------\nG : NetworkX graph\n\nweight : string or None, optional (default: None)\n    If None, every edge has weight 1.\n    If a string, use this edge attribute as the edge weight.\n    Any edge attribute not present defaults to 1.\n    The edge weights are used to computing shortest-path distances.\n\nReturns\n-------\nnumber\n    The Gutman Index of the graph `G`.\n\nExamples\n--------\nThe Gutman Index of the (unweighted) complete graph on *n* nodes\nequals the number of pairs of the *n* nodes times ``(n - 1) * (n - 1)``,\nsince each pair of nodes is at distance one and the product of degree of two\nvertices is ``(n - 1) * (n - 1)``.\n\n>>> n = 10\n>>> G = nx.complete_graph(n)\n>>> nx.gutman_index(G) == (n * (n - 1) / 2) * ((n - 1) * (n - 1))\nTrue\n\nGraphs that are disconnected\n\n>>> G = nx.empty_graph(2)\n>>> nx.gutman_index(G)\ninf\n\nReferences\n----------\n.. [1] M.V. Diudeaa and I. Gutman, Wiener-Type Topological Indices,\n       Croatica Chemica Acta, 71 (1998), 21-51.\n       https://hrcak.srce.hr/132323\n.. [2] I. Gutman, Selected properties of the Schultz molecular topological index,\n       J. Chem. Inf. Comput. Sci. 34 (1994), 1087\u20131089.\n       https://doi.org/10.1021/ci00021a009"}, {"type": "function", "name": "networkx.harmonic_centrality", "documentation": "Compute harmonic centrality for nodes.\n\nHarmonic centrality [1]_ of a node `u` is the sum of the reciprocal\nof the shortest path distances from all other nodes to `u`\n\n.. math::\n\n    C(u) = \\sum_{v \\neq u} \\frac{1}{d(v, u)}\n\nwhere `d(v, u)` is the shortest-path distance between `v` and `u`.\n\nIf `sources` is given as an argument, the returned harmonic centrality\nvalues are calculated as the sum of the reciprocals of the shortest\npath distances from the nodes specified in `sources` to `u` instead\nof from all nodes to `u`.\n\nNotice that higher values indicate higher centrality.\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nnbunch : container (default: all nodes in G)\n  Container of nodes for which harmonic centrality values are calculated.\n\nsources : container (default: all nodes in G)\n  Container of nodes `v` over which reciprocal distances are computed.\n  Nodes not in `G` are silently ignored.\n\ndistance : edge attribute key, optional (default=None)\n  Use the specified edge attribute as the edge distance in shortest\n  path calculations.  If `None`, then each edge will have distance equal to 1.\n\nReturns\n-------\nnodes : dictionary\n  Dictionary of nodes with harmonic centrality as the value.\n\nSee Also\n--------\nbetweenness_centrality, load_centrality, eigenvector_centrality,\ndegree_centrality, closeness_centrality\n\nNotes\n-----\nIf the 'distance' keyword is set to an edge attribute key then the\nshortest-path length will be computed using Dijkstra's algorithm with\nthat edge attribute as the edge weight.\n\nReferences\n----------\n.. [1] Boldi, Paolo, and Sebastiano Vigna. \"Axioms for centrality.\"\n       Internet Mathematics 10.3-4 (2014): 222-262."}, {"type": "function", "name": "networkx.has_bridges", "documentation": "Decide whether a graph has any bridges.\n\nA *bridge* in a graph is an edge whose removal causes the number of\nconnected components of the graph to increase.\n\nParameters\n----------\nG : undirected graph\n\nroot : node (optional)\n   A node in the graph `G`. If specified, only the bridges in the\n   connected component containing this node will be considered.\n\nReturns\n-------\nbool\n   Whether the graph (or the connected component containing `root`)\n   has any bridges.\n\nRaises\n------\nNodeNotFound\n   If `root` is not in the graph `G`.\n\nNetworkXNotImplemented\n    If `G` is a directed graph.\n\nExamples\n--------\nThe barbell graph with parameter zero has a single bridge::\n\n    >>> G = nx.barbell_graph(10, 0)\n    >>> nx.has_bridges(G)\n    True\n\nOn the other hand, the cycle graph has no bridges::\n\n    >>> G = nx.cycle_graph(5)\n    >>> nx.has_bridges(G)\n    False\n\nNotes\n-----\nThis implementation uses the :func:`networkx.bridges` function, so\nit shares its worst-case time complexity, $O(m + n)$, ignoring\npolylogarithmic factors, where $n$ is the number of nodes in the\ngraph and $m$ is the number of edges."}, {"type": "function", "name": "networkx.has_eulerian_path", "documentation": "Return True iff `G` has an Eulerian path.\n\nAn Eulerian path is a path in a graph which uses each edge of a graph\nexactly once. If `source` is specified, then this function checks\nwhether an Eulerian path that starts at node `source` exists.\n\nA directed graph has an Eulerian path iff:\n    - at most one vertex has out_degree - in_degree = 1,\n    - at most one vertex has in_degree - out_degree = 1,\n    - every other vertex has equal in_degree and out_degree,\n    - and all of its vertices belong to a single connected\n      component of the underlying undirected graph.\n\nIf `source` is not None, an Eulerian path starting at `source` exists if no\nother node has out_degree - in_degree = 1. This is equivalent to either\nthere exists an Eulerian circuit or `source` has out_degree - in_degree = 1\nand the conditions above hold.\n\nAn undirected graph has an Eulerian path iff:\n    - exactly zero or two vertices have odd degree,\n    - and all of its vertices belong to a single connected component.\n\nIf `source` is not None, an Eulerian path starting at `source` exists if\neither there exists an Eulerian circuit or `source` has an odd degree and the\nconditions above hold.\n\nGraphs with isolated vertices (i.e. vertices with zero degree) are not considered\nto have an Eulerian path. Therefore, if the graph is not connected (or not strongly\nconnected, for directed graphs), this function returns False.\n\nParameters\n----------\nG : NetworkX Graph\n    The graph to find an euler path in.\n\nsource : node, optional\n    Starting node for path.\n\nReturns\n-------\nBool : True if G has an Eulerian path.\n\nExamples\n--------\nIf you prefer to allow graphs with isolated vertices to have Eulerian path,\nyou can first remove such vertices and then call `has_eulerian_path` as below example shows.\n\n>>> G = nx.Graph([(0, 1), (1, 2), (0, 2)])\n>>> G.add_node(3)\n>>> nx.has_eulerian_path(G)\nFalse\n\n>>> G.remove_nodes_from(list(nx.isolates(G)))\n>>> nx.has_eulerian_path(G)\nTrue\n\nSee Also\n--------\nis_eulerian\neulerian_path"}, {"type": "function", "name": "networkx.has_path", "documentation": "Returns *True* if *G* has a path from *source* to *target*.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n   Starting node for path\n\ntarget : node\n   Ending node for path"}, {"type": "function", "name": "networkx.havel_hakimi_graph", "documentation": "Returns a simple graph with given degree sequence constructed\nusing the Havel-Hakimi algorithm.\n\nParameters\n----------\ndeg_sequence: list of integers\n    Each integer corresponds to the degree of a node (need not be sorted).\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n    Directed graphs are not allowed.\n\nRaises\n------\nNetworkXException\n    For a non-graphical degree sequence (i.e. one\n    not realizable by some simple graph).\n\nNotes\n-----\nThe Havel-Hakimi algorithm constructs a simple graph by\nsuccessively connecting the node of highest degree to other nodes\nof highest degree, resorting remaining nodes by degree, and\nrepeating the process. The resulting graph has a high\ndegree-associativity.  Nodes are labeled 1,.., len(deg_sequence),\ncorresponding to their position in deg_sequence.\n\nThe basic algorithm is from Hakimi [1]_ and was generalized by\nKleitman and Wang [2]_.\n\nReferences\n----------\n.. [1] Hakimi S., On Realizability of a Set of Integers as\n   Degrees of the Vertices of a Linear Graph. I,\n   Journal of SIAM, 10(3), pp. 496-506 (1962)\n.. [2] Kleitman D.J. and Wang D.L.\n   Algorithms for Constructing Graphs and Digraphs with Given Valences\n   and Factors  Discrete Mathematics, 6(1), pp. 79-88 (1973)"}, {"type": "function", "name": "networkx.heawood_graph", "documentation": "Returns the Heawood Graph, a (3,6) cage.\n\nThe Heawood Graph is an undirected graph with 14 nodes and 21 edges,\nnamed after Percy John Heawood [1]_.\nIt is cubic symmetric, nonplanar, Hamiltonian, and can be represented\nin LCF notation as ``[5,-5]^7`` [2]_.\nIt is the unique (3,6)-cage: the regular cubic graph of girth 6 with\nminimal number of vertices [3]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Heawood Graph with 14 nodes and 21 edges\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Heawood_graph\n.. [2] https://mathworld.wolfram.com/HeawoodGraph.html\n.. [3] https://www.win.tue.nl/~aeb/graphs/Heawood.html"}, {"type": "function", "name": "networkx.hexagonal_lattice_graph", "documentation": "Returns an `m` by `n` hexagonal lattice graph.\n\nThe *hexagonal lattice graph* is a graph whose nodes and edges are\nthe `hexagonal tiling`_ of the plane.\n\nThe returned graph will have `m` rows and `n` columns of hexagons.\n`Odd numbered columns`_ are shifted up relative to even numbered columns.\n\nPositions of nodes are computed by default or `with_positions is True`.\nNode positions creating the standard embedding in the plane\nwith sidelength 1 and are stored in the node attribute 'pos'.\n`pos = nx.get_node_attributes(G, 'pos')` creates a dict ready for drawing.\n\n.. _hexagonal tiling: https://en.wikipedia.org/wiki/Hexagonal_tiling\n.. _Odd numbered columns: http://www-cs-students.stanford.edu/~amitp/game-programming/grids/\n\nParameters\n----------\nm : int\n    The number of rows of hexagons in the lattice.\n\nn : int\n    The number of columns of hexagons in the lattice.\n\nperiodic : bool\n    Whether to make a periodic grid by joining the boundary vertices.\n    For this to work `n` must be even and both `n > 1` and `m > 1`.\n    The periodic connections create another row and column of hexagons\n    so these graphs have fewer nodes as boundary nodes are identified.\n\nwith_positions : bool (default: True)\n    Store the coordinates of each node in the graph node attribute 'pos'.\n    The coordinates provide a lattice with vertical columns of hexagons\n    offset to interleave and cover the plane.\n    Periodic positions shift the nodes vertically in a nonlinear way so\n    the edges don't overlap so much.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n    If graph is directed, edges will point up or right.\n\nReturns\n-------\nNetworkX graph\n    The *m* by *n* hexagonal lattice graph."}, {"type": "function", "name": "networkx.hits", "documentation": "Returns HITS hubs and authorities values for nodes.\n\nThe HITS algorithm computes two numbers for a node.\nAuthorities estimates the node value based on the incoming links.\nHubs estimates the node value based on outgoing links.\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nmax_iter : integer, optional\n  Maximum number of iterations in power method.\n\ntol : float, optional\n  Error tolerance used to check convergence in power method iteration.\n\nnstart : dictionary, optional\n  Starting value of each node for power method iteration.\n\nnormalized : bool (default=True)\n   Normalize results by the sum of all of the values.\n\nReturns\n-------\n(hubs,authorities) : two-tuple of dictionaries\n   Two dictionaries keyed by node containing the hub and authority\n   values.\n\nRaises\n------\nPowerIterationFailedConvergence\n    If the algorithm fails to converge to the specified tolerance\n    within the specified number of iterations of the power iteration\n    method.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> h, a = nx.hits(G)\n\nNotes\n-----\nThe eigenvector calculation is done by the power iteration method\nand has no guarantee of convergence.  The iteration will stop\nafter max_iter iterations or an error tolerance of\nnumber_of_nodes(G)*tol has been reached.\n\nThe HITS algorithm was designed for directed graphs but this\nalgorithm does not check if the input graph is directed and will\nexecute on undirected graphs.\n\nReferences\n----------\n.. [1] A. Langville and C. Meyer,\n   \"A survey of eigenvector methods of web information retrieval.\"\n   http://citeseer.ist.psu.edu/713792.html\n.. [2] Jon Kleinberg,\n   Authoritative sources in a hyperlinked environment\n   Journal of the ACM 46 (5): 604-32, 1999.\n   doi:10.1145/324133.324140.\n   http://www.cs.cornell.edu/home/kleinber/auth.pdf."}, {"type": "function", "name": "networkx.hkn_harary_graph", "documentation": "Returns the Harary graph with given node connectivity and node number.\n\nThe Harary graph $H_{k,n}$ is the graph that minimizes the number of\nedges needed with given node connectivity $k$ and node number $n$.\n\nThis smallest number of edges is known to be ceil($kn/2$) [1]_.\n\nParameters\n----------\nk: integer\n   The node connectivity of the generated graph\n\nn: integer\n   The number of nodes the generated graph is to contain\n\ncreate_using : NetworkX graph constructor, optional Graph type\n to create (default=nx.Graph). If graph instance, then cleared\n before populated.\n\nReturns\n-------\nNetworkX graph\n    The Harary graph $H_{k,n}$.\n\nSee Also\n--------\nhnm_harary_graph\n\nNotes\n-----\nThis algorithm runs in $O(kn)$ time.\nIt is implemented by following the Reference [2]_.\n\nReferences\n----------\n.. [1] Weisstein, Eric W. \"Harary Graph.\" From MathWorld--A Wolfram Web\n Resource. http://mathworld.wolfram.com/HararyGraph.html.\n\n.. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\n  Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962."}, {"type": "function", "name": "networkx.hnm_harary_graph", "documentation": "Returns the Harary graph with given numbers of nodes and edges.\n\nThe Harary graph $H_{n,m}$ is the graph that maximizes node connectivity\nwith $n$ nodes and $m$ edges.\n\nThis maximum node connectivity is known to be floor($2m/n$). [1]_\n\nParameters\n----------\nn: integer\n   The number of nodes the generated graph is to contain\n\nm: integer\n   The number of edges the generated graph is to contain\n\ncreate_using : NetworkX graph constructor, optional Graph type\n to create (default=nx.Graph). If graph instance, then cleared\n before populated.\n\nReturns\n-------\nNetworkX graph\n    The Harary graph $H_{n,m}$.\n\nSee Also\n--------\nhkn_harary_graph\n\nNotes\n-----\nThis algorithm runs in $O(m)$ time.\nIt is implemented by following the Reference [2]_.\n\nReferences\n----------\n.. [1] F. T. Boesch, A. Satyanarayana, and C. L. Suffel,\n   \"A Survey of Some Network Reliability Analysis and Synthesis Results,\"\n   Networks, pp. 99-107, 2009.\n\n.. [2] Harary, F. \"The Maximum Connectivity of a Graph.\"\n   Proc. Nat. Acad. Sci. USA 48, 1142-1146, 1962."}, {"type": "function", "name": "networkx.hoffman_singleton_graph", "documentation": "Returns the Hoffman-Singleton Graph.\n\nThe Hoffman\u2013Singleton graph is a symmetrical undirected graph\nwith 50 nodes and 175 edges.\nAll indices lie in ``Z % 5``: that is, the integers mod 5 [1]_.\nIt is the only regular graph of vertex degree 7, diameter 2, and girth 5.\nIt is the unique (7,5)-cage graph and Moore graph, and contains many\ncopies of the Petersen graph [2]_.\n\nReturns\n-------\nG : networkx Graph\n    Hoffman\u2013Singleton Graph with 50 nodes and 175 edges\n\nNotes\n-----\nConstructed from pentagon and pentagram as follows: Take five pentagons $P_h$\nand five pentagrams $Q_i$ . Join vertex $j$ of $P_h$ to vertex $h\u00b7i+j$ of $Q_i$ [3]_.\n\nReferences\n----------\n.. [1] https://blogs.ams.org/visualinsight/2016/02/01/hoffman-singleton-graph/\n.. [2] https://mathworld.wolfram.com/Hoffman-SingletonGraph.html\n.. [3] https://en.wikipedia.org/wiki/Hoffman%E2%80%93Singleton_graph"}, {"type": "function", "name": "networkx.house_graph", "documentation": "Returns the House graph (square with triangle on top)\n\nThe house graph is a simple undirected graph with\n5 nodes and 6 edges [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    House graph in the form of a square with a triangle on top\n\nReferences\n----------\n.. [1] https://mathworld.wolfram.com/HouseGraph.html"}, {"type": "function", "name": "networkx.house_x_graph", "documentation": "Returns the House graph with a cross inside the house square.\n\nThe House X-graph is the House graph plus the two edges connecting diagonally\nopposite vertices of the square base. It is also one of the two graphs\nobtained by removing two edges from the pentatope graph [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    House graph with diagonal vertices connected\n\nReferences\n----------\n.. [1] https://mathworld.wolfram.com/HouseGraph.html"}, {"type": "function", "name": "networkx.hypercube_graph", "documentation": "Returns the *n*-dimensional hypercube graph.\n\nThe nodes are the integers between 0 and ``2 ** n - 1``, inclusive.\n\nFor more information on the hypercube graph, see the Wikipedia\narticle `Hypercube graph`_.\n\n.. _Hypercube graph: https://en.wikipedia.org/wiki/Hypercube_graph\n\nParameters\n----------\nn : int\n    The dimension of the hypercube.\n    The number of nodes in the graph will be ``2 ** n``.\n\nReturns\n-------\nNetworkX graph\n    The hypercube graph of dimension *n*."}, {"type": "function", "name": "networkx.icosahedral_graph", "documentation": "Returns the Platonic Icosahedral graph.\n\nThe icosahedral graph has 12 nodes and 30 edges. It is a Platonic graph\nwhose nodes have the connectivity of the icosahedron. It is undirected,\nregular and Hamiltonian [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Icosahedral graph with 12 nodes and 30 edges.\n\nReferences\n----------\n.. [1] https://mathworld.wolfram.com/IcosahedralGraph.html"}, {"type": "function", "name": "networkx.identified_nodes", "documentation": "Returns the graph that results from contracting `u` and `v`.\n\nNode contraction identifies the two nodes as a single node incident to any\nedge that was incident to the original two nodes.\n\nParameters\n----------\nG : NetworkX graph\n    The graph whose nodes will be contracted.\n\nu, v : nodes\n    Must be nodes in `G`.\n\nself_loops : Boolean\n    If this is True, any edges joining `u` and `v` in `G` become\n    self-loops on the new node in the returned graph.\n\ncopy : Boolean\n    If this is True (default True), make a copy of\n    `G` and return that instead of directly changing `G`.\n\n\nReturns\n-------\nNetworkx graph\n    If Copy is True,\n    A new graph object of the same type as `G` (leaving `G` unmodified)\n    with `u` and `v` identified in a single node. The right node `v`\n    will be merged into the node `u`, so only `u` will appear in the\n    returned graph.\n    If copy is False,\n    Modifies `G` with `u` and `v` identified in a single node.\n    The right node `v` will be merged into the node `u`, so\n    only `u` will appear in the returned graph.\n\nNotes\n-----\nFor multigraphs, the edge keys for the realigned edges may\nnot be the same as the edge keys for the old edges. This is\nnatural because edge keys are unique only within each pair of nodes.\n\nFor non-multigraphs where `u` and `v` are adjacent to a third node\n`w`, the edge (`v`, `w`) will be contracted into the edge (`u`,\n`w`) with its attributes stored into a \"contraction\" attribute.\n\nThis function is also available as `identified_nodes`.\n\nExamples\n--------\nContracting two nonadjacent nodes of the cycle graph on four nodes `C_4`\nyields the path graph (ignoring parallel edges):\n\n>>> G = nx.cycle_graph(4)\n>>> M = nx.contracted_nodes(G, 1, 3)\n>>> P3 = nx.path_graph(3)\n>>> nx.is_isomorphic(M, P3)\nTrue\n\n>>> G = nx.MultiGraph(P3)\n>>> M = nx.contracted_nodes(G, 0, 2)\n>>> M.edges\nMultiEdgeView([(0, 1, 0), (0, 1, 1)])\n\n>>> G = nx.Graph([(1, 2), (2, 2)])\n>>> H = nx.contracted_nodes(G, 1, 2, self_loops=False)\n>>> list(H.nodes())\n[1]\n>>> list(H.edges())\n[(1, 1)]\n\nIn a ``MultiDiGraph`` with a self loop, the in and out edges will\nbe treated separately as edges, so while contracting a node which\nhas a self loop the contraction will add multiple edges:\n\n>>> G = nx.MultiDiGraph([(1, 2), (2, 2)])\n>>> H = nx.contracted_nodes(G, 1, 2)\n>>> list(H.edges())  # edge 1->2, 2->2, 2<-2 from the original Graph G\n[(1, 1), (1, 1), (1, 1)]\n>>> H = nx.contracted_nodes(G, 1, 2, self_loops=False)\n>>> list(H.edges())  # edge 2->2, 2<-2 from the original Graph G\n[(1, 1), (1, 1)]\n\nSee Also\n--------\ncontracted_edge\nquotient_graph"}, {"type": "function", "name": "networkx.immediate_dominators", "documentation": "Returns the immediate dominators of all nodes of a directed graph.\n\nParameters\n----------\nG : a DiGraph or MultiDiGraph\n    The graph where dominance is to be computed.\n\nstart : node\n    The start node of dominance computation.\n\nReturns\n-------\nidom : dict keyed by nodes\n    A dict containing the immediate dominators of each node reachable from\n    `start`.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is undirected.\n\nNetworkXError\n    If `start` is not in `G`.\n\nNotes\n-----\nExcept for `start`, the immediate dominators are the parents of their\ncorresponding nodes in the dominator tree.\n\nExamples\n--------\n>>> G = nx.DiGraph([(1, 2), (1, 3), (2, 5), (3, 4), (4, 5)])\n>>> sorted(nx.immediate_dominators(G, 1).items())\n[(1, 1), (2, 1), (3, 1), (4, 3), (5, 1)]\n\nReferences\n----------\n.. [1] K. D. Cooper, T. J. Harvey, and K. Kennedy.\n       A simple, fast dominance algorithm.\n       Software Practice & Experience, 4:110, 2001."}, {"type": "function", "name": "networkx.in_degree_centrality", "documentation": "Compute the in-degree centrality for nodes.\n\nThe in-degree centrality for a node v is the fraction of nodes its\nincoming edges are connected to.\n\nParameters\n----------\nG : graph\n    A NetworkX graph\n\nReturns\n-------\nnodes : dictionary\n    Dictionary of nodes with in-degree centrality as values.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is undirected.\n\nExamples\n--------\n>>> G = nx.DiGraph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n>>> nx.in_degree_centrality(G)\n{0: 0.0, 1: 0.3333333333333333, 2: 0.6666666666666666, 3: 0.6666666666666666}\n\nSee Also\n--------\ndegree_centrality, out_degree_centrality\n\nNotes\n-----\nThe degree centrality values are normalized by dividing by the maximum\npossible degree in a simple graph n-1 where n is the number of nodes in G.\n\nFor multigraphs or graphs with self loops the maximum degree might\nbe higher than n-1 and values of degree centrality greater than 1\nare possible."}, {"type": "function", "name": "networkx.incidence_matrix", "documentation": "Returns incidence matrix of G.\n\nThe incidence matrix assigns each row to a node and each column to an edge.\nFor a standard incidence matrix a 1 appears wherever a row's node is\nincident on the column's edge.  For an oriented incidence matrix each\nedge is assigned an orientation (arbitrarily for undirected and aligning to\ndirection for directed).  A -1 appears for the source (tail) of an edge and\n1 for the destination (head) of the edge.  The elements are zero otherwise.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nnodelist : list, optional   (default= all nodes in G)\n   The rows are ordered according to the nodes in nodelist.\n   If nodelist is None, then the ordering is produced by G.nodes().\n\nedgelist : list, optional (default= all edges in G)\n   The columns are ordered according to the edges in edgelist.\n   If edgelist is None, then the ordering is produced by G.edges().\n\noriented: bool, optional (default=False)\n   If True, matrix elements are +1 or -1 for the head or tail node\n   respectively of each edge.  If False, +1 occurs at both nodes.\n\nweight : string or None, optional (default=None)\n   The edge data key used to provide each value in the matrix.\n   If None, then each edge has weight 1.  Edge weights, if used,\n   should be positive so that the orientation can provide the sign.\n\ndtype : a NumPy dtype or None (default=None)\n    The dtype of the output sparse array. This type should be a compatible\n    type of the weight argument, eg. if weight would return a float this\n    argument should also be a float.\n    If None, then the default for SciPy is used.\n\nReturns\n-------\nA : SciPy sparse array\n  The incidence matrix of G.\n\nNotes\n-----\nFor MultiGraph/MultiDiGraph, the edges in edgelist should be\n(u,v,key) 3-tuples.\n\n\"Networks are the best discrete model for so many problems in\napplied mathematics\" [1]_.\n\nReferences\n----------\n.. [1] Gil Strang, Network applications: A = incidence matrix,\n   http://videolectures.net/mit18085f07_strang_lec03/"}, {"type": "function", "name": "networkx.incremental_closeness_centrality", "documentation": "Incremental closeness centrality for nodes.\n\nCompute closeness centrality for nodes using level-based work filtering\nas described in Incremental Algorithms for Closeness Centrality by Sariyuce et al.\n\nLevel-based work filtering detects unnecessary updates to the closeness\ncentrality and filters them out.\n\n---\nFrom \"Incremental Algorithms for Closeness Centrality\":\n\nTheorem 1: Let :math:`G = (V, E)` be a graph and u and v be two vertices in V\nsuch that there is no edge (u, v) in E. Let :math:`G' = (V, E \\cup uv)`\nThen :math:`cc[s] = cc'[s]` if and only if :math:`\\left|dG(s, u) - dG(s, v)\\right| \\leq 1`.\n\nWhere :math:`dG(u, v)` denotes the length of the shortest path between\ntwo vertices u, v in a graph G, cc[s] is the closeness centrality for a\nvertex s in V, and cc'[s] is the closeness centrality for a\nvertex s in V, with the (u, v) edge added.\n---\n\nWe use Theorem 1 to filter out updates when adding or removing an edge.\nWhen adding an edge (u, v), we compute the shortest path lengths from all\nother nodes to u and to v before the node is added. When removing an edge,\nwe compute the shortest path lengths after the edge is removed. Then we\napply Theorem 1 to use previously computed closeness centrality for nodes\nwhere :math:`\\left|dG(s, u) - dG(s, v)\\right| \\leq 1`. This works only for\nundirected, unweighted graphs; the distance argument is not supported.\n\nCloseness centrality [1]_ of a node `u` is the reciprocal of the\nsum of the shortest path distances from `u` to all `n-1` other nodes.\nSince the sum of distances depends on the number of nodes in the\ngraph, closeness is normalized by the sum of minimum possible\ndistances `n-1`.\n\n.. math::\n\n    C(u) = \\frac{n - 1}{\\sum_{v=1}^{n-1} d(v, u)},\n\nwhere `d(v, u)` is the shortest-path distance between `v` and `u`,\nand `n` is the number of nodes in the graph.\n\nNotice that higher values of closeness indicate higher centrality.\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nedge : tuple\n  The modified edge (u, v) in the graph.\n\nprev_cc : dictionary\n  The previous closeness centrality for all nodes in the graph.\n\ninsertion : bool, optional\n  If True (default) the edge was inserted, otherwise it was deleted from the graph.\n\nwf_improved : bool, optional (default=True)\n  If True, scale by the fraction of nodes reachable. This gives the\n  Wasserman and Faust improved formula. For single component graphs\n  it is the same as the original formula.\n\nReturns\n-------\nnodes : dictionary\n  Dictionary of nodes with closeness centrality as the value.\n\nSee Also\n--------\nbetweenness_centrality, load_centrality, eigenvector_centrality,\ndegree_centrality, closeness_centrality\n\nNotes\n-----\nThe closeness centrality is normalized to `(n-1)/(|G|-1)` where\n`n` is the number of nodes in the connected part of graph\ncontaining the node.  If the graph is not completely connected,\nthis algorithm computes the closeness centrality for each\nconnected part separately.\n\nReferences\n----------\n.. [1] Freeman, L.C., 1979. Centrality in networks: I.\n   Conceptual clarification.  Social Networks 1, 215--239.\n   https://doi.org/10.1016/0378-8733(78)90021-7\n.. [2] Sariyuce, A.E. ; Kaya, K. ; Saule, E. ; Catalyiirek, U.V. Incremental\n   Algorithms for Closeness Centrality. 2013 IEEE International Conference on Big Data\n   http://sariyuce.com/papers/bigdata13.pdf"}, {"type": "function", "name": "networkx.induced_subgraph", "documentation": "Returns a SubGraph view of `G` showing only nodes in nbunch.\n\nThe induced subgraph of a graph on a set of nodes N is the\ngraph with nodes N and edges from G which have both ends in N.\n\nParameters\n----------\nG : NetworkX Graph\nnbunch : node, container of nodes or None (for all nodes)\n\nReturns\n-------\nsubgraph : SubGraph View\n    A read-only view of the subgraph in `G` induced by the nodes.\n    Changes to the graph `G` will be reflected in the view.\n\nNotes\n-----\nTo create a mutable subgraph with its own copies of nodes\nedges and attributes use `subgraph.copy()` or `Graph(subgraph)`\n\nFor an inplace reduction of a graph to a subgraph you can remove nodes:\n`G.remove_nodes_from(n in G if n not in set(nbunch))`\n\nIf you are going to compute subgraphs of your subgraphs you could\nend up with a chain of views that can be very slow once the chain\nhas about 15 views in it. If they are all induced subgraphs, you\ncan short-cut the chain by making them all subgraphs of the original\ngraph. The graph class method `G.subgraph` does this when `G` is\na subgraph. In contrast, this function allows you to choose to build\nchains or not, as you wish. The returned subgraph is a view on `G`.\n\nExamples\n--------\n>>> G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> H = nx.induced_subgraph(G, [0, 1, 3])\n>>> list(H.edges)\n[(0, 1)]\n>>> list(H.nodes)\n[0, 1, 3]"}, {"type": "function", "name": "networkx.information_centrality", "documentation": "Compute current-flow closeness centrality for nodes.\n\nCurrent-flow closeness centrality is variant of closeness\ncentrality based on effective resistance between nodes in\na network. This metric is also known as information centrality.\n\nParameters\n----------\nG : graph\n  A NetworkX graph.\n\nweight : None or string, optional (default=None)\n  If None, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n  The weight reflects the capacity or the strength of the\n  edge.\n\ndtype: data type (default=float)\n  Default data type for internal matrices.\n  Set to np.float32 for lower memory consumption.\n\nsolver: string (default='lu')\n   Type of linear solver to use for computing the flow matrix.\n   Options are \"full\" (uses most memory), \"lu\" (recommended), and\n   \"cg\" (uses least memory).\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with current flow closeness centrality as the value.\n\nSee Also\n--------\ncloseness_centrality\n\nNotes\n-----\nThe algorithm is from Brandes [1]_.\n\nSee also [2]_ for the original definition of information centrality.\n\nReferences\n----------\n.. [1] Ulrik Brandes and Daniel Fleischer,\n   Centrality Measures Based on Current Flow.\n   Proc. 22nd Symp. Theoretical Aspects of Computer Science (STACS '05).\n   LNCS 3404, pp. 533-544. Springer-Verlag, 2005.\n   https://doi.org/10.1007/978-3-540-31856-9_44\n\n.. [2] Karen Stephenson and Marvin Zelen:\n   Rethinking centrality: Methods and examples.\n   Social Networks 11(1):1-37, 1989.\n   https://doi.org/10.1016/0378-8733(89)90016-6"}, {"type": "function", "name": "networkx.intersection", "documentation": "Returns a new graph that contains only the nodes and the edges that exist in\nboth G and H.\n\nParameters\n----------\nG,H : graph\n   A NetworkX graph. G and H can have different node sets but must be both graphs or both multigraphs.\n\nRaises\n------\nNetworkXError\n    If one is a MultiGraph and the other one is a graph.\n\nReturns\n-------\nGH : A new graph with the same type as G.\n\nNotes\n-----\nAttributes from the graph, nodes, and edges are not copied to the new\ngraph.  If you want a new graph of the intersection of G and H\nwith the attributes (including edge data) from G use remove_nodes_from()\nas follows\n\n>>> G = nx.path_graph(3)\n>>> H = nx.path_graph(5)\n>>> R = G.copy()\n>>> R.remove_nodes_from(n for n in G if n not in H)\n>>> R.remove_edges_from(e for e in G.edges if e not in H.edges)\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (1, 2)])\n>>> H = nx.Graph([(0, 3), (1, 2), (2, 3)])\n>>> R = nx.intersection(G, H)\n>>> R.nodes\nNodeView((0, 1, 2))\n>>> R.edges\nEdgeView([(1, 2)])"}, {"type": "function", "name": "networkx.intersection_all", "documentation": "Returns a new graph that contains only the nodes and the edges that exist in\nall graphs.\n\nParameters\n----------\ngraphs : iterable\n   Iterable of NetworkX graphs\n\nReturns\n-------\nR : A new graph with the same type as the first graph in list\n\nRaises\n------\nValueError\n   If `graphs` is an empty list.\n\nNetworkXError\n    In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs.\n\nNotes\n-----\nFor operating on mixed type graphs, they should be converted to the same type.\n\nAttributes from the graph, nodes, and edges are not copied to the new\ngraph.\n\nThe resulting graph can be updated with attributes if desired. For example, code which adds the minimum attribute for each node across all graphs could work.\n>>> g = nx.Graph()\n>>> g.add_node(0, capacity=4)\n>>> g.add_node(1, capacity=3)\n>>> g.add_edge(0, 1)\n\n>>> h = g.copy()\n>>> h.nodes[0][\"capacity\"] = 2\n\n>>> gh = nx.intersection_all([g, h])\n\n>>> new_node_attr = {\n...     n: min(*(anyG.nodes[n].get(\"capacity\", float(\"inf\")) for anyG in [g, h]))\n...     for n in gh\n... }\n>>> nx.set_node_attributes(gh, new_node_attr, \"new_capacity\")\n>>> gh.nodes(data=True)\nNodeDataView({0: {'new_capacity': 2}, 1: {'new_capacity': 3}})\n\nExamples\n--------\n>>> G1 = nx.Graph([(1, 2), (2, 3)])\n>>> G2 = nx.Graph([(2, 3), (3, 4)])\n>>> R = nx.intersection_all([G1, G2])\n>>> list(R.nodes())\n[2, 3]\n>>> list(R.edges())\n[(2, 3)]"}, {"type": "function", "name": "networkx.intersection_array", "documentation": "Returns the intersection array of a distance-regular graph.\n\nGiven a distance-regular graph G with integers b_i, c_i,i = 0,....,d\nsuch that for any 2 vertices x,y in G at a distance i=d(x,y), there\nare exactly c_i neighbors of y at a distance of i-1 from x and b_i\nneighbors of y at a distance of i+1 from x.\n\nA distance regular graph's intersection array is given by,\n[b_0,b_1,.....b_{d-1};c_1,c_2,.....c_d]\n\nParameters\n----------\nG: Networkx graph (undirected)\n\nReturns\n-------\nb,c: tuple of lists\n\nExamples\n--------\n>>> G = nx.icosahedral_graph()\n>>> nx.intersection_array(G)\n([5, 2, 1], [1, 2, 5])\n\nReferences\n----------\n.. [1] Weisstein, Eric W. \"Intersection Array.\"\n   From MathWorld--A Wolfram Web Resource.\n   http://mathworld.wolfram.com/IntersectionArray.html\n\nSee Also\n--------\nglobal_parameters"}, {"type": "function", "name": "networkx.interval_graph", "documentation": "Generates an interval graph for a list of intervals given.\n\nIn graph theory, an interval graph is an undirected graph formed from a set\nof closed intervals on the real line, with a vertex for each interval\nand an edge between vertices whose intervals intersect.\nIt is the intersection graph of the intervals.\n\nMore information can be found at:\nhttps://en.wikipedia.org/wiki/Interval_graph\n\nParameters\n----------\nintervals : a sequence of intervals, say (l, r) where l is the left end,\nand r is the right end of the closed interval.\n\nReturns\n-------\nG : networkx graph\n\nExamples\n--------\n>>> intervals = [(-2, 3), [1, 4], (2, 3), (4, 6)]\n>>> G = nx.interval_graph(intervals)\n>>> sorted(G.edges)\n[((-2, 3), (1, 4)), ((-2, 3), (2, 3)), ((1, 4), (2, 3)), ((1, 4), (4, 6))]\n\nRaises\n------\n:exc:`TypeError`\n    if `intervals` contains None or an element which is not\n    collections.abc.Sequence or not a length of 2.\n:exc:`ValueError`\n    if `intervals` contains an interval such that min1 > max1\n    where min1,max1 = interval"}, {"type": "function", "name": "networkx.inverse_line_graph", "documentation": "Returns the inverse line graph of graph G.\n\nIf H is a graph, and G is the line graph of H, such that G = L(H).\nThen H is the inverse line graph of G.\n\nNot all graphs are line graphs and these do not have an inverse line graph.\nIn these cases this function raises a NetworkXError.\n\nParameters\n----------\nG : graph\n    A NetworkX Graph\n\nReturns\n-------\nH : graph\n    The inverse line graph of G.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is directed or a multigraph\n\nNetworkXError\n    If G is not a line graph\n\nNotes\n-----\nThis is an implementation of the Roussopoulos algorithm[1]_.\n\nIf G consists of multiple components, then the algorithm doesn't work.\nYou should invert every component separately:\n\n>>> K5 = nx.complete_graph(5)\n>>> P4 = nx.Graph([(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"d\")])\n>>> G = nx.union(K5, P4)\n>>> root_graphs = []\n>>> for comp in nx.connected_components(G):\n...     root_graphs.append(nx.inverse_line_graph(G.subgraph(comp)))\n>>> len(root_graphs)\n2\n\nReferences\n----------\n.. [1] Roussopoulos, N.D. , \"A max {m, n} algorithm for determining the graph H from\n   its line graph G\", Information Processing Letters 2, (1973), 108--112, ISSN 0020-0190,\n   `DOI link <https://doi.org/10.1016/0020-0190(73)90029-X>`_"}, {"type": "function", "name": "networkx.is_aperiodic", "documentation": "Returns True if `G` is aperiodic.\n\nA directed graph is aperiodic if there is no integer k > 1 that\ndivides the length of every cycle in the graph.\n\nParameters\n----------\nG : NetworkX DiGraph\n    A directed graph\n\nReturns\n-------\nbool\n    True if the graph is aperiodic False otherwise\n\nRaises\n------\nNetworkXError\n    If `G` is not directed\n\nExamples\n--------\nA graph consisting of one cycle, the length of which is 2. Therefore ``k = 2``\ndivides the length of every cycle in the graph and thus the graph\nis *not aperiodic*::\n\n    >>> DG = nx.DiGraph([(1, 2), (2, 1)])\n    >>> nx.is_aperiodic(DG)\n    False\n\nA graph consisting of two cycles: one of length 2 and the other of length 3.\nThe cycle lengths are coprime, so there is no single value of k where ``k > 1``\nthat divides each cycle length and therefore the graph is *aperiodic*::\n\n    >>> DG = nx.DiGraph([(1, 2), (2, 3), (3, 1), (1, 4), (4, 1)])\n    >>> nx.is_aperiodic(DG)\n    True\n\nA graph consisting of two cycles: one of length 2 and the other of length 4.\nThe lengths of the cycles share a common factor ``k = 2``, and therefore\nthe graph is *not aperiodic*::\n\n    >>> DG = nx.DiGraph([(1, 2), (2, 1), (3, 4), (4, 5), (5, 6), (6, 3)])\n    >>> nx.is_aperiodic(DG)\n    False\n\nAn acyclic graph, therefore the graph is *not aperiodic*::\n\n    >>> DG = nx.DiGraph([(1, 2), (2, 3)])\n    >>> nx.is_aperiodic(DG)\n    False\n\nNotes\n-----\nThis uses the method outlined in [1]_, which runs in $O(m)$ time\ngiven $m$ edges in `G`. Note that a graph is not aperiodic if it is\nacyclic as every integer trivial divides length 0 cycles.\n\nReferences\n----------\n.. [1] Jarvis, J. P.; Shier, D. R. (1996),\n   \"Graph-theoretic analysis of finite Markov chains,\"\n   in Shier, D. R.; Wallenius, K. T., Applied Mathematical Modeling:\n   A Multidisciplinary Approach, CRC Press."}, {"type": "function", "name": "networkx.is_arborescence", "documentation": "Returns True if `G` is an arborescence.\n\nAn arborescence is a directed tree with maximum in-degree equal to 1.\n\nParameters\n----------\nG : graph\n    The graph to test.\n\nReturns\n-------\nb : bool\n    A boolean that is True if `G` is an arborescence.\n\nExamples\n--------\n>>> G = nx.DiGraph([(0, 1), (0, 2), (2, 3), (3, 4)])\n>>> nx.is_arborescence(G)\nTrue\n>>> G.remove_edge(0, 1)\n>>> G.add_edge(1, 2)  # maximum in-degree is 2\n>>> nx.is_arborescence(G)\nFalse\n\nNotes\n-----\nIn another convention, an arborescence is known as a *tree*.\n\nSee Also\n--------\nis_tree"}, {"type": "function", "name": "networkx.is_at_free", "documentation": "Check if a graph is AT-free.\n\nThe method uses the `find_asteroidal_triple` method to recognize\nan AT-free graph. If no asteroidal triple is found the graph is\nAT-free and True is returned. If at least one asteroidal triple is\nfound the graph is not AT-free and False is returned.\n\nParameters\n----------\nG : NetworkX Graph\n    The graph to check whether is AT-free or not.\n\nReturns\n-------\nbool\n    True if G is AT-free and False otherwise.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (1, 2), (1, 3), (1, 4), (4, 5)])\n>>> nx.is_at_free(G)\nTrue\n\n>>> G = nx.cycle_graph(6)\n>>> nx.is_at_free(G)\nFalse"}, {"type": "function", "name": "networkx.is_attracting_component", "documentation": "Returns True if `G` consists of a single attracting component.\n\nParameters\n----------\nG : DiGraph, MultiDiGraph\n    The graph to be analyzed.\n\nReturns\n-------\nattracting : bool\n    True if `G` has a single attracting component. Otherwise, False.\n\nRaises\n------\nNetworkXNotImplemented\n    If the input graph is undirected.\n\nSee Also\n--------\nattracting_components\nnumber_attracting_components"}, {"type": "function", "name": "networkx.is_biconnected", "documentation": "Returns True if the graph is biconnected, False otherwise.\n\nA graph is biconnected if, and only if, it cannot be disconnected by\nremoving only one node (and all edges incident on that node).  If\nremoving a node increases the number of disconnected components\nin the graph, that node is called an articulation point, or cut\nvertex.  A biconnected graph has no articulation points.\n\nParameters\n----------\nG : NetworkX Graph\n    An undirected graph.\n\nReturns\n-------\nbiconnected : bool\n    True if the graph is biconnected, False otherwise.\n\nRaises\n------\nNetworkXNotImplemented\n    If the input graph is not undirected.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> print(nx.is_biconnected(G))\nFalse\n>>> G.add_edge(0, 3)\n>>> print(nx.is_biconnected(G))\nTrue\n\nSee Also\n--------\nbiconnected_components\narticulation_points\nbiconnected_component_edges\nis_strongly_connected\nis_weakly_connected\nis_connected\nis_semiconnected\n\nNotes\n-----\nThe algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node `n` is an articulation point if, and only\nif, there exists a subtree rooted at `n` such that there is no\nback edge from any successor of `n` that links to a predecessor of\n`n` in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.\n\nReferences\n----------\n.. [1] Hopcroft, J.; Tarjan, R. (1973).\n   \"Efficient algorithms for graph manipulation\".\n   Communications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272"}, {"type": "function", "name": "networkx.is_bipartite", "documentation": "Returns True if graph G is bipartite, False if not.\n\nParameters\n----------\nG : NetworkX graph\n\nExamples\n--------\n>>> from networkx.algorithms import bipartite\n>>> G = nx.path_graph(4)\n>>> print(bipartite.is_bipartite(G))\nTrue\n\nSee Also\n--------\ncolor, is_bipartite_node_set"}, {"type": "function", "name": "networkx.is_branching", "documentation": "Returns True if `G` is a branching.\n\nA branching is a directed forest with maximum in-degree equal to 1.\n\nParameters\n----------\nG : directed graph\n    The directed graph to test.\n\nReturns\n-------\nb : bool\n    A boolean that is True if `G` is a branching.\n\nExamples\n--------\n>>> G = nx.DiGraph([(0, 1), (1, 2), (2, 3), (3, 4)])\n>>> nx.is_branching(G)\nTrue\n>>> G.remove_edge(2, 3)\n>>> G.add_edge(3, 1)  # maximum in-degree is 2\n>>> nx.is_branching(G)\nFalse\n\nNotes\n-----\nIn another convention, a branching is also known as a *forest*.\n\nSee Also\n--------\nis_forest"}, {"type": "function", "name": "networkx.is_chordal", "documentation": "Checks whether G is a chordal graph.\n\nA graph is chordal if every cycle of length at least 4 has a chord\n(an edge joining two nodes not adjacent in the cycle).\n\nParameters\n----------\nG : graph\n  A NetworkX graph.\n\nReturns\n-------\nchordal : bool\n  True if G is a chordal graph and False otherwise.\n\nRaises\n------\nNetworkXNotImplemented\n    The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\n\nExamples\n--------\n>>> e = [\n...     (1, 2),\n...     (1, 3),\n...     (2, 3),\n...     (2, 4),\n...     (3, 4),\n...     (3, 5),\n...     (3, 6),\n...     (4, 5),\n...     (4, 6),\n...     (5, 6),\n... ]\n>>> G = nx.Graph(e)\n>>> nx.is_chordal(G)\nTrue\n\nNotes\n-----\nThe routine tries to go through every node following maximum cardinality\nsearch. It returns False when it finds that the separator for any node\nis not a clique.  Based on the algorithms in [1]_.\n\nSelf loops are ignored.\n\nReferences\n----------\n.. [1] R. E. Tarjan and M. Yannakakis, Simple linear-time algorithms\n   to test chordality of graphs, test acyclicity of hypergraphs, and\n   selectively reduce acyclic hypergraphs, SIAM J. Comput., 13 (1984),\n   pp. 566\u2013579."}, {"type": "function", "name": "networkx.is_connected", "documentation": "Returns True if the graph is connected, False otherwise.\n\nParameters\n----------\nG : NetworkX Graph\n   An undirected graph.\n\nReturns\n-------\nconnected : bool\n  True if the graph is connected, false otherwise.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is directed.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> print(nx.is_connected(G))\nTrue\n\nSee Also\n--------\nis_strongly_connected\nis_weakly_connected\nis_semiconnected\nis_biconnected\nconnected_components\n\nNotes\n-----\nFor undirected graphs only."}, {"type": "function", "name": "networkx.is_d_separator", "documentation": "Return whether node sets `x` and `y` are d-separated by `z`.\n\nParameters\n----------\nG : nx.DiGraph\n    A NetworkX DAG.\n\nx : node or set of nodes\n    First node or set of nodes in `G`.\n\ny : node or set of nodes\n    Second node or set of nodes in `G`.\n\nz : node or set of nodes\n    Potential separator (set of conditioning nodes in `G`). Can be empty set.\n\nReturns\n-------\nb : bool\n    A boolean that is true if `x` is d-separated from `y` given `z` in `G`.\n\nRaises\n------\nNetworkXError\n    The *d-separation* test is commonly used on disjoint sets of\n    nodes in acyclic directed graphs.  Accordingly, the algorithm\n    raises a :exc:`NetworkXError` if the node sets are not\n    disjoint or if the input graph is not a DAG.\n\nNodeNotFound\n    If any of the input nodes are not found in the graph,\n    a :exc:`NodeNotFound` exception is raised\n\nNotes\n-----\nA d-separating set in a DAG is a set of nodes that\nblocks all paths between the two sets. Nodes in `z`\nblock a path if they are part of the path and are not a collider,\nor a descendant of a collider. Also colliders that are not in `z`\nblock a path. A collider structure along a path\nis ``... -> c <- ...`` where ``c`` is the collider node.\n\nhttps://en.wikipedia.org/wiki/Bayesian_network#d-separation"}, {"type": "function", "name": "networkx.is_digraphical", "documentation": "Returns True if some directed graph can realize the in- and out-degree\nsequences.\n\nParameters\n----------\nin_sequence : list or iterable container\n    A sequence of integer node in-degrees\n\nout_sequence : list or iterable container\n    A sequence of integer node out-degrees\n\nReturns\n-------\nvalid : bool\n  True if in and out-sequences are digraphic False if not.\n\nExamples\n--------\n>>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\n>>> in_seq = (d for n, d in G.in_degree())\n>>> out_seq = (d for n, d in G.out_degree())\n>>> nx.is_digraphical(in_seq, out_seq)\nTrue\n\nTo test a non-digraphical scenario:\n>>> in_seq_list = [d for n, d in G.in_degree()]\n>>> in_seq_list[-1] += 1\n>>> nx.is_digraphical(in_seq_list, out_seq)\nFalse\n\nNotes\n-----\nThis algorithm is from Kleitman and Wang [1]_.\nThe worst case runtime is $O(s \\times \\log n)$ where $s$ and $n$ are the\nsum and length of the sequences respectively.\n\nReferences\n----------\n.. [1] D.J. Kleitman and D.L. Wang\n   Algorithms for Constructing Graphs and Digraphs with Given Valences\n   and Factors, Discrete Mathematics, 6(1), pp. 79-88 (1973)"}, {"type": "function", "name": "networkx.is_directed", "documentation": "Return True if graph is directed."}, {"type": "function", "name": "networkx.is_directed_acyclic_graph", "documentation": "Returns True if the graph `G` is a directed acyclic graph (DAG) or\nFalse if not.\n\nParameters\n----------\nG : NetworkX graph\n\nReturns\n-------\nbool\n    True if `G` is a DAG, False otherwise\n\nExamples\n--------\nUndirected graph::\n\n    >>> G = nx.Graph([(1, 2), (2, 3)])\n    >>> nx.is_directed_acyclic_graph(G)\n    False\n\nDirected graph with cycle::\n\n    >>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\n    >>> nx.is_directed_acyclic_graph(G)\n    False\n\nDirected acyclic graph::\n\n    >>> G = nx.DiGraph([(1, 2), (2, 3)])\n    >>> nx.is_directed_acyclic_graph(G)\n    True\n\nSee also\n--------\ntopological_sort"}, {"type": "function", "name": "networkx.is_distance_regular", "documentation": "Returns True if the graph is distance regular, False otherwise.\n\nA connected graph G is distance-regular if for any nodes x,y\nand any integers i,j=0,1,...,d (where d is the graph\ndiameter), the number of vertices at distance i from x and\ndistance j from y depends only on i,j and the graph distance\nbetween x and y, independently of the choice of x and y.\n\nParameters\n----------\nG: Networkx graph (undirected)\n\nReturns\n-------\nbool\n  True if the graph is Distance Regular, False otherwise\n\nExamples\n--------\n>>> G = nx.hypercube_graph(6)\n>>> nx.is_distance_regular(G)\nTrue\n\nSee Also\n--------\nintersection_array, global_parameters\n\nNotes\n-----\nFor undirected and simple graphs only\n\nReferences\n----------\n.. [1] Brouwer, A. E.; Cohen, A. M.; and Neumaier, A.\n    Distance-Regular Graphs. New York: Springer-Verlag, 1989.\n.. [2] Weisstein, Eric W. \"Distance-Regular Graph.\"\n    http://mathworld.wolfram.com/Distance-RegularGraph.html"}, {"type": "function", "name": "networkx.is_dominating_set", "documentation": "Checks if `nbunch` is a dominating set for `G`.\n\nA *dominating set* for a graph with node set *V* is a subset *D* of\n*V* such that every node not in *D* is adjacent to at least one\nmember of *D* [1]_.\n\nParameters\n----------\nG : NetworkX graph\n\nnbunch : iterable\n    An iterable of nodes in the graph `G`.\n\nSee also\n--------\ndominating_set\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Dominating_set"}, {"type": "function", "name": "networkx.is_edge_cover", "documentation": "Decides whether a set of edges is a valid edge cover of the graph.\n\nGiven a set of edges, whether it is an edge covering can\nbe decided if we just check whether all nodes of the graph\nhas an edge from the set, incident on it.\n\nParameters\n----------\nG : NetworkX graph\n    An undirected bipartite graph.\n\ncover : set\n    Set of edges to be checked.\n\nReturns\n-------\nbool\n    Whether the set of edges is a valid edge cover of the graph.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n>>> cover = {(2, 1), (3, 0)}\n>>> nx.is_edge_cover(G, cover)\nTrue\n\nNotes\n-----\nAn edge cover of a graph is a set of edges such that every node of\nthe graph is incident to at least one edge of the set."}, {"type": "function", "name": "networkx.is_empty", "documentation": "Returns True if `G` has no edges.\n\nParameters\n----------\nG : graph\n    A NetworkX graph.\n\nReturns\n-------\nbool\n    True if `G` has no edges, and False otherwise.\n\nNotes\n-----\nAn empty graph can have nodes but not edges. The empty graph with zero\nnodes is known as the null graph. This is an $O(n)$ operation where n\nis the number of nodes in the graph."}, {"type": "function", "name": "networkx.is_eulerian", "documentation": "Returns True if and only if `G` is Eulerian.\n\nA graph is *Eulerian* if it has an Eulerian circuit. An *Eulerian\ncircuit* is a closed walk that includes each edge of a graph exactly\nonce.\n\nGraphs with isolated vertices (i.e. vertices with zero degree) are not\nconsidered to have Eulerian circuits. Therefore, if the graph is not\nconnected (or not strongly connected, for directed graphs), this function\nreturns False.\n\nParameters\n----------\nG : NetworkX graph\n   A graph, either directed or undirected.\n\nExamples\n--------\n>>> nx.is_eulerian(nx.DiGraph({0: [3], 1: [2], 2: [3], 3: [0, 1]}))\nTrue\n>>> nx.is_eulerian(nx.complete_graph(5))\nTrue\n>>> nx.is_eulerian(nx.petersen_graph())\nFalse\n\nIf you prefer to allow graphs with isolated vertices to have Eulerian circuits,\nyou can first remove such vertices and then call `is_eulerian` as below example shows.\n\n>>> G = nx.Graph([(0, 1), (1, 2), (0, 2)])\n>>> G.add_node(3)\n>>> nx.is_eulerian(G)\nFalse\n\n>>> G.remove_nodes_from(list(nx.isolates(G)))\n>>> nx.is_eulerian(G)\nTrue"}, {"type": "function", "name": "networkx.is_forest", "documentation": "Returns True if `G` is a forest.\n\nA forest is a graph with no undirected cycles.\n\nFor directed graphs, `G` is a forest if the underlying graph is a forest.\nThe underlying graph is obtained by treating each directed edge as a single\nundirected edge in a multigraph.\n\nParameters\n----------\nG : graph\n    The graph to test.\n\nReturns\n-------\nb : bool\n    A boolean that is True if `G` is a forest.\n\nRaises\n------\nNetworkXPointlessConcept\n    If `G` is empty.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_edges_from([(1, 2), (1, 3), (2, 4), (2, 5)])\n>>> nx.is_forest(G)\nTrue\n>>> G.add_edge(4, 1)\n>>> nx.is_forest(G)\nFalse\n\nNotes\n-----\nIn another convention, a directed forest is known as a *polyforest* and\nthen *forest* corresponds to a *branching*.\n\nSee Also\n--------\nis_branching"}, {"type": "function", "name": "networkx.is_frozen", "documentation": "Returns True if graph is frozen.\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nSee Also\n--------\nfreeze"}, {"type": "function", "name": "networkx.is_graphical", "documentation": "Returns True if sequence is a valid degree sequence.\n\nA degree sequence is valid if some graph can realize it.\n\nParameters\n----------\nsequence : list or iterable container\n    A sequence of integer node degrees\n\nmethod : \"eg\" | \"hh\"  (default: 'eg')\n    The method used to validate the degree sequence.\n    \"eg\" corresponds to the Erd\u0151s-Gallai algorithm\n    [EG1960]_, [choudum1986]_, and\n    \"hh\" to the Havel-Hakimi algorithm\n    [havel1955]_, [hakimi1962]_, [CL1996]_.\n\nReturns\n-------\nvalid : bool\n    True if the sequence is a valid degree sequence and False if not.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> sequence = (d for n, d in G.degree())\n>>> nx.is_graphical(sequence)\nTrue\n\nTo test a non-graphical sequence:\n>>> sequence_list = [d for n, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_graphical(sequence_list)\nFalse\n\nReferences\n----------\n.. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.\n.. [choudum1986] S.A. Choudum. \"A simple proof of the Erd\u0151s-Gallai theorem on\n   graph sequences.\" Bulletin of the Australian Mathematical Society, 33,\n   pp 67-70, 1986. https://doi.org/10.1017/S0004972700002872\n.. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\n   Casopis Pest. Mat. 80, 477-480, 1955.\n.. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\n   Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\n.. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\n   Chapman and Hall/CRC, 1996."}, {"type": "function", "name": "networkx.is_isolate", "documentation": "Determines whether a node is an isolate.\n\nAn *isolate* is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors.\n\nParameters\n----------\nG : NetworkX graph\n\nn : node\n    A node in `G`.\n\nReturns\n-------\nis_isolate : bool\n   True if and only if `n` has no neighbors.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_edge(1, 2)\n>>> G.add_node(3)\n>>> nx.is_isolate(G, 2)\nFalse\n>>> nx.is_isolate(G, 3)\nTrue"}, {"type": "function", "name": "networkx.is_isomorphic", "documentation": "Returns True if the graphs G1 and G2 are isomorphic and False otherwise.\n\nParameters\n----------\nG1, G2: graphs\n    The two graphs G1 and G2 must be the same type.\n\nnode_match : callable\n    A function that returns True if node n1 in G1 and n2 in G2 should\n    be considered equal during the isomorphism test.\n    If node_match is not specified then node attributes are not considered.\n\n    The function will be called like\n\n       node_match(G1.nodes[n1], G2.nodes[n2]).\n\n    That is, the function will receive the node attribute dictionaries\n    for n1 and n2 as inputs.\n\nedge_match : callable\n    A function that returns True if the edge attribute dictionary\n    for the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\n    be considered equal during the isomorphism test.  If edge_match is\n    not specified then edge attributes are not considered.\n\n    The function will be called like\n\n       edge_match(G1[u1][v1], G2[u2][v2]).\n\n    That is, the function will receive the edge attribute dictionaries\n    of the edges under consideration.\n\nNotes\n-----\nUses the vf2 algorithm [1]_.\n\nExamples\n--------\n>>> import networkx.algorithms.isomorphism as iso\n\nFor digraphs G1 and G2, using 'weight' edge attribute (default: 1)\n\n>>> G1 = nx.DiGraph()\n>>> G2 = nx.DiGraph()\n>>> nx.add_path(G1, [1, 2, 3, 4], weight=1)\n>>> nx.add_path(G2, [10, 20, 30, 40], weight=2)\n>>> em = iso.numerical_edge_match(\"weight\", 1)\n>>> nx.is_isomorphic(G1, G2)  # no weights considered\nTrue\n>>> nx.is_isomorphic(G1, G2, edge_match=em)  # match weights\nFalse\n\nFor multidigraphs G1 and G2, using 'fill' node attribute (default: '')\n\n>>> G1 = nx.MultiDiGraph()\n>>> G2 = nx.MultiDiGraph()\n>>> G1.add_nodes_from([1, 2, 3], fill=\"red\")\n>>> G2.add_nodes_from([10, 20, 30, 40], fill=\"red\")\n>>> nx.add_path(G1, [1, 2, 3, 4], weight=3, linewidth=2.5)\n>>> nx.add_path(G2, [10, 20, 30, 40], weight=3)\n>>> nm = iso.categorical_node_match(\"fill\", \"red\")\n>>> nx.is_isomorphic(G1, G2, node_match=nm)\nTrue\n\nFor multidigraphs G1 and G2, using 'weight' edge attribute (default: 7)\n\n>>> G1.add_edge(1, 2, weight=7)\n1\n>>> G2.add_edge(10, 20)\n1\n>>> em = iso.numerical_multiedge_match(\"weight\", 7, rtol=1e-6)\n>>> nx.is_isomorphic(G1, G2, edge_match=em)\nTrue\n\nFor multigraphs G1 and G2, using 'weight' and 'linewidth' edge attributes\nwith default values 7 and 2.5. Also using 'fill' node attribute with\ndefault value 'red'.\n\n>>> em = iso.numerical_multiedge_match([\"weight\", \"linewidth\"], [7, 2.5])\n>>> nm = iso.categorical_node_match(\"fill\", \"red\")\n>>> nx.is_isomorphic(G1, G2, edge_match=em, node_match=nm)\nTrue\n\nSee Also\n--------\nnumerical_node_match, numerical_edge_match, numerical_multiedge_match\ncategorical_node_match, categorical_edge_match, categorical_multiedge_match\n\nReferences\n----------\n.. [1]  L. P. Cordella, P. Foggia, C. Sansone, M. Vento,\n   \"An Improved Algorithm for Matching Large Graphs\",\n   3rd IAPR-TC15 Workshop  on Graph-based Representations in\n   Pattern Recognition, Cuen, pp. 149-159, 2001.\n   https://www.researchgate.net/publication/200034365_An_Improved_Algorithm_for_Matching_Large_Graphs"}, {"type": "function", "name": "networkx.is_k_edge_connected", "documentation": "Tests to see if a graph is k-edge-connected.\n\nIs it impossible to disconnect the graph by removing fewer than k edges?\nIf so, then G is k-edge-connected.\n\nParameters\n----------\nG : NetworkX graph\n   An undirected graph.\n\nk : integer\n    edge connectivity to test for\n\nReturns\n-------\nboolean\n    True if G is k-edge-connected.\n\nSee Also\n--------\n:func:`is_locally_k_edge_connected`\n\nExamples\n--------\n>>> G = nx.barbell_graph(10, 0)\n>>> nx.is_k_edge_connected(G, k=1)\nTrue\n>>> nx.is_k_edge_connected(G, k=2)\nFalse"}, {"type": "function", "name": "networkx.is_k_regular", "documentation": "Determines whether the graph ``G`` is a k-regular graph.\n\nA k-regular graph is a graph where each vertex has degree k.\n\nParameters\n----------\nG : NetworkX graph\n\nReturns\n-------\nbool\n    Whether the given graph is k-regular.\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (2, 3), (3, 4), (4, 1)])\n>>> nx.is_k_regular(G, k=3)\nFalse"}, {"type": "function", "name": "networkx.is_kl_connected", "documentation": "Returns True if and only if `G` is locally `(k, l)`-connected.\n\nA graph is locally `(k, l)`-connected if for each edge `(u, v)` in the\ngraph there are at least `l` edge-disjoint paths of length at most `k`\njoining `u` to `v`.\n\nParameters\n----------\nG : NetworkX graph\n    The graph to test for local `(k, l)`-connectedness.\n\nk : integer\n    The maximum length of paths to consider. A higher number means a looser\n    connectivity requirement.\n\nl : integer\n    The number of edge-disjoint paths. A higher number means a stricter\n    connectivity requirement.\n\nlow_memory : bool\n    If this is True, this function uses an algorithm that uses slightly\n    more time but less memory.\n\nReturns\n-------\nbool\n    Whether the graph is locally `(k, l)`-connected subgraph.\n\nSee also\n--------\nkl_connected_subgraph\n\nReferences\n----------\n.. [1] Chung, Fan and Linyuan Lu. \"The Small World Phenomenon in Hybrid\n       Power Law Graphs.\" *Complex Networks*. Springer Berlin Heidelberg,\n       2004. 89--104."}, {"type": "function", "name": "networkx.is_matching", "documentation": "Return True if ``matching`` is a valid matching of ``G``\n\nA *matching* in a graph is a set of edges in which no two distinct\nedges share a common endpoint. Each node is incident to at most one\nedge in the matching. The edges are said to be independent.\n\nParameters\n----------\nG : NetworkX graph\n\nmatching : dict or set\n    A dictionary or set representing a matching. If a dictionary, it\n    must have ``matching[u] == v`` and ``matching[v] == u`` for each\n    edge ``(u, v)`` in the matching. If a set, it must have elements\n    of the form ``(u, v)``, where ``(u, v)`` is an edge in the\n    matching.\n\nReturns\n-------\nbool\n    Whether the given set or dictionary represents a valid matching\n    in the graph.\n\nRaises\n------\nNetworkXError\n    If the proposed matching has an edge to a node not in G.\n    Or if the matching is not a collection of 2-tuple edges.\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 5)])\n>>> nx.is_maximal_matching(G, {1: 3, 2: 4})  # using dict to represent matching\nTrue\n\n>>> nx.is_matching(G, {(1, 3), (2, 4)})  # using set to represent matching\nTrue"}, {"type": "function", "name": "networkx.is_maximal_matching", "documentation": "Return True if ``matching`` is a maximal matching of ``G``\n\nA *maximal matching* in a graph is a matching in which adding any\nedge would cause the set to no longer be a valid matching.\n\nParameters\n----------\nG : NetworkX graph\n\nmatching : dict or set\n    A dictionary or set representing a matching. If a dictionary, it\n    must have ``matching[u] == v`` and ``matching[v] == u`` for each\n    edge ``(u, v)`` in the matching. If a set, it must have elements\n    of the form ``(u, v)``, where ``(u, v)`` is an edge in the\n    matching.\n\nReturns\n-------\nbool\n    Whether the given set or dictionary represents a valid maximal\n    matching in the graph.\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (3, 5)])\n>>> nx.is_maximal_matching(G, {(1, 2), (3, 4)})\nTrue"}, {"type": "function", "name": "networkx.is_minimal_d_separator", "documentation": "Determine if `z` is a minimal d-separator for `x` and `y`.\n\nA d-separator, `z`, in a DAG is a set of nodes that blocks\nall paths from nodes in set `x` to nodes in set `y`.\nA minimal d-separator is a d-separator `z` such that removing\nany subset of nodes makes it no longer a d-separator.\n\nNote: This function checks whether `z` is a d-separator AND is\nminimal. One can use the function `is_d_separator` to only check if\n`z` is a d-separator. See examples below.\n\nParameters\n----------\nG : nx.DiGraph\n    A NetworkX DAG.\nx : node | set\n    A node or set of nodes in the graph.\ny : node | set\n    A node or set of nodes in the graph.\nz : node | set\n    The node or set of nodes to check if it is a minimal d-separating set.\n    The function :func:`is_d_separator` is called inside this function\n    to verify that `z` is in fact a d-separator.\nincluded : set | node | None\n    A node or set of nodes which must be included in the found separating set,\n    default is ``None``, which means the empty set.\nrestricted : set | node | None\n    Restricted node or set of nodes to consider. Only these nodes can be in\n    the found separating set, default is ``None`` meaning all nodes in ``G``.\n\nReturns\n-------\nbool\n    Whether or not the set `z` is a minimal d-separator subject to\n    `restricted` nodes and `included` node constraints.\n\nExamples\n--------\n>>> G = nx.path_graph([0, 1, 2, 3], create_using=nx.DiGraph)\n>>> G.add_node(4)\n>>> nx.is_minimal_d_separator(G, 0, 2, {1})\nTrue\n>>> # since {1} is the minimal d-separator, {1, 3, 4} is not minimal\n>>> nx.is_minimal_d_separator(G, 0, 2, {1, 3, 4})\nFalse\n>>> # alternatively, if we only want to check that {1, 3, 4} is a d-separator\n>>> nx.is_d_separator(G, 0, 2, {1, 3, 4})\nTrue\n\nRaises\n------\nNetworkXError\n    Raises a :exc:`NetworkXError` if the input graph is not a DAG.\n\nNodeNotFound\n    If any of the input nodes are not found in the graph,\n    a :exc:`NodeNotFound` exception is raised.\n\nReferences\n----------\n.. [1] van der Zander, Benito, and Maciej Li\u015bkiewicz. \"Finding\n    minimal d-separators in linear time and applications.\" In\n    Uncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020.\n\nNotes\n-----\nThis function works on verifying that a set is minimal and\nd-separating between two nodes. Uses criterion (a), (b), (c) on\npage 4 of [1]_. a) closure(`x`) and `y` are disjoint. b) `z` contains\nall nodes from `included` and is contained in the `restricted`\nnodes and in the union of ancestors of `x`, `y`, and `included`.\nc) the nodes in `z` not in `included` are contained in both\nclosure(x) and closure(y). The closure of a set is the set of nodes\nconnected to the set by a directed path in G.\n\nThe complexity is :math:`O(m)`, where :math:`m` stands for the\nnumber of edges in the subgraph of G consisting of only the\nancestors of `x` and `y`.\n\nFor full details, see [1]_."}, {"type": "function", "name": "networkx.is_multigraphical", "documentation": "Returns True if some multigraph can realize the sequence.\n\nParameters\n----------\nsequence : list\n    A list of integers\n\nReturns\n-------\nvalid : bool\n    True if deg_sequence is a multigraphic degree sequence and False if not.\n\nExamples\n--------\n>>> G = nx.MultiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\n>>> sequence = (d for _, d in G.degree())\n>>> nx.is_multigraphical(sequence)\nTrue\n\nTo test a non-multigraphical sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_multigraphical(sequence_list)\nFalse\n\nNotes\n-----\nThe worst-case run time is $O(n)$ where $n$ is the length of the sequence.\n\nReferences\n----------\n.. [1] S. L. Hakimi. \"On the realizability of a set of integers as\n   degrees of the vertices of a linear graph\", J. SIAM, 10, pp. 496-506\n   (1962)."}, {"type": "function", "name": "networkx.is_negatively_weighted", "documentation": "Returns True if `G` has negatively weighted edges.\n\nParameters\n----------\nG : graph\n    A NetworkX graph.\n\nedge : tuple, optional\n    A 2-tuple specifying the only edge in `G` that will be tested. If\n    None, then every edge in `G` is tested.\n\nweight: string, optional\n    The attribute name used to query for edge weights.\n\nReturns\n-------\nbool\n    A boolean signifying if `G`, or the specified edge, is negatively\n    weighted.\n\nRaises\n------\nNetworkXError\n    If the specified edge does not exist.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_edges_from([(1, 3), (2, 4), (2, 6)])\n>>> G.add_edge(1, 2, weight=4)\n>>> nx.is_negatively_weighted(G, (1, 2))\nFalse\n>>> G[2][4][\"weight\"] = -2\n>>> nx.is_negatively_weighted(G)\nTrue\n>>> G = nx.DiGraph()\n>>> edges = [(\"0\", \"3\", 3), (\"0\", \"1\", -5), (\"1\", \"0\", -2)]\n>>> G.add_weighted_edges_from(edges)\n>>> nx.is_negatively_weighted(G)\nTrue"}, {"type": "function", "name": "networkx.is_path", "documentation": "Returns whether or not the specified path exists.\n\nFor it to return True, every node on the path must exist and\neach consecutive pair must be connected via one or more edges.\n\nParameters\n----------\nG : graph\n    A NetworkX graph.\n\npath : list\n    A list of nodes which defines the path to traverse\n\nReturns\n-------\nbool\n    True if `path` is a valid path in `G`"}, {"type": "function", "name": "networkx.is_perfect_matching", "documentation": "Return True if ``matching`` is a perfect matching for ``G``\n\nA *perfect matching* in a graph is a matching in which exactly one edge\nis incident upon each vertex.\n\nParameters\n----------\nG : NetworkX graph\n\nmatching : dict or set\n    A dictionary or set representing a matching. If a dictionary, it\n    must have ``matching[u] == v`` and ``matching[v] == u`` for each\n    edge ``(u, v)`` in the matching. If a set, it must have elements\n    of the form ``(u, v)``, where ``(u, v)`` is an edge in the\n    matching.\n\nReturns\n-------\nbool\n    Whether the given set or dictionary represents a valid perfect\n    matching in the graph.\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 5), (4, 6)])\n>>> my_match = {1: 2, 3: 5, 4: 6}\n>>> nx.is_perfect_matching(G, my_match)\nTrue"}, {"type": "function", "name": "networkx.is_planar", "documentation": "Returns True if and only if `G` is planar.\n\nA graph is *planar* iff it can be drawn in a plane without\nany edge intersections.\n\nParameters\n----------\nG : NetworkX graph\n\nReturns\n-------\nbool\n   Whether the graph is planar.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2)])\n>>> nx.is_planar(G)\nTrue\n>>> nx.is_planar(nx.complete_graph(5))\nFalse\n\nSee Also\n--------\ncheck_planarity :\n    Check if graph is planar *and* return a `PlanarEmbedding` instance if True."}, {"type": "function", "name": "networkx.is_pseudographical", "documentation": "Returns True if some pseudograph can realize the sequence.\n\nEvery nonnegative integer sequence with an even sum is pseudographical\n(see [1]_).\n\nParameters\n----------\nsequence : list or iterable container\n    A sequence of integer node degrees\n\nReturns\n-------\nvalid : bool\n  True if the sequence is a pseudographic degree sequence and False if not.\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\n>>> sequence = (d for _, d in G.degree())\n>>> nx.is_pseudographical(sequence)\nTrue\n\nTo test a non-pseudographical sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_pseudographical(sequence_list)\nFalse\n\nNotes\n-----\nThe worst-case run time is $O(n)$ where n is the length of the sequence.\n\nReferences\n----------\n.. [1] F. Boesch and F. Harary. \"Line removal algorithms for graphs\n   and their degree lists\", IEEE Trans. Circuits and Systems, CAS-23(12),\n   pp. 778-782 (1976)."}, {"type": "function", "name": "networkx.is_regular", "documentation": "Determines whether the graph ``G`` is a regular graph.\n\nA regular graph is a graph where each vertex has the same degree. A\nregular digraph is a graph where the indegree and outdegree of each\nvertex are equal.\n\nParameters\n----------\nG : NetworkX graph\n\nReturns\n-------\nbool\n    Whether the given graph or digraph is regular.\n\nExamples\n--------\n>>> G = nx.DiGraph([(1, 2), (2, 3), (3, 4), (4, 1)])\n>>> nx.is_regular(G)\nTrue"}, {"type": "function", "name": "networkx.is_regular_expander", "documentation": "Determines whether the graph G is a regular expander. [1]_\n\nAn expander graph is a sparse graph with strong connectivity properties.\n\nMore precisely, this helper checks whether the graph is a\nregular $(n, d, \\lambda)$-expander with $\\lambda$ close to\nthe Alon-Boppana bound and given by\n$\\lambda = 2 \\sqrt{d - 1} + \\epsilon$. [2]_\n\nIn the case where $\\epsilon = 0$ then if the graph successfully passes the test\nit is a Ramanujan graph. [3]_\n\nA Ramanujan graph has spectral gap almost as large as possible, which makes them\nexcellent expanders.\n\nParameters\n----------\nG : NetworkX graph\nepsilon : int, float, default=0\n\nReturns\n-------\nbool\n    Whether the given graph is a regular $(n, d, \\lambda)$-expander\n    where $\\lambda = 2 \\sqrt{d - 1} + \\epsilon$.\n\nExamples\n--------\n>>> G = nx.random_regular_expander_graph(20, 4)\n>>> nx.is_regular_expander(G)\nTrue\n\nSee Also\n--------\nmaybe_regular_expander\nrandom_regular_expander_graph\n\nReferences\n----------\n.. [1] Expander graph, https://en.wikipedia.org/wiki/Expander_graph\n.. [2] Alon-Boppana bound, https://en.wikipedia.org/wiki/Alon%E2%80%93Boppana_bound\n.. [3] Ramanujan graphs, https://en.wikipedia.org/wiki/Ramanujan_graph"}, {"type": "function", "name": "networkx.is_semiconnected", "documentation": "Returns True if the graph is semiconnected, False otherwise.\n\nA graph is semiconnected if and only if for any pair of nodes, either one\nis reachable from the other, or they are mutually reachable.\n\nThis function uses a theorem that states that a DAG is semiconnected\nif for any topological sort, for node $v_n$ in that sort, there is an\nedge $(v_i, v_{i+1})$. That allows us to check if a non-DAG `G` is\nsemiconnected by condensing the graph: i.e. constructing a new graph `H`\nwith nodes being the strongly connected components of `G`, and edges\n(scc_1, scc_2) if there is a edge $(v_1, v_2)$ in `G` for some\n$v_1 \\in scc_1$ and $v_2 \\in scc_2$. That results in a DAG, so we compute\nthe topological sort of `H` and check if for every $n$ there is an edge\n$(scc_n, scc_{n+1})$.\n\nParameters\n----------\nG : NetworkX graph\n    A directed graph.\n\nReturns\n-------\nsemiconnected : bool\n    True if the graph is semiconnected, False otherwise.\n\nRaises\n------\nNetworkXNotImplemented\n    If the input graph is undirected.\n\nNetworkXPointlessConcept\n    If the graph is empty.\n\nExamples\n--------\n>>> G = nx.path_graph(4, create_using=nx.DiGraph())\n>>> print(nx.is_semiconnected(G))\nTrue\n>>> G = nx.DiGraph([(1, 2), (3, 2)])\n>>> print(nx.is_semiconnected(G))\nFalse\n\nSee Also\n--------\nis_strongly_connected\nis_weakly_connected\nis_connected\nis_biconnected"}, {"type": "function", "name": "networkx.is_semieulerian", "documentation": "Return True iff `G` is semi-Eulerian.\n\nG is semi-Eulerian if it has an Eulerian path but no Eulerian circuit.\n\nSee Also\n--------\nhas_eulerian_path\nis_eulerian"}, {"type": "function", "name": "networkx.is_simple_path", "documentation": "Returns True if and only if `nodes` form a simple path in `G`.\n\nA *simple path* in a graph is a nonempty sequence of nodes in which\nno node appears more than once in the sequence, and each adjacent\npair of nodes in the sequence is adjacent in the graph.\n\nParameters\n----------\nG : graph\n    A NetworkX graph.\nnodes : list\n    A list of one or more nodes in the graph `G`.\n\nReturns\n-------\nbool\n    Whether the given list of nodes represents a simple path in `G`.\n\nNotes\n-----\nAn empty list of nodes is not a path but a list of one node is a\npath. Here's an explanation why.\n\nThis function operates on *node paths*. One could also consider\n*edge paths*. There is a bijection between node paths and edge\npaths.\n\nThe *length of a path* is the number of edges in the path, so a list\nof nodes of length *n* corresponds to a path of length *n* - 1.\nThus the smallest edge path would be a list of zero edges, the empty\npath. This corresponds to a list of one node.\n\nTo convert between a node path and an edge path, you can use code\nlike the following::\n\n    >>> from networkx.utils import pairwise\n    >>> nodes = [0, 1, 2, 3]\n    >>> edges = list(pairwise(nodes))\n    >>> edges\n    [(0, 1), (1, 2), (2, 3)]\n    >>> nodes = [edges[0][0]] + [v for u, v in edges]\n    >>> nodes\n    [0, 1, 2, 3]\n\nExamples\n--------\n>>> G = nx.cycle_graph(4)\n>>> nx.is_simple_path(G, [2, 3, 0])\nTrue\n>>> nx.is_simple_path(G, [0, 2])\nFalse"}, {"type": "function", "name": "networkx.is_strongly_connected", "documentation": "Test directed graph for strong connectivity.\n\nA directed graph is strongly connected if and only if every vertex in\nthe graph is reachable from every other vertex.\n\nParameters\n----------\nG : NetworkX Graph\n   A directed graph.\n\nReturns\n-------\nconnected : bool\n  True if the graph is strongly connected, False otherwise.\n\nExamples\n--------\n>>> G = nx.DiGraph([(0, 1), (1, 2), (2, 3), (3, 0), (2, 4), (4, 2)])\n>>> nx.is_strongly_connected(G)\nTrue\n>>> G.remove_edge(2, 3)\n>>> nx.is_strongly_connected(G)\nFalse\n\nRaises\n------\nNetworkXNotImplemented\n    If G is undirected.\n\nSee Also\n--------\nis_weakly_connected\nis_semiconnected\nis_connected\nis_biconnected\nstrongly_connected_components\n\nNotes\n-----\nFor directed graphs only."}, {"type": "function", "name": "networkx.is_strongly_regular", "documentation": "Returns True if and only if the given graph is strongly\nregular.\n\nAn undirected graph is *strongly regular* if\n\n* it is regular,\n* each pair of adjacent vertices has the same number of neighbors in\n  common,\n* each pair of nonadjacent vertices has the same number of neighbors\n  in common.\n\nEach strongly regular graph is a distance-regular graph.\nConversely, if a distance-regular graph has diameter two, then it is\na strongly regular graph. For more information on distance-regular\ngraphs, see :func:`is_distance_regular`.\n\nParameters\n----------\nG : NetworkX graph\n    An undirected graph.\n\nReturns\n-------\nbool\n    Whether `G` is strongly regular.\n\nExamples\n--------\n\nThe cycle graph on five vertices is strongly regular. It is\ntwo-regular, each pair of adjacent vertices has no shared neighbors,\nand each pair of nonadjacent vertices has one shared neighbor::\n\n    >>> G = nx.cycle_graph(5)\n    >>> nx.is_strongly_regular(G)\n    True"}, {"type": "function", "name": "networkx.is_tournament", "documentation": "Returns True if and only if `G` is a tournament.\n\nA tournament is a directed graph, with neither self-loops nor\nmulti-edges, in which there is exactly one directed edge joining\neach pair of distinct nodes.\n\nParameters\n----------\nG : NetworkX graph\n    A directed graph representing a tournament.\n\nReturns\n-------\nbool\n    Whether the given graph is a tournament graph.\n\nExamples\n--------\n>>> G = nx.DiGraph([(0, 1), (1, 2), (2, 0)])\n>>> nx.is_tournament(G)\nTrue\n\nNotes\n-----\nSome definitions require a self-loop on each node, but that is not\nthe convention used here."}, {"type": "function", "name": "networkx.is_tree", "documentation": "Returns True if `G` is a tree.\n\nA tree is a connected graph with no undirected cycles.\n\nFor directed graphs, `G` is a tree if the underlying graph is a tree. The\nunderlying graph is obtained by treating each directed edge as a single\nundirected edge in a multigraph.\n\nParameters\n----------\nG : graph\n    The graph to test.\n\nReturns\n-------\nb : bool\n    A boolean that is True if `G` is a tree.\n\nRaises\n------\nNetworkXPointlessConcept\n    If `G` is empty.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_edges_from([(1, 2), (1, 3), (2, 4), (2, 5)])\n>>> nx.is_tree(G)  # n-1 edges\nTrue\n>>> G.add_edge(3, 4)\n>>> nx.is_tree(G)  # n edges\nFalse\n\nNotes\n-----\nIn another convention, a directed tree is known as a *polytree* and then\n*tree* corresponds to an *arborescence*.\n\nSee Also\n--------\nis_arborescence"}, {"type": "function", "name": "networkx.is_triad", "documentation": "Returns True if the graph G is a triad, else False.\n\nParameters\n----------\nG : graph\n   A NetworkX Graph\n\nReturns\n-------\nistriad : boolean\n   Whether G is a valid triad\n\nExamples\n--------\n>>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\n>>> nx.is_triad(G)\nTrue\n>>> G.add_edge(0, 1)\n>>> nx.is_triad(G)\nFalse"}, {"type": "function", "name": "networkx.is_valid_degree_sequence_erdos_gallai", "documentation": "Returns True if deg_sequence can be realized by a simple graph.\n\nThe validation is done using the Erd\u0151s-Gallai theorem [EG1960]_.\n\nParameters\n----------\ndeg_sequence : list\n    A list of integers\n\nReturns\n-------\nvalid : bool\n    True if deg_sequence is graphical and False if not.\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\n>>> sequence = (d for _, d in G.degree())\n>>> nx.is_valid_degree_sequence_erdos_gallai(sequence)\nTrue\n\nTo test a non-valid sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_valid_degree_sequence_erdos_gallai(sequence_list)\nFalse\n\nNotes\n-----\n\nThis implementation uses an equivalent form of the Erd\u0151s-Gallai criterion.\nWorst-case run time is $O(n)$ where $n$ is the length of the sequence.\n\nSpecifically, a sequence d is graphical if and only if the\nsum of the sequence is even and for all strong indices k in the sequence,\n\n .. math::\n\n   \\sum_{i=1}^{k} d_i \\leq k(k-1) + \\sum_{j=k+1}^{n} \\min(d_i,k)\n         = k(n-1) - ( k \\sum_{j=0}^{k-1} n_j - \\sum_{j=0}^{k-1} j n_j )\n\nA strong index k is any index where d_k >= k and the value n_j is the\nnumber of occurrences of j in d.  The maximal strong index is called the\nDurfee index.\n\nThis particular rearrangement comes from the proof of Theorem 3 in [2]_.\n\nThe ZZ condition says that for the sequence d if\n\n.. math::\n    |d| >= \\frac{(\\max(d) + \\min(d) + 1)^2}{4*\\min(d)}\n\nthen d is graphical.  This was shown in Theorem 6 in [2]_.\n\nReferences\n----------\n.. [1] A. Tripathi and S. Vijay. \"A note on a theorem of Erd\u0151s & Gallai\",\n   Discrete Mathematics, 265, pp. 417-420 (2003).\n.. [2] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\n   of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\n.. [EG1960] Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960."}, {"type": "function", "name": "networkx.is_valid_degree_sequence_havel_hakimi", "documentation": "Returns True if deg_sequence can be realized by a simple graph.\n\nThe validation proceeds using the Havel-Hakimi theorem\n[havel1955]_, [hakimi1962]_, [CL1996]_.\nWorst-case run time is $O(s)$ where $s$ is the sum of the sequence.\n\nParameters\n----------\ndeg_sequence : list\n    A list of integers where each element specifies the degree of a node\n    in a graph.\n\nReturns\n-------\nvalid : bool\n    True if deg_sequence is graphical and False if not.\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (3, 4), (4, 2), (5, 1), (5, 4)])\n>>> sequence = (d for _, d in G.degree())\n>>> nx.is_valid_degree_sequence_havel_hakimi(sequence)\nTrue\n\nTo test a non-valid sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_valid_degree_sequence_havel_hakimi(sequence_list)\nFalse\n\nNotes\n-----\nThe ZZ condition says that for the sequence d if\n\n.. math::\n    |d| >= \\frac{(\\max(d) + \\min(d) + 1)^2}{4*\\min(d)}\n\nthen d is graphical.  This was shown in Theorem 6 in [1]_.\n\nReferences\n----------\n.. [1] I.E. Zverovich and V.E. Zverovich. \"Contributions to the theory\n   of graphic sequences\", Discrete Mathematics, 105, pp. 292-303 (1992).\n.. [havel1955] Havel, V. \"A Remark on the Existence of Finite Graphs\"\n   Casopis Pest. Mat. 80, 477-480, 1955.\n.. [hakimi1962] Hakimi, S. \"On the Realizability of a Set of Integers as\n   Degrees of the Vertices of a Graph.\" SIAM J. Appl. Math. 10, 496-506, 1962.\n.. [CL1996] G. Chartrand and L. Lesniak, \"Graphs and Digraphs\",\n   Chapman and Hall/CRC, 1996."}, {"type": "function", "name": "networkx.is_valid_directed_joint_degree", "documentation": "Checks whether the given directed joint degree input is realizable\n\nParameters\n----------\nin_degrees :  list of integers\n    in degree sequence contains the in degrees of nodes.\nout_degrees : list of integers\n    out degree sequence contains the out degrees of nodes.\nnkk  :  dictionary of dictionary of integers\n    directed joint degree dictionary. for nodes of out degree k (first\n    level of dict) and nodes of in degree l (second level of dict)\n    describes the number of edges.\n\nReturns\n-------\nboolean\n    returns true if given input is realizable, else returns false.\n\nNotes\n-----\nHere is the list of conditions that the inputs (in/out degree sequences,\nnkk) need to satisfy for simple directed graph realizability:\n\n- Condition 0: in_degrees and out_degrees have the same length\n- Condition 1: nkk[k][l]  is integer for all k,l\n- Condition 2: sum(nkk[k])/k = number of nodes with partition id k, is an\n               integer and matching degree sequence\n- Condition 3: number of edges and non-chords between k and l cannot exceed\n               maximum possible number of edges\n\n\nReferences\n----------\n[1] B. Tillman, A. Markopoulou, C. T. Butts & M. Gjoka,\n    \"Construction of Directed 2K Graphs\". In Proc. of KDD 2017."}, {"type": "function", "name": "networkx.is_valid_joint_degree", "documentation": "Checks whether the given joint degree dictionary is realizable.\n\nA *joint degree dictionary* is a dictionary of dictionaries, in\nwhich entry ``joint_degrees[k][l]`` is an integer representing the\nnumber of edges joining nodes of degree *k* with nodes of degree\n*l*. Such a dictionary is realizable as a simple graph if and only\nif the following conditions are satisfied.\n\n- each entry must be an integer,\n- the total number of nodes of degree *k*, computed by\n  ``sum(joint_degrees[k].values()) / k``, must be an integer,\n- the total number of edges joining nodes of degree *k* with\n  nodes of degree *l* cannot exceed the total number of possible edges,\n- each diagonal entry ``joint_degrees[k][k]`` must be even (this is\n  a convention assumed by the :func:`joint_degree_graph` function).\n\n\nParameters\n----------\njoint_degrees :  dictionary of dictionary of integers\n    A joint degree dictionary in which entry ``joint_degrees[k][l]``\n    is the number of edges joining nodes of degree *k* with nodes of\n    degree *l*.\n\nReturns\n-------\nbool\n    Whether the given joint degree dictionary is realizable as a\n    simple graph.\n\nReferences\n----------\n.. [1] M. Gjoka, M. Kurant, A. Markopoulou, \"2.5K Graphs: from Sampling\n   to Generation\", IEEE Infocom, 2013.\n.. [2] I. Stanton, A. Pinar, \"Constructing and sampling graphs with a\n   prescribed joint degree distribution\", Journal of Experimental\n   Algorithmics, 2012."}, {"type": "function", "name": "networkx.is_weakly_connected", "documentation": "Test directed graph for weak connectivity.\n\nA directed graph is weakly connected if and only if the graph\nis connected when the direction of the edge between nodes is ignored.\n\nNote that if a graph is strongly connected (i.e. the graph is connected\neven when we account for directionality), it is by definition weakly\nconnected as well.\n\nParameters\n----------\nG : NetworkX Graph\n    A directed graph.\n\nReturns\n-------\nconnected : bool\n    True if the graph is weakly connected, False otherwise.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is undirected.\n\nExamples\n--------\n>>> G = nx.DiGraph([(0, 1), (2, 1)])\n>>> G.add_node(3)\n>>> nx.is_weakly_connected(G)  # node 3 is not connected to the graph\nFalse\n>>> G.add_edge(2, 3)\n>>> nx.is_weakly_connected(G)\nTrue\n\nSee Also\n--------\nis_strongly_connected\nis_semiconnected\nis_connected\nis_biconnected\nweakly_connected_components\n\nNotes\n-----\nFor directed graphs only."}, {"type": "function", "name": "networkx.is_weighted", "documentation": "Returns True if `G` has weighted edges.\n\nParameters\n----------\nG : graph\n    A NetworkX graph.\n\nedge : tuple, optional\n    A 2-tuple specifying the only edge in `G` that will be tested. If\n    None, then every edge in `G` is tested.\n\nweight: string, optional\n    The attribute name used to query for edge weights.\n\nReturns\n-------\nbool\n    A boolean signifying if `G`, or the specified edge, is weighted.\n\nRaises\n------\nNetworkXError\n    If the specified edge does not exist.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.is_weighted(G)\nFalse\n>>> nx.is_weighted(G, (2, 3))\nFalse\n\n>>> G = nx.DiGraph()\n>>> G.add_edge(1, 2, weight=1)\n>>> nx.is_weighted(G)\nTrue"}, {"type": "function", "name": "networkx.isolates", "documentation": "Iterator over isolates in the graph.\n\nAn *isolate* is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors.\n\nParameters\n----------\nG : NetworkX graph\n\nReturns\n-------\niterator\n    An iterator over the isolates of `G`.\n\nExamples\n--------\nTo get a list of all isolates of a graph, use the :class:`list`\nconstructor::\n\n    >>> G = nx.Graph()\n    >>> G.add_edge(1, 2)\n    >>> G.add_node(3)\n    >>> list(nx.isolates(G))\n    [3]\n\nTo remove all isolates in the graph, first create a list of the\nisolates, then use :meth:`Graph.remove_nodes_from`::\n\n    >>> G.remove_nodes_from(list(nx.isolates(G)))\n    >>> list(G)\n    [1, 2]\n\nFor digraphs, isolates have zero in-degree and zero out_degre::\n\n    >>> G = nx.DiGraph([(0, 1), (1, 2)])\n    >>> G.add_node(3)\n    >>> list(nx.isolates(G))\n    [3]"}, {"type": "function", "name": "networkx.jaccard_coefficient", "documentation": "Compute the Jaccard coefficient of all node pairs in ebunch.\n\nJaccard coefficient of nodes `u` and `v` is defined as\n\n.. math::\n\n    \\frac{|\\Gamma(u) \\cap \\Gamma(v)|}{|\\Gamma(u) \\cup \\Gamma(v)|}\n\nwhere $\\Gamma(u)$ denotes the set of neighbors of $u$.\n\nParameters\n----------\nG : graph\n    A NetworkX undirected graph.\n\nebunch : iterable of node pairs, optional (default = None)\n    Jaccard coefficient will be computed for each pair of nodes\n    given in the iterable. The pairs must be given as 2-tuples\n    (u, v) where u and v are nodes in the graph. If ebunch is None\n    then all nonexistent edges in the graph will be used.\n    Default value: None.\n\nReturns\n-------\npiter : iterator\n    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\n    pair of nodes and p is their Jaccard coefficient.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is a `DiGraph`, a `Multigraph` or a `MultiDiGraph`.\n\nNodeNotFound\n    If `ebunch` has a node that is not in `G`.\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> preds = nx.jaccard_coefficient(G, [(0, 1), (2, 3)])\n>>> for u, v, p in preds:\n...     print(f\"({u}, {v}) -> {p:.8f}\")\n(0, 1) -> 0.60000000\n(2, 3) -> 0.60000000\n\nReferences\n----------\n.. [1] D. Liben-Nowell, J. Kleinberg.\n       The Link Prediction Problem for Social Networks (2004).\n       http://www.cs.cornell.edu/home/kleinber/link-pred.pdf"}, {"type": "function", "name": "networkx.johnson", "documentation": "Uses Johnson's Algorithm to compute shortest paths.\n\nJohnson's Algorithm finds a shortest path between each pair of\nnodes in a weighted graph even if negative weights are present.\n\nParameters\n----------\nG : NetworkX graph\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\nReturns\n-------\ndistance : dictionary\n    Dictionary, keyed by source and target, of shortest paths.\n\nExamples\n--------\n>>> graph = nx.DiGraph()\n>>> graph.add_weighted_edges_from(\n...     [(\"0\", \"3\", 3), (\"0\", \"1\", -5), (\"0\", \"2\", 2), (\"1\", \"2\", 4), (\"2\", \"3\", 1)]\n... )\n>>> paths = nx.johnson(graph, weight=\"weight\")\n>>> paths[\"0\"][\"2\"]\n['0', '1', '2']\n\nNotes\n-----\nJohnson's algorithm is suitable even for graphs with negative weights. It\nworks by using the Bellman\u2013Ford algorithm to compute a transformation of\nthe input graph that removes all negative weights, allowing Dijkstra's\nalgorithm to be used on the transformed graph.\n\nThe time complexity of this algorithm is $O(n^2 \\log n + n m)$,\nwhere $n$ is the number of nodes and $m$ the number of edges in the\ngraph. For dense graphs, this may be faster than the Floyd\u2013Warshall\nalgorithm.\n\nSee Also\n--------\nfloyd_warshall_predecessor_and_distance\nfloyd_warshall_numpy\nall_pairs_shortest_path\nall_pairs_shortest_path_length\nall_pairs_dijkstra_path\nbellman_ford_predecessor_and_distance\nall_pairs_bellman_ford_path\nall_pairs_bellman_ford_path_length"}, {"type": "function", "name": "networkx.join", "documentation": "A deprecated name for `join_trees`\n\nReturns a new rooted tree with a root node joined with the roots\nof each of the given rooted trees.\n\n.. deprecated:: 3.2\n\n   `join` is deprecated in NetworkX v3.2 and will be removed in v3.4.\n   It has been renamed join_trees with the same syntax/interface."}, {"type": "function", "name": "networkx.join_trees", "documentation": "Returns a new rooted tree made by joining `rooted_trees`\n\nConstructs a new tree by joining each tree in `rooted_trees`.\nA new root node is added and connected to each of the roots\nof the input trees. While copying the nodes from the trees,\nrelabeling to integers occurs. If the `label_attribute` is provided,\nthe old node labels will be stored in the new tree under this attribute.\n\nParameters\n----------\nrooted_trees : list\n    A list of pairs in which each left element is a NetworkX graph\n    object representing a tree and each right element is the root\n    node of that tree. The nodes of these trees will be relabeled to\n    integers.\n\nlabel_attribute : str\n    If provided, the old node labels will be stored in the new tree\n    under this node attribute. If not provided, the original labels\n    of the nodes in the input trees are not stored.\n\nfirst_label : int, optional (default=0)\n    Specifies the label for the new root node. If provided, the root node of the joined tree\n    will have this label. If not provided, the root node will default to a label of 0.\n\nReturns\n-------\nNetworkX graph\n    The rooted tree resulting from joining the provided `rooted_trees`. The new tree has a root node\n    labeled as specified by `first_label` (defaulting to 0 if not provided). Subtrees from the input\n    `rooted_trees` are attached to this new root node. Each non-root node, if the `label_attribute`\n    is provided, has an attribute that indicates the original label of the node in the input tree.\n\nNotes\n-----\nTrees are stored in NetworkX as NetworkX Graphs. There is no specific\nenforcement of the fact that these are trees. Testing for each tree\ncan be done using :func:`networkx.is_tree`.\n\nGraph, edge, and node attributes are propagated from the given\nrooted trees to the created tree. If there are any overlapping graph\nattributes, those from later trees will overwrite those from earlier\ntrees in the tuple of positional arguments.\n\nExamples\n--------\nJoin two full balanced binary trees of height *h* to get a full\nbalanced binary tree of depth *h* + 1::\n\n    >>> h = 4\n    >>> left = nx.balanced_tree(2, h)\n    >>> right = nx.balanced_tree(2, h)\n    >>> joined_tree = nx.join([(left, 0), (right, 0)])\n    >>> nx.is_isomorphic(joined_tree, nx.balanced_tree(2, h + 1))\n    True"}, {"type": "function", "name": "networkx.joint_degree_graph", "documentation": "Generates a random simple graph with the given joint degree dictionary.\n\nParameters\n----------\njoint_degrees :  dictionary of dictionary of integers\n    A joint degree dictionary in which entry ``joint_degrees[k][l]`` is the\n    number of edges joining nodes of degree *k* with nodes of degree *l*.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : Graph\n    A graph with the specified joint degree dictionary.\n\nRaises\n------\nNetworkXError\n    If *joint_degrees* dictionary is not realizable.\n\nNotes\n-----\nIn each iteration of the \"while loop\" the algorithm picks two disconnected\nnodes *v* and *w*, of degree *k* and *l* correspondingly,  for which\n``joint_degrees[k][l]`` has not reached its target yet. It then adds\nedge (*v*, *w*) and increases the number of edges in graph G by one.\n\nThe intelligence of the algorithm lies in the fact that  it is always\npossible to add an edge between such disconnected nodes *v* and *w*,\neven if one or both nodes do not have free stubs. That is made possible by\nexecuting a \"neighbor switch\", an edge rewiring move that releases\na free stub while keeping the joint degree of G the same.\n\nThe algorithm continues for E (number of edges) iterations of\nthe \"while loop\", at the which point all entries of the given\n``joint_degrees[k][l]`` have reached their target values and the\nconstruction is complete.\n\nReferences\n----------\n..  [1] M. Gjoka, B. Tillman, A. Markopoulou, \"Construction of Simple\n    Graphs with a Target Joint Degree Matrix and Beyond\", IEEE Infocom, '15\n\nExamples\n--------\n>>> joint_degrees = {\n...     1: {4: 1},\n...     2: {2: 2, 3: 2, 4: 2},\n...     3: {2: 2, 4: 1},\n...     4: {1: 1, 2: 2, 3: 1},\n... }\n>>> G = nx.joint_degree_graph(joint_degrees)\n>>>"}, {"type": "function", "name": "networkx.junction_tree", "documentation": "Returns a junction tree of a given graph.\n\nA junction tree (or clique tree) is constructed from a (un)directed graph G.\nThe tree is constructed based on a moralized and triangulated version of G.\nThe tree's nodes consist of maximal cliques and sepsets of the revised graph.\nThe sepset of two cliques is the intersection of the nodes of these cliques,\ne.g. the sepset of (A,B,C) and (A,C,E,F) is (A,C). These nodes are often called\n\"variables\" in this literature. The tree is bipartite with each sepset\nconnected to its two cliques.\n\nJunction Trees are not unique as the order of clique consideration determines\nwhich sepsets are included.\n\nThe junction tree algorithm consists of five steps [1]_:\n\n1. Moralize the graph\n2. Triangulate the graph\n3. Find maximal cliques\n4. Build the tree from cliques, connecting cliques with shared\n   nodes, set edge-weight to number of shared variables\n5. Find maximum spanning tree\n\n\nParameters\n----------\nG : networkx.Graph\n    Directed or undirected graph.\n\nReturns\n-------\njunction_tree : networkx.Graph\n    The corresponding junction tree of `G`.\n\nRaises\n------\nNetworkXNotImplemented\n    Raised if `G` is an instance of `MultiGraph` or `MultiDiGraph`.\n\nReferences\n----------\n.. [1] Junction tree algorithm:\n   https://en.wikipedia.org/wiki/Junction_tree_algorithm\n\n.. [2] Finn V. Jensen and Frank Jensen. 1994. Optimal\n   junction trees. In Proceedings of the Tenth international\n   conference on Uncertainty in artificial intelligence (UAI\u201994).\n   Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 360\u2013366."}, {"type": "function", "name": "networkx.k_components", "documentation": "Returns the k-component structure of a graph G.\n\nA `k`-component is a maximal subgraph of a graph G that has, at least,\nnode connectivity `k`: we need to remove at least `k` nodes to break it\ninto more components. `k`-components have an inherent hierarchical\nstructure because they are nested in terms of connectivity: a connected\ngraph can contain several 2-components, each of which can contain\none or more 3-components, and so forth.\n\nParameters\n----------\nG : NetworkX graph\n\nflow_func : function\n    Function to perform the underlying flow computations. Default value\n    :meth:`edmonds_karp`. This function performs better in sparse graphs with\n    right tailed degree distributions. :meth:`shortest_augmenting_path` will\n    perform better in denser graphs.\n\nReturns\n-------\nk_components : dict\n    Dictionary with all connectivity levels `k` in the input Graph as keys\n    and a list of sets of nodes that form a k-component of level `k` as\n    values.\n\nRaises\n------\nNetworkXNotImplemented\n    If the input graph is directed.\n\nExamples\n--------\n>>> # Petersen graph has 10 nodes and it is triconnected, thus all\n>>> # nodes are in a single component on all three connectivity levels\n>>> G = nx.petersen_graph()\n>>> k_components = nx.k_components(G)\n\nNotes\n-----\nMoody and White [1]_ (appendix A) provide an algorithm for identifying\nk-components in a graph, which is based on Kanevsky's algorithm [2]_\nfor finding all minimum-size node cut-sets of a graph (implemented in\n:meth:`all_node_cuts` function):\n\n    1. Compute node connectivity, k, of the input graph G.\n\n    2. Identify all k-cutsets at the current level of connectivity using\n       Kanevsky's algorithm.\n\n    3. Generate new graph components based on the removal of\n       these cutsets. Nodes in a cutset belong to both sides\n       of the induced cut.\n\n    4. If the graph is neither complete nor trivial, return to 1;\n       else end.\n\nThis implementation also uses some heuristics (see [3]_ for details)\nto speed up the computation.\n\nSee also\n--------\nnode_connectivity\nall_node_cuts\nbiconnected_components : special case of this function when k=2\nk_edge_components : similar to this function, but uses edge-connectivity\n    instead of node-connectivity\n\nReferences\n----------\n.. [1]  Moody, J. and D. White (2003). Social cohesion and embeddedness:\n        A hierarchical conception of social groups.\n        American Sociological Review 68(1), 103--28.\n        http://www2.asanet.org/journals/ASRFeb03MoodyWhite.pdf\n\n.. [2]  Kanevsky, A. (1993). Finding all minimum-size separating vertex\n        sets in a graph. Networks 23(6), 533--541.\n        http://onlinelibrary.wiley.com/doi/10.1002/net.3230230604/abstract\n\n.. [3]  Torrents, J. and F. Ferraro (2015). Structural Cohesion:\n        Visualization and Heuristics for Fast Computation.\n        https://arxiv.org/pdf/1503.04476v1"}, {"type": "function", "name": "networkx.k_core", "documentation": "Returns the k-core of G.\n\nA k-core is a maximal subgraph that contains nodes of degree `k` or more.\n\n.. deprecated:: 3.3\n   `k_core` will not accept `MultiGraph` objects in version 3.5.\n\nParameters\n----------\nG : NetworkX graph\n  A graph or directed graph\nk : int, optional\n  The order of the core. If not specified return the main core.\ncore_number : dictionary, optional\n  Precomputed core numbers for the graph G.\n\nReturns\n-------\nG : NetworkX graph\n  The k-core subgraph\n\nRaises\n------\nNetworkXNotImplemented\n  The k-core is not defined for multigraphs or graphs with self loops.\n\nNotes\n-----\nThe main core is the core with `k` as the largest core_number.\n\nFor directed graphs the node degree is defined to be the\nin-degree + out-degree.\n\nGraph, node, and edge attributes are copied to the subgraph.\n\nExamples\n--------\n>>> degrees = [0, 1, 2, 2, 2, 2, 3]\n>>> H = nx.havel_hakimi_graph(degrees)\n>>> H.degree\nDegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\n>>> nx.k_core(H).nodes\nNodeView((1, 2, 3, 5))\n\nSee Also\n--------\ncore_number\n\nReferences\n----------\n.. [1] An O(m) Algorithm for Cores Decomposition of Networks\n   Vladimir Batagelj and Matjaz Zaversnik,  2003.\n   https://arxiv.org/abs/cs.DS/0310049"}, {"type": "function", "name": "networkx.k_corona", "documentation": "Returns the k-corona of G.\n\nThe k-corona is the subgraph of nodes in the k-core which have\nexactly k neighbors in the k-core.\n\n.. deprecated:: 3.3\n   `k_corona` will not accept `MultiGraph` objects in version 3.5.\n\nParameters\n----------\nG : NetworkX graph\n   A graph or directed graph\nk : int\n   The order of the corona.\ncore_number : dictionary, optional\n   Precomputed core numbers for the graph G.\n\nReturns\n-------\nG : NetworkX graph\n   The k-corona subgraph\n\nRaises\n------\nNetworkXNotImplemented\n    The k-corona is not defined for multigraphs or graphs with self loops.\n\nNotes\n-----\nFor directed graphs the node degree is defined to be the\nin-degree + out-degree.\n\nGraph, node, and edge attributes are copied to the subgraph.\n\nExamples\n--------\n>>> degrees = [0, 1, 2, 2, 2, 2, 3]\n>>> H = nx.havel_hakimi_graph(degrees)\n>>> H.degree\nDegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\n>>> nx.k_corona(H, k=2).nodes\nNodeView((1, 2, 3, 5))\n\nSee Also\n--------\ncore_number\n\nReferences\n----------\n.. [1]  k -core (bootstrap) percolation on complex networks:\n   Critical phenomena and nonlocal effects,\n   A. V. Goltsev, S. N. Dorogovtsev, and J. F. F. Mendes,\n   Phys. Rev. E 73, 056101 (2006)\n   http://link.aps.org/doi/10.1103/PhysRevE.73.056101"}, {"type": "function", "name": "networkx.k_crust", "documentation": "Returns the k-crust of G.\n\nThe k-crust is the graph G with the edges of the k-core removed\nand isolated nodes found after the removal of edges are also removed.\n\n.. deprecated:: 3.3\n   `k_crust` will not accept `MultiGraph` objects in version 3.5.\n\nParameters\n----------\nG : NetworkX graph\n   A graph or directed graph.\nk : int, optional\n  The order of the shell. If not specified return the main crust.\ncore_number : dictionary, optional\n  Precomputed core numbers for the graph G.\n\nReturns\n-------\nG : NetworkX graph\n   The k-crust subgraph\n\nRaises\n------\nNetworkXNotImplemented\n    The k-crust is not implemented for multigraphs or graphs with self loops.\n\nNotes\n-----\nThis definition of k-crust is different than the definition in [1]_.\nThe k-crust in [1]_ is equivalent to the k+1 crust of this algorithm.\n\nFor directed graphs the node degree is defined to be the\nin-degree + out-degree.\n\nGraph, node, and edge attributes are copied to the subgraph.\n\nExamples\n--------\n>>> degrees = [0, 1, 2, 2, 2, 2, 3]\n>>> H = nx.havel_hakimi_graph(degrees)\n>>> H.degree\nDegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\n>>> nx.k_crust(H, k=1).nodes\nNodeView((0, 4, 6))\n\nSee Also\n--------\ncore_number\n\nReferences\n----------\n.. [1] A model of Internet topology using k-shell decomposition\n   Shai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,\n   and Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154\n   http://www.pnas.org/content/104/27/11150.full"}, {"type": "function", "name": "networkx.k_edge_augmentation", "documentation": "Finds set of edges to k-edge-connect G.\n\nAdding edges from the augmentation to G make it impossible to disconnect G\nunless k or more edges are removed. This function uses the most efficient\nfunction available (depending on the value of k and if the problem is\nweighted or unweighted) to search for a minimum weight subset of available\nedges that k-edge-connects G. In general, finding a k-edge-augmentation is\nNP-hard, so solutions are not guaranteed to be minimal. Furthermore, a\nk-edge-augmentation may not exist.\n\nParameters\n----------\nG : NetworkX graph\n   An undirected graph.\n\nk : integer\n    Desired edge connectivity\n\navail : dict or a set of 2 or 3 tuples\n    The available edges that can be used in the augmentation.\n\n    If unspecified, then all edges in the complement of G are available.\n    Otherwise, each item is an available edge (with an optional weight).\n\n    In the unweighted case, each item is an edge ``(u, v)``.\n\n    In the weighted case, each item is a 3-tuple ``(u, v, d)`` or a dict\n    with items ``(u, v): d``.  The third item, ``d``, can be a dictionary\n    or a real number.  If ``d`` is a dictionary ``d[weight]``\n    correspondings to the weight.\n\nweight : string\n    key to use to find weights if ``avail`` is a set of 3-tuples where the\n    third item in each tuple is a dictionary.\n\npartial : boolean\n    If partial is True and no feasible k-edge-augmentation exists, then all\n    a partial k-edge-augmentation is generated. Adding the edges in a\n    partial augmentation to G, minimizes the number of k-edge-connected\n    components and maximizes the edge connectivity between those\n    components. For details, see :func:`partial_k_edge_augmentation`.\n\nYields\n------\nedge : tuple\n    Edges that, once added to G, would cause G to become k-edge-connected.\n    If partial is False, an error is raised if this is not possible.\n    Otherwise, generated edges form a partial augmentation, which\n    k-edge-connects any part of G where it is possible, and maximally\n    connects the remaining parts.\n\nRaises\n------\nNetworkXUnfeasible\n    If partial is False and no k-edge-augmentation exists.\n\nNetworkXNotImplemented\n    If the input graph is directed or a multigraph.\n\nValueError:\n    If k is less than 1\n\nNotes\n-----\nWhen k=1 this returns an optimal solution.\n\nWhen k=2 and ``avail`` is None, this returns an optimal solution.\nOtherwise when k=2, this returns a 2-approximation of the optimal solution.\n\nFor k>3, this problem is NP-hard and this uses a randomized algorithm that\n    produces a feasible solution, but provides no guarantees on the\n    solution weight.\n\nExamples\n--------\n>>> # Unweighted cases\n>>> G = nx.path_graph((1, 2, 3, 4))\n>>> G.add_node(5)\n>>> sorted(nx.k_edge_augmentation(G, k=1))\n[(1, 5)]\n>>> sorted(nx.k_edge_augmentation(G, k=2))\n[(1, 5), (5, 4)]\n>>> sorted(nx.k_edge_augmentation(G, k=3))\n[(1, 4), (1, 5), (2, 5), (3, 5), (4, 5)]\n>>> complement = list(nx.k_edge_augmentation(G, k=5, partial=True))\n>>> G.add_edges_from(complement)\n>>> nx.edge_connectivity(G)\n4\n\n>>> # Weighted cases\n>>> G = nx.path_graph((1, 2, 3, 4))\n>>> G.add_node(5)\n>>> # avail can be a tuple with a dict\n>>> avail = [(1, 5, {\"weight\": 11}), (2, 5, {\"weight\": 10})]\n>>> sorted(nx.k_edge_augmentation(G, k=1, avail=avail, weight=\"weight\"))\n[(2, 5)]\n>>> # or avail can be a 3-tuple with a real number\n>>> avail = [(1, 5, 11), (2, 5, 10), (4, 3, 1), (4, 5, 51)]\n>>> sorted(nx.k_edge_augmentation(G, k=2, avail=avail))\n[(1, 5), (2, 5), (4, 5)]\n>>> # or avail can be a dict\n>>> avail = {(1, 5): 11, (2, 5): 10, (4, 3): 1, (4, 5): 51}\n>>> sorted(nx.k_edge_augmentation(G, k=2, avail=avail))\n[(1, 5), (2, 5), (4, 5)]\n>>> # If augmentation is infeasible, then a partial solution can be found\n>>> avail = {(1, 5): 11}\n>>> sorted(nx.k_edge_augmentation(G, k=2, avail=avail, partial=True))\n[(1, 5)]"}, {"type": "function", "name": "networkx.k_edge_components", "documentation": "Generates nodes in each maximal k-edge-connected component in G.\n\nParameters\n----------\nG : NetworkX graph\n\nk : Integer\n    Desired edge connectivity\n\nReturns\n-------\nk_edge_components : a generator of k-edge-ccs. Each set of returned nodes\n   will have k-edge-connectivity in the graph G.\n\nSee Also\n--------\n:func:`local_edge_connectivity`\n:func:`k_edge_subgraphs` : similar to this function, but the subgraph\n    defined by the nodes must also have k-edge-connectivity.\n:func:`k_components` : similar to this function, but uses node-connectivity\n    instead of edge-connectivity\n\nRaises\n------\nNetworkXNotImplemented\n    If the input graph is a multigraph.\n\nValueError:\n    If k is less than 1\n\nNotes\n-----\nAttempts to use the most efficient implementation available based on k.\nIf k=1, this is simply connected components for directed graphs and\nconnected components for undirected graphs.\nIf k=2 on an efficient bridge connected component algorithm from _[1] is\nrun based on the chain decomposition.\nOtherwise, the algorithm from _[2] is used.\n\nExamples\n--------\n>>> import itertools as it\n>>> from networkx.utils import pairwise\n>>> paths = [\n...     (1, 2, 4, 3, 1, 4),\n...     (5, 6, 7, 8, 5, 7, 8, 6),\n... ]\n>>> G = nx.Graph()\n>>> G.add_nodes_from(it.chain(*paths))\n>>> G.add_edges_from(it.chain(*[pairwise(path) for path in paths]))\n>>> # note this returns {1, 4} unlike k_edge_subgraphs\n>>> sorted(map(sorted, nx.k_edge_components(G, k=3)))\n[[1, 4], [2], [3], [5, 6, 7, 8]]\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29\n.. [2] Wang, Tianhao, et al. (2015) A simple algorithm for finding all\n    k-edge-connected components.\n    http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0136264"}, {"type": "function", "name": "networkx.k_edge_subgraphs", "documentation": "Generates nodes in each maximal k-edge-connected subgraph in G.\n\nParameters\n----------\nG : NetworkX graph\n\nk : Integer\n    Desired edge connectivity\n\nReturns\n-------\nk_edge_subgraphs : a generator of k-edge-subgraphs\n    Each k-edge-subgraph is a maximal set of nodes that defines a subgraph\n    of G that is k-edge-connected.\n\nSee Also\n--------\n:func:`edge_connectivity`\n:func:`k_edge_components` : similar to this function, but nodes only\n    need to have k-edge-connectivity within the graph G and the subgraphs\n    might not be k-edge-connected.\n\nRaises\n------\nNetworkXNotImplemented\n    If the input graph is a multigraph.\n\nValueError:\n    If k is less than 1\n\nNotes\n-----\nAttempts to use the most efficient implementation available based on k.\nIf k=1, or k=2 and the graph is undirected, then this simply calls\n`k_edge_components`.  Otherwise the algorithm from _[1] is used.\n\nExamples\n--------\n>>> import itertools as it\n>>> from networkx.utils import pairwise\n>>> paths = [\n...     (1, 2, 4, 3, 1, 4),\n...     (5, 6, 7, 8, 5, 7, 8, 6),\n... ]\n>>> G = nx.Graph()\n>>> G.add_nodes_from(it.chain(*paths))\n>>> G.add_edges_from(it.chain(*[pairwise(path) for path in paths]))\n>>> # note this does not return {1, 4} unlike k_edge_components\n>>> sorted(map(sorted, nx.k_edge_subgraphs(G, k=3)))\n[[1], [2], [3], [4], [5, 6, 7, 8]]\n\nReferences\n----------\n.. [1] Zhou, Liu, et al. (2012) Finding maximal k-edge-connected subgraphs\n    from a large graph.  ACM International Conference on Extending Database\n    Technology 2012 480-\u2013491.\n    https://openproceedings.org/2012/conf/edbt/ZhouLYLCL12.pdf"}, {"type": "function", "name": "networkx.k_factor", "documentation": "Compute a k-factor of G\n\nA k-factor of a graph is a spanning k-regular subgraph.\nA spanning k-regular subgraph of G is a subgraph that contains\neach vertex of G and a subset of the edges of G such that each\nvertex has degree k.\n\nParameters\n----------\nG : NetworkX graph\n  Undirected graph\n\nmatching_weight: string, optional (default='weight')\n   Edge data key corresponding to the edge weight.\n   Used for finding the max-weighted perfect matching.\n   If key not found, uses 1 as weight.\n\nReturns\n-------\nG2 : NetworkX graph\n    A k-factor of G\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (2, 3), (3, 4), (4, 1)])\n>>> G2 = nx.k_factor(G, k=1)\n>>> G2.edges()\nEdgeView([(1, 2), (3, 4)])\n\nReferences\n----------\n.. [1] \"An algorithm for computing simple k-factors.\",\n   Meijer, Henk, Yurai N\u00fa\u00f1ez-Rodr\u00edguez, and David Rappaport,\n   Information processing letters, 2009."}, {"type": "function", "name": "networkx.k_random_intersection_graph", "documentation": "Returns a intersection graph with randomly chosen attribute sets for\neach node that are of equal size (k).\n\nParameters\n----------\nn : int\n    The number of nodes in the first bipartite set (nodes)\nm : int\n    The number of nodes in the second bipartite set (attributes)\nk : float\n    Size of attribute set to assign to each node.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nSee Also\n--------\ngnp_random_graph, uniform_random_intersection_graph\n\nReferences\n----------\n.. [1] Godehardt, E., and Jaworski, J.\n   Two models of random intersection graphs and their applications.\n   Electronic Notes in Discrete Mathematics 10 (2001), 129--132."}, {"type": "function", "name": "networkx.k_shell", "documentation": "Returns the k-shell of G.\n\nThe k-shell is the subgraph induced by nodes with core number k.\nThat is, nodes in the k-core that are not in the (k+1)-core.\n\n.. deprecated:: 3.3\n   `k_shell` will not accept `MultiGraph` objects in version 3.5.\n\nParameters\n----------\nG : NetworkX graph\n  A graph or directed graph.\nk : int, optional\n  The order of the shell. If not specified return the outer shell.\ncore_number : dictionary, optional\n  Precomputed core numbers for the graph G.\n\n\nReturns\n-------\nG : NetworkX graph\n   The k-shell subgraph\n\nRaises\n------\nNetworkXNotImplemented\n    The k-shell is not implemented for multigraphs or graphs with self loops.\n\nNotes\n-----\nThis is similar to k_corona but in that case only neighbors in the\nk-core are considered.\n\nFor directed graphs the node degree is defined to be the\nin-degree + out-degree.\n\nGraph, node, and edge attributes are copied to the subgraph.\n\nExamples\n--------\n>>> degrees = [0, 1, 2, 2, 2, 2, 3]\n>>> H = nx.havel_hakimi_graph(degrees)\n>>> H.degree\nDegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\n>>> nx.k_shell(H, k=1).nodes\nNodeView((0, 4))\n\nSee Also\n--------\ncore_number\nk_corona\n\n\nReferences\n----------\n.. [1] A model of Internet topology using k-shell decomposition\n   Shai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,\n   and Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154\n   http://www.pnas.org/content/104/27/11150.full"}, {"type": "function", "name": "networkx.k_truss", "documentation": "Returns the k-truss of `G`.\n\nThe k-truss is the maximal induced subgraph of `G` which contains at least\nthree vertices where every edge is incident to at least `k-2` triangles.\n\nParameters\n----------\nG : NetworkX graph\n  An undirected graph\nk : int\n  The order of the truss\n\nReturns\n-------\nH : NetworkX graph\n  The k-truss subgraph\n\nRaises\n------\nNetworkXNotImplemented\n  If `G` is a multigraph or directed graph or if it contains self loops.\n\nNotes\n-----\nA k-clique is a (k-2)-truss and a k-truss is a (k+1)-core.\n\nGraph, node, and edge attributes are copied to the subgraph.\n\nK-trusses were originally defined in [2] which states that the k-truss\nis the maximal induced subgraph where each edge belongs to at least\n`k-2` triangles. A more recent paper, [1], uses a slightly different\ndefinition requiring that each edge belong to at least `k` triangles.\nThis implementation uses the original definition of `k-2` triangles.\n\nExamples\n--------\n>>> degrees = [0, 1, 2, 2, 2, 2, 3]\n>>> H = nx.havel_hakimi_graph(degrees)\n>>> H.degree\nDegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\n>>> nx.k_truss(H, k=2).nodes\nNodeView((0, 1, 2, 3, 4, 5))\n\nReferences\n----------\n.. [1] Bounds and Algorithms for k-truss. Paul Burkhardt, Vance Faber,\n   David G. Harris, 2018. https://arxiv.org/abs/1806.05523v2\n.. [2] Trusses: Cohesive Subgraphs for Social Network Analysis. Jonathan\n   Cohen, 2005."}, {"type": "function", "name": "networkx.kamada_kawai_layout", "documentation": "Position nodes using Kamada-Kawai path-length cost-function.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\ndist : dict (default=None)\n    A two-level dictionary of optimal distances between nodes,\n    indexed by source and destination node.\n    If None, the distance is computed using shortest_path_length().\n\npos : dict or None  optional (default=None)\n    Initial positions for nodes as a dictionary with node as keys\n    and values as a coordinate list or tuple.  If None, then use\n    circular_layout() for dim >= 2 and a linear layout for dim == 1.\n\nweight : string or None   optional (default='weight')\n    The edge attribute that holds the numerical value used for\n    the edge weight.  If None, then all edge weights are 1.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\ndim : int\n    Dimension of layout.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.kamada_kawai_layout(G)"}, {"type": "function", "name": "networkx.karate_club_graph", "documentation": "Returns Zachary's Karate Club graph.\n\nEach node in the returned graph has a node attribute 'club' that\nindicates the name of the club to which the member represented by that node\nbelongs, either 'Mr. Hi' or 'Officer'. Each edge has a weight based on the\nnumber of contexts in which that edge's incident node members interacted.\n\nExamples\n--------\nTo get the name of the club to which a node belongs::\n\n    >>> G = nx.karate_club_graph()\n    >>> G.nodes[5][\"club\"]\n    'Mr. Hi'\n    >>> G.nodes[9][\"club\"]\n    'Officer'\n\nReferences\n----------\n.. [1] Zachary, Wayne W.\n   \"An Information Flow Model for Conflict and Fission in Small Groups.\"\n   *Journal of Anthropological Research*, 33, 452--473, (1977)."}, {"type": "function", "name": "networkx.katz_centrality", "documentation": "Compute the Katz centrality for the nodes of the graph G.\n\nKatz centrality computes the centrality for a node based on the centrality\nof its neighbors. It is a generalization of the eigenvector centrality. The\nKatz centrality for node $i$ is\n\n.. math::\n\n    x_i = \\alpha \\sum_{j} A_{ij} x_j + \\beta,\n\nwhere $A$ is the adjacency matrix of graph G with eigenvalues $\\lambda$.\n\nThe parameter $\\beta$ controls the initial centrality and\n\n.. math::\n\n    \\alpha < \\frac{1}{\\lambda_{\\max}}.\n\nKatz centrality computes the relative influence of a node within a\nnetwork by measuring the number of the immediate neighbors (first\ndegree nodes) and also all other nodes in the network that connect\nto the node under consideration through these immediate neighbors.\n\nExtra weight can be provided to immediate neighbors through the\nparameter $\\beta$.  Connections made with distant neighbors\nare, however, penalized by an attenuation factor $\\alpha$ which\nshould be strictly less than the inverse largest eigenvalue of the\nadjacency matrix in order for the Katz centrality to be computed\ncorrectly. More information is provided in [1]_.\n\nParameters\n----------\nG : graph\n  A NetworkX graph.\n\nalpha : float, optional (default=0.1)\n  Attenuation factor\n\nbeta : scalar or dictionary, optional (default=1.0)\n  Weight attributed to the immediate neighborhood. If not a scalar, the\n  dictionary must have a value for every node.\n\nmax_iter : integer, optional (default=1000)\n  Maximum number of iterations in power method.\n\ntol : float, optional (default=1.0e-6)\n  Error tolerance used to check convergence in power method iteration.\n\nnstart : dictionary, optional\n  Starting value of Katz iteration for each node.\n\nnormalized : bool, optional (default=True)\n  If True normalize the resulting values.\n\nweight : None or string, optional (default=None)\n  If None, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n  In this measure the weight is interpreted as the connection strength.\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with Katz centrality as the value.\n\nRaises\n------\nNetworkXError\n   If the parameter `beta` is not a scalar but lacks a value for at least\n   one node\n\nPowerIterationFailedConvergence\n    If the algorithm fails to converge to the specified tolerance\n    within the specified number of iterations of the power iteration\n    method.\n\nExamples\n--------\n>>> import math\n>>> G = nx.path_graph(4)\n>>> phi = (1 + math.sqrt(5)) / 2.0  # largest eigenvalue of adj matrix\n>>> centrality = nx.katz_centrality(G, 1 / phi - 0.01)\n>>> for n, c in sorted(centrality.items()):\n...     print(f\"{n} {c:.2f}\")\n0 0.37\n1 0.60\n2 0.60\n3 0.37\n\nSee Also\n--------\nkatz_centrality_numpy\neigenvector_centrality\neigenvector_centrality_numpy\n:func:`~networkx.algorithms.link_analysis.pagerank_alg.pagerank`\n:func:`~networkx.algorithms.link_analysis.hits_alg.hits`\n\nNotes\n-----\nKatz centrality was introduced by [2]_.\n\nThis algorithm it uses the power method to find the eigenvector\ncorresponding to the largest eigenvalue of the adjacency matrix of ``G``.\nThe parameter ``alpha`` should be strictly less than the inverse of largest\neigenvalue of the adjacency matrix for the algorithm to converge.\nYou can use ``max(nx.adjacency_spectrum(G))`` to get $\\lambda_{\\max}$ the largest\neigenvalue of the adjacency matrix.\nThe iteration will stop after ``max_iter`` iterations or an error tolerance of\n``number_of_nodes(G) * tol`` has been reached.\n\nFor strongly connected graphs, as $\\alpha \\to 1/\\lambda_{\\max}$, and $\\beta > 0$,\nKatz centrality approaches the results for eigenvector centrality.\n\nFor directed graphs this finds \"left\" eigenvectors which corresponds\nto the in-edges in the graph. For out-edges Katz centrality,\nfirst reverse the graph with ``G.reverse()``.\n\nReferences\n----------\n.. [1] Mark E. J. Newman:\n   Networks: An Introduction.\n   Oxford University Press, USA, 2010, p. 720.\n.. [2] Leo Katz:\n   A New Status Index Derived from Sociometric Index.\n   Psychometrika 18(1):39\u201343, 1953\n   https://link.springer.com/content/pdf/10.1007/BF02289026.pdf"}, {"type": "function", "name": "networkx.katz_centrality_numpy", "documentation": "Compute the Katz centrality for the graph G.\n\nKatz centrality computes the centrality for a node based on the centrality\nof its neighbors. It is a generalization of the eigenvector centrality. The\nKatz centrality for node $i$ is\n\n.. math::\n\n    x_i = \\alpha \\sum_{j} A_{ij} x_j + \\beta,\n\nwhere $A$ is the adjacency matrix of graph G with eigenvalues $\\lambda$.\n\nThe parameter $\\beta$ controls the initial centrality and\n\n.. math::\n\n    \\alpha < \\frac{1}{\\lambda_{\\max}}.\n\nKatz centrality computes the relative influence of a node within a\nnetwork by measuring the number of the immediate neighbors (first\ndegree nodes) and also all other nodes in the network that connect\nto the node under consideration through these immediate neighbors.\n\nExtra weight can be provided to immediate neighbors through the\nparameter $\\beta$.  Connections made with distant neighbors\nare, however, penalized by an attenuation factor $\\alpha$ which\nshould be strictly less than the inverse largest eigenvalue of the\nadjacency matrix in order for the Katz centrality to be computed\ncorrectly. More information is provided in [1]_.\n\nParameters\n----------\nG : graph\n  A NetworkX graph\n\nalpha : float\n  Attenuation factor\n\nbeta : scalar or dictionary, optional (default=1.0)\n  Weight attributed to the immediate neighborhood. If not a scalar the\n  dictionary must have an value for every node.\n\nnormalized : bool\n  If True normalize the resulting values.\n\nweight : None or string, optional\n  If None, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n  In this measure the weight is interpreted as the connection strength.\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with Katz centrality as the value.\n\nRaises\n------\nNetworkXError\n   If the parameter `beta` is not a scalar but lacks a value for at least\n   one node\n\nExamples\n--------\n>>> import math\n>>> G = nx.path_graph(4)\n>>> phi = (1 + math.sqrt(5)) / 2.0  # largest eigenvalue of adj matrix\n>>> centrality = nx.katz_centrality_numpy(G, 1 / phi)\n>>> for n, c in sorted(centrality.items()):\n...     print(f\"{n} {c:.2f}\")\n0 0.37\n1 0.60\n2 0.60\n3 0.37\n\nSee Also\n--------\nkatz_centrality\neigenvector_centrality_numpy\neigenvector_centrality\n:func:`~networkx.algorithms.link_analysis.pagerank_alg.pagerank`\n:func:`~networkx.algorithms.link_analysis.hits_alg.hits`\n\nNotes\n-----\nKatz centrality was introduced by [2]_.\n\nThis algorithm uses a direct linear solver to solve the above equation.\nThe parameter ``alpha`` should be strictly less than the inverse of largest\neigenvalue of the adjacency matrix for there to be a solution.\nYou can use ``max(nx.adjacency_spectrum(G))`` to get $\\lambda_{\\max}$ the largest\neigenvalue of the adjacency matrix.\n\nFor strongly connected graphs, as $\\alpha \\to 1/\\lambda_{\\max}$, and $\\beta > 0$,\nKatz centrality approaches the results for eigenvector centrality.\n\nFor directed graphs this finds \"left\" eigenvectors which corresponds\nto the in-edges in the graph. For out-edges Katz centrality,\nfirst reverse the graph with ``G.reverse()``.\n\nReferences\n----------\n.. [1] Mark E. J. Newman:\n   Networks: An Introduction.\n   Oxford University Press, USA, 2010, p. 173.\n.. [2] Leo Katz:\n   A New Status Index Derived from Sociometric Index.\n   Psychometrika 18(1):39\u201343, 1953\n   https://link.springer.com/content/pdf/10.1007/BF02289026.pdf"}, {"type": "function", "name": "networkx.kemeny_constant", "documentation": "Returns the Kemeny constant of the given graph.\n\nThe *Kemeny constant* (or Kemeny's constant) of a graph `G`\ncan be computed by regarding the graph as a Markov chain.\nThe Kemeny constant is then the expected number of time steps\nto transition from a starting state i to a random destination state\nsampled from the Markov chain's stationary distribution.\nThe Kemeny constant is independent of the chosen initial state [1]_.\n\nThe Kemeny constant measures the time needed for spreading\nacross a graph. Low values indicate a closely connected graph\nwhereas high values indicate a spread-out graph.\n\nIf weight is not provided, then a weight of 1 is used for all edges.\n\nSince `G` represents a Markov chain, the weights must be positive.\n\nParameters\n----------\nG : NetworkX graph\n\nweight : string or None, optional (default=None)\n   The edge data key used to compute the Kemeny constant.\n   If None, then each edge has weight 1.\n\nReturns\n-------\nfloat\n    The Kemeny constant of the graph `G`.\n\nRaises\n------\nNetworkXNotImplemented\n    If the graph `G` is directed.\n\nNetworkXError\n    If the graph `G` is not connected, or contains no nodes,\n    or has edges with negative weights.\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> round(nx.kemeny_constant(G), 10)\n3.2\n\nNotes\n-----\nThe implementation is based on equation (3.3) in [2]_.\nSelf-loops are allowed and indicate a Markov chain where\nthe state can remain the same. Multi-edges are contracted\nin one edge with weight equal to the sum of the weights.\n\nReferences\n----------\n.. [1] Wikipedia\n   \"Kemeny's constant.\"\n   https://en.wikipedia.org/wiki/Kemeny%27s_constant\n.. [2] Lov\u00e1sz L.\n    Random walks on graphs: A survey.\n    Paul Erd\u00f6s is Eighty, vol. 2, Bolyai Society,\n    Mathematical Studies, Keszthely, Hungary (1993), pp. 1-46"}, {"type": "function", "name": "networkx.kl_connected_subgraph", "documentation": "Returns the maximum locally `(k, l)`-connected subgraph of `G`.\n\nA graph is locally `(k, l)`-connected if for each edge `(u, v)` in the\ngraph there are at least `l` edge-disjoint paths of length at most `k`\njoining `u` to `v`.\n\nParameters\n----------\nG : NetworkX graph\n    The graph in which to find a maximum locally `(k, l)`-connected\n    subgraph.\n\nk : integer\n    The maximum length of paths to consider. A higher number means a looser\n    connectivity requirement.\n\nl : integer\n    The number of edge-disjoint paths. A higher number means a stricter\n    connectivity requirement.\n\nlow_memory : bool\n    If this is True, this function uses an algorithm that uses slightly\n    more time but less memory.\n\nsame_as_graph : bool\n    If True then return a tuple of the form `(H, is_same)`,\n    where `H` is the maximum locally `(k, l)`-connected subgraph and\n    `is_same` is a Boolean representing whether `G` is locally `(k,\n    l)`-connected (and hence, whether `H` is simply a copy of the input\n    graph `G`).\n\nReturns\n-------\nNetworkX graph or two-tuple\n    If `same_as_graph` is True, then this function returns a\n    two-tuple as described above. Otherwise, it returns only the maximum\n    locally `(k, l)`-connected subgraph.\n\nSee also\n--------\nis_kl_connected\n\nReferences\n----------\n.. [1] Chung, Fan and Linyuan Lu. \"The Small World Phenomenon in Hybrid\n       Power Law Graphs.\" *Complex Networks*. Springer Berlin Heidelberg,\n       2004. 89--104."}, {"type": "function", "name": "networkx.kneser_graph", "documentation": "Returns the Kneser Graph with parameters `n` and `k`.\n\nThe Kneser Graph has nodes that are k-tuples (subsets) of the integers\nbetween 0 and ``n-1``. Nodes are adjacent if their corresponding sets are disjoint.\n\nParameters\n----------\nn: int\n    Number of integers from which to make node subsets.\n    Subsets are drawn from ``set(range(n))``.\nk: int\n    Size of the subsets.\n\nReturns\n-------\nG : NetworkX Graph\n\nExamples\n--------\n>>> G = nx.kneser_graph(5, 2)\n>>> G.number_of_nodes()\n10\n>>> G.number_of_edges()\n15\n>>> nx.is_isomorphic(G, nx.petersen_graph())\nTrue"}, {"type": "function", "name": "networkx.kosaraju_strongly_connected_components", "documentation": "Generate nodes in strongly connected components of graph.\n\nParameters\n----------\nG : NetworkX Graph\n    A directed graph.\n\nReturns\n-------\ncomp : generator of sets\n    A generator of sets of nodes, one for each strongly connected\n    component of G.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is undirected.\n\nExamples\n--------\nGenerate a sorted list of strongly connected components, largest first.\n\n>>> G = nx.cycle_graph(4, create_using=nx.DiGraph())\n>>> nx.add_cycle(G, [10, 11, 12])\n>>> [\n...     len(c)\n...     for c in sorted(\n...         nx.kosaraju_strongly_connected_components(G), key=len, reverse=True\n...     )\n... ]\n[4, 3]\n\nIf you only want the largest component, it's more efficient to\nuse max instead of sort.\n\n>>> largest = max(nx.kosaraju_strongly_connected_components(G), key=len)\n\nSee Also\n--------\nstrongly_connected_components\n\nNotes\n-----\nUses Kosaraju's algorithm."}, {"type": "function", "name": "networkx.krackhardt_kite_graph", "documentation": "Returns the Krackhardt Kite Social Network.\n\nA 10 actor social network introduced by David Krackhardt\nto illustrate different centrality measures [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Krackhardt Kite graph with 10 nodes and 18 edges\n\nNotes\n-----\nThe traditional labeling is:\nAndre=1, Beverley=2, Carol=3, Diane=4,\nEd=5, Fernando=6, Garth=7, Heather=8, Ike=9, Jane=10.\n\nReferences\n----------\n.. [1] Krackhardt, David. \"Assessing the Political Landscape: Structure,\n   Cognition, and Power in Organizations\". Administrative Science Quarterly.\n   35 (2): 342\u2013369. doi:10.2307/2393394. JSTOR 2393394. June 1990."}, {"type": "function", "name": "networkx.ladder_graph", "documentation": "Returns the Ladder graph of length n.\n\nThis is two paths of n nodes, with\neach pair connected by a single edge.\n\nNode labels are the integers 0 to 2*n - 1.\n\n.. plot::\n\n    >>> nx.draw(nx.ladder_graph(5))"}, {"type": "function", "name": "networkx.laplacian_centrality", "documentation": "Compute the Laplacian centrality for nodes in the graph `G`.\n\nThe Laplacian Centrality of a node ``i`` is measured by the drop in the\nLaplacian Energy after deleting node ``i`` from the graph. The Laplacian Energy\nis the sum of the squared eigenvalues of a graph's Laplacian matrix.\n\n.. math::\n\n    C_L(u_i,G) = \\frac{(\\Delta E)_i}{E_L (G)} = \\frac{E_L (G)-E_L (G_i)}{E_L (G)}\n\n    E_L (G) = \\sum_{i=0}^n \\lambda_i^2\n\nWhere $E_L (G)$ is the Laplacian energy of graph `G`,\nE_L (G_i) is the Laplacian energy of graph `G` after deleting node ``i``\nand $\\lambda_i$ are the eigenvalues of `G`'s Laplacian matrix.\nThis formula shows the normalized value. Without normalization,\nthe numerator on the right side is returned.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\nnormalized : bool (default = True)\n    If True the centrality score is scaled so the sum over all nodes is 1.\n    If False the centrality score for each node is the drop in Laplacian\n    energy when that node is removed.\n\nnodelist : list, optional (default = None)\n    The rows and columns are ordered according to the nodes in nodelist.\n    If nodelist is None, then the ordering is produced by G.nodes().\n\nweight: string or None, optional (default=`weight`)\n    Optional parameter `weight` to compute the Laplacian matrix.\n    The edge data key used to compute each value in the matrix.\n    If None, then each edge has weight 1.\n\nwalk_type : string or None, optional (default=None)\n    Optional parameter `walk_type` used when calling\n    :func:`directed_laplacian_matrix <networkx.directed_laplacian_matrix>`.\n    One of ``\"random\"``, ``\"lazy\"``, or ``\"pagerank\"``. If ``walk_type=None``\n    (the default), then a value is selected according to the properties of `G`:\n    - ``walk_type=\"random\"`` if `G` is strongly connected and aperiodic\n    - ``walk_type=\"lazy\"`` if `G` is strongly connected but not aperiodic\n    - ``walk_type=\"pagerank\"`` for all other cases.\n\nalpha : real (default = 0.95)\n    Optional parameter `alpha` used when calling\n    :func:`directed_laplacian_matrix <networkx.directed_laplacian_matrix>`.\n    (1 - alpha) is the teleportation probability used with pagerank.\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with Laplacian centrality as the value.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> edges = [(0, 1, 4), (0, 2, 2), (2, 1, 1), (1, 3, 2), (1, 4, 2), (4, 5, 1)]\n>>> G.add_weighted_edges_from(edges)\n>>> sorted((v, f\"{c:0.2f}\") for v, c in laplacian_centrality(G).items())\n[(0, '0.70'), (1, '0.90'), (2, '0.28'), (3, '0.22'), (4, '0.26'), (5, '0.04')]\n\nNotes\n-----\nThe algorithm is implemented based on [1]_ with an extension to directed graphs\nusing the ``directed_laplacian_matrix`` function.\n\nRaises\n------\nNetworkXPointlessConcept\n    If the graph `G` is the null graph.\nZeroDivisionError\n    If the graph `G` has no edges (is empty) and normalization is requested.\n\nReferences\n----------\n.. [1] Qi, X., Fuller, E., Wu, Q., Wu, Y., and Zhang, C.-Q. (2012).\n   Laplacian centrality: A new centrality measure for weighted networks.\n   Information Sciences, 194:240-253.\n   https://math.wvu.edu/~cqzhang/Publication-files/my-paper/INS-2012-Laplacian-W.pdf\n\nSee Also\n--------\n:func:`~networkx.linalg.laplacianmatrix.directed_laplacian_matrix`\n:func:`~networkx.linalg.laplacianmatrix.laplacian_matrix`"}, {"type": "function", "name": "networkx.laplacian_matrix", "documentation": "Returns the Laplacian matrix of G.\n\nThe graph Laplacian is the matrix L = D - A, where\nA is the adjacency matrix and D is the diagonal matrix of node degrees.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nnodelist : list, optional\n   The rows and columns are ordered according to the nodes in nodelist.\n   If nodelist is None, then the ordering is produced by G.nodes().\n\nweight : string or None, optional (default='weight')\n   The edge data key used to compute each value in the matrix.\n   If None, then each edge has weight 1.\n\nReturns\n-------\nL : SciPy sparse array\n  The Laplacian matrix of G.\n\nNotes\n-----\nFor MultiGraph, the edges weights are summed.\n\nThis returns an unnormalized matrix. For a normalized output,\nuse `normalized_laplacian_matrix`, `directed_laplacian_matrix`,\nor `directed_combinatorial_laplacian_matrix`.\n\nThis calculation uses the out-degree of the graph `G`. To use the\nin-degree for calculations instead, use `G.reverse(copy=False)` and\ntake the transpose.\n\nSee Also\n--------\n:func:`~networkx.convert_matrix.to_numpy_array`\nnormalized_laplacian_matrix\ndirected_laplacian_matrix\ndirected_combinatorial_laplacian_matrix\n:func:`~networkx.linalg.spectrum.laplacian_spectrum`\n\nExamples\n--------\nFor graphs with multiple connected components, L is permutation-similar\nto a block diagonal matrix where each block is the respective Laplacian\nmatrix for each component.\n\n>>> G = nx.Graph([(1, 2), (2, 3), (4, 5)])\n>>> print(nx.laplacian_matrix(G).toarray())\n[[ 1 -1  0  0  0]\n [-1  2 -1  0  0]\n [ 0 -1  1  0  0]\n [ 0  0  0  1 -1]\n [ 0  0  0 -1  1]]\n\n>>> edges = [\n...     (1, 2),\n...     (2, 1),\n...     (2, 4),\n...     (4, 3),\n...     (3, 4),\n... ]\n>>> DiG = nx.DiGraph(edges)\n>>> print(nx.laplacian_matrix(DiG).toarray())\n[[ 1 -1  0  0]\n [-1  2 -1  0]\n [ 0  0  1 -1]\n [ 0  0 -1  1]]\n\nNotice that node 4 is represented by the third column and row. This is because\nby default the row/column order is the order of `G.nodes` (i.e. the node added\norder -- in the edgelist, 4 first appears in (2, 4), before node 3 in edge (4, 3).)\nTo control the node order of the matrix, use the `nodelist` argument.\n\n>>> print(nx.laplacian_matrix(DiG, nodelist=[1, 2, 3, 4]).toarray())\n[[ 1 -1  0  0]\n [-1  2  0 -1]\n [ 0  0  1 -1]\n [ 0  0 -1  1]]\n\nThis calculation uses the out-degree of the graph `G`. To use the\nin-degree for calculations instead, use `G.reverse(copy=False)` and\ntake the transpose.\n\n>>> print(nx.laplacian_matrix(DiG.reverse(copy=False)).toarray().T)\n[[ 1 -1  0  0]\n [-1  1 -1  0]\n [ 0  0  2 -1]\n [ 0  0 -1  1]]\n\nReferences\n----------\n.. [1] Langville, Amy N., and Carl D. Meyer. Google\u2019s PageRank and Beyond:\n   The Science of Search Engine Rankings. Princeton University Press, 2006."}, {"type": "function", "name": "networkx.laplacian_spectrum", "documentation": "Returns eigenvalues of the Laplacian of G\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nweight : string or None, optional (default='weight')\n   The edge data key used to compute each value in the matrix.\n   If None, then each edge has weight 1.\n\nReturns\n-------\nevals : NumPy array\n  Eigenvalues\n\nNotes\n-----\nFor MultiGraph/MultiDiGraph, the edges weights are summed.\nSee :func:`~networkx.convert_matrix.to_numpy_array` for other options.\n\nSee Also\n--------\nlaplacian_matrix\n\nExamples\n--------\nThe multiplicity of 0 as an eigenvalue of the laplacian matrix is equal\nto the number of connected components of G.\n\n>>> G = nx.Graph()  # Create a graph with 5 nodes and 3 connected components\n>>> G.add_nodes_from(range(5))\n>>> G.add_edges_from([(0, 2), (3, 4)])\n>>> nx.laplacian_spectrum(G)\narray([0., 0., 0., 2., 2.])"}, {"type": "function", "name": "networkx.lattice_reference", "documentation": "Latticize the given graph by swapping edges.\n\nParameters\n----------\nG : graph\n    An undirected graph.\n\nniter : integer (optional, default=1)\n    An edge is rewired approximately niter times.\n\nD : numpy.array (optional, default=None)\n    Distance to the diagonal matrix.\n\nconnectivity : boolean (optional, default=True)\n    Ensure connectivity for the latticized graph when set to True.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : graph\n    The latticized graph.\n\nRaises\n------\nNetworkXError\n    If there are fewer than 4 nodes or 2 edges in `G`\n\nNotes\n-----\nThe implementation is adapted from the algorithm by Sporns et al. [1]_.\nwhich is inspired from the original work by Maslov and Sneppen(2002) [2]_.\n\nReferences\n----------\n.. [1] Sporns, Olaf, and Jonathan D. Zwi.\n   \"The small world of the cerebral cortex.\"\n   Neuroinformatics 2.2 (2004): 145-162.\n.. [2] Maslov, Sergei, and Kim Sneppen.\n   \"Specificity and stability in topology of protein networks.\"\n   Science 296.5569 (2002): 910-913."}, {"type": "function", "name": "networkx.les_miserables_graph", "documentation": "Returns coappearance network of characters in the novel Les Miserables.\n\nReferences\n----------\n.. [1] D. E. Knuth, 1993.\n   The Stanford GraphBase: a platform for combinatorial computing,\n   pp. 74-87. New York: AcM Press."}, {"type": "function", "name": "networkx.lexicographic_product", "documentation": "Returns the lexicographic product of G and H.\n\nThe lexicographical product $P$ of the graphs $G$ and $H$ has a node set\nthat is the Cartesian product of the node sets, $V(P)=V(G) \\times V(H)$.\n$P$ has an edge $((u,v), (x,y))$ if and only if $(u,v)$ is an edge in $G$\nor $u==v$ and $(x,y)$ is an edge in $H$.\n\nParameters\n----------\nG, H: graphs\n Networkx graphs.\n\nReturns\n-------\nP: NetworkX graph\n The Cartesian product of G and H. P will be a multi-graph if either G\n or H is a multi-graph. Will be a directed if G and H are directed,\n and undirected if G and H are undirected.\n\nRaises\n------\nNetworkXError\n If G and H are not both directed or both undirected.\n\nNotes\n-----\nNode attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> H = nx.Graph()\n>>> G.add_node(0, a1=True)\n>>> H.add_node(\"a\", a2=\"Spam\")\n>>> P = nx.lexicographic_product(G, H)\n>>> list(P)\n[(0, 'a')]\n\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph"}, {"type": "function", "name": "networkx.lexicographical_topological_sort", "documentation": "Generate the nodes in the unique lexicographical topological sort order.\n\nGenerates a unique ordering of nodes by first sorting topologically (for which there are often\nmultiple valid orderings) and then additionally by sorting lexicographically.\n\nA topological sort arranges the nodes of a directed graph so that the\nupstream node of each directed edge precedes the downstream node.\nIt is always possible to find a solution for directed graphs that have no cycles.\nThere may be more than one valid solution.\n\nLexicographical sorting is just sorting alphabetically. It is used here to break ties in the\ntopological sort and to determine a single, unique ordering.  This can be useful in comparing\nsort results.\n\nThe lexicographical order can be customized by providing a function to the `key=` parameter.\nThe definition of the key function is the same as used in python's built-in `sort()`.\nThe function takes a single argument and returns a key to use for sorting purposes.\n\nLexicographical sorting can fail if the node names are un-sortable. See the example below.\nThe solution is to provide a function to the `key=` argument that returns sortable keys.\n\n\nParameters\n----------\nG : NetworkX digraph\n    A directed acyclic graph (DAG)\n\nkey : function, optional\n    A function of one argument that converts a node name to a comparison key.\n    It defines and resolves ambiguities in the sort order.  Defaults to the identity function.\n\nYields\n------\nnodes\n    Yields the nodes of G in lexicographical topological sort order.\n\nRaises\n------\nNetworkXError\n    Topological sort is defined for directed graphs only. If the graph `G`\n    is undirected, a :exc:`NetworkXError` is raised.\n\nNetworkXUnfeasible\n    If `G` is not a directed acyclic graph (DAG) no topological sort exists\n    and a :exc:`NetworkXUnfeasible` exception is raised.  This can also be\n    raised if `G` is changed while the returned iterator is being processed\n\nRuntimeError\n    If `G` is changed while the returned iterator is being processed.\n\nTypeError\n    Results from un-sortable node names.\n    Consider using `key=` parameter to resolve ambiguities in the sort order.\n\nExamples\n--------\n>>> DG = nx.DiGraph([(2, 1), (2, 5), (1, 3), (1, 4), (5, 4)])\n>>> list(nx.lexicographical_topological_sort(DG))\n[2, 1, 3, 5, 4]\n>>> list(nx.lexicographical_topological_sort(DG, key=lambda x: -x))\n[2, 5, 1, 4, 3]\n\nThe sort will fail for any graph with integer and string nodes. Comparison of integer to strings\nis not defined in python.  Is 3 greater or less than 'red'?\n\n>>> DG = nx.DiGraph([(1, \"red\"), (3, \"red\"), (1, \"green\"), (2, \"blue\")])\n>>> list(nx.lexicographical_topological_sort(DG))\nTraceback (most recent call last):\n...\nTypeError: '<' not supported between instances of 'str' and 'int'\n...\n\nIncomparable nodes can be resolved using a `key` function. This example function\nallows comparison of integers and strings by returning a tuple where the first\nelement is True for `str`, False otherwise. The second element is the node name.\nThis groups the strings and integers separately so they can be compared only among themselves.\n\n>>> key = lambda node: (isinstance(node, str), node)\n>>> list(nx.lexicographical_topological_sort(DG, key=key))\n[1, 2, 3, 'blue', 'green', 'red']\n\nNotes\n-----\nThis algorithm is based on a description and proof in\n\"Introduction to Algorithms: A Creative Approach\" [1]_ .\n\nSee also\n--------\ntopological_sort\n\nReferences\n----------\n.. [1] Manber, U. (1989).\n   *Introduction to Algorithms - A Creative Approach.* Addison-Wesley."}, {"type": "function", "name": "networkx.line_graph", "documentation": "Returns the line graph of the graph or digraph `G`.\n\nThe line graph of a graph `G` has a node for each edge in `G` and an\nedge joining those nodes if the two edges in `G` share a common node. For\ndirected graphs, nodes are adjacent exactly when the edges they represent\nform a directed path of length two.\n\nThe nodes of the line graph are 2-tuples of nodes in the original graph (or\n3-tuples for multigraphs, with the key of the edge as the third element).\n\nFor information about self-loops and more discussion, see the **Notes**\nsection below.\n\nParameters\n----------\nG : graph\n    A NetworkX Graph, DiGraph, MultiGraph, or MultiDigraph.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nL : graph\n    The line graph of G.\n\nExamples\n--------\n>>> G = nx.star_graph(3)\n>>> L = nx.line_graph(G)\n>>> print(sorted(map(sorted, L.edges())))  # makes a 3-clique, K3\n[[(0, 1), (0, 2)], [(0, 1), (0, 3)], [(0, 2), (0, 3)]]\n\nEdge attributes from `G` are not copied over as node attributes in `L`, but\nattributes can be copied manually:\n\n>>> G = nx.path_graph(4)\n>>> G.add_edges_from((u, v, {\"tot\": u + v}) for u, v in G.edges)\n>>> G.edges(data=True)\nEdgeDataView([(0, 1, {'tot': 1}), (1, 2, {'tot': 3}), (2, 3, {'tot': 5})])\n>>> H = nx.line_graph(G)\n>>> H.add_nodes_from((node, G.edges[node]) for node in H)\n>>> H.nodes(data=True)\nNodeDataView({(0, 1): {'tot': 1}, (2, 3): {'tot': 5}, (1, 2): {'tot': 3}})\n\nNotes\n-----\nGraph, node, and edge data are not propagated to the new graph. For\nundirected graphs, the nodes in G must be sortable, otherwise the\nconstructed line graph may not be correct.\n\n*Self-loops in undirected graphs*\n\nFor an undirected graph `G` without multiple edges, each edge can be\nwritten as a set `\\{u, v\\}`.  Its line graph `L` has the edges of `G` as\nits nodes. If `x` and `y` are two nodes in `L`, then `\\{x, y\\}` is an edge\nin `L` if and only if the intersection of `x` and `y` is nonempty. Thus,\nthe set of all edges is determined by the set of all pairwise intersections\nof edges in `G`.\n\nTrivially, every edge in G would have a nonzero intersection with itself,\nand so every node in `L` should have a self-loop. This is not so\ninteresting, and the original context of line graphs was with simple\ngraphs, which had no self-loops or multiple edges. The line graph was also\nmeant to be a simple graph and thus, self-loops in `L` are not part of the\nstandard definition of a line graph. In a pairwise intersection matrix,\nthis is analogous to excluding the diagonal entries from the line graph\ndefinition.\n\nSelf-loops and multiple edges in `G` add nodes to `L` in a natural way, and\ndo not require any fundamental changes to the definition. It might be\nargued that the self-loops we excluded before should now be included.\nHowever, the self-loops are still \"trivial\" in some sense and thus, are\nusually excluded.\n\n*Self-loops in directed graphs*\n\nFor a directed graph `G` without multiple edges, each edge can be written\nas a tuple `(u, v)`. Its line graph `L` has the edges of `G` as its\nnodes. If `x` and `y` are two nodes in `L`, then `(x, y)` is an edge in `L`\nif and only if the tail of `x` matches the head of `y`, for example, if `x\n= (a, b)` and `y = (b, c)` for some vertices `a`, `b`, and `c` in `G`.\n\nDue to the directed nature of the edges, it is no longer the case that\nevery edge in `G` should have a self-loop in `L`. Now, the only time\nself-loops arise is if a node in `G` itself has a self-loop.  So such\nself-loops are no longer \"trivial\" but instead, represent essential\nfeatures of the topology of `G`. For this reason, the historical\ndevelopment of line digraphs is such that self-loops are included. When the\ngraph `G` has multiple edges, once again only superficial changes are\nrequired to the definition.\n\nReferences\n----------\n* Harary, Frank, and Norman, Robert Z., \"Some properties of line digraphs\",\n  Rend. Circ. Mat. Palermo, II. Ser. 9 (1960), 161--168.\n* Hemminger, R. L.; Beineke, L. W. (1978), \"Line graphs and line digraphs\",\n  in Beineke, L. W.; Wilson, R. J., Selected Topics in Graph Theory,\n  Academic Press Inc., pp. 271--305."}, {"type": "function", "name": "networkx.load_centrality", "documentation": "Compute load centrality for nodes.\n\nThe load centrality of a node is the fraction of all shortest\npaths that pass through that node.\n\nParameters\n----------\nG : graph\n  A networkx graph.\n\nnormalized : bool, optional (default=True)\n  If True the betweenness values are normalized by b=b/(n-1)(n-2) where\n  n is the number of nodes in G.\n\nweight : None or string, optional (default=None)\n  If None, edge weights are ignored.\n  Otherwise holds the name of the edge attribute used as weight.\n  The weight of an edge is treated as the length or distance between the two sides.\n\ncutoff : bool, optional (default=None)\n  If specified, only consider paths of length <= cutoff.\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with centrality as the value.\n\nSee Also\n--------\nbetweenness_centrality\n\nNotes\n-----\nLoad centrality is slightly different than betweenness. It was originally\nintroduced by [2]_. For this load algorithm see [1]_.\n\nReferences\n----------\n.. [1] Mark E. J. Newman:\n   Scientific collaboration networks. II.\n   Shortest paths, weighted networks, and centrality.\n   Physical Review E 64, 016132, 2001.\n   http://journals.aps.org/pre/abstract/10.1103/PhysRevE.64.016132\n.. [2] Kwang-Il Goh, Byungnam Kahng and Doochul Kim\n   Universal behavior of Load Distribution in Scale-Free Networks.\n   Physical Review Letters 87(27):1\u20134, 2001.\n   https://doi.org/10.1103/PhysRevLett.87.278701"}, {"type": "function", "name": "networkx.local_bridges", "documentation": "Iterate over local bridges of `G` optionally computing the span\n\nA *local bridge* is an edge whose endpoints have no common neighbors.\nThat is, the edge is not part of a triangle in the graph.\n\nThe *span* of a *local bridge* is the shortest path length between\nthe endpoints if the local bridge is removed.\n\nParameters\n----------\nG : undirected graph\n\nwith_span : bool\n    If True, yield a 3-tuple `(u, v, span)`\n\nweight : function, string or None (default: None)\n    If function, used to compute edge weights for the span.\n    If string, the edge data attribute used in calculating span.\n    If None, all edges have weight 1.\n\nYields\n------\ne : edge\n    The local bridges as an edge 2-tuple of nodes `(u, v)` or\n    as a 3-tuple `(u, v, span)` when `with_span is True`.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is a directed graph or multigraph.\n\nExamples\n--------\nA cycle graph has every edge a local bridge with span N-1.\n\n   >>> G = nx.cycle_graph(9)\n   >>> (0, 8, 8) in set(nx.local_bridges(G))\n   True"}, {"type": "function", "name": "networkx.local_constraint", "documentation": "Returns the local constraint on the node ``u`` with respect to\nthe node ``v`` in the graph ``G``.\n\nFormally, the *local constraint on u with respect to v*, denoted\n$\\ell(u, v)$, is defined by\n\n.. math::\n\n   \\ell(u, v) = \\left(p_{uv} + \\sum_{w \\in N(v)} p_{uw} p_{wv}\\right)^2,\n\nwhere $N(v)$ is the set of neighbors of $v$ and $p_{uv}$ is the\nnormalized mutual weight of the (directed or undirected) edges\njoining $u$ and $v$, for each vertex $u$ and $v$ [1]_. The *mutual\nweight* of $u$ and $v$ is the sum of the weights of edges joining\nthem (edge weights are assumed to be one if the graph is\nunweighted).\n\nParameters\n----------\nG : NetworkX graph\n    The graph containing ``u`` and ``v``. This can be either\n    directed or undirected.\n\nu : node\n    A node in the graph ``G``.\n\nv : node\n    A node in the graph ``G``.\n\nweight : None or string, optional\n  If None, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n\nReturns\n-------\nfloat\n    The constraint of the node ``v`` in the graph ``G``.\n\nSee also\n--------\nconstraint\n\nReferences\n----------\n.. [1] Burt, Ronald S.\n       \"Structural holes and good ideas\".\n       American Journal of Sociology (110): 349\u2013399."}, {"type": "function", "name": "networkx.local_efficiency", "documentation": "Returns the average local efficiency of the graph.\n\nThe *efficiency* of a pair of nodes in a graph is the multiplicative\ninverse of the shortest path distance between the nodes. The *local\nefficiency* of a node in the graph is the average global efficiency of the\nsubgraph induced by the neighbors of the node. The *average local\nefficiency* is the average of the local efficiencies of each node [1]_.\n\nParameters\n----------\nG : :class:`networkx.Graph`\n    An undirected graph for which to compute the average local efficiency.\n\nReturns\n-------\nfloat\n    The average local efficiency of the graph.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n>>> nx.local_efficiency(G)\n0.9166666666666667\n\nNotes\n-----\nEdge weights are ignored when computing the shortest path distances.\n\nSee also\n--------\nglobal_efficiency\n\nReferences\n----------\n.. [1] Latora, Vito, and Massimo Marchiori.\n       \"Efficient behavior of small-world networks.\"\n       *Physical Review Letters* 87.19 (2001): 198701.\n       <https://doi.org/10.1103/PhysRevLett.87.198701>"}, {"type": "function", "name": "networkx.local_reaching_centrality", "documentation": "Returns the local reaching centrality of a node in a directed\ngraph.\n\nThe *local reaching centrality* of a node in a directed graph is the\nproportion of other nodes reachable from that node [1]_.\n\nParameters\n----------\nG : DiGraph\n    A NetworkX DiGraph.\n\nv : node\n    A node in the directed graph `G`.\n\npaths : dictionary (default=None)\n    If this is not `None` it must be a dictionary representation\n    of single-source shortest paths, as computed by, for example,\n    :func:`networkx.shortest_path` with source node `v`. Use this\n    keyword argument if you intend to invoke this function many\n    times but don't want the paths to be recomputed each time.\n\nweight : None or string, optional (default=None)\n    Attribute to use for edge weights.  If `None`, each edge weight\n    is assumed to be one. A higher weight implies a stronger\n    connection between nodes and a *shorter* path length.\n\nnormalized : bool, optional (default=True)\n    Whether to normalize the edge weights by the total sum of edge\n    weights.\n\nReturns\n-------\nh : float\n    The local reaching centrality of the node ``v`` in the graph\n    ``G``.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_edges_from([(1, 2), (1, 3)])\n>>> nx.local_reaching_centrality(G, 3)\n0.0\n>>> G.add_edge(3, 2)\n>>> nx.local_reaching_centrality(G, 3)\n0.5\n\nSee also\n--------\nglobal_reaching_centrality\n\nReferences\n----------\n.. [1] Mones, Enys, Lilla Vicsek, and Tam\u00e1s Vicsek.\n       \"Hierarchy Measure for Complex Networks.\"\n       *PLoS ONE* 7.3 (2012): e33799.\n       https://doi.org/10.1371/journal.pone.0033799"}, {"type": "function", "name": "networkx.lollipop_graph", "documentation": "Returns the Lollipop Graph; ``K_m`` connected to ``P_n``.\n\nThis is the Barbell Graph without the right barbell.\n\n.. plot::\n\n    >>> nx.draw(nx.lollipop_graph(3, 4))\n\nParameters\n----------\nm, n : int or iterable container of nodes\n    If an integer, nodes are from ``range(m)`` and ``range(m, m+n)``.\n    If a container of nodes, those nodes appear in the graph.\n    Warning: `m` and `n` are not checked for duplicates and if present the\n    resulting graph may not be as desired. Make sure you have no duplicates.\n\n    The nodes for `m` appear in the complete graph $K_m$ and the nodes\n    for `n` appear in the path $P_n$\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkx graph\n   A complete graph with `m` nodes connected to a path of length `n`.\n\nNotes\n-----\nThe 2 subgraphs are joined via an edge ``(m-1, m)``.\nIf ``n=0``, this is merely a complete graph.\n\n(This graph is an extremal example in David Aldous and Jim\nFill's etext on Random Walks on Graphs.)"}, {"type": "function", "name": "networkx.lowest_common_ancestor", "documentation": "Compute the lowest common ancestor of the given pair of nodes.\n\nParameters\n----------\nG : NetworkX directed graph\n\nnode1, node2 : nodes in the graph.\n\ndefault : object\n    Returned if no common ancestor between `node1` and `node2`\n\nReturns\n-------\nThe lowest common ancestor of node1 and node2,\nor default if they have no common ancestors.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> nx.add_path(G, (0, 1, 2, 3))\n>>> nx.add_path(G, (0, 4, 3))\n>>> nx.lowest_common_ancestor(G, 2, 4)\n0\n\nSee Also\n--------\nall_pairs_lowest_common_ancestor"}, {"type": "function", "name": "networkx.make_clique_bipartite", "documentation": "Returns the bipartite clique graph corresponding to `G`.\n\nIn the returned bipartite graph, the \"bottom\" nodes are the nodes of\n`G` and the \"top\" nodes represent the maximal cliques of `G`.\nThere is an edge from node *v* to clique *C* in the returned graph\nif and only if *v* is an element of *C*.\n\nParameters\n----------\nG : NetworkX graph\n    An undirected graph.\n\nfpos : bool\n    If True or not None, the returned graph will have an\n    additional attribute, `pos`, a dictionary mapping node to\n    position in the Euclidean plane.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkX graph\n    A bipartite graph whose \"bottom\" set is the nodes of the graph\n    `G`, whose \"top\" set is the cliques of `G`, and whose edges\n    join nodes of `G` to the cliques that contain them.\n\n    The nodes of the graph `G` have the node attribute\n    'bipartite' set to 1 and the nodes representing cliques\n    have the node attribute 'bipartite' set to 0, as is the\n    convention for bipartite graphs in NetworkX."}, {"type": "function", "name": "networkx.make_max_clique_graph", "documentation": "Returns the maximal clique graph of the given graph.\n\nThe nodes of the maximal clique graph of `G` are the cliques of\n`G` and an edge joins two cliques if the cliques are not disjoint.\n\nParameters\n----------\nG : NetworkX graph\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkX graph\n    A graph whose nodes are the cliques of `G` and whose edges\n    join two cliques if they are not disjoint.\n\nNotes\n-----\nThis function behaves like the following code::\n\n    import networkx as nx\n\n    G = nx.make_clique_bipartite(G)\n    cliques = [v for v in G.nodes() if G.nodes[v][\"bipartite\"] == 0]\n    G = nx.bipartite.projected_graph(G, cliques)\n    G = nx.relabel_nodes(G, {-v: v - 1 for v in G})\n\nIt should be faster, though, since it skips all the intermediate\nsteps."}, {"type": "function", "name": "networkx.margulis_gabber_galil_graph", "documentation": "Returns the Margulis-Gabber-Galil undirected MultiGraph on `n^2` nodes.\n\nThe undirected MultiGraph is regular with degree `8`. Nodes are integer\npairs. The second-largest eigenvalue of the adjacency matrix of the graph\nis at most `5 \\sqrt{2}`, regardless of `n`.\n\nParameters\n----------\nn : int\n    Determines the number of nodes in the graph: `n^2`.\ncreate_using : NetworkX graph constructor, optional (default MultiGraph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : graph\n    The constructed undirected multigraph.\n\nRaises\n------\nNetworkXError\n    If the graph is directed or not a multigraph."}, {"type": "function", "name": "networkx.max_flow_min_cost", "documentation": "Returns a maximum (s, t)-flow of minimum cost.\n\nG is a digraph with edge costs and capacities. There is a source\nnode s and a sink node t. This function finds a maximum flow from\ns to t whose total cost is minimized.\n\nParameters\n----------\nG : NetworkX graph\n    DiGraph on which a minimum cost flow satisfying all demands is\n    to be found.\n\ns: node label\n    Source of the flow.\n\nt: node label\n    Destination of the flow.\n\ncapacity: string\n    Edges of the graph G are expected to have an attribute capacity\n    that indicates how much flow the edge can support. If this\n    attribute is not present, the edge is considered to have\n    infinite capacity. Default value: 'capacity'.\n\nweight: string\n    Edges of the graph G are expected to have an attribute weight\n    that indicates the cost incurred by sending one unit of flow on\n    that edge. If not present, the weight is considered to be 0.\n    Default value: 'weight'.\n\nReturns\n-------\nflowDict: dictionary\n    Dictionary of dictionaries keyed by nodes such that\n    flowDict[u][v] is the flow edge (u, v).\n\nRaises\n------\nNetworkXError\n    This exception is raised if the input graph is not directed or\n    not connected.\n\nNetworkXUnbounded\n    This exception is raised if there is an infinite capacity path\n    from s to t in G. In this case there is no maximum flow. This\n    exception is also raised if the digraph G has a cycle of\n    negative cost and infinite capacity. Then, the cost of a flow\n    is unbounded below.\n\nSee also\n--------\ncost_of_flow, min_cost_flow, min_cost_flow_cost, network_simplex\n\nNotes\n-----\nThis algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_edges_from(\n...     [\n...         (1, 2, {\"capacity\": 12, \"weight\": 4}),\n...         (1, 3, {\"capacity\": 20, \"weight\": 6}),\n...         (2, 3, {\"capacity\": 6, \"weight\": -3}),\n...         (2, 6, {\"capacity\": 14, \"weight\": 1}),\n...         (3, 4, {\"weight\": 9}),\n...         (3, 5, {\"capacity\": 10, \"weight\": 5}),\n...         (4, 2, {\"capacity\": 19, \"weight\": 13}),\n...         (4, 5, {\"capacity\": 4, \"weight\": 0}),\n...         (5, 7, {\"capacity\": 28, \"weight\": 2}),\n...         (6, 5, {\"capacity\": 11, \"weight\": 1}),\n...         (6, 7, {\"weight\": 8}),\n...         (7, 4, {\"capacity\": 6, \"weight\": 6}),\n...     ]\n... )\n>>> mincostFlow = nx.max_flow_min_cost(G, 1, 7)\n>>> mincost = nx.cost_of_flow(G, mincostFlow)\n>>> mincost\n373\n>>> from networkx.algorithms.flow import maximum_flow\n>>> maxFlow = maximum_flow(G, 1, 7)[1]\n>>> nx.cost_of_flow(G, maxFlow) >= mincost\nTrue\n>>> mincostFlowValue = sum((mincostFlow[u][7] for u in G.predecessors(7))) - sum(\n...     (mincostFlow[7][v] for v in G.successors(7))\n... )\n>>> mincostFlowValue == nx.maximum_flow_value(G, 1, 7)\nTrue"}, {"type": "function", "name": "networkx.max_weight_clique", "documentation": "Find a maximum weight clique in G.\n\nA *clique* in a graph is a set of nodes such that every two distinct nodes\nare adjacent.  The *weight* of a clique is the sum of the weights of its\nnodes.  A *maximum weight clique* of graph G is a clique C in G such that\nno clique in G has weight greater than the weight of C.\n\nParameters\n----------\nG : NetworkX graph\n    Undirected graph\nweight : string or None, optional (default='weight')\n    The node attribute that holds the integer value used as a weight.\n    If None, then each node has weight 1.\n\nReturns\n-------\nclique : list\n    the nodes of a maximum weight clique\nweight : int\n    the weight of a maximum weight clique\n\nNotes\n-----\nThe implementation is recursive, and therefore it may run into recursion\ndepth issues if G contains a clique whose number of nodes is close to the\nrecursion depth limit.\n\nAt each search node, the algorithm greedily constructs a weighted\nindependent set cover of part of the graph in order to find a small set of\nnodes on which to branch.  The algorithm is very similar to the algorithm\nof Tavares et al. [1]_, other than the fact that the NetworkX version does\nnot use bitsets.  This style of algorithm for maximum weight clique (and\nmaximum weight independent set, which is the same problem but on the\ncomplement graph) has a decades-long history.  See Algorithm B of Warren\nand Hicks [2]_ and the references in that paper.\n\nReferences\n----------\n.. [1] Tavares, W.A., Neto, M.B.C., Rodrigues, C.D., Michelon, P.: Um\n       algoritmo de branch and bound para o problema da clique m\u00e1xima\n       ponderada.  Proceedings of XLVII SBPO 1 (2015).\n\n.. [2] Warren, Jeffrey S, Hicks, Illya V.: Combinatorial Branch-and-Bound\n       for the Maximum Weight Independent Set Problem.  Technical Report,\n       Texas A&M University (2016)."}, {"type": "function", "name": "networkx.max_weight_matching", "documentation": "Compute a maximum-weighted matching of G.\n\nA matching is a subset of edges in which no node occurs more than once.\nThe weight of a matching is the sum of the weights of its edges.\nA maximal matching cannot add more edges and still be a matching.\nThe cardinality of a matching is the number of matched edges.\n\nParameters\n----------\nG : NetworkX graph\n  Undirected graph\n\nmaxcardinality: bool, optional (default=False)\n   If maxcardinality is True, compute the maximum-cardinality matching\n   with maximum weight among all maximum-cardinality matchings.\n\nweight: string, optional (default='weight')\n   Edge data key corresponding to the edge weight.\n   If key not found, uses 1 as weight.\n\n\nReturns\n-------\nmatching : set\n    A maximal matching of the graph.\n\n Examples\n--------\n>>> G = nx.Graph()\n>>> edges = [(1, 2, 6), (1, 3, 2), (2, 3, 1), (2, 4, 7), (3, 5, 9), (4, 5, 3)]\n>>> G.add_weighted_edges_from(edges)\n>>> sorted(nx.max_weight_matching(G))\n[(2, 4), (5, 3)]\n\nNotes\n-----\nIf G has edges with weight attributes the edge data are used as\nweight values else the weights are assumed to be 1.\n\nThis function takes time O(number_of_nodes ** 3).\n\nIf all edge weights are integers, the algorithm uses only integer\ncomputations.  If floating point weights are used, the algorithm\ncould return a slightly suboptimal matching due to numeric\nprecision errors.\n\nThis method is based on the \"blossom\" method for finding augmenting\npaths and the \"primal-dual\" method for finding a matching of maximum\nweight, both methods invented by Jack Edmonds [1]_.\n\nBipartite graphs can also be matched using the functions present in\n:mod:`networkx.algorithms.bipartite.matching`.\n\nReferences\n----------\n.. [1] \"Efficient Algorithms for Finding Maximum Matching in Graphs\",\n   Zvi Galil, ACM Computing Surveys, 1986."}, {"type": "function", "name": "networkx.maximal_independent_set", "documentation": "Returns a random maximal independent set guaranteed to contain\na given set of nodes.\n\nAn independent set is a set of nodes such that the subgraph\nof G induced by these nodes contains no edges. A maximal\nindependent set is an independent set such that it is not possible\nto add a new node and still get an independent set.\n\nParameters\n----------\nG : NetworkX graph\n\nnodes : list or iterable\n   Nodes that must be part of the independent set. This set of nodes\n   must be independent.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nindep_nodes : list\n   List of nodes that are part of a maximal independent set.\n\nRaises\n------\nNetworkXUnfeasible\n   If the nodes in the provided list are not part of the graph or\n   do not form an independent set, an exception is raised.\n\nNetworkXNotImplemented\n    If `G` is directed.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> nx.maximal_independent_set(G)  # doctest: +SKIP\n[4, 0, 2]\n>>> nx.maximal_independent_set(G, [1])  # doctest: +SKIP\n[1, 3]\n\nNotes\n-----\nThis algorithm does not solve the maximum independent set problem."}, {"type": "function", "name": "networkx.maximal_matching", "documentation": "Find a maximal matching in the graph.\n\nA matching is a subset of edges in which no node occurs more than once.\nA maximal matching cannot add more edges and still be a matching.\n\nParameters\n----------\nG : NetworkX graph\n    Undirected graph\n\nReturns\n-------\nmatching : set\n    A maximal matching of the graph.\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 5)])\n>>> sorted(nx.maximal_matching(G))\n[(1, 2), (3, 5)]\n\nNotes\n-----\nThe algorithm greedily selects a maximal matching M of the graph G\n(i.e. no superset of M exists). It runs in $O(|E|)$ time."}, {"type": "function", "name": "networkx.maximum_branching", "documentation": "Returns a maximum branching from G.\n\nParameters\n----------\nG : (multi)digraph-like\n    The graph to be searched.\nattr : str\n    The edge attribute used to in determining optimality.\ndefault : float\n    The value of the edge attribute used if an edge does not have\n    the attribute `attr`.\npreserve_attrs : bool\n    If True, preserve the other attributes of the original graph (that are not\n    passed to `attr`)\npartition : str\n    The key for the edge attribute containing the partition\n    data on the graph. Edges can be included, excluded or open using the\n    `EdgePartition` enum.\n\nReturns\n-------\nB : (multi)digraph-like\n    A maximum branching."}, {"type": "function", "name": "networkx.maximum_flow", "documentation": "Find a maximum single-commodity flow.\n\nParameters\n----------\nflowG : NetworkX graph\n    Edges of the graph are expected to have an attribute called\n    'capacity'. If this attribute is not present, the edge is\n    considered to have infinite capacity.\n\n_s : node\n    Source node for the flow.\n\n_t : node\n    Sink node for the flow.\n\ncapacity : string\n    Edges of the graph G are expected to have an attribute capacity\n    that indicates how much flow the edge can support. If this\n    attribute is not present, the edge is considered to have\n    infinite capacity. Default value: 'capacity'.\n\nflow_func : function\n    A function for computing the maximum flow among a pair of nodes\n    in a capacitated graph. The function has to accept at least three\n    parameters: a Graph or Digraph, a source node, and a target node.\n    And return a residual network that follows NetworkX conventions\n    (see Notes). If flow_func is None, the default maximum\n    flow function (:meth:`preflow_push`) is used. See below for\n    alternative algorithms. The choice of the default function may change\n    from version to version and should not be relied on. Default value:\n    None.\n\nkwargs : Any other keyword parameter is passed to the function that\n    computes the maximum flow.\n\nReturns\n-------\nflow_value : integer, float\n    Value of the maximum flow, i.e., net outflow from the source.\n\nflow_dict : dict\n    A dictionary containing the value of the flow that went through\n    each edge.\n\nRaises\n------\nNetworkXError\n    The algorithm does not support MultiGraph and MultiDiGraph. If\n    the input graph is an instance of one of these two classes, a\n    NetworkXError is raised.\n\nNetworkXUnbounded\n    If the graph has a path of infinite capacity, the value of a\n    feasible flow on the graph is unbounded above and the function\n    raises a NetworkXUnbounded.\n\nSee also\n--------\n:meth:`maximum_flow_value`\n:meth:`minimum_cut`\n:meth:`minimum_cut_value`\n:meth:`edmonds_karp`\n:meth:`preflow_push`\n:meth:`shortest_augmenting_path`\n\nNotes\n-----\nThe function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions:\n\nThe residual network :samp:`R` from an input graph :samp:`G` has the\nsame nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\nof edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\nself-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\nin :samp:`G`.\n\nFor each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`\nis equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\nin :samp:`G` or zero otherwise. If the capacity is infinite,\n:samp:`R[u][v]['capacity']` will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in\n:samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,\n:samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and\nsatisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.\n\nThe flow value, defined as the total flow into :samp:`t`, the sink, is\nstored in :samp:`R.graph['flow_value']`. Reachability to :samp:`t` using\nonly edges :samp:`(u, v)` such that\n:samp:`R[u][v]['flow'] < R[u][v]['capacity']` induces a minimum\n:samp:`s`-:samp:`t` cut.\n\nSpecific algorithms may store extra data in :samp:`R`.\n\nThe function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_edge(\"x\", \"a\", capacity=3.0)\n>>> G.add_edge(\"x\", \"b\", capacity=1.0)\n>>> G.add_edge(\"a\", \"c\", capacity=3.0)\n>>> G.add_edge(\"b\", \"c\", capacity=5.0)\n>>> G.add_edge(\"b\", \"d\", capacity=4.0)\n>>> G.add_edge(\"d\", \"e\", capacity=2.0)\n>>> G.add_edge(\"c\", \"y\", capacity=2.0)\n>>> G.add_edge(\"e\", \"y\", capacity=3.0)\n\nmaximum_flow returns both the value of the maximum flow and a\ndictionary with all flows.\n\n>>> flow_value, flow_dict = nx.maximum_flow(G, \"x\", \"y\")\n>>> flow_value\n3.0\n>>> print(flow_dict[\"x\"][\"b\"])\n1.0\n\nYou can also use alternative algorithms for computing the\nmaximum flow by using the flow_func parameter.\n\n>>> from networkx.algorithms.flow import shortest_augmenting_path\n>>> flow_value == nx.maximum_flow(G, \"x\", \"y\", flow_func=shortest_augmenting_path)[0]\nTrue"}, {"type": "function", "name": "networkx.maximum_flow_value", "documentation": "Find the value of maximum single-commodity flow.\n\nParameters\n----------\nflowG : NetworkX graph\n    Edges of the graph are expected to have an attribute called\n    'capacity'. If this attribute is not present, the edge is\n    considered to have infinite capacity.\n\n_s : node\n    Source node for the flow.\n\n_t : node\n    Sink node for the flow.\n\ncapacity : string\n    Edges of the graph G are expected to have an attribute capacity\n    that indicates how much flow the edge can support. If this\n    attribute is not present, the edge is considered to have\n    infinite capacity. Default value: 'capacity'.\n\nflow_func : function\n    A function for computing the maximum flow among a pair of nodes\n    in a capacitated graph. The function has to accept at least three\n    parameters: a Graph or Digraph, a source node, and a target node.\n    And return a residual network that follows NetworkX conventions\n    (see Notes). If flow_func is None, the default maximum\n    flow function (:meth:`preflow_push`) is used. See below for\n    alternative algorithms. The choice of the default function may change\n    from version to version and should not be relied on. Default value:\n    None.\n\nkwargs : Any other keyword parameter is passed to the function that\n    computes the maximum flow.\n\nReturns\n-------\nflow_value : integer, float\n    Value of the maximum flow, i.e., net outflow from the source.\n\nRaises\n------\nNetworkXError\n    The algorithm does not support MultiGraph and MultiDiGraph. If\n    the input graph is an instance of one of these two classes, a\n    NetworkXError is raised.\n\nNetworkXUnbounded\n    If the graph has a path of infinite capacity, the value of a\n    feasible flow on the graph is unbounded above and the function\n    raises a NetworkXUnbounded.\n\nSee also\n--------\n:meth:`maximum_flow`\n:meth:`minimum_cut`\n:meth:`minimum_cut_value`\n:meth:`edmonds_karp`\n:meth:`preflow_push`\n:meth:`shortest_augmenting_path`\n\nNotes\n-----\nThe function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions:\n\nThe residual network :samp:`R` from an input graph :samp:`G` has the\nsame nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\nof edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\nself-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\nin :samp:`G`.\n\nFor each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`\nis equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\nin :samp:`G` or zero otherwise. If the capacity is infinite,\n:samp:`R[u][v]['capacity']` will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in\n:samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,\n:samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and\nsatisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.\n\nThe flow value, defined as the total flow into :samp:`t`, the sink, is\nstored in :samp:`R.graph['flow_value']`. Reachability to :samp:`t` using\nonly edges :samp:`(u, v)` such that\n:samp:`R[u][v]['flow'] < R[u][v]['capacity']` induces a minimum\n:samp:`s`-:samp:`t` cut.\n\nSpecific algorithms may store extra data in :samp:`R`.\n\nThe function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_edge(\"x\", \"a\", capacity=3.0)\n>>> G.add_edge(\"x\", \"b\", capacity=1.0)\n>>> G.add_edge(\"a\", \"c\", capacity=3.0)\n>>> G.add_edge(\"b\", \"c\", capacity=5.0)\n>>> G.add_edge(\"b\", \"d\", capacity=4.0)\n>>> G.add_edge(\"d\", \"e\", capacity=2.0)\n>>> G.add_edge(\"c\", \"y\", capacity=2.0)\n>>> G.add_edge(\"e\", \"y\", capacity=3.0)\n\nmaximum_flow_value computes only the value of the\nmaximum flow:\n\n>>> flow_value = nx.maximum_flow_value(G, \"x\", \"y\")\n>>> flow_value\n3.0\n\nYou can also use alternative algorithms for computing the\nmaximum flow by using the flow_func parameter.\n\n>>> from networkx.algorithms.flow import shortest_augmenting_path\n>>> flow_value == nx.maximum_flow_value(G, \"x\", \"y\", flow_func=shortest_augmenting_path)\nTrue"}, {"type": "function", "name": "networkx.maximum_spanning_arborescence", "documentation": "Returns a maximum spanning arborescence from G.\n\nParameters\n----------\nG : (multi)digraph-like\n    The graph to be searched.\nattr : str\n    The edge attribute used to in determining optimality.\ndefault : float\n    The value of the edge attribute used if an edge does not have\n    the attribute `attr`.\npreserve_attrs : bool\n    If True, preserve the other attributes of the original graph (that are not\n    passed to `attr`)\npartition : str\n    The key for the edge attribute containing the partition\n    data on the graph. Edges can be included, excluded or open using the\n    `EdgePartition` enum.\n\nReturns\n-------\nB : (multi)digraph-like\n    A maximum spanning arborescence.\n\nRaises\n------\nNetworkXException\n    If the graph does not contain a maximum spanning arborescence."}, {"type": "function", "name": "networkx.maximum_spanning_edges", "documentation": "Generate edges in a maximum spanning forest of an undirected\nweighted graph.\n\nA maximum spanning tree is a subgraph of the graph (a tree)\nwith the maximum possible sum of edge weights.  A spanning forest is a\nunion of the spanning trees for each connected component of the graph.\n\nParameters\n----------\nG : undirected Graph\n   An undirected graph. If `G` is connected, then the algorithm finds a\n   spanning tree. Otherwise, a spanning forest is found.\n\nalgorithm : string\n   The algorithm to use when finding a maximum spanning tree. Valid\n   choices are 'kruskal', 'prim', or 'boruvka'. The default is 'kruskal'.\n\nweight : string\n   Edge data key to use for weight (default 'weight').\n\nkeys : bool\n   Whether to yield edge key in multigraphs in addition to the edge.\n   If `G` is not a multigraph, this is ignored.\n\ndata : bool, optional\n   If True yield the edge data along with the edge.\n\nignore_nan : bool (default: False)\n    If a NaN is found as an edge weight normally an exception is raised.\n    If `ignore_nan is True` then that edge is ignored instead.\n\nReturns\n-------\nedges : iterator\n   An iterator over edges in a maximum spanning tree of `G`.\n   Edges connecting nodes `u` and `v` are represented as tuples:\n   `(u, v, k, d)` or `(u, v, k)` or `(u, v, d)` or `(u, v)`\n\n   If `G` is a multigraph, `keys` indicates whether the edge key `k` will\n   be reported in the third position in the edge tuple. `data` indicates\n   whether the edge datadict `d` will appear at the end of the edge tuple.\n\n   If `G` is not a multigraph, the tuples are `(u, v, d)` if `data` is True\n   or `(u, v)` if `data` is False.\n\nExamples\n--------\n>>> from networkx.algorithms import tree\n\nFind maximum spanning edges by Kruskal's algorithm\n\n>>> G = nx.cycle_graph(4)\n>>> G.add_edge(0, 3, weight=2)\n>>> mst = tree.maximum_spanning_edges(G, algorithm=\"kruskal\", data=False)\n>>> edgelist = list(mst)\n>>> sorted(sorted(e) for e in edgelist)\n[[0, 1], [0, 3], [1, 2]]\n\nFind maximum spanning edges by Prim's algorithm\n\n>>> G = nx.cycle_graph(4)\n>>> G.add_edge(0, 3, weight=2)  # assign weight 2 to edge 0-3\n>>> mst = tree.maximum_spanning_edges(G, algorithm=\"prim\", data=False)\n>>> edgelist = list(mst)\n>>> sorted(sorted(e) for e in edgelist)\n[[0, 1], [0, 3], [2, 3]]\n\nNotes\n-----\nFor Bor\u016fvka's algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct.\n\nFor the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used.\n\nModified code from David Eppstein, April 2006\nhttp://www.ics.uci.edu/~eppstein/PADS/"}, {"type": "function", "name": "networkx.maximum_spanning_tree", "documentation": "Returns a maximum spanning tree or forest on an undirected graph `G`.\n\nParameters\n----------\nG : undirected graph\n    An undirected graph. If `G` is connected, then the algorithm finds a\n    spanning tree. Otherwise, a spanning forest is found.\n\nweight : str\n   Data key to use for edge weights.\n\nalgorithm : string\n   The algorithm to use when finding a maximum spanning tree. Valid\n   choices are 'kruskal', 'prim', or 'boruvka'. The default is\n   'kruskal'.\n\nignore_nan : bool (default: False)\n    If a NaN is found as an edge weight normally an exception is raised.\n    If `ignore_nan is True` then that edge is ignored instead.\n\n\nReturns\n-------\nG : NetworkX Graph\n   A maximum spanning tree or forest.\n\n\nExamples\n--------\n>>> G = nx.cycle_graph(4)\n>>> G.add_edge(0, 3, weight=2)\n>>> T = nx.maximum_spanning_tree(G)\n>>> sorted(T.edges(data=True))\n[(0, 1, {}), (0, 3, {'weight': 2}), (1, 2, {})]\n\n\nNotes\n-----\nFor Bor\u016fvka's algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct.\n\nFor the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used.\n\nThere may be more than one tree with the same minimum or maximum weight.\nSee :mod:`networkx.tree.recognition` for more detailed definitions.\n\nIsolated nodes with self-loops are in the tree as edgeless isolated nodes."}, {"type": "function", "name": "networkx.maybe_regular_expander", "documentation": "Utility for creating a random regular expander.\n\nReturns a random $d$-regular graph on $n$ nodes which is an expander\ngraph with very good probability.\n\nParameters\n----------\nn : int\n  The number of nodes.\nd : int\n  The degree of each node.\ncreate_using : Graph Instance or Constructor\n  Indicator of type of graph to return.\n  If a Graph-type instance, then clear and use it.\n  If a constructor, call it to create an empty graph.\n  Use the Graph constructor by default.\nmax_tries : int. (default: 100)\n  The number of allowed loops when generating each independent cycle\nseed : (default: None)\n  Seed used to set random number generation state. See :ref`Randomness<randomness>`.\n\nNotes\n-----\nThe nodes are numbered from $0$ to $n - 1$.\n\nThe graph is generated by taking $d / 2$ random independent cycles.\n\nJoel Friedman proved that in this model the resulting\ngraph is an expander with probability\n$1 - O(n^{-\\tau})$ where $\\tau = \\lceil (\\sqrt{d - 1}) / 2 \\rceil - 1$. [1]_\n\nExamples\n--------\n>>> G = nx.maybe_regular_expander(n=200, d=6, seed=8020)\n\nReturns\n-------\nG : graph\n    The constructed undirected graph.\n\nRaises\n------\nNetworkXError\n    If $d % 2 != 0$ as the degree must be even.\n    If $n - 1$ is less than $ 2d $ as the graph is complete at most.\n    If max_tries is reached\n\nSee Also\n--------\nis_regular_expander\nrandom_regular_expander_graph\n\nReferences\n----------\n.. [1] Joel Friedman,\n   A Proof of Alon\u2019s Second Eigenvalue Conjecture and Related Problems, 2004\n   https://arxiv.org/abs/cs/0405020"}, {"type": "function", "name": "networkx.min_cost_flow", "documentation": "Returns a minimum cost flow satisfying all demands in digraph G.\n\nG is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node.\n\nParameters\n----------\nG : NetworkX graph\n    DiGraph on which a minimum cost flow satisfying all demands is\n    to be found.\n\ndemand : string\n    Nodes of the graph G are expected to have an attribute demand\n    that indicates how much flow a node wants to send (negative\n    demand) or receive (positive demand). Note that the sum of the\n    demands should be 0 otherwise the problem in not feasible. If\n    this attribute is not present, a node is considered to have 0\n    demand. Default value: 'demand'.\n\ncapacity : string\n    Edges of the graph G are expected to have an attribute capacity\n    that indicates how much flow the edge can support. If this\n    attribute is not present, the edge is considered to have\n    infinite capacity. Default value: 'capacity'.\n\nweight : string\n    Edges of the graph G are expected to have an attribute weight\n    that indicates the cost incurred by sending one unit of flow on\n    that edge. If not present, the weight is considered to be 0.\n    Default value: 'weight'.\n\nReturns\n-------\nflowDict : dictionary\n    Dictionary of dictionaries keyed by nodes such that\n    flowDict[u][v] is the flow edge (u, v).\n\nRaises\n------\nNetworkXError\n    This exception is raised if the input graph is not directed or\n    not connected.\n\nNetworkXUnfeasible\n    This exception is raised in the following situations:\n\n        * The sum of the demands is not zero. Then, there is no\n          flow satisfying all demands.\n        * There is no flow satisfying all demand.\n\nNetworkXUnbounded\n    This exception is raised if the digraph G has a cycle of\n    negative cost and infinite capacity. Then, the cost of a flow\n    satisfying all demands is unbounded below.\n\nSee also\n--------\ncost_of_flow, max_flow_min_cost, min_cost_flow_cost, network_simplex\n\nNotes\n-----\nThis algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).\n\nExamples\n--------\nA simple example of a min cost flow problem.\n\n>>> G = nx.DiGraph()\n>>> G.add_node(\"a\", demand=-5)\n>>> G.add_node(\"d\", demand=5)\n>>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\n>>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\n>>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\n>>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\n>>> flowDict = nx.min_cost_flow(G)\n>>> flowDict\n{'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}"}, {"type": "function", "name": "networkx.min_cost_flow_cost", "documentation": "Find the cost of a minimum cost flow satisfying all demands in digraph G.\n\nG is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node.\n\nParameters\n----------\nG : NetworkX graph\n    DiGraph on which a minimum cost flow satisfying all demands is\n    to be found.\n\ndemand : string\n    Nodes of the graph G are expected to have an attribute demand\n    that indicates how much flow a node wants to send (negative\n    demand) or receive (positive demand). Note that the sum of the\n    demands should be 0 otherwise the problem in not feasible. If\n    this attribute is not present, a node is considered to have 0\n    demand. Default value: 'demand'.\n\ncapacity : string\n    Edges of the graph G are expected to have an attribute capacity\n    that indicates how much flow the edge can support. If this\n    attribute is not present, the edge is considered to have\n    infinite capacity. Default value: 'capacity'.\n\nweight : string\n    Edges of the graph G are expected to have an attribute weight\n    that indicates the cost incurred by sending one unit of flow on\n    that edge. If not present, the weight is considered to be 0.\n    Default value: 'weight'.\n\nReturns\n-------\nflowCost : integer, float\n    Cost of a minimum cost flow satisfying all demands.\n\nRaises\n------\nNetworkXError\n    This exception is raised if the input graph is not directed or\n    not connected.\n\nNetworkXUnfeasible\n    This exception is raised in the following situations:\n\n        * The sum of the demands is not zero. Then, there is no\n          flow satisfying all demands.\n        * There is no flow satisfying all demand.\n\nNetworkXUnbounded\n    This exception is raised if the digraph G has a cycle of\n    negative cost and infinite capacity. Then, the cost of a flow\n    satisfying all demands is unbounded below.\n\nSee also\n--------\ncost_of_flow, max_flow_min_cost, min_cost_flow, network_simplex\n\nNotes\n-----\nThis algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).\n\nExamples\n--------\nA simple example of a min cost flow problem.\n\n>>> G = nx.DiGraph()\n>>> G.add_node(\"a\", demand=-5)\n>>> G.add_node(\"d\", demand=5)\n>>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\n>>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\n>>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\n>>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\n>>> flowCost = nx.min_cost_flow_cost(G)\n>>> flowCost\n24"}, {"type": "function", "name": "networkx.min_edge_cover", "documentation": "Returns the min cardinality edge cover of the graph as a set of edges.\n\nA smallest edge cover can be found in polynomial time by finding\na maximum matching and extending it greedily so that all nodes\nare covered. This function follows that process. A maximum matching\nalgorithm can be specified for the first step of the algorithm.\nThe resulting set may return a set with one 2-tuple for each edge,\n(the usual case) or with both 2-tuples `(u, v)` and `(v, u)` for\neach edge. The latter is only done when a bipartite matching algorithm\nis specified as `matching_algorithm`.\n\nParameters\n----------\nG : NetworkX graph\n    An undirected graph.\n\nmatching_algorithm : function\n    A function that returns a maximum cardinality matching for `G`.\n    The function must take one input, the graph `G`, and return\n    either a set of edges (with only one direction for the pair of nodes)\n    or a dictionary mapping each node to its mate. If not specified,\n    :func:`~networkx.algorithms.matching.max_weight_matching` is used.\n    Common bipartite matching functions include\n    :func:`~networkx.algorithms.bipartite.matching.hopcroft_karp_matching`\n    or\n    :func:`~networkx.algorithms.bipartite.matching.eppstein_matching`.\n\nReturns\n-------\nmin_cover : set\n\n    A set of the edges in a minimum edge cover in the form of tuples.\n    It contains only one of the equivalent 2-tuples `(u, v)` and `(v, u)`\n    for each edge. If a bipartite method is used to compute the matching,\n    the returned set contains both the 2-tuples `(u, v)` and `(v, u)`\n    for each edge of a minimum edge cover.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n>>> sorted(nx.min_edge_cover(G))\n[(2, 1), (3, 0)]\n\nNotes\n-----\nAn edge cover of a graph is a set of edges such that every node of\nthe graph is incident to at least one edge of the set.\nThe minimum edge cover is an edge covering of smallest cardinality.\n\nDue to its implementation, the worst-case running time of this algorithm\nis bounded by the worst-case running time of the function\n``matching_algorithm``.\n\nMinimum edge cover for `G` can also be found using the `min_edge_covering`\nfunction in :mod:`networkx.algorithms.bipartite.covering` which is\nsimply this function with a default matching algorithm of\n:func:`~networkx.algorithms.bipartite.matching.hopcraft_karp_matching`"}, {"type": "function", "name": "networkx.min_weight_matching", "documentation": "Computing a minimum-weight maximal matching of G.\n\nUse the maximum-weight algorithm with edge weights subtracted\nfrom the maximum weight of all edges.\n\nA matching is a subset of edges in which no node occurs more than once.\nThe weight of a matching is the sum of the weights of its edges.\nA maximal matching cannot add more edges and still be a matching.\nThe cardinality of a matching is the number of matched edges.\n\nThis method replaces the edge weights with 1 plus the maximum edge weight\nminus the original edge weight.\n\nnew_weight = (max_weight + 1) - edge_weight\n\nthen runs :func:`max_weight_matching` with the new weights.\nThe max weight matching with these new weights corresponds\nto the min weight matching using the original weights.\nAdding 1 to the max edge weight keeps all edge weights positive\nand as integers if they started as integers.\n\nYou might worry that adding 1 to each weight would make the algorithm\nfavor matchings with more edges. But we use the parameter\n`maxcardinality=True` in `max_weight_matching` to ensure that the\nnumber of edges in the competing matchings are the same and thus\nthe optimum does not change due to changes in the number of edges.\n\nRead the documentation of `max_weight_matching` for more information.\n\nParameters\n----------\nG : NetworkX graph\n  Undirected graph\n\nweight: string, optional (default='weight')\n   Edge data key corresponding to the edge weight.\n   If key not found, uses 1 as weight.\n\nReturns\n-------\nmatching : set\n    A minimal weight matching of the graph.\n\nSee Also\n--------\nmax_weight_matching"}, {"type": "function", "name": "networkx.minimal_d_separator", "documentation": "Returns a minimal_d-separating set between `x` and `y` if possible\n\n.. deprecated:: 3.3\n\n    minimal_d_separator is deprecated and will be removed in NetworkX v3.5.\n    Please use `find_minimal_d_separator(G, x, y)`."}, {"type": "function", "name": "networkx.minimum_branching", "documentation": "Returns a minimum branching from G.\n\nParameters\n----------\nG : (multi)digraph-like\n    The graph to be searched.\nattr : str\n    The edge attribute used to in determining optimality.\ndefault : float\n    The value of the edge attribute used if an edge does not have\n    the attribute `attr`.\npreserve_attrs : bool\n    If True, preserve the other attributes of the original graph (that are not\n    passed to `attr`)\npartition : str\n    The key for the edge attribute containing the partition\n    data on the graph. Edges can be included, excluded or open using the\n    `EdgePartition` enum.\n\nReturns\n-------\nB : (multi)digraph-like\n    A minimum branching.\n\nSee Also\n--------\n    minimal_branching"}, {"type": "function", "name": "networkx.minimum_cut", "documentation": "Compute the value and the node partition of a minimum (s, t)-cut.\n\nUse the max-flow min-cut theorem, i.e., the capacity of a minimum\ncapacity cut is equal to the flow value of a maximum flow.\n\nParameters\n----------\nflowG : NetworkX graph\n    Edges of the graph are expected to have an attribute called\n    'capacity'. If this attribute is not present, the edge is\n    considered to have infinite capacity.\n\n_s : node\n    Source node for the flow.\n\n_t : node\n    Sink node for the flow.\n\ncapacity : string\n    Edges of the graph G are expected to have an attribute capacity\n    that indicates how much flow the edge can support. If this\n    attribute is not present, the edge is considered to have\n    infinite capacity. Default value: 'capacity'.\n\nflow_func : function\n    A function for computing the maximum flow among a pair of nodes\n    in a capacitated graph. The function has to accept at least three\n    parameters: a Graph or Digraph, a source node, and a target node.\n    And return a residual network that follows NetworkX conventions\n    (see Notes). If flow_func is None, the default maximum\n    flow function (:meth:`preflow_push`) is used. See below for\n    alternative algorithms. The choice of the default function may change\n    from version to version and should not be relied on. Default value:\n    None.\n\nkwargs : Any other keyword parameter is passed to the function that\n    computes the maximum flow.\n\nReturns\n-------\ncut_value : integer, float\n    Value of the minimum cut.\n\npartition : pair of node sets\n    A partitioning of the nodes that defines a minimum cut.\n\nRaises\n------\nNetworkXUnbounded\n    If the graph has a path of infinite capacity, all cuts have\n    infinite capacity and the function raises a NetworkXError.\n\nSee also\n--------\n:meth:`maximum_flow`\n:meth:`maximum_flow_value`\n:meth:`minimum_cut_value`\n:meth:`edmonds_karp`\n:meth:`preflow_push`\n:meth:`shortest_augmenting_path`\n\nNotes\n-----\nThe function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions:\n\nThe residual network :samp:`R` from an input graph :samp:`G` has the\nsame nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\nof edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\nself-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\nin :samp:`G`.\n\nFor each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`\nis equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\nin :samp:`G` or zero otherwise. If the capacity is infinite,\n:samp:`R[u][v]['capacity']` will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in\n:samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,\n:samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and\nsatisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.\n\nThe flow value, defined as the total flow into :samp:`t`, the sink, is\nstored in :samp:`R.graph['flow_value']`. Reachability to :samp:`t` using\nonly edges :samp:`(u, v)` such that\n:samp:`R[u][v]['flow'] < R[u][v]['capacity']` induces a minimum\n:samp:`s`-:samp:`t` cut.\n\nSpecific algorithms may store extra data in :samp:`R`.\n\nThe function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_edge(\"x\", \"a\", capacity=3.0)\n>>> G.add_edge(\"x\", \"b\", capacity=1.0)\n>>> G.add_edge(\"a\", \"c\", capacity=3.0)\n>>> G.add_edge(\"b\", \"c\", capacity=5.0)\n>>> G.add_edge(\"b\", \"d\", capacity=4.0)\n>>> G.add_edge(\"d\", \"e\", capacity=2.0)\n>>> G.add_edge(\"c\", \"y\", capacity=2.0)\n>>> G.add_edge(\"e\", \"y\", capacity=3.0)\n\nminimum_cut computes both the value of the\nminimum cut and the node partition:\n\n>>> cut_value, partition = nx.minimum_cut(G, \"x\", \"y\")\n>>> reachable, non_reachable = partition\n\n'partition' here is a tuple with the two sets of nodes that define\nthe minimum cut. You can compute the cut set of edges that induce\nthe minimum cut as follows:\n\n>>> cutset = set()\n>>> for u, nbrs in ((n, G[n]) for n in reachable):\n...     cutset.update((u, v) for v in nbrs if v in non_reachable)\n>>> print(sorted(cutset))\n[('c', 'y'), ('x', 'b')]\n>>> cut_value == sum(G.edges[u, v][\"capacity\"] for (u, v) in cutset)\nTrue\n\nYou can also use alternative algorithms for computing the\nminimum cut by using the flow_func parameter.\n\n>>> from networkx.algorithms.flow import shortest_augmenting_path\n>>> cut_value == nx.minimum_cut(G, \"x\", \"y\", flow_func=shortest_augmenting_path)[0]\nTrue"}, {"type": "function", "name": "networkx.minimum_cut_value", "documentation": "Compute the value of a minimum (s, t)-cut.\n\nUse the max-flow min-cut theorem, i.e., the capacity of a minimum\ncapacity cut is equal to the flow value of a maximum flow.\n\nParameters\n----------\nflowG : NetworkX graph\n    Edges of the graph are expected to have an attribute called\n    'capacity'. If this attribute is not present, the edge is\n    considered to have infinite capacity.\n\n_s : node\n    Source node for the flow.\n\n_t : node\n    Sink node for the flow.\n\ncapacity : string\n    Edges of the graph G are expected to have an attribute capacity\n    that indicates how much flow the edge can support. If this\n    attribute is not present, the edge is considered to have\n    infinite capacity. Default value: 'capacity'.\n\nflow_func : function\n    A function for computing the maximum flow among a pair of nodes\n    in a capacitated graph. The function has to accept at least three\n    parameters: a Graph or Digraph, a source node, and a target node.\n    And return a residual network that follows NetworkX conventions\n    (see Notes). If flow_func is None, the default maximum\n    flow function (:meth:`preflow_push`) is used. See below for\n    alternative algorithms. The choice of the default function may change\n    from version to version and should not be relied on. Default value:\n    None.\n\nkwargs : Any other keyword parameter is passed to the function that\n    computes the maximum flow.\n\nReturns\n-------\ncut_value : integer, float\n    Value of the minimum cut.\n\nRaises\n------\nNetworkXUnbounded\n    If the graph has a path of infinite capacity, all cuts have\n    infinite capacity and the function raises a NetworkXError.\n\nSee also\n--------\n:meth:`maximum_flow`\n:meth:`maximum_flow_value`\n:meth:`minimum_cut`\n:meth:`edmonds_karp`\n:meth:`preflow_push`\n:meth:`shortest_augmenting_path`\n\nNotes\n-----\nThe function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions:\n\nThe residual network :samp:`R` from an input graph :samp:`G` has the\nsame nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair\nof edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a\nself-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists\nin :samp:`G`.\n\nFor each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`\nis equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists\nin :samp:`G` or zero otherwise. If the capacity is infinite,\n:samp:`R[u][v]['capacity']` will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in\n:samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,\n:samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and\nsatisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.\n\nThe flow value, defined as the total flow into :samp:`t`, the sink, is\nstored in :samp:`R.graph['flow_value']`. Reachability to :samp:`t` using\nonly edges :samp:`(u, v)` such that\n:samp:`R[u][v]['flow'] < R[u][v]['capacity']` induces a minimum\n:samp:`s`-:samp:`t` cut.\n\nSpecific algorithms may store extra data in :samp:`R`.\n\nThe function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_edge(\"x\", \"a\", capacity=3.0)\n>>> G.add_edge(\"x\", \"b\", capacity=1.0)\n>>> G.add_edge(\"a\", \"c\", capacity=3.0)\n>>> G.add_edge(\"b\", \"c\", capacity=5.0)\n>>> G.add_edge(\"b\", \"d\", capacity=4.0)\n>>> G.add_edge(\"d\", \"e\", capacity=2.0)\n>>> G.add_edge(\"c\", \"y\", capacity=2.0)\n>>> G.add_edge(\"e\", \"y\", capacity=3.0)\n\nminimum_cut_value computes only the value of the\nminimum cut:\n\n>>> cut_value = nx.minimum_cut_value(G, \"x\", \"y\")\n>>> cut_value\n3.0\n\nYou can also use alternative algorithms for computing the\nminimum cut by using the flow_func parameter.\n\n>>> from networkx.algorithms.flow import shortest_augmenting_path\n>>> cut_value == nx.minimum_cut_value(G, \"x\", \"y\", flow_func=shortest_augmenting_path)\nTrue"}, {"type": "function", "name": "networkx.minimum_cycle_basis", "documentation": "Returns a minimum weight cycle basis for G\n\nMinimum weight means a cycle basis for which the total weight\n(length for unweighted graphs) of all the cycles is minimum.\n\nParameters\n----------\nG : NetworkX Graph\nweight: string\n    name of the edge attribute to use for edge weights\n\nReturns\n-------\nA list of cycle lists.  Each cycle list is a list of nodes\nwhich forms a cycle (loop) in G. Note that the nodes are not\nnecessarily returned in a order by which they appear in the cycle\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> nx.add_cycle(G, [0, 1, 2, 3])\n>>> nx.add_cycle(G, [0, 3, 4, 5])\n>>> nx.minimum_cycle_basis(G)\n[[5, 4, 3, 0], [3, 2, 1, 0]]\n\nReferences:\n    [1] Kavitha, Telikepalli, et al. \"An O(m^2n) Algorithm for\n    Minimum Cycle Basis of Graphs.\"\n    http://link.springer.com/article/10.1007/s00453-007-9064-z\n    [2] de Pina, J. 1995. Applications of shortest path methods.\n    Ph.D. thesis, University of Amsterdam, Netherlands\n\nSee Also\n--------\nsimple_cycles, cycle_basis"}, {"type": "function", "name": "networkx.minimum_edge_cut", "documentation": "Returns a set of edges of minimum cardinality that disconnects G.\n\nIf source and target nodes are provided, this function returns the\nset of edges of minimum cardinality that, if removed, would break\nall paths among source and target in G. If not, it returns a set of\nedges of minimum cardinality that disconnects G.\n\nParameters\n----------\nG : NetworkX graph\n\ns : node\n    Source node. Optional. Default value: None.\n\nt : node\n    Target node. Optional. Default value: None.\n\nflow_func : function\n    A function for computing the maximum flow among a pair of nodes.\n    The function has to accept at least three parameters: a Digraph,\n    a source node, and a target node. And return a residual network\n    that follows NetworkX conventions (see :meth:`maximum_flow` for\n    details). If flow_func is None, the default maximum flow function\n    (:meth:`edmonds_karp`) is used. See below for details. The\n    choice of the default function may change from version\n    to version and should not be relied on. Default value: None.\n\nReturns\n-------\ncutset : set\n    Set of edges that, if removed, would disconnect G. If source\n    and target nodes are provided, the set contains the edges that\n    if removed, would destroy all paths between source and target.\n\nExamples\n--------\n>>> # Platonic icosahedral graph has edge connectivity 5\n>>> G = nx.icosahedral_graph()\n>>> len(nx.minimum_edge_cut(G))\n5\n\nYou can use alternative flow algorithms for the underlying\nmaximum flow computation. In dense networks the algorithm\n:meth:`shortest_augmenting_path` will usually perform better\nthan the default :meth:`edmonds_karp`, which is faster for\nsparse networks with highly skewed degree distributions.\nAlternative flow functions have to be explicitly imported\nfrom the flow package.\n\n>>> from networkx.algorithms.flow import shortest_augmenting_path\n>>> len(nx.minimum_edge_cut(G, flow_func=shortest_augmenting_path))\n5\n\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns the value of local edge connectivity.\n\n>>> nx.edge_connectivity(G, 3, 7)\n5\n\nIf you need to perform several local computations among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. See\n:meth:`local_edge_connectivity` for details.\n\nNotes\n-----\nThis is a flow based implementation of minimum edge cut. For\nundirected graphs the algorithm works by finding a 'small' dominating\nset of nodes of G (see algorithm 7 in [1]_) and computing the maximum\nflow between an arbitrary node in the dominating set and the rest of\nnodes in it. This is an implementation of algorithm 6 in [1]_. For\ndirected graphs, the algorithm does n calls to the max flow function.\nThe function raises an error if the directed graph is not weakly\nconnected and returns an empty set if it is weakly connected.\nIt is an implementation of algorithm 8 in [1]_.\n\nSee also\n--------\n:meth:`minimum_st_edge_cut`\n:meth:`minimum_node_cut`\n:meth:`stoer_wagner`\n:meth:`node_connectivity`\n:meth:`edge_connectivity`\n:meth:`maximum_flow`\n:meth:`edmonds_karp`\n:meth:`preflow_push`\n:meth:`shortest_augmenting_path`\n\nReferences\n----------\n.. [1] Abdol-Hossein Esfahanian. Connectivity Algorithms.\n    http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf"}, {"type": "function", "name": "networkx.minimum_node_cut", "documentation": "Returns a set of nodes of minimum cardinality that disconnects G.\n\nIf source and target nodes are provided, this function returns the\nset of nodes of minimum cardinality that, if removed, would destroy\nall paths among source and target in G. If not, it returns a set\nof nodes of minimum cardinality that disconnects G.\n\nParameters\n----------\nG : NetworkX graph\n\ns : node\n    Source node. Optional. Default value: None.\n\nt : node\n    Target node. Optional. Default value: None.\n\nflow_func : function\n    A function for computing the maximum flow among a pair of nodes.\n    The function has to accept at least three parameters: a Digraph,\n    a source node, and a target node. And return a residual network\n    that follows NetworkX conventions (see :meth:`maximum_flow` for\n    details). If flow_func is None, the default maximum flow function\n    (:meth:`edmonds_karp`) is used. See below for details. The\n    choice of the default function may change from version\n    to version and should not be relied on. Default value: None.\n\nReturns\n-------\ncutset : set\n    Set of nodes that, if removed, would disconnect G. If source\n    and target nodes are provided, the set contains the nodes that\n    if removed, would destroy all paths between source and target.\n\nExamples\n--------\n>>> # Platonic icosahedral graph has node connectivity 5\n>>> G = nx.icosahedral_graph()\n>>> node_cut = nx.minimum_node_cut(G)\n>>> len(node_cut)\n5\n\nYou can use alternative flow algorithms for the underlying maximum\nflow computation. In dense networks the algorithm\n:meth:`shortest_augmenting_path` will usually perform better\nthan the default :meth:`edmonds_karp`, which is faster for\nsparse networks with highly skewed degree distributions. Alternative\nflow functions have to be explicitly imported from the flow package.\n\n>>> from networkx.algorithms.flow import shortest_augmenting_path\n>>> node_cut == nx.minimum_node_cut(G, flow_func=shortest_augmenting_path)\nTrue\n\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns a local st node cut.\n\n>>> len(nx.minimum_node_cut(G, 3, 7))\n5\n\nIf you need to perform several local st cuts among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. See\n:meth:`minimum_st_node_cut` for details.\n\nNotes\n-----\nThis is a flow based implementation of minimum node cut. The algorithm\nis based in solving a number of maximum flow computations to determine\nthe capacity of the minimum cut on an auxiliary directed network that\ncorresponds to the minimum node cut of G. It handles both directed\nand undirected graphs. This implementation is based on algorithm 11\nin [1]_.\n\nSee also\n--------\n:meth:`minimum_st_node_cut`\n:meth:`minimum_cut`\n:meth:`minimum_edge_cut`\n:meth:`stoer_wagner`\n:meth:`node_connectivity`\n:meth:`edge_connectivity`\n:meth:`maximum_flow`\n:meth:`edmonds_karp`\n:meth:`preflow_push`\n:meth:`shortest_augmenting_path`\n\nReferences\n----------\n.. [1] Abdol-Hossein Esfahanian. Connectivity Algorithms.\n    http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf"}, {"type": "function", "name": "networkx.minimum_spanning_arborescence", "documentation": "Returns a minimum spanning arborescence from G.\n\nParameters\n----------\nG : (multi)digraph-like\n    The graph to be searched.\nattr : str\n    The edge attribute used to in determining optimality.\ndefault : float\n    The value of the edge attribute used if an edge does not have\n    the attribute `attr`.\npreserve_attrs : bool\n    If True, preserve the other attributes of the original graph (that are not\n    passed to `attr`)\npartition : str\n    The key for the edge attribute containing the partition\n    data on the graph. Edges can be included, excluded or open using the\n    `EdgePartition` enum.\n\nReturns\n-------\nB : (multi)digraph-like\n    A minimum spanning arborescence.\n\nRaises\n------\nNetworkXException\n    If the graph does not contain a minimum spanning arborescence."}, {"type": "function", "name": "networkx.minimum_spanning_edges", "documentation": "Generate edges in a minimum spanning forest of an undirected\nweighted graph.\n\nA minimum spanning tree is a subgraph of the graph (a tree)\nwith the minimum sum of edge weights.  A spanning forest is a\nunion of the spanning trees for each connected component of the graph.\n\nParameters\n----------\nG : undirected Graph\n   An undirected graph. If `G` is connected, then the algorithm finds a\n   spanning tree. Otherwise, a spanning forest is found.\n\nalgorithm : string\n   The algorithm to use when finding a minimum spanning tree. Valid\n   choices are 'kruskal', 'prim', or 'boruvka'. The default is 'kruskal'.\n\nweight : string\n   Edge data key to use for weight (default 'weight').\n\nkeys : bool\n   Whether to yield edge key in multigraphs in addition to the edge.\n   If `G` is not a multigraph, this is ignored.\n\ndata : bool, optional\n   If True yield the edge data along with the edge.\n\nignore_nan : bool (default: False)\n    If a NaN is found as an edge weight normally an exception is raised.\n    If `ignore_nan is True` then that edge is ignored instead.\n\nReturns\n-------\nedges : iterator\n   An iterator over edges in a maximum spanning tree of `G`.\n   Edges connecting nodes `u` and `v` are represented as tuples:\n   `(u, v, k, d)` or `(u, v, k)` or `(u, v, d)` or `(u, v)`\n\n   If `G` is a multigraph, `keys` indicates whether the edge key `k` will\n   be reported in the third position in the edge tuple. `data` indicates\n   whether the edge datadict `d` will appear at the end of the edge tuple.\n\n   If `G` is not a multigraph, the tuples are `(u, v, d)` if `data` is True\n   or `(u, v)` if `data` is False.\n\nExamples\n--------\n>>> from networkx.algorithms import tree\n\nFind minimum spanning edges by Kruskal's algorithm\n\n>>> G = nx.cycle_graph(4)\n>>> G.add_edge(0, 3, weight=2)\n>>> mst = tree.minimum_spanning_edges(G, algorithm=\"kruskal\", data=False)\n>>> edgelist = list(mst)\n>>> sorted(sorted(e) for e in edgelist)\n[[0, 1], [1, 2], [2, 3]]\n\nFind minimum spanning edges by Prim's algorithm\n\n>>> G = nx.cycle_graph(4)\n>>> G.add_edge(0, 3, weight=2)\n>>> mst = tree.minimum_spanning_edges(G, algorithm=\"prim\", data=False)\n>>> edgelist = list(mst)\n>>> sorted(sorted(e) for e in edgelist)\n[[0, 1], [1, 2], [2, 3]]\n\nNotes\n-----\nFor Bor\u016fvka's algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct.\n\nFor the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used.\n\nModified code from David Eppstein, April 2006\nhttp://www.ics.uci.edu/~eppstein/PADS/"}, {"type": "function", "name": "networkx.minimum_spanning_tree", "documentation": "Returns a minimum spanning tree or forest on an undirected graph `G`.\n\nParameters\n----------\nG : undirected graph\n    An undirected graph. If `G` is connected, then the algorithm finds a\n    spanning tree. Otherwise, a spanning forest is found.\n\nweight : str\n   Data key to use for edge weights.\n\nalgorithm : string\n   The algorithm to use when finding a minimum spanning tree. Valid\n   choices are 'kruskal', 'prim', or 'boruvka'. The default is\n   'kruskal'.\n\nignore_nan : bool (default: False)\n    If a NaN is found as an edge weight normally an exception is raised.\n    If `ignore_nan is True` then that edge is ignored instead.\n\nReturns\n-------\nG : NetworkX Graph\n   A minimum spanning tree or forest.\n\nExamples\n--------\n>>> G = nx.cycle_graph(4)\n>>> G.add_edge(0, 3, weight=2)\n>>> T = nx.minimum_spanning_tree(G)\n>>> sorted(T.edges(data=True))\n[(0, 1, {}), (1, 2, {}), (2, 3, {})]\n\n\nNotes\n-----\nFor Bor\u016fvka's algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct.\n\nFor the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used.\n\nThere may be more than one tree with the same minimum or maximum weight.\nSee :mod:`networkx.tree.recognition` for more detailed definitions.\n\nIsolated nodes with self-loops are in the tree as edgeless isolated nodes."}, {"type": "function", "name": "networkx.mixing_dict", "documentation": "Returns a dictionary representation of mixing matrix.\n\nParameters\n----------\nxy : list or container of two-tuples\n   Pairs of (x,y) items.\n\nattribute : string\n   Node attribute key\n\nnormalized : bool (default=False)\n   Return counts if False or probabilities if True.\n\nReturns\n-------\nd: dictionary\n   Counts or Joint probability of occurrence of values in xy."}, {"type": "function", "name": "networkx.mixing_expansion", "documentation": "Returns the mixing expansion between two node sets.\n\nThe *mixing expansion* is the quotient of the cut size and twice the\nnumber of edges in the graph. [1]\n\nParameters\n----------\nG : NetworkX graph\n\nS : collection\n    A collection of nodes in `G`.\n\nT : collection\n    A collection of nodes in `G`.\n\nweight : object\n    Edge attribute key to use as weight. If not specified, edges\n    have weight one.\n\nReturns\n-------\nnumber\n    The mixing expansion between the two sets `S` and `T`.\n\nSee also\n--------\nboundary_expansion\nedge_expansion\nnode_expansion\n\nReferences\n----------\n.. [1] Vadhan, Salil P.\n       \"Pseudorandomness.\"\n       *Foundations and Trends\n       in Theoretical Computer Science* 7.1\u20133 (2011): 1\u2013336.\n       <https://doi.org/10.1561/0400000010>"}, {"type": "function", "name": "networkx.modular_product", "documentation": "Returns the Modular product of G and H.\n\nThe modular product of `G` and `H` is the graph $M = G \\nabla H$,\nconsisting of the node set $V(M) = V(G) \\times V(H)$ that is the Cartesian\nproduct of the node sets of `G` and `H`. Further, M contains an edge ((u, v), (x, y)):\n\n- if u is adjacent to x in `G` and v is adjacent to y in `H`, or\n- if u is not adjacent to x in `G` and v is not adjacent to y in `H`.\n\nMore formally::\n\n    E(M) = {((u, v), (x, y)) | ((u, x) in E(G) and (v, y) in E(H)) or\n                               ((u, x) not in E(G) and (v, y) not in E(H))}\n\nParameters\n----------\nG, H: NetworkX graphs\n    The graphs to take the modular product of.\n\nReturns\n-------\nM: NetworkX graph\n    The Modular product of `G` and `H`.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is not a simple graph.\n\nExamples\n--------\n>>> G = nx.cycle_graph(4)\n>>> H = nx.path_graph(2)\n>>> M = nx.modular_product(G, H)\n>>> list(M)\n[(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)]\n>>> print(M)\nGraph with 8 nodes and 8 edges\n\nNotes\n-----\nThe *modular product* is defined in [1]_ and was first\nintroduced as the *weak modular product*.\n\nThe modular product reduces the problem of counting isomorphic subgraphs\nin `G` and `H` to the problem of counting cliques in M. The subgraphs of\n`G` and `H` that are induced by the nodes of a clique in M are\nisomorphic [2]_ [3]_.\n\nReferences\n----------\n.. [1] R. Hammack, W. Imrich, and S. Klav\u017ear,\n    \"Handbook of Product Graphs\", CRC Press, 2011.\n\n.. [2] H. G. Barrow and R. M. Burstall,\n    \"Subgraph isomorphism, matching relational structures and maximal\n    cliques\", Information Processing Letters, vol. 4, issue 4, pp. 83-84,\n    1976, https://doi.org/10.1016/0020-0190(76)90049-1.\n\n.. [3] V. G. Vizing, \"Reduction of the problem of isomorphism and isomorphic\n    entrance to the task of finding the nondensity of a graph.\" Proc. Third\n    All-Union Conference on Problems of Theoretical Cybernetics. 1974."}, {"type": "function", "name": "networkx.modularity_matrix", "documentation": "Returns the modularity matrix of G.\n\nThe modularity matrix is the matrix B = A - <A>, where A is the adjacency\nmatrix and <A> is the average adjacency matrix, assuming that the graph\nis described by the configuration model.\n\nMore specifically, the element B_ij of B is defined as\n\n.. math::\n    A_{ij} - {k_i k_j \\over 2 m}\n\nwhere k_i is the degree of node i, and where m is the number of edges\nin the graph. When weight is set to a name of an attribute edge, Aij, k_i,\nk_j and m are computed using its value.\n\nParameters\n----------\nG : Graph\n   A NetworkX graph\n\nnodelist : list, optional\n   The rows and columns are ordered according to the nodes in nodelist.\n   If nodelist is None, then the ordering is produced by G.nodes().\n\nweight : string or None, optional (default=None)\n   The edge attribute that holds the numerical value used for\n   the edge weight.  If None then all edge weights are 1.\n\nReturns\n-------\nB : Numpy array\n  The modularity matrix of G.\n\nExamples\n--------\n>>> k = [3, 2, 2, 1, 0]\n>>> G = nx.havel_hakimi_graph(k)\n>>> B = nx.modularity_matrix(G)\n\n\nSee Also\n--------\nto_numpy_array\nmodularity_spectrum\nadjacency_matrix\ndirected_modularity_matrix\n\nReferences\n----------\n.. [1] M. E. J. Newman, \"Modularity and community structure in networks\",\n       Proc. Natl. Acad. Sci. USA, vol. 103, pp. 8577-8582, 2006."}, {"type": "function", "name": "networkx.modularity_spectrum", "documentation": "Returns eigenvalues of the modularity matrix of G.\n\nParameters\n----------\nG : Graph\n   A NetworkX Graph or DiGraph\n\nReturns\n-------\nevals : NumPy array\n  Eigenvalues\n\nSee Also\n--------\nmodularity_matrix\n\nReferences\n----------\n.. [1] M. E. J. Newman, \"Modularity and community structure in networks\",\n   Proc. Natl. Acad. Sci. USA, vol. 103, pp. 8577-8582, 2006."}, {"type": "function", "name": "networkx.moebius_kantor_graph", "documentation": "Returns the Moebius-Kantor graph.\n\nThe M\u00f6bius-Kantor graph is the cubic symmetric graph on 16 nodes.\nIts LCF notation is [5,-5]^8, and it is isomorphic to the generalized\nPetersen graph [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Moebius-Kantor graph\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/M%C3%B6bius%E2%80%93Kantor_graph"}, {"type": "function", "name": "networkx.moral_graph", "documentation": "Return the Moral Graph\n\nReturns the moralized graph of a given directed graph.\n\nParameters\n----------\nG : NetworkX graph\n    Directed graph\n\nReturns\n-------\nH : NetworkX graph\n    The undirected moralized graph of G\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is undirected.\n\nExamples\n--------\n>>> G = nx.DiGraph([(1, 2), (2, 3), (2, 5), (3, 4), (4, 3)])\n>>> G_moral = nx.moral_graph(G)\n>>> G_moral.edges()\nEdgeView([(1, 2), (2, 3), (2, 5), (2, 4), (3, 4)])\n\nNotes\n-----\nA moral graph is an undirected graph H = (V, E) generated from a\ndirected Graph, where if a node has more than one parent node, edges\nbetween these parent nodes are inserted and all directed edges become\nundirected.\n\nhttps://en.wikipedia.org/wiki/Moral_graph\n\nReferences\n----------\n.. [1] Wray L. Buntine. 1995. Chain graphs for learning.\n       In Proceedings of the Eleventh conference on Uncertainty\n       in artificial intelligence (UAI'95)"}, {"type": "function", "name": "networkx.multi_source_dijkstra", "documentation": "Find shortest weighted paths and lengths from a given set of\nsource nodes.\n\nUses Dijkstra's algorithm to compute the shortest paths and lengths\nbetween one of the source nodes and the given `target`, or all other\nreachable nodes if not specified, for a weighted graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsources : non-empty set of nodes\n    Starting nodes for paths. If this is just a set containing a\n    single node, then all paths computed by this function will start\n    from that node. If there are two or more nodes in the set, the\n    computed paths may begin from any one of the start nodes.\n\ntarget : node label, optional\n    Ending node for path\n\ncutoff : integer or float, optional\n    Length (sum of edge weights) at which the search is stopped.\n    If cutoff is provided, only return paths with summed weight <= cutoff.\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number or None to indicate a hidden edge.\n\nReturns\n-------\ndistance, path : pair of dictionaries, or numeric and list\n    If target is None, returns a tuple of two dictionaries keyed by node.\n    The first dictionary stores distance from one of the source nodes.\n    The second stores the path from one of the sources to that node.\n    If target is not None, returns a tuple of (distance, path) where\n    distance is the distance from source to target and path is a list\n    representing the path from source to target.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> length, path = nx.multi_source_dijkstra(G, {0, 4})\n>>> for node in [0, 1, 2, 3, 4]:\n...     print(f\"{node}: {length[node]}\")\n0: 0\n1: 1\n2: 2\n3: 1\n4: 0\n>>> path[1]\n[0, 1]\n>>> path[3]\n[4, 3]\n\n>>> length, path = nx.multi_source_dijkstra(G, {0, 4}, 1)\n>>> length\n1\n>>> path\n[0, 1]\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe weight function can be used to hide edges by returning None.\nSo ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\nwill find the shortest red path.\n\nBased on the Python cookbook recipe (119466) at\nhttps://code.activestate.com/recipes/119466/\n\nThis algorithm is not guaranteed to work if edge weights\nare negative or are floating point numbers\n(overflows and roundoff errors can cause problems).\n\nRaises\n------\nValueError\n    If `sources` is empty.\nNodeNotFound\n    If any of `sources` is not in `G`.\n\nSee Also\n--------\nmulti_source_dijkstra_path\nmulti_source_dijkstra_path_length"}, {"type": "function", "name": "networkx.multi_source_dijkstra_path", "documentation": "Find shortest weighted paths in G from a given set of source\nnodes.\n\nCompute shortest path between any of the source nodes and all other\nreachable nodes for a weighted graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsources : non-empty set of nodes\n    Starting nodes for paths. If this is just a set containing a\n    single node, then all paths computed by this function will start\n    from that node. If there are two or more nodes in the set, the\n    computed paths may begin from any one of the start nodes.\n\ncutoff : integer or float, optional\n    Length (sum of edge weights) at which the search is stopped.\n    If cutoff is provided, only return paths with summed weight <= cutoff.\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number or None to indicate a hidden edge.\n\nReturns\n-------\npaths : dictionary\n    Dictionary of shortest paths keyed by target.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> path = nx.multi_source_dijkstra_path(G, {0, 4})\n>>> path[1]\n[0, 1]\n>>> path[3]\n[4, 3]\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe weight function can be used to hide edges by returning None.\nSo ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\nwill find the shortest red path.\n\nRaises\n------\nValueError\n    If `sources` is empty.\nNodeNotFound\n    If any of `sources` is not in `G`.\n\nSee Also\n--------\nmulti_source_dijkstra, multi_source_bellman_ford"}, {"type": "function", "name": "networkx.multi_source_dijkstra_path_length", "documentation": "Find shortest weighted path lengths in G from a given set of\nsource nodes.\n\nCompute the shortest path length between any of the source nodes and\nall other reachable nodes for a weighted graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsources : non-empty set of nodes\n    Starting nodes for paths. If this is just a set containing a\n    single node, then all paths computed by this function will start\n    from that node. If there are two or more nodes in the set, the\n    computed paths may begin from any one of the start nodes.\n\ncutoff : integer or float, optional\n    Length (sum of edge weights) at which the search is stopped.\n    If cutoff is provided, only return paths with summed weight <= cutoff.\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number or None to indicate a hidden edge.\n\nReturns\n-------\nlength : dict\n    Dict keyed by node to shortest path length to nearest source.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> length = nx.multi_source_dijkstra_path_length(G, {0, 4})\n>>> for node in [0, 1, 2, 3, 4]:\n...     print(f\"{node}: {length[node]}\")\n0: 0\n1: 1\n2: 2\n3: 1\n4: 0\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe weight function can be used to hide edges by returning None.\nSo ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\nwill find the shortest red path.\n\nRaises\n------\nValueError\n    If `sources` is empty.\nNodeNotFound\n    If any of `sources` is not in `G`.\n\nSee Also\n--------\nmulti_source_dijkstra"}, {"type": "function", "name": "networkx.multipartite_layout", "documentation": "Position nodes in layers of straight lines.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\nsubset_key : string or dict (default='subset')\n    If a string, the key of node data in G that holds the node subset.\n    If a dict, keyed by layer number to the nodes in that layer/subset.\n\nalign : string (default='vertical')\n    The alignment of nodes. Vertical or horizontal.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node.\n\nExamples\n--------\n>>> G = nx.complete_multipartite_graph(28, 16, 10)\n>>> pos = nx.multipartite_layout(G)\n\nor use a dict to provide the layers of the layout\n\n>>> G = nx.Graph([(0, 1), (1, 2), (1, 3), (3, 4)])\n>>> layers = {\"a\": [0], \"b\": [1], \"c\": [2, 3], \"d\": [4]}\n>>> pos = nx.multipartite_layout(G, subset_key=layers)\n\nNotes\n-----\nThis algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings.\n\nNetwork does not need to be a complete multipartite graph. As long as nodes\nhave subset_key data, they will be placed in the corresponding layers."}, {"type": "function", "name": "networkx.mycielski_graph", "documentation": "Generator for the n_th Mycielski Graph.\n\nThe Mycielski family of graphs is an infinite set of graphs.\n:math:`M_1` is the singleton graph, :math:`M_2` is two vertices with an\nedge, and, for :math:`i > 2`, :math:`M_i` is the Mycielskian of\n:math:`M_{i-1}`.\n\nMore information can be found at\nhttp://mathworld.wolfram.com/MycielskiGraph.html\n\nParameters\n----------\nn : int\n    The desired Mycielski Graph.\n\nReturns\n-------\nM : graph\n    The n_th Mycielski Graph\n\nNotes\n-----\nThe first graph in the Mycielski sequence is the singleton graph.\nThe Mycielskian of this graph is not the :math:`P_2` graph, but rather the\n:math:`P_2` graph with an extra, isolated vertex. The second Mycielski\ngraph is the :math:`P_2` graph, so the first two are hard coded.\nThe remaining graphs are generated using the Mycielski operation."}, {"type": "function", "name": "networkx.mycielskian", "documentation": "Returns the Mycielskian of a simple, undirected graph G\n\nThe Mycielskian of graph preserves a graph's triangle free\nproperty while increasing the chromatic number by 1.\n\nThe Mycielski Operation on a graph, :math:`G=(V, E)`, constructs a new\ngraph with :math:`2|V| + 1` nodes and :math:`3|E| + |V|` edges.\n\nThe construction is as follows:\n\nLet :math:`V = {0, ..., n-1}`. Construct another vertex set\n:math:`U = {n, ..., 2n}` and a vertex, `w`.\nConstruct a new graph, `M`, with vertices :math:`U \\bigcup V \\bigcup w`.\nFor edges, :math:`(u, v) \\in E` add edges :math:`(u, v), (u, v + n)`, and\n:math:`(u + n, v)` to M. Finally, for all vertices :math:`u \\in U`, add\nedge :math:`(u, w)` to M.\n\nThe Mycielski Operation can be done multiple times by repeating the above\nprocess iteratively.\n\nMore information can be found at https://en.wikipedia.org/wiki/Mycielskian\n\nParameters\n----------\nG : graph\n    A simple, undirected NetworkX graph\niterations : int\n    The number of iterations of the Mycielski operation to\n    perform on G. Defaults to 1. Must be a non-negative integer.\n\nReturns\n-------\nM : graph\n    The Mycielskian of G after the specified number of iterations.\n\nNotes\n-----\nGraph, node, and edge data are not necessarily propagated to the new graph."}, {"type": "function", "name": "networkx.navigable_small_world_graph", "documentation": "Returns a navigable small-world graph.\n\nA navigable small-world graph is a directed grid with additional long-range\nconnections that are chosen randomly.\n\n  [...] we begin with a set of nodes [...] that are identified with the set\n  of lattice points in an $n \\times n$ square,\n  $\\{(i, j): i \\in \\{1, 2, \\ldots, n\\}, j \\in \\{1, 2, \\ldots, n\\}\\}$,\n  and we define the *lattice distance* between two nodes $(i, j)$ and\n  $(k, l)$ to be the number of \"lattice steps\" separating them:\n  $d((i, j), (k, l)) = |k - i| + |l - j|$.\n\n  For a universal constant $p >= 1$, the node $u$ has a directed edge to\n  every other node within lattice distance $p$---these are its *local\n  contacts*. For universal constants $q >= 0$ and $r >= 0$ we also\n  construct directed edges from $u$ to $q$ other nodes (the *long-range\n  contacts*) using independent random trials; the $i$th directed edge from\n  $u$ has endpoint $v$ with probability proportional to $[d(u,v)]^{-r}$.\n\n  -- [1]_\n\nParameters\n----------\nn : int\n    The length of one side of the lattice; the number of nodes in\n    the graph is therefore $n^2$.\np : int\n    The diameter of short range connections. Each node is joined with every\n    other node within this lattice distance.\nq : int\n    The number of long-range connections for each node.\nr : float\n    Exponent for decaying probability of connections.  The probability of\n    connecting to a node at lattice distance $d$ is $1/d^r$.\ndim : int\n    Dimension of grid\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReferences\n----------\n.. [1] J. Kleinberg. The small-world phenomenon: An algorithmic\n   perspective. Proc. 32nd ACM Symposium on Theory of Computing, 2000."}, {"type": "function", "name": "networkx.negative_edge_cycle", "documentation": "Returns True if there exists a negative edge cycle anywhere in G.\n\nParameters\n----------\nG : NetworkX graph\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\nheuristic : bool\n    Determines whether to use a heuristic to early detect negative\n    cycles at a negligible cost. In case of graphs with a negative cycle,\n    the performance of detection increases by at least an order of magnitude.\n\nReturns\n-------\nnegative_cycle : bool\n    True if a negative edge cycle exists, otherwise False.\n\nExamples\n--------\n>>> G = nx.cycle_graph(5, create_using=nx.DiGraph())\n>>> print(nx.negative_edge_cycle(G))\nFalse\n>>> G[1][2][\"weight\"] = -7\n>>> print(nx.negative_edge_cycle(G))\nTrue\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThis algorithm uses bellman_ford_predecessor_and_distance() but finds\nnegative cycles on any component by first adding a new node connected to\nevery node, and starting bellman_ford_predecessor_and_distance on that\nnode.  It then removes that extra node."}, {"type": "function", "name": "networkx.neighbors", "documentation": "Returns an iterator over all neighbors of node n.\n\nThis function wraps the :func:`G.neighbors <networkx.Graph.neighbors>` function."}, {"type": "function", "name": "networkx.network_simplex", "documentation": "Find a minimum cost flow satisfying all demands in digraph G.\n\nThis is a primal network simplex algorithm that uses the leaving\narc rule to prevent cycling.\n\nG is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node.\n\nParameters\n----------\nG : NetworkX graph\n    DiGraph on which a minimum cost flow satisfying all demands is\n    to be found.\n\ndemand : string\n    Nodes of the graph G are expected to have an attribute demand\n    that indicates how much flow a node wants to send (negative\n    demand) or receive (positive demand). Note that the sum of the\n    demands should be 0 otherwise the problem in not feasible. If\n    this attribute is not present, a node is considered to have 0\n    demand. Default value: 'demand'.\n\ncapacity : string\n    Edges of the graph G are expected to have an attribute capacity\n    that indicates how much flow the edge can support. If this\n    attribute is not present, the edge is considered to have\n    infinite capacity. Default value: 'capacity'.\n\nweight : string\n    Edges of the graph G are expected to have an attribute weight\n    that indicates the cost incurred by sending one unit of flow on\n    that edge. If not present, the weight is considered to be 0.\n    Default value: 'weight'.\n\nReturns\n-------\nflowCost : integer, float\n    Cost of a minimum cost flow satisfying all demands.\n\nflowDict : dictionary\n    Dictionary of dictionaries keyed by nodes such that\n    flowDict[u][v] is the flow edge (u, v).\n\nRaises\n------\nNetworkXError\n    This exception is raised if the input graph is not directed or\n    not connected.\n\nNetworkXUnfeasible\n    This exception is raised in the following situations:\n\n        * The sum of the demands is not zero. Then, there is no\n          flow satisfying all demands.\n        * There is no flow satisfying all demand.\n\nNetworkXUnbounded\n    This exception is raised if the digraph G has a cycle of\n    negative cost and infinite capacity. Then, the cost of a flow\n    satisfying all demands is unbounded below.\n\nNotes\n-----\nThis algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).\n\nSee also\n--------\ncost_of_flow, max_flow_min_cost, min_cost_flow, min_cost_flow_cost\n\nExamples\n--------\nA simple example of a min cost flow problem.\n\n>>> G = nx.DiGraph()\n>>> G.add_node(\"a\", demand=-5)\n>>> G.add_node(\"d\", demand=5)\n>>> G.add_edge(\"a\", \"b\", weight=3, capacity=4)\n>>> G.add_edge(\"a\", \"c\", weight=6, capacity=10)\n>>> G.add_edge(\"b\", \"d\", weight=1, capacity=9)\n>>> G.add_edge(\"c\", \"d\", weight=2, capacity=5)\n>>> flowCost, flowDict = nx.network_simplex(G)\n>>> flowCost\n24\n>>> flowDict\n{'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\n\nThe mincost flow algorithm can also be used to solve shortest path\nproblems. To find the shortest path between two nodes u and v,\ngive all edges an infinite capacity, give node u a demand of -1 and\nnode v a demand a 1. Then run the network simplex. The value of a\nmin cost flow will be the distance between u and v and edges\ncarrying positive flow will indicate the path.\n\n>>> G = nx.DiGraph()\n>>> G.add_weighted_edges_from(\n...     [\n...         (\"s\", \"u\", 10),\n...         (\"s\", \"x\", 5),\n...         (\"u\", \"v\", 1),\n...         (\"u\", \"x\", 2),\n...         (\"v\", \"y\", 1),\n...         (\"x\", \"u\", 3),\n...         (\"x\", \"v\", 5),\n...         (\"x\", \"y\", 2),\n...         (\"y\", \"s\", 7),\n...         (\"y\", \"v\", 6),\n...     ]\n... )\n>>> G.add_node(\"s\", demand=-1)\n>>> G.add_node(\"v\", demand=1)\n>>> flowCost, flowDict = nx.network_simplex(G)\n>>> flowCost == nx.shortest_path_length(G, \"s\", \"v\", weight=\"weight\")\nTrue\n>>> sorted([(u, v) for u in flowDict for v in flowDict[u] if flowDict[u][v] > 0])\n[('s', 'x'), ('u', 'v'), ('x', 'u')]\n>>> nx.shortest_path(G, \"s\", \"v\", weight=\"weight\")\n['s', 'x', 'u', 'v']\n\nIt is possible to change the name of the attributes used for the\nalgorithm.\n\n>>> G = nx.DiGraph()\n>>> G.add_node(\"p\", spam=-4)\n>>> G.add_node(\"q\", spam=2)\n>>> G.add_node(\"a\", spam=-2)\n>>> G.add_node(\"d\", spam=-1)\n>>> G.add_node(\"t\", spam=2)\n>>> G.add_node(\"w\", spam=3)\n>>> G.add_edge(\"p\", \"q\", cost=7, vacancies=5)\n>>> G.add_edge(\"p\", \"a\", cost=1, vacancies=4)\n>>> G.add_edge(\"q\", \"d\", cost=2, vacancies=3)\n>>> G.add_edge(\"t\", \"q\", cost=1, vacancies=2)\n>>> G.add_edge(\"a\", \"t\", cost=2, vacancies=4)\n>>> G.add_edge(\"d\", \"w\", cost=3, vacancies=4)\n>>> G.add_edge(\"t\", \"w\", cost=4, vacancies=1)\n>>> flowCost, flowDict = nx.network_simplex(\n...     G, demand=\"spam\", capacity=\"vacancies\", weight=\"cost\"\n... )\n>>> flowCost\n37\n>>> flowDict\n{'p': {'q': 2, 'a': 2}, 'q': {'d': 1}, 'a': {'t': 4}, 'd': {'w': 2}, 't': {'q': 1, 'w': 1}, 'w': {}}\n\nReferences\n----------\n.. [1] Z. Kiraly, P. Kovacs.\n       Efficient implementation of minimum-cost flow algorithms.\n       Acta Universitatis Sapientiae, Informatica 4(1):67--118. 2012.\n.. [2] R. Barr, F. Glover, D. Klingman.\n       Enhancement of spanning tree labeling procedures for network\n       optimization.\n       INFOR 17(1):16--34. 1979."}, {"type": "function", "name": "networkx.newman_watts_strogatz_graph", "documentation": "Returns a Newman\u2013Watts\u2013Strogatz small-world graph.\n\nParameters\n----------\nn : int\n    The number of nodes.\nk : int\n    Each node is joined with its `k` nearest neighbors in a ring\n    topology.\np : float\n    The probability of adding a new edge for each edge.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nNotes\n-----\nFirst create a ring over $n$ nodes [1]_.  Then each node in the ring is\nconnected with its $k$ nearest neighbors (or $k - 1$ neighbors if $k$\nis odd).  Then shortcuts are created by adding new edges as follows: for\neach edge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest\nneighbors\" with probability $p$ add a new edge $(u, w)$ with\nrandomly-chosen existing node $w$.  In contrast with\n:func:`watts_strogatz_graph`, no edges are removed.\n\nSee Also\n--------\nwatts_strogatz_graph\n\nReferences\n----------\n.. [1] M. E. J. Newman and D. J. Watts,\n   Renormalization group analysis of the small-world network model,\n   Physics Letters A, 263, 341, 1999.\n   https://doi.org/10.1016/S0375-9601(99)00757-4"}, {"type": "function", "name": "networkx.node_attribute_xy", "documentation": "Returns iterator of node-attribute pairs for all edges in G.\n\nParameters\n----------\nG: NetworkX graph\n\nattribute: key\n   The node attribute key.\n\nnodes: list or iterable (optional)\n    Use only edges that are incident to specified nodes.\n    The default is all nodes.\n\nReturns\n-------\n(x, y): 2-tuple\n    Generates 2-tuple of (attribute, attribute) values.\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_node(1, color=\"red\")\n>>> G.add_node(2, color=\"blue\")\n>>> G.add_edge(1, 2)\n>>> list(nx.node_attribute_xy(G, \"color\"))\n[('red', 'blue')]\n\nNotes\n-----\nFor undirected graphs each edge is produced twice, once for each edge\nrepresentation (u, v) and (v, u), with the exception of self-loop edges\nwhich only appear once."}, {"type": "function", "name": "networkx.node_boundary", "documentation": "Returns the node boundary of `nbunch1`.\n\nThe *node boundary* of a set *S* with respect to a set *T* is the\nset of nodes *v* in *T* such that for some *u* in *S*, there is an\nedge joining *u* to *v*. If *T* is not specified, it is assumed to\nbe the set of all nodes not in *S*.\n\nParameters\n----------\nG : NetworkX graph\n\nnbunch1 : iterable\n    Iterable of nodes in the graph representing the set of nodes\n    whose node boundary will be returned. (This is the set *S* from\n    the definition above.)\n\nnbunch2 : iterable\n    Iterable of nodes representing the target (or \"exterior\") set of\n    nodes. (This is the set *T* from the definition above.) If not\n    specified, this is assumed to be the set of all nodes in `G`\n    not in `nbunch1`.\n\nReturns\n-------\nset\n    The node boundary of `nbunch1` with respect to `nbunch2`.\n\nExamples\n--------\n>>> G = nx.wheel_graph(6)\n\nWhen nbunch2=None:\n\n>>> list(nx.node_boundary(G, (3, 4)))\n[0, 2, 5]\n\nWhen nbunch2 is given:\n\n>>> list(nx.node_boundary(G, (3, 4), (0, 1, 5)))\n[0, 5]\n\nNotes\n-----\nAny element of `nbunch` that is not in the graph `G` will be\nignored.\n\n`nbunch1` and `nbunch2` are usually meant to be disjoint, but in\nthe interest of speed and generality, that is not required here."}, {"type": "function", "name": "networkx.node_clique_number", "documentation": "Returns the size of the largest maximal clique containing each given node.\n\nReturns a single or list depending on input nodes.\nAn optional list of cliques can be input if already computed.\n\nParameters\n----------\nG : NetworkX graph\n    An undirected graph.\n\ncliques : list, optional (default=None)\n    A list of cliques, each of which is itself a list of nodes.\n    If not specified, the list of all cliques will be computed\n    using :func:`find_cliques`.\n\nReturns\n-------\nint or dict\n    If `nodes` is a single node, returns the size of the\n    largest maximal clique in `G` containing that node.\n    Otherwise return a dict keyed by node to the size\n    of the largest maximal clique containing that node.\n\nSee Also\n--------\nfind_cliques\n    find_cliques yields the maximal cliques of G.\n    It accepts a `nodes` argument which restricts consideration to\n    maximal cliques containing all the given `nodes`.\n    The search for the cliques is optimized for `nodes`."}, {"type": "function", "name": "networkx.node_connected_component", "documentation": "Returns the set of nodes in the component of graph containing node n.\n\nParameters\n----------\nG : NetworkX Graph\n   An undirected graph.\n\nn : node label\n   A node in G\n\nReturns\n-------\ncomp : set\n   A set of nodes in the component of G containing node n.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is directed.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (1, 2), (5, 6), (3, 4)])\n>>> nx.node_connected_component(G, 0)  # nodes of component that contains node 0\n{0, 1, 2}\n\nSee Also\n--------\nconnected_components\n\nNotes\n-----\nFor undirected graphs only."}, {"type": "function", "name": "networkx.node_connectivity", "documentation": "Returns node connectivity for a graph or digraph G.\n\nNode connectivity is equal to the minimum number of nodes that\nmust be removed to disconnect G or render it trivial. If source\nand target nodes are provided, this function returns the local node\nconnectivity: the minimum number of nodes that must be removed to break\nall paths from source to target in G.\n\nParameters\n----------\nG : NetworkX graph\n    Undirected graph\n\ns : node\n    Source node. Optional. Default value: None.\n\nt : node\n    Target node. Optional. Default value: None.\n\nflow_func : function\n    A function for computing the maximum flow among a pair of nodes.\n    The function has to accept at least three parameters: a Digraph,\n    a source node, and a target node. And return a residual network\n    that follows NetworkX conventions (see :meth:`maximum_flow` for\n    details). If flow_func is None, the default maximum flow function\n    (:meth:`edmonds_karp`) is used. See below for details. The\n    choice of the default function may change from version\n    to version and should not be relied on. Default value: None.\n\nReturns\n-------\nK : integer\n    Node connectivity of G, or local node connectivity if source\n    and target are provided.\n\nExamples\n--------\n>>> # Platonic icosahedral graph is 5-node-connected\n>>> G = nx.icosahedral_graph()\n>>> nx.node_connectivity(G)\n5\n\nYou can use alternative flow algorithms for the underlying maximum\nflow computation. In dense networks the algorithm\n:meth:`shortest_augmenting_path` will usually perform better\nthan the default :meth:`edmonds_karp`, which is faster for\nsparse networks with highly skewed degree distributions. Alternative\nflow functions have to be explicitly imported from the flow package.\n\n>>> from networkx.algorithms.flow import shortest_augmenting_path\n>>> nx.node_connectivity(G, flow_func=shortest_augmenting_path)\n5\n\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns the value of local node connectivity.\n\n>>> nx.node_connectivity(G, 3, 7)\n5\n\nIf you need to perform several local computations among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. See\n:meth:`local_node_connectivity` for details.\n\nNotes\n-----\nThis is a flow based implementation of node connectivity. The\nalgorithm works by solving $O((n-\\delta-1+\\delta(\\delta-1)/2))$\nmaximum flow problems on an auxiliary digraph. Where $\\delta$\nis the minimum degree of G. For details about the auxiliary\ndigraph and the computation of local node connectivity see\n:meth:`local_node_connectivity`. This implementation is based\non algorithm 11 in [1]_.\n\nSee also\n--------\n:meth:`local_node_connectivity`\n:meth:`edge_connectivity`\n:meth:`maximum_flow`\n:meth:`edmonds_karp`\n:meth:`preflow_push`\n:meth:`shortest_augmenting_path`\n\nReferences\n----------\n.. [1] Abdol-Hossein Esfahanian. Connectivity Algorithms.\n    http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf"}, {"type": "function", "name": "networkx.node_degree_xy", "documentation": "Generate node degree-degree pairs for edges in G.\n\nParameters\n----------\nG: NetworkX graph\n\nx: string ('in','out')\n   The degree type for source node (directed graphs only).\n\ny: string ('in','out')\n   The degree type for target node (directed graphs only).\n\nweight: string or None, optional (default=None)\n   The edge attribute that holds the numerical value used\n   as a weight.  If None, then each edge has weight 1.\n   The degree is the sum of the edge weights adjacent to the node.\n\nnodes: list or iterable (optional)\n    Use only edges that are adjacency to specified nodes.\n    The default is all nodes.\n\nReturns\n-------\n(x, y): 2-tuple\n    Generates 2-tuple of (degree, degree) values.\n\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_edge(1, 2)\n>>> list(nx.node_degree_xy(G, x=\"out\", y=\"in\"))\n[(1, 1)]\n>>> list(nx.node_degree_xy(G, x=\"in\", y=\"out\"))\n[(0, 0)]\n\nNotes\n-----\nFor undirected graphs each edge is produced twice, once for each edge\nrepresentation (u, v) and (v, u), with the exception of self-loop edges\nwhich only appear once."}, {"type": "function", "name": "networkx.node_disjoint_paths", "documentation": "Computes node disjoint paths between source and target.\n\nNode disjoint paths are paths that only share their first and last\nnodes. The number of node independent paths between two nodes is\nequal to their local node connectivity.\n\nParameters\n----------\nG : NetworkX graph\n\ns : node\n    Source node.\n\nt : node\n    Target node.\n\nflow_func : function\n    A function for computing the maximum flow among a pair of nodes.\n    The function has to accept at least three parameters: a Digraph,\n    a source node, and a target node. And return a residual network\n    that follows NetworkX conventions (see :meth:`maximum_flow` for\n    details). If flow_func is None, the default maximum flow function\n    (:meth:`edmonds_karp`) is used. See below for details. The choice\n    of the default function may change from version to version and\n    should not be relied on. Default value: None.\n\ncutoff : integer or None (default: None)\n    Maximum number of paths to yield. If specified, the maximum flow\n    algorithm will terminate when the flow value reaches or exceeds the\n    cutoff. This only works for flows that support the cutoff parameter\n    (most do) and is ignored otherwise.\n\nauxiliary : NetworkX DiGraph\n    Auxiliary digraph to compute flow based node connectivity. It has\n    to have a graph attribute called mapping with a dictionary mapping\n    node names in G and in the auxiliary digraph. If provided\n    it will be reused instead of recreated. Default value: None.\n\nresidual : NetworkX DiGraph\n    Residual network to compute maximum flow. If provided it will be\n    reused instead of recreated. Default value: None.\n\nReturns\n-------\npaths : generator\n    Generator of node disjoint paths.\n\nRaises\n------\nNetworkXNoPath\n    If there is no path between source and target.\n\nNetworkXError\n    If source or target are not in the graph G.\n\nExamples\n--------\nWe use in this example the platonic icosahedral graph, which has node\nconnectivity 5, thus there are 5 node disjoint paths between any pair\nof non neighbor nodes.\n\n>>> G = nx.icosahedral_graph()\n>>> len(list(nx.node_disjoint_paths(G, 0, 6)))\n5\n\nIf you need to compute node disjoint paths between several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for node connectivity and node cuts, and the\nresidual network for the underlying maximum flow computation.\n\nExample of how to compute node disjoint paths reusing the data\nstructures:\n\n>>> # You also have to explicitly import the function for\n>>> # building the auxiliary digraph from the connectivity package\n>>> from networkx.algorithms.connectivity import build_auxiliary_node_connectivity\n>>> H = build_auxiliary_node_connectivity(G)\n>>> # And the function for building the residual network from the\n>>> # flow package\n>>> from networkx.algorithms.flow import build_residual_network\n>>> # Note that the auxiliary digraph has an edge attribute named capacity\n>>> R = build_residual_network(H, \"capacity\")\n>>> # Reuse the auxiliary digraph and the residual network by passing them\n>>> # as arguments\n>>> len(list(nx.node_disjoint_paths(G, 0, 6, auxiliary=H, residual=R)))\n5\n\nYou can also use alternative flow algorithms for computing node disjoint\npaths. For instance, in dense networks the algorithm\n:meth:`shortest_augmenting_path` will usually perform better than\nthe default :meth:`edmonds_karp` which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\n\n>>> from networkx.algorithms.flow import shortest_augmenting_path\n>>> len(list(nx.node_disjoint_paths(G, 0, 6, flow_func=shortest_augmenting_path)))\n5\n\nNotes\n-----\nThis is a flow based implementation of node disjoint paths. We compute\nthe maximum flow between source and target on an auxiliary directed\nnetwork. The saturated edges in the residual network after running the\nmaximum flow algorithm correspond to node disjoint paths between source\nand target in the original network. This function handles both directed\nand undirected graphs, and can use all flow algorithms from NetworkX flow\npackage.\n\nSee also\n--------\n:meth:`edge_disjoint_paths`\n:meth:`node_connectivity`\n:meth:`maximum_flow`\n:meth:`edmonds_karp`\n:meth:`preflow_push`\n:meth:`shortest_augmenting_path`"}, {"type": "function", "name": "networkx.node_expansion", "documentation": "Returns the node expansion of the set `S`.\n\nThe *node expansion* is the quotient of the size of the node\nboundary of *S* and the cardinality of *S*. [1]\n\nParameters\n----------\nG : NetworkX graph\n\nS : collection\n    A collection of nodes in `G`.\n\nReturns\n-------\nnumber\n    The node expansion of the set `S`.\n\nSee also\n--------\nboundary_expansion\nedge_expansion\nmixing_expansion\n\nReferences\n----------\n.. [1] Vadhan, Salil P.\n       \"Pseudorandomness.\"\n       *Foundations and Trends\n       in Theoretical Computer Science* 7.1\u20133 (2011): 1\u2013336.\n       <https://doi.org/10.1561/0400000010>"}, {"type": "function", "name": "networkx.node_link_data", "documentation": "Returns data in node-link format that is suitable for JSON serialization\nand use in JavaScript documents.\n\nParameters\n----------\nG : NetworkX graph\nsource : string\n    A string that provides the 'source' attribute name for storing NetworkX-internal graph data.\ntarget : string\n    A string that provides the 'target' attribute name for storing NetworkX-internal graph data.\nname : string\n    A string that provides the 'name' attribute name for storing NetworkX-internal graph data.\nkey : string\n    A string that provides the 'key' attribute name for storing NetworkX-internal graph data.\nlink : string\n    A string that provides the 'link' attribute name for storing NetworkX-internal graph data.\n\nReturns\n-------\ndata : dict\n   A dictionary with node-link formatted data.\n\nRaises\n------\nNetworkXError\n    If the values of 'source', 'target' and 'key' are not unique.\n\nExamples\n--------\n>>> G = nx.Graph([(\"A\", \"B\")])\n>>> data1 = nx.node_link_data(G)\n>>> data1\n{'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\n\nTo serialize with JSON\n\n>>> import json\n>>> s1 = json.dumps(data1)\n>>> s1\n'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}'\n\nA graph can also be serialized by passing `node_link_data` as an encoder function. The two methods are equivalent.\n\n>>> s1 = json.dumps(G, default=nx.node_link_data)\n>>> s1\n'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}'\n\nThe attribute names for storing NetworkX-internal graph data can\nbe specified as keyword options.\n\n>>> H = nx.gn_graph(2)\n>>> data2 = nx.node_link_data(H, link=\"edges\", source=\"from\", target=\"to\")\n>>> data2\n{'directed': True, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 0}, {'id': 1}], 'edges': [{'from': 1, 'to': 0}]}\n\nNotes\n-----\nGraph, node, and link attributes are stored in this format.  Note that\nattribute keys will be converted to strings in order to comply with JSON.\n\nAttribute 'key' is only used for multigraphs.\n\nTo use `node_link_data` in conjunction with `node_link_graph`,\nthe keyword names for the attributes must match.\n\n\nSee Also\n--------\nnode_link_graph, adjacency_data, tree_data"}, {"type": "function", "name": "networkx.node_link_graph", "documentation": "Returns graph from node-link data format.\nUseful for de-serialization from JSON.\n\nParameters\n----------\ndata : dict\n    node-link formatted graph data\n\ndirected : bool\n    If True, and direction not specified in data, return a directed graph.\n\nmultigraph : bool\n    If True, and multigraph not specified in data, return a multigraph.\n\nsource : string\n    A string that provides the 'source' attribute name for storing NetworkX-internal graph data.\ntarget : string\n    A string that provides the 'target' attribute name for storing NetworkX-internal graph data.\nname : string\n    A string that provides the 'name' attribute name for storing NetworkX-internal graph data.\nkey : string\n    A string that provides the 'key' attribute name for storing NetworkX-internal graph data.\nlink : string\n    A string that provides the 'link' attribute name for storing NetworkX-internal graph data.\n\nReturns\n-------\nG : NetworkX graph\n    A NetworkX graph object\n\nExamples\n--------\n\nCreate data in node-link format by converting a graph.\n\n>>> G = nx.Graph([(\"A\", \"B\")])\n>>> data = nx.node_link_data(G)\n>>> data\n{'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\n\nRevert data in node-link format to a graph.\n\n>>> H = nx.node_link_graph(data)\n>>> print(H.edges)\n[('A', 'B')]\n\nTo serialize and deserialize a graph with JSON,\n\n>>> import json\n>>> d = json.dumps(node_link_data(G))\n>>> H = node_link_graph(json.loads(d))\n>>> print(G.edges, H.edges)\n[('A', 'B')] [('A', 'B')]\n\n\nNotes\n-----\nAttribute 'key' is only used for multigraphs.\n\nTo use `node_link_data` in conjunction with `node_link_graph`,\nthe keyword names for the attributes must match.\n\nSee Also\n--------\nnode_link_data, adjacency_data, tree_data"}, {"type": "function", "name": "networkx.nodes", "documentation": "Returns a NodeView over the graph nodes.\n\nThis function wraps the :func:`G.nodes <networkx.Graph.nodes>` property."}, {"type": "function", "name": "networkx.nodes_with_selfloops", "documentation": "Returns an iterator over nodes with self loops.\n\nA node with a self loop has an edge with both ends adjacent\nto that node.\n\nReturns\n-------\nnodelist : iterator\n    A iterator over nodes with self loops.\n\nSee Also\n--------\nselfloop_edges, number_of_selfloops\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edge(1, 1)\n>>> G.add_edge(1, 2)\n>>> list(nx.nodes_with_selfloops(G))\n[1]"}, {"type": "function", "name": "networkx.non_edges", "documentation": "Returns the nonexistent edges in the graph.\n\nParameters\n----------\ngraph : NetworkX graph.\n    Graph to find nonexistent edges.\n\nReturns\n-------\nnon_edges : iterator\n    Iterator of edges that are not in the graph."}, {"type": "function", "name": "networkx.non_neighbors", "documentation": "Returns the non-neighbors of the node in the graph.\n\nParameters\n----------\ngraph : NetworkX graph\n    Graph to find neighbors.\n\nnode : node\n    The node whose neighbors will be returned.\n\nReturns\n-------\nnon_neighbors : set\n    Set of nodes in the graph that are not neighbors of the node."}, {"type": "function", "name": "networkx.non_randomness", "documentation": "Compute the non-randomness of graph G.\n\nThe first returned value nr is the sum of non-randomness values of all\nedges within the graph (where the non-randomness of an edge tends to be\nsmall when the two nodes linked by that edge are from two different\ncommunities).\n\nThe second computed value nr_rd is a relative measure that indicates\nto what extent graph G is different from random graphs in terms\nof probability. When it is close to 0, the graph tends to be more\nlikely generated by an Erdos Renyi model.\n\nParameters\n----------\nG : NetworkX graph\n    Graph must be symmetric, connected, and without self-loops.\n\nk : int\n    The number of communities in G.\n    If k is not set, the function will use a default community\n    detection algorithm to set it.\n\nweight : string or None, optional (default=None)\n    The name of an edge attribute that holds the numerical value used\n    as a weight. If None, then each edge has weight 1, i.e., the graph is\n    binary.\n\nReturns\n-------\nnon-randomness : (float, float) tuple\n    Non-randomness, Relative non-randomness w.r.t.\n    Erdos Renyi random graphs.\n\nRaises\n------\nNetworkXException\n    if the input graph is not connected.\nNetworkXError\n    if the input graph contains self-loops.\n\nExamples\n--------\n>>> G = nx.karate_club_graph()\n>>> nr, nr_rd = nx.non_randomness(G, 2)\n>>> nr, nr_rd = nx.non_randomness(G, 2, \"weight\")\n\nNotes\n-----\nThis computes Eq. (4.4) and (4.5) in Ref. [1]_.\n\nIf a weight field is passed, this algorithm will use the eigenvalues\nof the weighted adjacency matrix to compute Eq. (4.4) and (4.5).\n\nReferences\n----------\n.. [1] Xiaowei Ying and Xintao Wu,\n       On Randomness Measures for Social Networks,\n       SIAM International Conference on Data Mining. 2009"}, {"type": "function", "name": "networkx.nonisomorphic_trees", "documentation": "Generates lists of nonisomorphic trees\n\nParameters\n----------\norder : int\n   order of the desired tree(s)\n\ncreate : one of {\"graph\", \"matrix\"} (default=\"graph\")\n   If ``\"graph\"`` is selected a list of ``Graph`` instances will be returned,\n   if matrix is selected a list of adjacency matrices will be returned.\n\n   .. deprecated:: 3.3\n\n      The `create` argument is deprecated and will be removed in NetworkX\n      version 3.5. In the future, `nonisomorphic_trees` will yield graph\n      instances by default. To generate adjacency matrices, call\n      ``nx.to_numpy_array`` on the output, e.g.::\n\n         [nx.to_numpy_array(G) for G in nx.nonisomorphic_trees(N)]\n\nYields\n------\nlist\n   A list of nonisomorphic trees, in one of two formats depending on the\n   value of the `create` parameter:\n   - ``create=\"graph\"``: yields a list of `networkx.Graph` instances\n   - ``create=\"matrix\"``: yields a list of list-of-lists representing adjacency matrices"}, {"type": "function", "name": "networkx.normalized_cut_size", "documentation": "Returns the normalized size of the cut between two sets of nodes.\n\nThe *normalized cut size* is the cut size times the sum of the\nreciprocal sizes of the volumes of the two sets. [1]\n\nParameters\n----------\nG : NetworkX graph\n\nS : collection\n    A collection of nodes in `G`.\n\nT : collection\n    A collection of nodes in `G`.\n\nweight : object\n    Edge attribute key to use as weight. If not specified, edges\n    have weight one.\n\nReturns\n-------\nnumber\n    The normalized cut size between the two sets `S` and `T`.\n\nNotes\n-----\nIn a multigraph, the cut size is the total weight of edges including\nmultiplicity.\n\nSee also\n--------\nconductance\ncut_size\nedge_expansion\nvolume\n\nReferences\n----------\n.. [1] David Gleich.\n       *Hierarchical Directed Spectral Graph Partitioning*.\n       <https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf>"}, {"type": "function", "name": "networkx.normalized_laplacian_matrix", "documentation": "Returns the normalized Laplacian matrix of G.\n\nThe normalized graph Laplacian is the matrix\n\n.. math::\n\n    N = D^{-1/2} L D^{-1/2}\n\nwhere `L` is the graph Laplacian and `D` is the diagonal matrix of\nnode degrees [1]_.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nnodelist : list, optional\n   The rows and columns are ordered according to the nodes in nodelist.\n   If nodelist is None, then the ordering is produced by G.nodes().\n\nweight : string or None, optional (default='weight')\n   The edge data key used to compute each value in the matrix.\n   If None, then each edge has weight 1.\n\nReturns\n-------\nN : SciPy sparse array\n  The normalized Laplacian matrix of G.\n\nNotes\n-----\nFor MultiGraph, the edges weights are summed.\nSee :func:`to_numpy_array` for other options.\n\nIf the Graph contains selfloops, D is defined as ``diag(sum(A, 1))``, where A is\nthe adjacency matrix [2]_.\n\nThis calculation uses the out-degree of the graph `G`. To use the\nin-degree for calculations instead, use `G.reverse(copy=False)` and\ntake the transpose.\n\nFor an unnormalized output, use `laplacian_matrix`.\n\nExamples\n--------\n\n>>> import numpy as np\n>>> edges = [\n...     (1, 2),\n...     (2, 1),\n...     (2, 4),\n...     (4, 3),\n...     (3, 4),\n... ]\n>>> DiG = nx.DiGraph(edges)\n>>> print(nx.normalized_laplacian_matrix(DiG).toarray())\n[[ 1.         -0.70710678  0.          0.        ]\n [-0.70710678  1.         -0.70710678  0.        ]\n [ 0.          0.          1.         -1.        ]\n [ 0.          0.         -1.          1.        ]]\n\nNotice that node 4 is represented by the third column and row. This is because\nby default the row/column order is the order of `G.nodes` (i.e. the node added\norder -- in the edgelist, 4 first appears in (2, 4), before node 3 in edge (4, 3).)\nTo control the node order of the matrix, use the `nodelist` argument.\n\n>>> print(nx.normalized_laplacian_matrix(DiG, nodelist=[1, 2, 3, 4]).toarray())\n[[ 1.         -0.70710678  0.          0.        ]\n [-0.70710678  1.          0.         -0.70710678]\n [ 0.          0.          1.         -1.        ]\n [ 0.          0.         -1.          1.        ]]\n>>> G = nx.Graph(edges)\n>>> print(nx.normalized_laplacian_matrix(G).toarray())\n[[ 1.         -0.70710678  0.          0.        ]\n [-0.70710678  1.         -0.5         0.        ]\n [ 0.         -0.5         1.         -0.70710678]\n [ 0.          0.         -0.70710678  1.        ]]\n\nSee Also\n--------\nlaplacian_matrix\nnormalized_laplacian_spectrum\ndirected_laplacian_matrix\ndirected_combinatorial_laplacian_matrix\n\nReferences\n----------\n.. [1] Fan Chung-Graham, Spectral Graph Theory,\n   CBMS Regional Conference Series in Mathematics, Number 92, 1997.\n.. [2] Steve Butler, Interlacing For Weighted Graphs Using The Normalized\n   Laplacian, Electronic Journal of Linear Algebra, Volume 16, pp. 90-98,\n   March 2007.\n.. [3] Langville, Amy N., and Carl D. Meyer. Google\u2019s PageRank and Beyond:\n   The Science of Search Engine Rankings. Princeton University Press, 2006."}, {"type": "function", "name": "networkx.normalized_laplacian_spectrum", "documentation": "Return eigenvalues of the normalized Laplacian of G\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nweight : string or None, optional (default='weight')\n   The edge data key used to compute each value in the matrix.\n   If None, then each edge has weight 1.\n\nReturns\n-------\nevals : NumPy array\n  Eigenvalues\n\nNotes\n-----\nFor MultiGraph/MultiDiGraph, the edges weights are summed.\nSee to_numpy_array for other options.\n\nSee Also\n--------\nnormalized_laplacian_matrix"}, {"type": "function", "name": "networkx.null_graph", "documentation": "Returns the Null graph with no nodes or edges.\n\nSee empty_graph for the use of create_using."}, {"type": "function", "name": "networkx.number_attracting_components", "documentation": "Returns the number of attracting components in `G`.\n\nParameters\n----------\nG : DiGraph, MultiDiGraph\n    The graph to be analyzed.\n\nReturns\n-------\nn : int\n    The number of attracting components in G.\n\nRaises\n------\nNetworkXNotImplemented\n    If the input graph is undirected.\n\nSee Also\n--------\nattracting_components\nis_attracting_component"}, {"type": "function", "name": "networkx.number_connected_components", "documentation": "Returns the number of connected components.\n\nParameters\n----------\nG : NetworkX graph\n   An undirected graph.\n\nReturns\n-------\nn : integer\n   Number of connected components\n\nRaises\n------\nNetworkXNotImplemented\n    If G is directed.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (1, 2), (5, 6), (3, 4)])\n>>> nx.number_connected_components(G)\n3\n\nSee Also\n--------\nconnected_components\nnumber_weakly_connected_components\nnumber_strongly_connected_components\n\nNotes\n-----\nFor undirected graphs only."}, {"type": "function", "name": "networkx.number_of_cliques", "documentation": "Returns the number of maximal cliques for each node.\n\nReturns a single or list depending on input nodes.\nOptional list of cliques can be input if already computed."}, {"type": "function", "name": "networkx.number_of_edges", "documentation": "Returns the number of edges in the graph.\n\nThis function wraps the :func:`G.number_of_edges <networkx.Graph.number_of_edges>` function."}, {"type": "function", "name": "networkx.number_of_isolates", "documentation": "Returns the number of isolates in the graph.\n\nAn *isolate* is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors.\n\nParameters\n----------\nG : NetworkX graph\n\nReturns\n-------\nint\n    The number of degree zero nodes in the graph `G`."}, {"type": "function", "name": "networkx.number_of_nodes", "documentation": "Returns the number of nodes in the graph.\n\nThis function wraps the :func:`G.number_of_nodes <networkx.Graph.number_of_nodes>` function."}, {"type": "function", "name": "networkx.number_of_nonisomorphic_trees", "documentation": "Returns the number of nonisomorphic trees\n\nParameters\n----------\norder : int\n  order of the desired tree(s)\n\nReturns\n-------\nlength : Number of nonisomorphic graphs for the given order\n\nReferences\n----------"}, {"type": "function", "name": "networkx.number_of_selfloops", "documentation": "Returns the number of selfloop edges.\n\nA selfloop edge has the same node at both ends.\n\nReturns\n-------\nnloops : int\n    The number of selfloops.\n\nSee Also\n--------\nnodes_with_selfloops, selfloop_edges\n\nExamples\n--------\n>>> G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc\n>>> G.add_edge(1, 1)\n>>> G.add_edge(1, 2)\n>>> nx.number_of_selfloops(G)\n1"}, {"type": "function", "name": "networkx.number_of_spanning_trees", "documentation": "Returns the number of spanning trees in `G`.\n\nA spanning tree for an undirected graph is a tree that connects\nall nodes in the graph. For a directed graph, the analog of a\nspanning tree is called a (spanning) arborescence. The arborescence\nincludes a unique directed path from the `root` node to each other node.\nThe graph must be weakly connected, and the root must be a node\nthat includes all nodes as successors [3]_. Note that to avoid\ndiscussing sink-roots and reverse-arborescences, we have reversed\nthe edge orientation from [3]_ and use the in-degree laplacian.\n\nThis function (when `weight` is `None`) returns the number of\nspanning trees for an undirected graph and the number of\narborescences from a single root node for a directed graph.\nWhen `weight` is the name of an edge attribute which holds the\nweight value of each edge, the function returns the sum over\nall trees of the multiplicative weight of each tree. That is,\nthe weight of the tree is the product of its edge weights.\n\nKirchoff's Tree Matrix Theorem states that any cofactor of the\nLaplacian matrix of a graph is the number of spanning trees in the\ngraph. (Here we use cofactors for a diagonal entry so that the\ncofactor becomes the determinant of the matrix with one row\nand its matching column removed.) For a weighted Laplacian matrix,\nthe cofactor is the sum across all spanning trees of the\nmultiplicative weight of each tree. That is, the weight of each\ntree is the product of its edge weights. The theorem is also\nknown as Kirchhoff's theorem [1]_ and the Matrix-Tree theorem [2]_.\n\nFor directed graphs, a similar theorem (Tutte's Theorem) holds with\nthe cofactor chosen to be the one with row and column removed that\ncorrespond to the root. The cofactor is the number of arborescences\nwith the specified node as root. And the weighted version gives the\nsum of the arborescence weights with root `root`. The arborescence\nweight is the product of its edge weights.\n\nParameters\n----------\nG : NetworkX graph\n\nroot : node\n   A node in the directed graph `G` that has all nodes as descendants.\n   (This is ignored for undirected graphs.)\n\nweight : string or None, optional (default=None)\n    The name of the edge attribute holding the edge weight.\n    If `None`, then each edge is assumed to have a weight of 1.\n\nReturns\n-------\nNumber\n    Undirected graphs:\n        The number of spanning trees of the graph `G`.\n        Or the sum of all spanning tree weights of the graph `G`\n        where the weight of a tree is the product of its edge weights.\n    Directed graphs:\n        The number of arborescences of `G` rooted at node `root`.\n        Or the sum of all arborescence weights of the graph `G` with\n        specified root where the weight of an arborescence is the product\n        of its edge weights.\n\nRaises\n------\nNetworkXPointlessConcept\n    If `G` does not contain any nodes.\n\nNetworkXError\n    If the graph `G` is directed and the root node\n    is not specified or is not in G.\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> round(nx.number_of_spanning_trees(G))\n125\n\n>>> G = nx.Graph()\n>>> G.add_edge(1, 2, weight=2)\n>>> G.add_edge(1, 3, weight=1)\n>>> G.add_edge(2, 3, weight=1)\n>>> round(nx.number_of_spanning_trees(G, weight=\"weight\"))\n5\n\nNotes\n-----\nSelf-loops are excluded. Multi-edges are contracted in one edge\nequal to the sum of the weights.\n\nReferences\n----------\n.. [1] Wikipedia\n   \"Kirchhoff's theorem.\"\n   https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem\n.. [2] Kirchhoff, G. R.\n    \u00dcber die Aufl\u00f6sung der Gleichungen, auf welche man\n    bei der Untersuchung der linearen Vertheilung\n    Galvanischer Str\u00f6me gef\u00fchrt wird\n    Annalen der Physik und Chemie, vol. 72, pp. 497-508, 1847.\n.. [3] Margoliash, J.\n    \"Matrix-Tree Theorem for Directed Graphs\"\n    https://www.math.uchicago.edu/~may/VIGRE/VIGRE2010/REUPapers/Margoliash.pdf"}, {"type": "function", "name": "networkx.number_of_walks", "documentation": "Returns the number of walks connecting each pair of nodes in `G`\n\nA *walk* is a sequence of nodes in which each adjacent pair of nodes\nin the sequence is adjacent in the graph. A walk can repeat the same\nedge and go in the opposite direction just as people can walk on a\nset of paths, but standing still is not counted as part of the walk.\n\nThis function only counts the walks with `walk_length` edges. Note that\nthe number of nodes in the walk sequence is one more than `walk_length`.\nThe number of walks can grow very quickly on a larger graph\nand with a larger walk length.\n\nParameters\n----------\nG : NetworkX graph\n\nwalk_length : int\n    A nonnegative integer representing the length of a walk.\n\nReturns\n-------\ndict\n    A dictionary of dictionaries in which outer keys are source\n    nodes, inner keys are target nodes, and inner values are the\n    number of walks of length `walk_length` connecting those nodes.\n\nRaises\n------\nValueError\n    If `walk_length` is negative\n\nExamples\n--------\n\n>>> G = nx.Graph([(0, 1), (1, 2)])\n>>> walks = nx.number_of_walks(G, 2)\n>>> walks\n{0: {0: 1, 1: 0, 2: 1}, 1: {0: 0, 1: 2, 2: 0}, 2: {0: 1, 1: 0, 2: 1}}\n>>> total_walks = sum(sum(tgts.values()) for _, tgts in walks.items())\n\nYou can also get the number of walks from a specific source node using the\nreturned dictionary. For example, number of walks of length 1 from node 0\ncan be found as follows:\n\n>>> walks = nx.number_of_walks(G, 1)\n>>> walks[0]\n{0: 0, 1: 1, 2: 0}\n>>> sum(walks[0].values())  # walks from 0 of length 1\n1\n\nSimilarly, a target node can also be specified:\n\n>>> walks[0][1]\n1"}, {"type": "function", "name": "networkx.number_strongly_connected_components", "documentation": "Returns number of strongly connected components in graph.\n\nParameters\n----------\nG : NetworkX graph\n   A directed graph.\n\nReturns\n-------\nn : integer\n   Number of strongly connected components\n\nRaises\n------\nNetworkXNotImplemented\n    If G is undirected.\n\nExamples\n--------\n>>> G = nx.DiGraph(\n...     [(0, 1), (1, 2), (2, 0), (2, 3), (4, 5), (3, 4), (5, 6), (6, 3), (6, 7)]\n... )\n>>> nx.number_strongly_connected_components(G)\n3\n\nSee Also\n--------\nstrongly_connected_components\nnumber_connected_components\nnumber_weakly_connected_components\n\nNotes\n-----\nFor directed graphs only."}, {"type": "function", "name": "networkx.number_weakly_connected_components", "documentation": "Returns the number of weakly connected components in G.\n\nParameters\n----------\nG : NetworkX graph\n    A directed graph.\n\nReturns\n-------\nn : integer\n    Number of weakly connected components\n\nRaises\n------\nNetworkXNotImplemented\n    If G is undirected.\n\nExamples\n--------\n>>> G = nx.DiGraph([(0, 1), (2, 1), (3, 4)])\n>>> nx.number_weakly_connected_components(G)\n2\n\nSee Also\n--------\nweakly_connected_components\nnumber_connected_components\nnumber_strongly_connected_components\n\nNotes\n-----\nFor directed graphs only."}, {"type": "function", "name": "networkx.numeric_assortativity_coefficient", "documentation": "Compute assortativity for numerical node attributes.\n\nAssortativity measures the similarity of connections\nin the graph with respect to the given numeric attribute.\n\nParameters\n----------\nG : NetworkX graph\n\nattribute : string\n    Node attribute key.\n\nnodes: list or iterable (optional)\n    Compute numeric assortativity only for attributes of nodes in\n    container. The default is all nodes.\n\nReturns\n-------\nr: float\n   Assortativity of graph for given attribute\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_nodes_from([0, 1], size=2)\n>>> G.add_nodes_from([2, 3], size=3)\n>>> G.add_edges_from([(0, 1), (2, 3)])\n>>> print(nx.numeric_assortativity_coefficient(G, \"size\"))\n1.0\n\nNotes\n-----\nThis computes Eq. (21) in Ref. [1]_ , which is the Pearson correlation\ncoefficient of the specified (scalar valued) attribute across edges.\n\nReferences\n----------\n.. [1] M. E. J. Newman, Mixing patterns in networks\n       Physical Review E, 67 026126, 2003"}, {"type": "function", "name": "networkx.octahedral_graph", "documentation": "Returns the Platonic Octahedral graph.\n\nThe octahedral graph is the 6-node 12-edge Platonic graph having the\nconnectivity of the octahedron [1]_. If 6 couples go to a party,\nand each person shakes hands with every person except his or her partner,\nthen this graph describes the set of handshakes that take place;\nfor this reason it is also called the cocktail party graph [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Octahedral graph\n\nReferences\n----------\n.. [1] https://mathworld.wolfram.com/OctahedralGraph.html\n.. [2] https://en.wikipedia.org/wiki/Tur%C3%A1n_graph#Special_cases"}, {"type": "function", "name": "networkx.omega", "documentation": "Returns the small-world coefficient (omega) of a graph\n\nThe small-world coefficient of a graph G is:\n\nomega = Lr/L - C/Cl\n\nwhere C and L are respectively the average clustering coefficient and\naverage shortest path length of G. Lr is the average shortest path length\nof an equivalent random graph and Cl is the average clustering coefficient\nof an equivalent lattice graph.\n\nThe small-world coefficient (omega) measures how much G is like a lattice\nor a random graph. Negative values mean G is similar to a lattice whereas\npositive values mean G is a random graph.\nValues close to 0 mean that G has small-world characteristics.\n\nParameters\n----------\nG : NetworkX graph\n    An undirected graph.\n\nniter: integer (optional, default=5)\n    Approximate number of rewiring per edge to compute the equivalent\n    random graph.\n\nnrand: integer (optional, default=10)\n    Number of random graphs generated to compute the maximal clustering\n    coefficient (Cr) and average shortest path length (Lr).\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\n\nReturns\n-------\nomega : float\n    The small-world coefficient (omega)\n\nNotes\n-----\nThe implementation is adapted from the algorithm by Telesford et al. [1]_.\n\nReferences\n----------\n.. [1] Telesford, Joyce, Hayasaka, Burdette, and Laurienti (2011).\n       \"The Ubiquity of Small-World Networks\".\n       Brain Connectivity. 1 (0038): 367-75.  PMC 3604768. PMID 22432451.\n       doi:10.1089/brain.2011.0038."}, {"type": "function", "name": "networkx.onion_layers", "documentation": "Returns the layer of each vertex in an onion decomposition of the graph.\n\nThe onion decomposition refines the k-core decomposition by providing\ninformation on the internal organization of each k-shell. It is usually\nused alongside the `core numbers`.\n\nParameters\n----------\nG : NetworkX graph\n    An undirected graph without self loops.\n\nReturns\n-------\nod_layers : dictionary\n    A dictionary keyed by node to the onion layer. The layers are\n    contiguous integers starting at 1.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is a multigraph or directed graph or if it contains self loops.\n\nExamples\n--------\n>>> degrees = [0, 1, 2, 2, 2, 2, 3]\n>>> H = nx.havel_hakimi_graph(degrees)\n>>> H.degree\nDegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\n>>> nx.onion_layers(H)\n{6: 1, 0: 2, 4: 3, 1: 4, 2: 4, 3: 4, 5: 4}\n\nSee Also\n--------\ncore_number\n\nReferences\n----------\n.. [1] Multi-scale structure and topological anomaly detection via a new\n   network statistic: The onion decomposition\n   L. H\u00e9bert-Dufresne, J. A. Grochow, and A. Allard\n   Scientific Reports 6, 31708 (2016)\n   http://doi.org/10.1038/srep31708\n.. [2] Percolation and the effective structure of complex networks\n   A. Allard and L. H\u00e9bert-Dufresne\n   Physical Review X 9, 011023 (2019)\n   http://doi.org/10.1103/PhysRevX.9.011023"}, {"type": "function", "name": "networkx.optimal_edit_paths", "documentation": "Returns all minimum-cost edit paths transforming G1 to G2.\n\nGraph edit path is a sequence of node and edge edit operations\ntransforming graph G1 to graph isomorphic to G2.  Edit operations\ninclude substitutions, deletions, and insertions.\n\nParameters\n----------\nG1, G2: graphs\n    The two graphs G1 and G2 must be of the same type.\n\nnode_match : callable\n    A function that returns True if node n1 in G1 and n2 in G2\n    should be considered equal during matching.\n\n    The function will be called like\n\n       node_match(G1.nodes[n1], G2.nodes[n2]).\n\n    That is, the function will receive the node attribute\n    dictionaries for n1 and n2 as inputs.\n\n    Ignored if node_subst_cost is specified.  If neither\n    node_match nor node_subst_cost are specified then node\n    attributes are not considered.\n\nedge_match : callable\n    A function that returns True if the edge attribute dictionaries\n    for the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\n    be considered equal during matching.\n\n    The function will be called like\n\n       edge_match(G1[u1][v1], G2[u2][v2]).\n\n    That is, the function will receive the edge attribute\n    dictionaries of the edges under consideration.\n\n    Ignored if edge_subst_cost is specified.  If neither\n    edge_match nor edge_subst_cost are specified then edge\n    attributes are not considered.\n\nnode_subst_cost, node_del_cost, node_ins_cost : callable\n    Functions that return the costs of node substitution, node\n    deletion, and node insertion, respectively.\n\n    The functions will be called like\n\n       node_subst_cost(G1.nodes[n1], G2.nodes[n2]),\n       node_del_cost(G1.nodes[n1]),\n       node_ins_cost(G2.nodes[n2]).\n\n    That is, the functions will receive the node attribute\n    dictionaries as inputs.  The functions are expected to return\n    positive numeric values.\n\n    Function node_subst_cost overrides node_match if specified.\n    If neither node_match nor node_subst_cost are specified then\n    default node substitution cost of 0 is used (node attributes\n    are not considered during matching).\n\n    If node_del_cost is not specified then default node deletion\n    cost of 1 is used.  If node_ins_cost is not specified then\n    default node insertion cost of 1 is used.\n\nedge_subst_cost, edge_del_cost, edge_ins_cost : callable\n    Functions that return the costs of edge substitution, edge\n    deletion, and edge insertion, respectively.\n\n    The functions will be called like\n\n       edge_subst_cost(G1[u1][v1], G2[u2][v2]),\n       edge_del_cost(G1[u1][v1]),\n       edge_ins_cost(G2[u2][v2]).\n\n    That is, the functions will receive the edge attribute\n    dictionaries as inputs.  The functions are expected to return\n    positive numeric values.\n\n    Function edge_subst_cost overrides edge_match if specified.\n    If neither edge_match nor edge_subst_cost are specified then\n    default edge substitution cost of 0 is used (edge attributes\n    are not considered during matching).\n\n    If edge_del_cost is not specified then default edge deletion\n    cost of 1 is used.  If edge_ins_cost is not specified then\n    default edge insertion cost of 1 is used.\n\nupper_bound : numeric\n    Maximum edit distance to consider.\n\nReturns\n-------\nedit_paths : list of tuples (node_edit_path, edge_edit_path)\n    node_edit_path : list of tuples (u, v)\n    edge_edit_path : list of tuples ((u1, v1), (u2, v2))\n\ncost : numeric\n    Optimal edit path cost (graph edit distance). When the cost\n    is zero, it indicates that `G1` and `G2` are isomorphic.\n\nExamples\n--------\n>>> G1 = nx.cycle_graph(4)\n>>> G2 = nx.wheel_graph(5)\n>>> paths, cost = nx.optimal_edit_paths(G1, G2)\n>>> len(paths)\n40\n>>> cost\n5.0\n\nNotes\n-----\nTo transform `G1` into a graph isomorphic to `G2`, apply the node\nand edge edits in the returned ``edit_paths``.\nIn the case of isomorphic graphs, the cost is zero, and the paths\nrepresent different isomorphic mappings (isomorphisms). That is, the\nedits involve renaming nodes and edges to match the structure of `G2`.\n\nSee Also\n--------\ngraph_edit_distance, optimize_edit_paths\n\nReferences\n----------\n.. [1] Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\n   Martineau. An Exact Graph Edit Distance Algorithm for Solving\n   Pattern Recognition Problems. 4th International Conference on\n   Pattern Recognition Applications and Methods 2015, Jan 2015,\n   Lisbon, Portugal. 2015,\n   <10.5220/0005209202710278>. <hal-01168816>\n   https://hal.archives-ouvertes.fr/hal-01168816"}, {"type": "function", "name": "networkx.optimize_edit_paths", "documentation": "GED (graph edit distance) calculation: advanced interface.\n\nGraph edit path is a sequence of node and edge edit operations\ntransforming graph G1 to graph isomorphic to G2.  Edit operations\ninclude substitutions, deletions, and insertions.\n\nGraph edit distance is defined as minimum cost of edit path.\n\nParameters\n----------\nG1, G2: graphs\n    The two graphs G1 and G2 must be of the same type.\n\nnode_match : callable\n    A function that returns True if node n1 in G1 and n2 in G2\n    should be considered equal during matching.\n\n    The function will be called like\n\n       node_match(G1.nodes[n1], G2.nodes[n2]).\n\n    That is, the function will receive the node attribute\n    dictionaries for n1 and n2 as inputs.\n\n    Ignored if node_subst_cost is specified.  If neither\n    node_match nor node_subst_cost are specified then node\n    attributes are not considered.\n\nedge_match : callable\n    A function that returns True if the edge attribute dictionaries\n    for the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\n    be considered equal during matching.\n\n    The function will be called like\n\n       edge_match(G1[u1][v1], G2[u2][v2]).\n\n    That is, the function will receive the edge attribute\n    dictionaries of the edges under consideration.\n\n    Ignored if edge_subst_cost is specified.  If neither\n    edge_match nor edge_subst_cost are specified then edge\n    attributes are not considered.\n\nnode_subst_cost, node_del_cost, node_ins_cost : callable\n    Functions that return the costs of node substitution, node\n    deletion, and node insertion, respectively.\n\n    The functions will be called like\n\n       node_subst_cost(G1.nodes[n1], G2.nodes[n2]),\n       node_del_cost(G1.nodes[n1]),\n       node_ins_cost(G2.nodes[n2]).\n\n    That is, the functions will receive the node attribute\n    dictionaries as inputs.  The functions are expected to return\n    positive numeric values.\n\n    Function node_subst_cost overrides node_match if specified.\n    If neither node_match nor node_subst_cost are specified then\n    default node substitution cost of 0 is used (node attributes\n    are not considered during matching).\n\n    If node_del_cost is not specified then default node deletion\n    cost of 1 is used.  If node_ins_cost is not specified then\n    default node insertion cost of 1 is used.\n\nedge_subst_cost, edge_del_cost, edge_ins_cost : callable\n    Functions that return the costs of edge substitution, edge\n    deletion, and edge insertion, respectively.\n\n    The functions will be called like\n\n       edge_subst_cost(G1[u1][v1], G2[u2][v2]),\n       edge_del_cost(G1[u1][v1]),\n       edge_ins_cost(G2[u2][v2]).\n\n    That is, the functions will receive the edge attribute\n    dictionaries as inputs.  The functions are expected to return\n    positive numeric values.\n\n    Function edge_subst_cost overrides edge_match if specified.\n    If neither edge_match nor edge_subst_cost are specified then\n    default edge substitution cost of 0 is used (edge attributes\n    are not considered during matching).\n\n    If edge_del_cost is not specified then default edge deletion\n    cost of 1 is used.  If edge_ins_cost is not specified then\n    default edge insertion cost of 1 is used.\n\nupper_bound : numeric\n    Maximum edit distance to consider.\n\nstrictly_decreasing : bool\n    If True, return consecutive approximations of strictly\n    decreasing cost.  Otherwise, return all edit paths of cost\n    less than or equal to the previous minimum cost.\n\nroots : 2-tuple\n    Tuple where first element is a node in G1 and the second\n    is a node in G2.\n    These nodes are forced to be matched in the comparison to\n    allow comparison between rooted graphs.\n\ntimeout : numeric\n    Maximum number of seconds to execute.\n    After timeout is met, the current best GED is returned.\n\nReturns\n-------\nGenerator of tuples (node_edit_path, edge_edit_path, cost)\n    node_edit_path : list of tuples (u, v)\n    edge_edit_path : list of tuples ((u1, v1), (u2, v2))\n    cost : numeric\n\nSee Also\n--------\ngraph_edit_distance, optimize_graph_edit_distance, optimal_edit_paths\n\nReferences\n----------\n.. [1] Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\n   Martineau. An Exact Graph Edit Distance Algorithm for Solving\n   Pattern Recognition Problems. 4th International Conference on\n   Pattern Recognition Applications and Methods 2015, Jan 2015,\n   Lisbon, Portugal. 2015,\n   <10.5220/0005209202710278>. <hal-01168816>\n   https://hal.archives-ouvertes.fr/hal-01168816"}, {"type": "function", "name": "networkx.optimize_graph_edit_distance", "documentation": "Returns consecutive approximations of GED (graph edit distance)\nbetween graphs G1 and G2.\n\nGraph edit distance is a graph similarity measure analogous to\nLevenshtein distance for strings.  It is defined as minimum cost\nof edit path (sequence of node and edge edit operations)\ntransforming graph G1 to graph isomorphic to G2.\n\nParameters\n----------\nG1, G2: graphs\n    The two graphs G1 and G2 must be of the same type.\n\nnode_match : callable\n    A function that returns True if node n1 in G1 and n2 in G2\n    should be considered equal during matching.\n\n    The function will be called like\n\n       node_match(G1.nodes[n1], G2.nodes[n2]).\n\n    That is, the function will receive the node attribute\n    dictionaries for n1 and n2 as inputs.\n\n    Ignored if node_subst_cost is specified.  If neither\n    node_match nor node_subst_cost are specified then node\n    attributes are not considered.\n\nedge_match : callable\n    A function that returns True if the edge attribute dictionaries\n    for the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\n    be considered equal during matching.\n\n    The function will be called like\n\n       edge_match(G1[u1][v1], G2[u2][v2]).\n\n    That is, the function will receive the edge attribute\n    dictionaries of the edges under consideration.\n\n    Ignored if edge_subst_cost is specified.  If neither\n    edge_match nor edge_subst_cost are specified then edge\n    attributes are not considered.\n\nnode_subst_cost, node_del_cost, node_ins_cost : callable\n    Functions that return the costs of node substitution, node\n    deletion, and node insertion, respectively.\n\n    The functions will be called like\n\n       node_subst_cost(G1.nodes[n1], G2.nodes[n2]),\n       node_del_cost(G1.nodes[n1]),\n       node_ins_cost(G2.nodes[n2]).\n\n    That is, the functions will receive the node attribute\n    dictionaries as inputs.  The functions are expected to return\n    positive numeric values.\n\n    Function node_subst_cost overrides node_match if specified.\n    If neither node_match nor node_subst_cost are specified then\n    default node substitution cost of 0 is used (node attributes\n    are not considered during matching).\n\n    If node_del_cost is not specified then default node deletion\n    cost of 1 is used.  If node_ins_cost is not specified then\n    default node insertion cost of 1 is used.\n\nedge_subst_cost, edge_del_cost, edge_ins_cost : callable\n    Functions that return the costs of edge substitution, edge\n    deletion, and edge insertion, respectively.\n\n    The functions will be called like\n\n       edge_subst_cost(G1[u1][v1], G2[u2][v2]),\n       edge_del_cost(G1[u1][v1]),\n       edge_ins_cost(G2[u2][v2]).\n\n    That is, the functions will receive the edge attribute\n    dictionaries as inputs.  The functions are expected to return\n    positive numeric values.\n\n    Function edge_subst_cost overrides edge_match if specified.\n    If neither edge_match nor edge_subst_cost are specified then\n    default edge substitution cost of 0 is used (edge attributes\n    are not considered during matching).\n\n    If edge_del_cost is not specified then default edge deletion\n    cost of 1 is used.  If edge_ins_cost is not specified then\n    default edge insertion cost of 1 is used.\n\nupper_bound : numeric\n    Maximum edit distance to consider.\n\nReturns\n-------\nGenerator of consecutive approximations of graph edit distance.\n\nExamples\n--------\n>>> G1 = nx.cycle_graph(6)\n>>> G2 = nx.wheel_graph(7)\n>>> for v in nx.optimize_graph_edit_distance(G1, G2):\n...     minv = v\n>>> minv\n7.0\n\nSee Also\n--------\ngraph_edit_distance, optimize_edit_paths\n\nReferences\n----------\n.. [1] Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\n   Martineau. An Exact Graph Edit Distance Algorithm for Solving\n   Pattern Recognition Problems. 4th International Conference on\n   Pattern Recognition Applications and Methods 2015, Jan 2015,\n   Lisbon, Portugal. 2015,\n   <10.5220/0005209202710278>. <hal-01168816>\n   https://hal.archives-ouvertes.fr/hal-01168816"}, {"type": "function", "name": "networkx.out_degree_centrality", "documentation": "Compute the out-degree centrality for nodes.\n\nThe out-degree centrality for a node v is the fraction of nodes its\noutgoing edges are connected to.\n\nParameters\n----------\nG : graph\n    A NetworkX graph\n\nReturns\n-------\nnodes : dictionary\n    Dictionary of nodes with out-degree centrality as values.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is undirected.\n\nExamples\n--------\n>>> G = nx.DiGraph([(0, 1), (0, 2), (0, 3), (1, 2), (1, 3)])\n>>> nx.out_degree_centrality(G)\n{0: 1.0, 1: 0.6666666666666666, 2: 0.0, 3: 0.0}\n\nSee Also\n--------\ndegree_centrality, in_degree_centrality\n\nNotes\n-----\nThe degree centrality values are normalized by dividing by the maximum\npossible degree in a simple graph n-1 where n is the number of nodes in G.\n\nFor multigraphs or graphs with self loops the maximum degree might\nbe higher than n-1 and values of degree centrality greater than 1\nare possible."}, {"type": "function", "name": "networkx.overall_reciprocity", "documentation": "Compute the reciprocity for the whole graph.\n\nSee the doc of reciprocity for the definition.\n\nParameters\n----------\nG : graph\n   A networkx graph"}, {"type": "function", "name": "networkx.pagerank", "documentation": "Returns the PageRank of the nodes in the graph.\n\nPageRank computes a ranking of the nodes in the graph G based on\nthe structure of the incoming links. It was originally designed as\nan algorithm to rank web pages.\n\nParameters\n----------\nG : graph\n  A NetworkX graph.  Undirected graphs will be converted to a directed\n  graph with two directed edges for each undirected edge.\n\nalpha : float, optional\n  Damping parameter for PageRank, default=0.85.\n\npersonalization: dict, optional\n  The \"personalization vector\" consisting of a dictionary with a\n  key some subset of graph nodes and personalization value each of those.\n  At least one personalization value must be non-zero.\n  If not specified, a nodes personalization value will be zero.\n  By default, a uniform distribution is used.\n\nmax_iter : integer, optional\n  Maximum number of iterations in power method eigenvalue solver.\n\ntol : float, optional\n  Error tolerance used to check convergence in power method solver.\n  The iteration will stop after a tolerance of ``len(G) * tol`` is reached.\n\nnstart : dictionary, optional\n  Starting value of PageRank iteration for each node.\n\nweight : key, optional\n  Edge data key to use as weight.  If None weights are set to 1.\n\ndangling: dict, optional\n  The outedges to be assigned to any \"dangling\" nodes, i.e., nodes without\n  any outedges. The dict key is the node the outedge points to and the dict\n  value is the weight of that outedge. By default, dangling nodes are given\n  outedges according to the personalization vector (uniform if not\n  specified). This must be selected to result in an irreducible transition\n  matrix (see notes under google_matrix). It may be common to have the\n  dangling dict to be the same as the personalization dict.\n\n\nReturns\n-------\npagerank : dictionary\n   Dictionary of nodes with PageRank as value\n\nExamples\n--------\n>>> G = nx.DiGraph(nx.path_graph(4))\n>>> pr = nx.pagerank(G, alpha=0.9)\n\nNotes\n-----\nThe eigenvector calculation is done by the power iteration method\nand has no guarantee of convergence.  The iteration will stop after\nan error tolerance of ``len(G) * tol`` has been reached. If the\nnumber of iterations exceed `max_iter`, a\n:exc:`networkx.exception.PowerIterationFailedConvergence` exception\nis raised.\n\nThe PageRank algorithm was designed for directed graphs but this\nalgorithm does not check if the input graph is directed and will\nexecute on undirected graphs by converting each edge in the\ndirected graph to two edges.\n\nSee Also\n--------\ngoogle_matrix\n\nRaises\n------\nPowerIterationFailedConvergence\n    If the algorithm fails to converge to the specified tolerance\n    within the specified number of iterations of the power iteration\n    method.\n\nReferences\n----------\n.. [1] A. Langville and C. Meyer,\n   \"A survey of eigenvector methods of web information retrieval.\"\n   http://citeseer.ist.psu.edu/713792.html\n.. [2] Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,\n   The PageRank citation ranking: Bringing order to the Web. 1999\n   http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&doc=1999-66&format=pdf"}, {"type": "function", "name": "networkx.paley_graph", "documentation": "Returns the Paley $\\frac{(p-1)}{2}$ -regular graph on $p$ nodes.\n\nThe returned graph is a graph on $\\mathbb{Z}/p\\mathbb{Z}$ with edges between $x$ and $y$\nif and only if $x-y$ is a nonzero square in $\\mathbb{Z}/p\\mathbb{Z}$.\n\nIf $p \\equiv 1  \\pmod 4$, $-1$ is a square in $\\mathbb{Z}/p\\mathbb{Z}$ and therefore $x-y$ is a square if and\nonly if $y-x$ is also a square, i.e the edges in the Paley graph are symmetric.\n\nIf $p \\equiv 3 \\pmod 4$, $-1$ is not a square in $\\mathbb{Z}/p\\mathbb{Z}$ and therefore either $x-y$ or $y-x$\nis a square in $\\mathbb{Z}/p\\mathbb{Z}$ but not both.\n\nNote that a more general definition of Paley graphs extends this construction\nto graphs over $q=p^n$ vertices, by using the finite field $F_q$ instead of $\\mathbb{Z}/p\\mathbb{Z}$.\nThis construction requires to compute squares in general finite fields and is\nnot what is implemented here (i.e `paley_graph(25)` does not return the true\nPaley graph associated with $5^2$).\n\nParameters\n----------\np : int, an odd prime number.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : graph\n    The constructed directed graph.\n\nRaises\n------\nNetworkXError\n    If the graph is a multigraph.\n\nReferences\n----------\nChapter 13 in B. Bollobas, Random Graphs. Second edition.\nCambridge Studies in Advanced Mathematics, 73.\nCambridge University Press, Cambridge (2001)."}, {"type": "function", "name": "networkx.panther_similarity", "documentation": "Returns the Panther similarity of nodes in the graph `G` to node ``v``.\n\nPanther is a similarity metric that says \"two objects are considered\nto be similar if they frequently appear on the same paths.\" [1]_.\n\nParameters\n----------\nG : NetworkX graph\n    A NetworkX graph\nsource : node\n    Source node for which to find the top `k` similar other nodes\nk : int (default = 5)\n    The number of most similar nodes to return.\npath_length : int (default = 5)\n    How long the randomly generated paths should be (``T`` in [1]_)\nc : float (default = 0.5)\n    A universal positive constant used to scale the number\n    of sample random paths to generate.\ndelta : float (default = 0.1)\n    The probability that the similarity $S$ is not an epsilon-approximation to (R, phi),\n    where $R$ is the number of random paths and $\\phi$ is the probability\n    that an element sampled from a set $A \\subseteq D$, where $D$ is the domain.\neps : float or None (default = None)\n    The error bound. Per [1]_, a good value is ``sqrt(1/|E|)``. Therefore,\n    if no value is provided, the recommended computed value will be used.\nweight : string or None, optional (default=\"weight\")\n    The name of an edge attribute that holds the numerical value\n    used as a weight. If None then each edge has weight 1.\n\nReturns\n-------\nsimilarity : dictionary\n    Dictionary of nodes to similarity scores (as floats). Note:\n    the self-similarity (i.e., ``v``) will not be included in\n    the returned dictionary. So, for ``k = 5``, a dictionary of\n    top 4 nodes and their similarity scores will be returned.\n\nRaises\n------\nNetworkXUnfeasible\n    If `source` is an isolated node.\n\nNodeNotFound\n    If `source` is not in `G`.\n\nNotes\n-----\n    The isolated nodes in `G` are ignored.\n\nExamples\n--------\n>>> G = nx.star_graph(10)\n>>> sim = nx.panther_similarity(G, 0)\n\nReferences\n----------\n.. [1] Zhang, J., Tang, J., Ma, C., Tong, H., Jing, Y., & Li, J.\n       Panther: Fast top-k similarity search on large networks.\n       In Proceedings of the ACM SIGKDD International Conference\n       on Knowledge Discovery and Data Mining (Vol. 2015-August, pp. 1445\u20131454).\n       Association for Computing Machinery. https://doi.org/10.1145/2783258.2783267."}, {"type": "function", "name": "networkx.pappus_graph", "documentation": "Returns the Pappus graph.\n\nThe Pappus graph is a cubic symmetric distance-regular graph with 18 nodes\nand 27 edges. It is Hamiltonian and can be represented in LCF notation as\n[5,7,-7,7,-7,-5]^3 [1]_.\n\nReturns\n-------\nG : networkx Graph\n    Pappus graph\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Pappus_graph"}, {"type": "function", "name": "networkx.parse_adjlist", "documentation": "Parse lines of a graph adjacency list representation.\n\nParameters\n----------\nlines : list or iterator of strings\n    Input data in adjlist format\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nnodetype : Python type, optional\n   Convert nodes to this type.\n\ncomments : string, optional\n   Marker for comment lines\n\ndelimiter : string, optional\n   Separator for node labels.  The default is whitespace.\n\nReturns\n-------\nG: NetworkX graph\n    The graph corresponding to the lines in adjacency list format.\n\nExamples\n--------\n>>> lines = [\"1 2 5\", \"2 3 4\", \"3 5\", \"4\", \"5\"]\n>>> G = nx.parse_adjlist(lines, nodetype=int)\n>>> nodes = [1, 2, 3, 4, 5]\n>>> all(node in G for node in nodes)\nTrue\n>>> edges = [(1, 2), (1, 5), (2, 3), (2, 4), (3, 5)]\n>>> all((u, v) in G.edges() or (v, u) in G.edges() for (u, v) in edges)\nTrue\n\nSee Also\n--------\nread_adjlist"}, {"type": "function", "name": "networkx.parse_edgelist", "documentation": "Parse lines of an edge list representation of a graph.\n\nParameters\n----------\nlines : list or iterator of strings\n    Input data in edgelist format\ncomments : string, optional\n   Marker for comment lines. Default is `'#'`. To specify that no character\n   should be treated as a comment, use ``comments=None``.\ndelimiter : string, optional\n   Separator for node labels. Default is `None`, meaning any whitespace.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\nnodetype : Python type, optional\n   Convert nodes to this type. Default is `None`, meaning no conversion is\n   performed.\ndata : bool or list of (label,type) tuples\n   If `False` generate no edge data or if `True` use a dictionary\n   representation of edge data or a list tuples specifying dictionary\n   key names and types for edge data.\n\nReturns\n-------\nG: NetworkX Graph\n    The graph corresponding to lines\n\nExamples\n--------\nEdgelist with no data:\n\n>>> lines = [\"1 2\", \"2 3\", \"3 4\"]\n>>> G = nx.parse_edgelist(lines, nodetype=int)\n>>> list(G)\n[1, 2, 3, 4]\n>>> list(G.edges())\n[(1, 2), (2, 3), (3, 4)]\n\nEdgelist with data in Python dictionary representation:\n\n>>> lines = [\"1 2 {'weight': 3}\", \"2 3 {'weight': 27}\", \"3 4 {'weight': 3.0}\"]\n>>> G = nx.parse_edgelist(lines, nodetype=int)\n>>> list(G)\n[1, 2, 3, 4]\n>>> list(G.edges(data=True))\n[(1, 2, {'weight': 3}), (2, 3, {'weight': 27}), (3, 4, {'weight': 3.0})]\n\nEdgelist with data in a list:\n\n>>> lines = [\"1 2 3\", \"2 3 27\", \"3 4 3.0\"]\n>>> G = nx.parse_edgelist(lines, nodetype=int, data=((\"weight\", float),))\n>>> list(G)\n[1, 2, 3, 4]\n>>> list(G.edges(data=True))\n[(1, 2, {'weight': 3.0}), (2, 3, {'weight': 27.0}), (3, 4, {'weight': 3.0})]\n\nSee Also\n--------\nread_weighted_edgelist"}, {"type": "function", "name": "networkx.parse_gml", "documentation": "Parse GML graph from a string or iterable.\n\nParameters\n----------\nlines : string or iterable of strings\n   Data in GML format.\n\nlabel : string, optional\n    If not None, the parsed nodes will be renamed according to node\n    attributes indicated by `label`. Default value: 'label'.\n\ndestringizer : callable, optional\n    A `destringizer` that recovers values stored as strings in GML. If it\n    cannot convert a string to a value, a `ValueError` is raised. Default\n    value : None.\n\nReturns\n-------\nG : NetworkX graph\n    The parsed graph.\n\nRaises\n------\nNetworkXError\n    If the input cannot be parsed.\n\nSee Also\n--------\nwrite_gml, read_gml\n\nNotes\n-----\nThis stores nested GML attributes as dictionaries in the NetworkX graph,\nnode, and edge attribute structures.\n\nGML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a `stringizer`/`destringizer`, the code is capable of\nwriting `int`/`float`/`str`/`dict`/`list` data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan `str` you need to explicitly supply a `stringizer`/`destringizer`.\n\nFor additional documentation on the GML file format, please see the\n`GML url <https://web.archive.org/web/20190207140002/http://www.fim.uni-passau.de/index.php?id=17297&L=1>`_.\n\nSee the module docstring :mod:`networkx.readwrite.gml` for more details."}, {"type": "function", "name": "networkx.parse_graphml", "documentation": "Read graph in GraphML format from string.\n\nParameters\n----------\ngraphml_string : string\n   String containing graphml information\n   (e.g., contents of a graphml file).\n\nnode_type: Python type (default: str)\n   Convert node ids to this type\n\nedge_key_type: Python type (default: int)\n   Convert graphml edge ids to this type. Multigraphs use id as edge key.\n   Non-multigraphs add to edge attribute dict with name \"id\".\n\nforce_multigraph : bool (default: False)\n   If True, return a multigraph with edge keys. If False (the default)\n   return a multigraph when multiedges are in the graph.\n\n\nReturns\n-------\ngraph: NetworkX graph\n    If no parallel edges are found a Graph or DiGraph is returned.\n    Otherwise a MultiGraph or MultiDiGraph is returned.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> linefeed = chr(10)  # linefeed = \n\n>>> s = linefeed.join(nx.generate_graphml(G))\n>>> H = nx.parse_graphml(s)\n\nNotes\n-----\nDefault node and edge attributes are not propagated to each node and edge.\nThey can be obtained from `G.graph` and applied to node and edge attributes\nif desired using something like this:\n\n>>> default_color = G.graph[\"node_default\"][\"color\"]  # doctest: +SKIP\n>>> for node, data in G.nodes(data=True):  # doctest: +SKIP\n...     if \"color\" not in data:\n...         data[\"color\"] = default_color\n>>> default_color = G.graph[\"edge_default\"][\"color\"]  # doctest: +SKIP\n>>> for u, v, data in G.edges(data=True):  # doctest: +SKIP\n...     if \"color\" not in data:\n...         data[\"color\"] = default_color\n\nThis implementation does not support mixed graphs (directed and unidirected\nedges together), hypergraphs, nested graphs, or ports.\n\nFor multigraphs the GraphML edge \"id\" will be used as the edge\nkey.  If not specified then they \"key\" attribute will be used.  If\nthere is no \"key\" attribute a default NetworkX multigraph edge key\nwill be provided."}, {"type": "function", "name": "networkx.parse_leda", "documentation": "Read graph in LEDA format from string or iterable.\n\nParameters\n----------\nlines : string or iterable\n   Data in LEDA format.\n\nReturns\n-------\nG : NetworkX graph\n\nExamples\n--------\nG=nx.parse_leda(string)\n\nReferences\n----------\n.. [1] http://www.algorithmic-solutions.info/leda_guide/graphs/leda_native_graph_fileformat.html"}, {"type": "function", "name": "networkx.parse_multiline_adjlist", "documentation": "Parse lines of a multiline adjacency list representation of a graph.\n\nParameters\n----------\nlines : list or iterator of strings\n    Input data in multiline adjlist format\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nnodetype : Python type, optional\n   Convert nodes to this type.\n\nedgetype : Python type, optional\n   Convert edges to this type.\n\ncomments : string, optional\n   Marker for comment lines\n\ndelimiter : string, optional\n   Separator for node labels.  The default is whitespace.\n\nReturns\n-------\nG: NetworkX graph\n    The graph corresponding to the lines in multiline adjacency list format.\n\nExamples\n--------\n>>> lines = [\n...     \"1 2\",\n...     \"2 {'weight':3, 'name': 'Frodo'}\",\n...     \"3 {}\",\n...     \"2 1\",\n...     \"5 {'weight':6, 'name': 'Saruman'}\",\n... ]\n>>> G = nx.parse_multiline_adjlist(iter(lines), nodetype=int)\n>>> list(G)\n[1, 2, 3, 5]"}, {"type": "function", "name": "networkx.parse_pajek", "documentation": "Parse Pajek format graph from string or iterable.\n\nParameters\n----------\nlines : string or iterable\n   Data in Pajek format.\n\nReturns\n-------\nG : NetworkX graph\n\nSee Also\n--------\nread_pajek"}, {"type": "function", "name": "networkx.partial_duplication_graph", "documentation": "Returns a random graph using the partial duplication model.\n\nParameters\n----------\nN : int\n    The total number of nodes in the final graph.\n\nn : int\n    The number of nodes in the initial clique.\n\np : float\n    The probability of joining each neighbor of a node to the\n    duplicate node. Must be a number in the between zero and one,\n    inclusive.\n\nq : float\n    The probability of joining the source node to the duplicate\n    node. Must be a number in the between zero and one, inclusive.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nNotes\n-----\nA graph of nodes is grown by creating a fully connected graph\nof size `n`. The following procedure is then repeated until\na total of `N` nodes have been reached.\n\n1. A random node, *u*, is picked and a new node, *v*, is created.\n2. For each neighbor of *u* an edge from the neighbor to *v* is created\n   with probability `p`.\n3. An edge from *u* to *v* is created with probability `q`.\n\nThis algorithm appears in [1].\n\nThis implementation allows the possibility of generating\ndisconnected graphs.\n\nReferences\n----------\n.. [1] Knudsen Michael, and Carsten Wiuf. \"A Markov chain approach to\n       randomly grown graphs.\" Journal of Applied Mathematics 2008.\n       <https://doi.org/10.1155/2008/190836>"}, {"type": "function", "name": "networkx.partition_spanning_tree", "documentation": "Find a spanning tree while respecting a partition of edges.\n\nEdges can be flagged as either `INCLUDED` which are required to be in the\nreturned tree, `EXCLUDED`, which cannot be in the returned tree and `OPEN`.\n\nThis is used in the SpanningTreeIterator to create new partitions following\nthe algorithm of S\u00f6rensen and Janssens [1]_.\n\nParameters\n----------\nG : undirected graph\n    An undirected graph.\n\nminimum : bool (default: True)\n    Determines whether the returned tree is the minimum spanning tree of\n    the partition of the maximum one.\n\nweight : str\n    Data key to use for edge weights.\n\npartition : str\n    The key for the edge attribute containing the partition\n    data on the graph. Edges can be included, excluded or open using the\n    `EdgePartition` enum.\n\nignore_nan : bool (default: False)\n    If a NaN is found as an edge weight normally an exception is raised.\n    If `ignore_nan is True` then that edge is ignored instead.\n\n\nReturns\n-------\nG : NetworkX Graph\n    A minimum spanning tree using all of the included edges in the graph and\n    none of the excluded edges.\n\nReferences\n----------\n.. [1] G.K. Janssens, K. S\u00f6rensen, An algorithm to generate all spanning\n       trees in order of increasing cost, Pesquisa Operacional, 2005-08,\n       Vol. 25 (2), p. 219-229,\n       https://www.scielo.br/j/pope/a/XHswBwRwJyrfL88dmMwYNWp/?lang=en"}, {"type": "function", "name": "networkx.path_graph", "documentation": "Returns the Path graph `P_n` of linearly connected nodes.\n\n.. plot::\n\n    >>> nx.draw(nx.path_graph(5))\n\nParameters\n----------\nn : int or iterable\n    If an integer, nodes are 0 to n - 1.\n    If an iterable of nodes, in the order they appear in the path.\n    Warning: n is not checked for duplicates and if present the\n    resulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated."}, {"type": "function", "name": "networkx.path_weight", "documentation": "Returns total cost associated with specified path and weight\n\nParameters\n----------\nG : graph\n    A NetworkX graph.\n\npath: list\n    A list of node labels which defines the path to traverse\n\nweight: string\n    A string indicating which edge attribute to use for path cost\n\nReturns\n-------\ncost: int or float\n    An integer or a float representing the total cost with respect to the\n    specified weight of the specified path\n\nRaises\n------\nNetworkXNoPath\n    If the specified edge does not exist."}, {"type": "function", "name": "networkx.percolation_centrality", "documentation": "Compute the percolation centrality for nodes.\n\nPercolation centrality of a node $v$, at a given time, is defined\nas the proportion of \u2018percolated paths\u2019 that go through that node.\n\nThis measure quantifies relative impact of nodes based on their\ntopological connectivity, as well as their percolation states.\n\nPercolation states of nodes are used to depict network percolation\nscenarios (such as during infection transmission in a social network\nof individuals, spreading of computer viruses on computer networks, or\ntransmission of disease over a network of towns) over time. In this\nmeasure usually the percolation state is expressed as a decimal\nbetween 0.0 and 1.0.\n\nWhen all nodes are in the same percolated state this measure is\nequivalent to betweenness centrality.\n\nParameters\n----------\nG : graph\n  A NetworkX graph.\n\nattribute : None or string, optional (default='percolation')\n  Name of the node attribute to use for percolation state, used\n  if `states` is None. If a node does not set the attribute the\n  state of that node will be set to the default value of 1.\n  If all nodes do not have the attribute all nodes will be set to\n  1 and the centrality measure will be equivalent to betweenness centrality.\n\nstates : None or dict, optional (default=None)\n  Specify percolation states for the nodes, nodes as keys states\n  as values.\n\nweight : None or string, optional (default=None)\n  If None, all edge weights are considered equal.\n  Otherwise holds the name of the edge attribute used as weight.\n  The weight of an edge is treated as the length or distance between the two sides.\n\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with percolation centrality as the value.\n\nSee Also\n--------\nbetweenness_centrality\n\nNotes\n-----\nThe algorithm is from Mahendra Piraveenan, Mikhail Prokopenko, and\nLiaquat Hossain [1]_\nPair dependencies are calculated and accumulated using [2]_\n\nFor weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\n\nReferences\n----------\n.. [1] Mahendra Piraveenan, Mikhail Prokopenko, Liaquat Hossain\n   Percolation Centrality: Quantifying Graph-Theoretic Impact of Nodes\n   during Percolation in Networks\n   http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0053095\n.. [2] Ulrik Brandes:\n   A Faster Algorithm for Betweenness Centrality.\n   Journal of Mathematical Sociology 25(2):163-177, 2001.\n   https://doi.org/10.1080/0022250X.2001.9990249"}, {"type": "function", "name": "networkx.periphery", "documentation": "Returns the periphery of the graph G.\n\nThe periphery is the set of nodes with eccentricity equal to the diameter.\n\nParameters\n----------\nG : NetworkX graph\n   A graph\n\ne : eccentricity dictionary, optional\n  A precomputed dictionary of eccentricities.\n\nweight : string, function, or None\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\n    If this is None, every edge has weight/distance/cost 1.\n\n    Weights stored as floating point values can lead to small round-off\n    errors in distances. Use integer weights to avoid this.\n\n    Weights should be positive, since they are distances.\n\nReturns\n-------\np : list\n   List of nodes in periphery\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (1, 4), (3, 4), (3, 5), (4, 5)])\n>>> nx.periphery(G)\n[2, 5]\n\nSee Also\n--------\nbarycenter\ncenter"}, {"type": "function", "name": "networkx.petersen_graph", "documentation": "Returns the Petersen graph.\n\nThe Peterson graph is a cubic, undirected graph with 10 nodes and 15 edges [1]_.\nJulius Petersen constructed the graph as the smallest counterexample\nagainst the claim that a connected bridgeless cubic graph\nhas an edge colouring with three colours [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Petersen graph\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Petersen_graph\n.. [2] https://www.win.tue.nl/~aeb/drg/graphs/Petersen.html"}, {"type": "function", "name": "networkx.planar_layout", "documentation": "Position nodes without edge intersections.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G. If G is of type\n    nx.PlanarEmbedding, the positions are selected accordingly.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\ndim : int\n    Dimension of layout.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nRaises\n------\nNetworkXException\n    If G is not planar\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.planar_layout(G)"}, {"type": "function", "name": "networkx.planted_partition_graph", "documentation": "Returns the planted l-partition graph.\n\nThis model partitions a graph with n=l*k vertices in\nl groups with k vertices each. Vertices of the same\ngroup are linked with a probability p_in, and vertices\nof different groups are linked with probability p_out.\n\nParameters\n----------\nl : int\n  Number of groups\nk : int\n  Number of vertices in each group\np_in : float\n  probability of connecting vertices within a group\np_out : float\n  probability of connected vertices between groups\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ndirected : bool,optional (default=False)\n  If True return a directed graph\n\nReturns\n-------\nG : NetworkX Graph or DiGraph\n  planted l-partition graph\n\nRaises\n------\nNetworkXError\n  If `p_in`, `p_out` are not in `[0, 1]`\n\nExamples\n--------\n>>> G = nx.planted_partition_graph(4, 3, 0.5, 0.1, seed=42)\n\nSee Also\n--------\nrandom_partition_model\n\nReferences\n----------\n.. [1] A. Condon, R.M. Karp, Algorithms for graph partitioning\n    on the planted partition model,\n    Random Struct. Algor. 18 (2001) 116-140.\n\n.. [2] Santo Fortunato 'Community Detection in Graphs' Physical Reports\n   Volume 486, Issue 3-5 p. 75-174. https://arxiv.org/abs/0906.0612"}, {"type": "function", "name": "networkx.power", "documentation": "Returns the specified power of a graph.\n\nThe $k$th power of a simple graph $G$, denoted $G^k$, is a\ngraph on the same set of nodes in which two distinct nodes $u$ and\n$v$ are adjacent in $G^k$ if and only if the shortest path\ndistance between $u$ and $v$ in $G$ is at most $k$.\n\nParameters\n----------\nG : graph\n    A NetworkX simple graph object.\n\nk : positive integer\n    The power to which to raise the graph `G`.\n\nReturns\n-------\nNetworkX simple graph\n    `G` to the power `k`.\n\nRaises\n------\nValueError\n    If the exponent `k` is not positive.\n\nNetworkXNotImplemented\n    If `G` is not a simple graph.\n\nExamples\n--------\nThe number of edges will never decrease when taking successive\npowers:\n\n>>> G = nx.path_graph(4)\n>>> list(nx.power(G, 2).edges)\n[(0, 1), (0, 2), (1, 2), (1, 3), (2, 3)]\n>>> list(nx.power(G, 3).edges)\n[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n\nThe `k` th power of a cycle graph on *n* nodes is the complete graph\non *n* nodes, if `k` is at least ``n // 2``:\n\n>>> G = nx.cycle_graph(5)\n>>> H = nx.complete_graph(5)\n>>> nx.is_isomorphic(nx.power(G, 2), H)\nTrue\n>>> G = nx.cycle_graph(8)\n>>> H = nx.complete_graph(8)\n>>> nx.is_isomorphic(nx.power(G, 4), H)\nTrue\n\nReferences\n----------\n.. [1] J. A. Bondy, U. S. R. Murty, *Graph Theory*. Springer, 2008.\n\nNotes\n-----\nThis definition of \"power graph\" comes from Exercise 3.1.6 of\n*Graph Theory* by Bondy and Murty [1]_."}, {"type": "function", "name": "networkx.powerlaw_cluster_graph", "documentation": "Holme and Kim algorithm for growing graphs with powerlaw\ndegree distribution and approximate average clustering.\n\nParameters\n----------\nn : int\n    the number of nodes\nm : int\n    the number of random edges to add for each new node\np : float,\n    Probability of adding a triangle after adding a random edge\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nNotes\n-----\nThe average clustering has a hard time getting above a certain\ncutoff that depends on `m`.  This cutoff is often quite low.  The\ntransitivity (fraction of triangles to possible triangles) seems to\ndecrease with network size.\n\nIt is essentially the Barab\u00e1si\u2013Albert (BA) growth model with an\nextra step that each random edge is followed by a chance of\nmaking an edge to one of its neighbors too (and thus a triangle).\n\nThis algorithm improves on BA in the sense that it enables a\nhigher average clustering to be attained if desired.\n\nIt seems possible to have a disconnected graph with this algorithm\nsince the initial `m` nodes may not be all linked to a new node\non the first iteration like the BA model.\n\nRaises\n------\nNetworkXError\n    If `m` does not satisfy ``1 <= m <= n`` or `p` does not\n    satisfy ``0 <= p <= 1``.\n\nReferences\n----------\n.. [1] P. Holme and B. J. Kim,\n   \"Growing scale-free networks with tunable clustering\",\n   Phys. Rev. E, 65, 026107, 2002."}, {"type": "function", "name": "networkx.predecessor", "documentation": "Returns dict of predecessors for the path from source to all nodes in G.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node label\n   Starting node for path\n\ntarget : node label, optional\n   Ending node for path. If provided only predecessors between\n   source and target are returned\n\ncutoff : integer, optional\n    Depth to stop the search. Only paths of length <= cutoff are returned.\n\nreturn_seen : bool, optional (default=None)\n    Whether to return a dictionary, keyed by node, of the level (number of\n    hops) to reach the node (as seen during breadth-first-search).\n\nReturns\n-------\npred : dictionary\n    Dictionary, keyed by node, of predecessors in the shortest path.\n\n\n(pred, seen): tuple of dictionaries\n    If `return_seen` argument is set to `True`, then a tuple of dictionaries\n    is returned. The first element is the dictionary, keyed by node, of\n    predecessors in the shortest path. The second element is the dictionary,\n    keyed by node, of the level (number of hops) to reach the node (as seen\n    during breadth-first-search).\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> list(G)\n[0, 1, 2, 3]\n>>> nx.predecessor(G, 0)\n{0: [], 1: [0], 2: [1], 3: [2]}\n>>> nx.predecessor(G, 0, return_seen=True)\n({0: [], 1: [0], 2: [1], 3: [2]}, {0: 0, 1: 1, 2: 2, 3: 3})"}, {"type": "function", "name": "networkx.preferential_attachment", "documentation": "Compute the preferential attachment score of all node pairs in ebunch.\n\nPreferential attachment score of `u` and `v` is defined as\n\n.. math::\n\n    |\\Gamma(u)| |\\Gamma(v)|\n\nwhere $\\Gamma(u)$ denotes the set of neighbors of $u$.\n\nParameters\n----------\nG : graph\n    NetworkX undirected graph.\n\nebunch : iterable of node pairs, optional (default = None)\n    Preferential attachment score will be computed for each pair of\n    nodes given in the iterable. The pairs must be given as\n    2-tuples (u, v) where u and v are nodes in the graph. If ebunch\n    is None then all nonexistent edges in the graph will be used.\n    Default value: None.\n\nReturns\n-------\npiter : iterator\n    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\n    pair of nodes and p is their preferential attachment score.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is a `DiGraph`, a `Multigraph` or a `MultiDiGraph`.\n\nNodeNotFound\n    If `ebunch` has a node that is not in `G`.\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> preds = nx.preferential_attachment(G, [(0, 1), (2, 3)])\n>>> for u, v, p in preds:\n...     print(f\"({u}, {v}) -> {p}\")\n(0, 1) -> 16\n(2, 3) -> 16\n\nReferences\n----------\n.. [1] D. Liben-Nowell, J. Kleinberg.\n       The Link Prediction Problem for Social Networks (2004).\n       http://www.cs.cornell.edu/home/kleinber/link-pred.pdf"}, {"type": "function", "name": "networkx.prefix_tree", "documentation": "Creates a directed prefix tree from a list of paths.\n\nUsually the paths are described as strings or lists of integers.\n\nA \"prefix tree\" represents the prefix structure of the strings.\nEach node represents a prefix of some string. The root represents\nthe empty prefix with children for the single letter prefixes which\nin turn have children for each double letter prefix starting with\nthe single letter corresponding to the parent node, and so on.\n\nMore generally the prefixes do not need to be strings. A prefix refers\nto the start of a sequence. The root has children for each one element\nprefix and they have children for each two element prefix that starts\nwith the one element sequence of the parent, and so on.\n\nNote that this implementation uses integer nodes with an attribute.\nEach node has an attribute \"source\" whose value is the original element\nof the path to which this node corresponds. For example, suppose `paths`\nconsists of one path: \"can\". Then the nodes `[1, 2, 3]` which represent\nthis path have \"source\" values \"c\", \"a\" and \"n\".\n\nAll the descendants of a node have a common prefix in the sequence/path\nassociated with that node. From the returned tree, the prefix for each\nnode can be constructed by traversing the tree up to the root and\naccumulating the \"source\" values along the way.\n\nThe root node is always `0` and has \"source\" attribute `None`.\nThe root is the only node with in-degree zero.\nThe nil node is always `-1` and has \"source\" attribute `\"NIL\"`.\nThe nil node is the only node with out-degree zero.\n\n\nParameters\n----------\npaths: iterable of paths\n    An iterable of paths which are themselves sequences.\n    Matching prefixes among these sequences are identified with\n    nodes of the prefix tree. One leaf of the tree is associated\n    with each path. (Identical paths are associated with the same\n    leaf of the tree.)\n\n\nReturns\n-------\ntree: DiGraph\n    A directed graph representing an arborescence consisting of the\n    prefix tree generated by `paths`. Nodes are directed \"downward\",\n    from parent to child. A special \"synthetic\" root node is added\n    to be the parent of the first node in each path. A special\n    \"synthetic\" leaf node, the \"nil\" node `-1`, is added to be the child\n    of all nodes representing the last element in a path. (The\n    addition of this nil node technically makes this not an\n    arborescence but a directed acyclic graph; removing the nil node\n    makes it an arborescence.)\n\n\nNotes\n-----\nThe prefix tree is also known as a *trie*.\n\n\nExamples\n--------\nCreate a prefix tree from a list of strings with common prefixes::\n\n    >>> paths = [\"ab\", \"abs\", \"ad\"]\n    >>> T = nx.prefix_tree(paths)\n    >>> list(T.edges)\n    [(0, 1), (1, 2), (1, 4), (2, -1), (2, 3), (3, -1), (4, -1)]\n\nThe leaf nodes can be obtained as predecessors of the nil node::\n\n    >>> root, NIL = 0, -1\n    >>> list(T.predecessors(NIL))\n    [2, 3, 4]\n\nTo recover the original paths that generated the prefix tree,\ntraverse up the tree from the node `-1` to the node `0`::\n\n    >>> recovered = []\n    >>> for v in T.predecessors(NIL):\n    ...     prefix = \"\"\n    ...     while v != root:\n    ...         prefix = str(T.nodes[v][\"source\"]) + prefix\n    ...         v = next(T.predecessors(v))  # only one predecessor\n    ...     recovered.append(prefix)\n    >>> sorted(recovered)\n    ['ab', 'abs', 'ad']"}, {"type": "function", "name": "networkx.prefix_tree_recursive", "documentation": "Recursively creates a directed prefix tree from a list of paths.\n\nThe original recursive version of prefix_tree for comparison. It is\nthe same algorithm but the recursion is unrolled onto a stack.\n\nUsually the paths are described as strings or lists of integers.\n\nA \"prefix tree\" represents the prefix structure of the strings.\nEach node represents a prefix of some string. The root represents\nthe empty prefix with children for the single letter prefixes which\nin turn have children for each double letter prefix starting with\nthe single letter corresponding to the parent node, and so on.\n\nMore generally the prefixes do not need to be strings. A prefix refers\nto the start of a sequence. The root has children for each one element\nprefix and they have children for each two element prefix that starts\nwith the one element sequence of the parent, and so on.\n\nNote that this implementation uses integer nodes with an attribute.\nEach node has an attribute \"source\" whose value is the original element\nof the path to which this node corresponds. For example, suppose `paths`\nconsists of one path: \"can\". Then the nodes `[1, 2, 3]` which represent\nthis path have \"source\" values \"c\", \"a\" and \"n\".\n\nAll the descendants of a node have a common prefix in the sequence/path\nassociated with that node. From the returned tree, ehe prefix for each\nnode can be constructed by traversing the tree up to the root and\naccumulating the \"source\" values along the way.\n\nThe root node is always `0` and has \"source\" attribute `None`.\nThe root is the only node with in-degree zero.\nThe nil node is always `-1` and has \"source\" attribute `\"NIL\"`.\nThe nil node is the only node with out-degree zero.\n\n\nParameters\n----------\npaths: iterable of paths\n    An iterable of paths which are themselves sequences.\n    Matching prefixes among these sequences are identified with\n    nodes of the prefix tree. One leaf of the tree is associated\n    with each path. (Identical paths are associated with the same\n    leaf of the tree.)\n\n\nReturns\n-------\ntree: DiGraph\n    A directed graph representing an arborescence consisting of the\n    prefix tree generated by `paths`. Nodes are directed \"downward\",\n    from parent to child. A special \"synthetic\" root node is added\n    to be the parent of the first node in each path. A special\n    \"synthetic\" leaf node, the \"nil\" node `-1`, is added to be the child\n    of all nodes representing the last element in a path. (The\n    addition of this nil node technically makes this not an\n    arborescence but a directed acyclic graph; removing the nil node\n    makes it an arborescence.)\n\n\nNotes\n-----\nThe prefix tree is also known as a *trie*.\n\n\nExamples\n--------\nCreate a prefix tree from a list of strings with common prefixes::\n\n    >>> paths = [\"ab\", \"abs\", \"ad\"]\n    >>> T = nx.prefix_tree(paths)\n    >>> list(T.edges)\n    [(0, 1), (1, 2), (1, 4), (2, -1), (2, 3), (3, -1), (4, -1)]\n\nThe leaf nodes can be obtained as predecessors of the nil node.\n\n    >>> root, NIL = 0, -1\n    >>> list(T.predecessors(NIL))\n    [2, 3, 4]\n\nTo recover the original paths that generated the prefix tree,\ntraverse up the tree from the node `-1` to the node `0`::\n\n    >>> recovered = []\n    >>> for v in T.predecessors(NIL):\n    ...     prefix = \"\"\n    ...     while v != root:\n    ...         prefix = str(T.nodes[v][\"source\"]) + prefix\n    ...         v = next(T.predecessors(v))  # only one predecessor\n    ...     recovered.append(prefix)\n    >>> sorted(recovered)\n    ['ab', 'abs', 'ad']"}, {"type": "function", "name": "networkx.projected_graph", "documentation": "Returns the projection of B onto one of its node sets.\n\nReturns the graph G that is the projection of the bipartite graph B\nonto the specified nodes. They retain their attributes and are connected\nin G if they have a common neighbor in B.\n\nParameters\n----------\nB : NetworkX graph\n  The input graph should be bipartite.\n\nnodes : list or iterable\n  Nodes to project onto (the \"bottom\" nodes).\n\nmultigraph: bool (default=False)\n   If True return a multigraph where the multiple edges represent multiple\n   shared neighbors.  They edge key in the multigraph is assigned to the\n   label of the neighbor.\n\nReturns\n-------\nGraph : NetworkX graph or multigraph\n   A graph that is the projection onto the given nodes.\n\nExamples\n--------\n>>> from networkx.algorithms import bipartite\n>>> B = nx.path_graph(4)\n>>> G = bipartite.projected_graph(B, [1, 3])\n>>> list(G)\n[1, 3]\n>>> list(G.edges())\n[(1, 3)]\n\nIf nodes `a`, and `b` are connected through both nodes 1 and 2 then\nbuilding a multigraph results in two edges in the projection onto\n[`a`, `b`]:\n\n>>> B = nx.Graph()\n>>> B.add_edges_from([(\"a\", 1), (\"b\", 1), (\"a\", 2), (\"b\", 2)])\n>>> G = bipartite.projected_graph(B, [\"a\", \"b\"], multigraph=True)\n>>> print([sorted((u, v)) for u, v in G.edges()])\n[['a', 'b'], ['a', 'b']]\n\nNotes\n-----\nNo attempt is made to verify that the input graph B is bipartite.\nReturns a simple graph that is the projection of the bipartite graph B\nonto the set of nodes given in list nodes.  If multigraph=True then\na multigraph is returned with an edge for every shared neighbor.\n\nDirected graphs are allowed as input.  The output will also then\nbe a directed graph with edges if there is a directed path between\nthe nodes.\n\nThe graph and node properties are (shallow) copied to the projected graph.\n\nSee :mod:`bipartite documentation <networkx.algorithms.bipartite>`\nfor further details on how bipartite graphs are handled in NetworkX.\n\nSee Also\n--------\nis_bipartite,\nis_bipartite_node_set,\nsets,\nweighted_projected_graph,\ncollaboration_weighted_projected_graph,\noverlap_weighted_projected_graph,\ngeneric_weighted_projected_graph"}, {"type": "function", "name": "networkx.prominent_group", "documentation": "Find the prominent group of size $k$ in graph $G$. The prominence of the\ngroup is evaluated by the group betweenness centrality.\n\nGroup betweenness centrality of a group of nodes $C$ is the sum of the\nfraction of all-pairs shortest paths that pass through any vertex in $C$\n\n.. math::\n\n   c_B(v) =\\sum_{s,t \\in V} \\frac{\\sigma(s, t|v)}{\\sigma(s, t)}\n\nwhere $V$ is the set of nodes, $\\sigma(s, t)$ is the number of\nshortest $(s, t)$-paths, and $\\sigma(s, t|C)$ is the number of\nthose paths passing through some node in group $C$. Note that\n$(s, t)$ are not members of the group ($V-C$ is the set of nodes\nin $V$ that are not in $C$).\n\nParameters\n----------\nG : graph\n   A NetworkX graph.\n\nk : int\n   The number of nodes in the group.\n\nnormalized : bool, optional (default=True)\n   If True, group betweenness is normalized by ``1/((|V|-|C|)(|V|-|C|-1))``\n   where ``|V|`` is the number of nodes in G and ``|C|`` is the number of\n   nodes in C.\n\nweight : None or string, optional (default=None)\n   If None, all edge weights are considered equal.\n   Otherwise holds the name of the edge attribute used as weight.\n   The weight of an edge is treated as the length or distance between the two sides.\n\nendpoints : bool, optional (default=False)\n   If True include the endpoints in the shortest path counts.\n\nC : list or set, optional (default=None)\n   list of nodes which won't be candidates of the prominent group.\n\ngreedy : bool, optional (default=False)\n   Using a naive greedy algorithm in order to find non-optimal prominent\n   group. For scale free networks the results are negligibly below the optimal\n   results.\n\nRaises\n------\nNodeNotFound\n   If node(s) in C are not present in G.\n\nReturns\n-------\nmax_GBC : float\n   The group betweenness centrality of the prominent group.\n\nmax_group : list\n    The list of nodes in the prominent group.\n\nSee Also\n--------\nbetweenness_centrality, group_betweenness_centrality\n\nNotes\n-----\nGroup betweenness centrality is described in [1]_ and its importance discussed in [3]_.\nThe algorithm is described in [2]_ and is based on techniques mentioned in [4]_.\n\nThe number of nodes in the group must be a maximum of ``n - 2`` where ``n``\nis the total number of nodes in the graph.\n\nFor weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\n\nThe total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nbetween \"u\" and \"v\" are counted as two possible paths (one each\ndirection) while undirected paths between \"u\" and \"v\" are counted\nas one path. Said another way, the sum in the expression above is\nover all ``s != t`` for directed graphs and for ``s < t`` for undirected graphs.\n\nReferences\n----------\n.. [1] M G Everett and S P Borgatti:\n   The Centrality of Groups and Classes.\n   Journal of Mathematical Sociology. 23(3): 181-201. 1999.\n   http://www.analytictech.com/borgatti/group_centrality.htm\n.. [2] Rami Puzis, Yuval Elovici, and Shlomi Dolev:\n   \"Finding the Most Prominent Group in Complex Networks\"\n   AI communications 20(4): 287-296, 2007.\n   https://www.researchgate.net/profile/Rami_Puzis2/publication/220308855\n.. [3] Sourav Medya et. al.:\n   Group Centrality Maximization via Network Design.\n   SIAM International Conference on Data Mining, SDM 2018, 126\u2013134.\n   https://sites.cs.ucsb.edu/~arlei/pubs/sdm18.pdf\n.. [4] Rami Puzis, Yuval Elovici, and Shlomi Dolev.\n   \"Fast algorithm for successive computation of group betweenness centrality.\"\n   https://journals.aps.org/pre/pdf/10.1103/PhysRevE.76.056709"}, {"type": "function", "name": "networkx.quotient_graph", "documentation": "Returns the quotient graph of `G` under the specified equivalence\nrelation on nodes.\n\nParameters\n----------\nG : NetworkX graph\n    The graph for which to return the quotient graph with the\n    specified node relation.\n\npartition : function, or dict or list of lists, tuples or sets\n    If a function, this function must represent an equivalence\n    relation on the nodes of `G`. It must take two arguments *u*\n    and *v* and return True exactly when *u* and *v* are in the\n    same equivalence class. The equivalence classes form the nodes\n    in the returned graph.\n\n    If a dict of lists/tuples/sets, the keys can be any meaningful\n    block labels, but the values must be the block lists/tuples/sets\n    (one list/tuple/set per block), and the blocks must form a valid\n    partition of the nodes of the graph. That is, each node must be\n    in exactly one block of the partition.\n\n    If a list of sets, the list must form a valid partition of\n    the nodes of the graph. That is, each node must be in exactly\n    one block of the partition.\n\nedge_relation : Boolean function with two arguments\n    This function must represent an edge relation on the *blocks* of\n    the `partition` of `G`. It must take two arguments, *B* and *C*,\n    each one a set of nodes, and return True exactly when there should be\n    an edge joining block *B* to block *C* in the returned graph.\n\n    If `edge_relation` is not specified, it is assumed to be the\n    following relation. Block *B* is related to block *C* if and\n    only if some node in *B* is adjacent to some node in *C*,\n    according to the edge set of `G`.\n\nnode_data : function\n    This function takes one argument, *B*, a set of nodes in `G`,\n    and must return a dictionary representing the node data\n    attributes to set on the node representing *B* in the quotient graph.\n    If None, the following node attributes will be set:\n\n    * 'graph', the subgraph of the graph `G` that this block\n      represents,\n    * 'nnodes', the number of nodes in this block,\n    * 'nedges', the number of edges within this block,\n    * 'density', the density of the subgraph of `G` that this\n      block represents.\n\nedge_data : function\n    This function takes two arguments, *B* and *C*, each one a set\n    of nodes, and must return a dictionary representing the edge\n    data attributes to set on the edge joining *B* and *C*, should\n    there be an edge joining *B* and *C* in the quotient graph (if\n    no such edge occurs in the quotient graph as determined by\n    `edge_relation`, then the output of this function is ignored).\n\n    If the quotient graph would be a multigraph, this function is\n    not applied, since the edge data from each edge in the graph\n    `G` appears in the edges of the quotient graph.\n\nweight : string or None, optional (default=\"weight\")\n    The name of an edge attribute that holds the numerical value\n    used as a weight. If None then each edge has weight 1.\n\nrelabel : bool\n    If True, relabel the nodes of the quotient graph to be\n    nonnegative integers. Otherwise, the nodes are identified with\n    :class:`frozenset` instances representing the blocks given in\n    `partition`.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkX graph\n    The quotient graph of `G` under the equivalence relation\n    specified by `partition`. If the partition were given as a\n    list of :class:`set` instances and `relabel` is False,\n    each node will be a :class:`frozenset` corresponding to the same\n    :class:`set`.\n\nRaises\n------\nNetworkXException\n    If the given partition is not a valid partition of the nodes of\n    `G`.\n\nExamples\n--------\nThe quotient graph of the complete bipartite graph under the \"same\nneighbors\" equivalence relation is `K_2`. Under this relation, two nodes\nare equivalent if they are not adjacent but have the same neighbor set.\n\n>>> G = nx.complete_bipartite_graph(2, 3)\n>>> same_neighbors = lambda u, v: (u not in G[v] and v not in G[u] and G[u] == G[v])\n>>> Q = nx.quotient_graph(G, same_neighbors)\n>>> K2 = nx.complete_graph(2)\n>>> nx.is_isomorphic(Q, K2)\nTrue\n\nThe quotient graph of a directed graph under the \"same strongly connected\ncomponent\" equivalence relation is the condensation of the graph (see\n:func:`condensation`). This example comes from the Wikipedia article\n*`Strongly connected component`_*.\n\n>>> G = nx.DiGraph()\n>>> edges = [\n...     \"ab\",\n...     \"be\",\n...     \"bf\",\n...     \"bc\",\n...     \"cg\",\n...     \"cd\",\n...     \"dc\",\n...     \"dh\",\n...     \"ea\",\n...     \"ef\",\n...     \"fg\",\n...     \"gf\",\n...     \"hd\",\n...     \"hf\",\n... ]\n>>> G.add_edges_from(tuple(x) for x in edges)\n>>> components = list(nx.strongly_connected_components(G))\n>>> sorted(sorted(component) for component in components)\n[['a', 'b', 'e'], ['c', 'd', 'h'], ['f', 'g']]\n>>>\n>>> C = nx.condensation(G, components)\n>>> component_of = C.graph[\"mapping\"]\n>>> same_component = lambda u, v: component_of[u] == component_of[v]\n>>> Q = nx.quotient_graph(G, same_component)\n>>> nx.is_isomorphic(C, Q)\nTrue\n\nNode identification can be represented as the quotient of a graph under the\nequivalence relation that places the two nodes in one block and each other\nnode in its own singleton block.\n\n>>> K24 = nx.complete_bipartite_graph(2, 4)\n>>> K34 = nx.complete_bipartite_graph(3, 4)\n>>> C = nx.contracted_nodes(K34, 1, 2)\n>>> nodes = {1, 2}\n>>> is_contracted = lambda u, v: u in nodes and v in nodes\n>>> Q = nx.quotient_graph(K34, is_contracted)\n>>> nx.is_isomorphic(Q, C)\nTrue\n>>> nx.is_isomorphic(Q, K24)\nTrue\n\nThe blockmodeling technique described in [1]_ can be implemented as a\nquotient graph.\n\n>>> G = nx.path_graph(6)\n>>> partition = [{0, 1}, {2, 3}, {4, 5}]\n>>> M = nx.quotient_graph(G, partition, relabel=True)\n>>> list(M.edges())\n[(0, 1), (1, 2)]\n\nHere is the sample example but using partition as a dict of block sets.\n\n>>> G = nx.path_graph(6)\n>>> partition = {0: {0, 1}, 2: {2, 3}, 4: {4, 5}}\n>>> M = nx.quotient_graph(G, partition, relabel=True)\n>>> list(M.edges())\n[(0, 1), (1, 2)]\n\nPartitions can be represented in various ways:\n\n0. a list/tuple/set of block lists/tuples/sets\n1. a dict with block labels as keys and blocks lists/tuples/sets as values\n2. a dict with block lists/tuples/sets as keys and block labels as values\n3. a function from nodes in the original iterable to block labels\n4. an equivalence relation function on the target iterable\n\nAs `quotient_graph` is designed to accept partitions represented as (0), (1) or\n(4) only, the `equivalence_classes` function can be used to get the partitions\nin the right form, in order to call `quotient_graph`.\n\n.. _Strongly connected component: https://en.wikipedia.org/wiki/Strongly_connected_component\n\nReferences\n----------\n.. [1] Patrick Doreian, Vladimir Batagelj, and Anuska Ferligoj.\n       *Generalized Blockmodeling*.\n       Cambridge University Press, 2004."}, {"type": "function", "name": "networkx.ra_index_soundarajan_hopcroft", "documentation": "Compute the resource allocation index of all node pairs in\nebunch using community information.\n\nFor two nodes $u$ and $v$, this function computes the resource\nallocation index considering only common neighbors belonging to the\nsame community as $u$ and $v$. Mathematically,\n\n.. math::\n\n    \\sum_{w \\in \\Gamma(u) \\cap \\Gamma(v)} \\frac{f(w)}{|\\Gamma(w)|}\n\nwhere $f(w)$ equals 1 if $w$ belongs to the same community as $u$\nand $v$ or 0 otherwise and $\\Gamma(u)$ denotes the set of\nneighbors of $u$.\n\nParameters\n----------\nG : graph\n    A NetworkX undirected graph.\n\nebunch : iterable of node pairs, optional (default = None)\n    The score will be computed for each pair of nodes given in the\n    iterable. The pairs must be given as 2-tuples (u, v) where u\n    and v are nodes in the graph. If ebunch is None then all\n    nonexistent edges in the graph will be used.\n    Default value: None.\n\ncommunity : string, optional (default = 'community')\n    Nodes attribute name containing the community information.\n    G[u][community] identifies which community u belongs to. Each\n    node belongs to at most one community. Default value: 'community'.\n\nReturns\n-------\npiter : iterator\n    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\n    pair of nodes and p is their score.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is a `DiGraph`, a `Multigraph` or a `MultiDiGraph`.\n\nNetworkXAlgorithmError\n    If no community information is available for a node in `ebunch` or in `G` (if `ebunch` is `None`).\n\nNodeNotFound\n    If `ebunch` has a node that is not in `G`.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_edges_from([(0, 1), (0, 2), (1, 3), (2, 3)])\n>>> G.nodes[0][\"community\"] = 0\n>>> G.nodes[1][\"community\"] = 0\n>>> G.nodes[2][\"community\"] = 1\n>>> G.nodes[3][\"community\"] = 0\n>>> preds = nx.ra_index_soundarajan_hopcroft(G, [(0, 3)])\n>>> for u, v, p in preds:\n...     print(f\"({u}, {v}) -> {p:.8f}\")\n(0, 3) -> 0.50000000\n\nReferences\n----------\n.. [1] Sucheta Soundarajan and John Hopcroft.\n   Using community information to improve the precision of link\n   prediction methods.\n   In Proceedings of the 21st international conference companion on\n   World Wide Web (WWW '12 Companion). ACM, New York, NY, USA, 607-608.\n   http://doi.acm.org/10.1145/2187980.2188150"}, {"type": "function", "name": "networkx.radius", "documentation": "Returns the radius of the graph G.\n\nThe radius is the minimum eccentricity.\n\nParameters\n----------\nG : NetworkX graph\n   A graph\n\ne : eccentricity dictionary, optional\n  A precomputed dictionary of eccentricities.\n\nweight : string, function, or None\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\n    If this is None, every edge has weight/distance/cost 1.\n\n    Weights stored as floating point values can lead to small round-off\n    errors in distances. Use integer weights to avoid this.\n\n    Weights should be positive, since they are distances.\n\nReturns\n-------\nr : integer\n   Radius of graph\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (1, 4), (3, 4), (3, 5), (4, 5)])\n>>> nx.radius(G)\n2"}, {"type": "function", "name": "networkx.random_clustered_graph", "documentation": "Generate a random graph with the given joint independent edge degree and\ntriangle degree sequence.\n\nThis uses a configuration model-like approach to generate a random graph\n(with parallel edges and self-loops) by randomly assigning edges to match\nthe given joint degree sequence.\n\nThe joint degree sequence is a list of pairs of integers of the form\n$[(d_{1,i}, d_{1,t}), \\dotsc, (d_{n,i}, d_{n,t})]$. According to this list,\nvertex $u$ is a member of $d_{u,t}$ triangles and has $d_{u, i}$ other\nedges. The number $d_{u,t}$ is the *triangle degree* of $u$ and the number\n$d_{u,i}$ is the *independent edge degree*.\n\nParameters\n----------\njoint_degree_sequence : list of integer pairs\n    Each list entry corresponds to the independent edge degree and\n    triangle degree of a node.\ncreate_using : NetworkX graph constructor, optional (default MultiGraph)\n   Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : MultiGraph\n    A graph with the specified degree sequence. Nodes are labeled\n    starting at 0 with an index corresponding to the position in\n    deg_sequence.\n\nRaises\n------\nNetworkXError\n    If the independent edge degree sequence sum is not even\n    or the triangle degree sequence sum is not divisible by 3.\n\nNotes\n-----\nAs described by Miller [1]_ (see also Newman [2]_ for an equivalent\ndescription).\n\nA non-graphical degree sequence (not realizable by some simple\ngraph) is allowed since this function returns graphs with self\nloops and parallel edges.  An exception is raised if the\nindependent degree sequence does not have an even sum or the\ntriangle degree sequence sum is not divisible by 3.\n\nThis configuration model-like construction process can lead to\nduplicate edges and loops.  You can remove the self-loops and\nparallel edges (see below) which will likely result in a graph\nthat doesn't have the exact degree sequence specified.  This\n\"finite-size effect\" decreases as the size of the graph increases.\n\nReferences\n----------\n.. [1] Joel C. Miller. \"Percolation and epidemics in random clustered\n       networks\". In: Physical review. E, Statistical, nonlinear, and soft\n       matter physics 80 (2 Part 1 August 2009).\n.. [2] M. E. J. Newman. \"Random Graphs with Clustering\".\n       In: Physical Review Letters 103 (5 July 2009)\n\nExamples\n--------\n>>> deg = [(1, 0), (1, 0), (1, 0), (2, 0), (1, 0), (2, 1), (0, 1), (0, 1)]\n>>> G = nx.random_clustered_graph(deg)\n\nTo remove parallel edges:\n\n>>> G = nx.Graph(G)\n\nTo remove self loops:\n\n>>> G.remove_edges_from(nx.selfloop_edges(G))"}, {"type": "function", "name": "networkx.random_cograph", "documentation": "Returns a random cograph with $2 ^ n$ nodes.\n\nA cograph is a graph containing no path on four vertices.\nCographs or $P_4$-free graphs can be obtained from a single vertex\nby disjoint union and complementation operations.\n\nThis generator starts off from a single vertex and performs disjoint\nunion and full join operations on itself.\nThe decision on which operation will take place is random.\n\nParameters\n----------\nn : int\n    The order of the cograph.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : A random graph containing no path on four vertices.\n\nSee Also\n--------\nfull_join\nunion\n\nReferences\n----------\n.. [1] D.G. Corneil, H. Lerchs, L.Stewart Burlingham,\n   \"Complement reducible graphs\",\n   Discrete Applied Mathematics, Volume 3, Issue 3, 1981, Pages 163-174,\n   ISSN 0166-218X."}, {"type": "function", "name": "networkx.random_degree_sequence_graph", "documentation": "Returns a simple random graph with the given degree sequence.\n\nIf the maximum degree $d_m$ in the sequence is $O(m^{1/4})$ then the\nalgorithm produces almost uniform random graphs in $O(m d_m)$ time\nwhere $m$ is the number of edges.\n\nParameters\n----------\nsequence :  list of integers\n    Sequence of degrees\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ntries : int, optional\n    Maximum number of tries to create a graph\n\nReturns\n-------\nG : Graph\n    A graph with the specified degree sequence.\n    Nodes are labeled starting at 0 with an index\n    corresponding to the position in the sequence.\n\nRaises\n------\nNetworkXUnfeasible\n    If the degree sequence is not graphical.\nNetworkXError\n    If a graph is not produced in specified number of tries\n\nSee Also\n--------\nis_graphical, configuration_model\n\nNotes\n-----\nThe generator algorithm [1]_ is not guaranteed to produce a graph.\n\nReferences\n----------\n.. [1] Moshen Bayati, Jeong Han Kim, and Amin Saberi,\n   A sequential algorithm for generating random graphs.\n   Algorithmica, Volume 58, Number 4, 860-910,\n   DOI: 10.1007/s00453-009-9340-1\n\nExamples\n--------\n>>> sequence = [1, 2, 2, 3]\n>>> G = nx.random_degree_sequence_graph(sequence, seed=42)\n>>> sorted(d for n, d in G.degree())\n[1, 2, 2, 3]"}, {"type": "function", "name": "networkx.random_geometric_graph", "documentation": "Returns a random geometric graph in the unit cube of dimensions `dim`.\n\nThe random geometric graph model places `n` nodes uniformly at\nrandom in the unit cube. Two nodes are joined by an edge if the\ndistance between the nodes is at most `radius`.\n\nEdges are determined using a KDTree when SciPy is available.\nThis reduces the time complexity from $O(n^2)$ to $O(n)$.\n\nParameters\n----------\nn : int or iterable\n    Number of nodes or iterable of nodes\nradius: float\n    Distance threshold value\ndim : int, optional\n    Dimension of graph\npos : dict, optional\n    A dictionary keyed by node with node positions as values.\np : float, optional\n    Which Minkowski distance metric to use.  `p` has to meet the condition\n    ``1 <= p <= infinity``.\n\n    If this argument is not specified, the :math:`L^2` metric\n    (the Euclidean distance metric), p = 2 is used.\n    This should not be confused with the `p` of an Erd\u0151s-R\u00e9nyi random\n    graph, which represents probability.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\npos_name : string, default=\"pos\"\n    The name of the node attribute which represents the position\n    in 2D coordinates of the node in the returned graph.\n\nReturns\n-------\nGraph\n    A random geometric graph, undirected and without self-loops.\n    Each node has a node attribute ``'pos'`` that stores the\n    position of that node in Euclidean space as provided by the\n    ``pos`` keyword argument or, if ``pos`` was not provided, as\n    generated by this function.\n\nExamples\n--------\nCreate a random geometric graph on twenty nodes where nodes are joined by\nan edge if their distance is at most 0.1::\n\n>>> G = nx.random_geometric_graph(20, 0.1)\n\nNotes\n-----\nThis uses a *k*-d tree to build the graph.\n\nThe `pos` keyword argument can be used to specify node positions so you\ncan create an arbitrary distribution and domain for positions.\n\nFor example, to use a 2D Gaussian distribution of node positions with mean\n(0, 0) and standard deviation 2::\n\n>>> import random\n>>> n = 20\n>>> pos = {i: (random.gauss(0, 2), random.gauss(0, 2)) for i in range(n)}\n>>> G = nx.random_geometric_graph(n, 0.2, pos=pos)\n\nReferences\n----------\n.. [1] Penrose, Mathew, *Random Geometric Graphs*,\n       Oxford Studies in Probability, 5, 2003."}, {"type": "function", "name": "networkx.random_internet_as_graph", "documentation": "Generates a random undirected graph resembling the Internet AS network\n\nParameters\n----------\nn: integer in [1000, 10000]\n    Number of graph nodes\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG: Networkx Graph object\n    A randomly generated undirected graph\n\nNotes\n-----\nThis algorithm returns an undirected graph resembling the Internet\nAutonomous System (AS) network, it uses the approach by Elmokashfi et al.\n[1]_ and it grants the properties described in the related paper [1]_.\n\nEach node models an autonomous system, with an attribute 'type' specifying\nits kind; tier-1 (T), mid-level (M), customer (C) or content-provider (CP).\nEach edge models an ADV communication link (hence, bidirectional) with\nattributes:\n\n  - type: transit|peer, the kind of commercial agreement between nodes;\n  - customer: <node id>, the identifier of the node acting as customer\n    ('none' if type is peer).\n\nReferences\n----------\n.. [1] A. Elmokashfi, A. Kvalbein and C. Dovrolis, \"On the Scalability of\n   BGP: The Role of Topology Growth,\" in IEEE Journal on Selected Areas\n   in Communications, vol. 28, no. 8, pp. 1250-1261, October 2010."}, {"type": "function", "name": "networkx.random_k_out_graph", "documentation": "Returns a random `k`-out graph with preferential attachment.\n\nA random `k`-out graph with preferential attachment is a\nmultidigraph generated by the following algorithm.\n\n1. Begin with an empty digraph, and initially set each node to have\n   weight `alpha`.\n2. Choose a node `u` with out-degree less than `k` uniformly at\n   random.\n3. Choose a node `v` from with probability proportional to its\n   weight.\n4. Add a directed edge from `u` to `v`, and increase the weight\n   of `v` by one.\n5. If each node has out-degree `k`, halt, otherwise repeat from\n   step 2.\n\nFor more information on this model of random graph, see [1].\n\nParameters\n----------\nn : int\n    The number of nodes in the returned graph.\n\nk : int\n    The out-degree of each node in the returned graph.\n\nalpha : float\n    A positive :class:`float` representing the initial weight of\n    each vertex. A higher number means that in step 3 above, nodes\n    will be chosen more like a true uniformly random sample, and a\n    lower number means that nodes are more likely to be chosen as\n    their in-degree increases. If this parameter is not positive, a\n    :exc:`ValueError` is raised.\n\nself_loops : bool\n    If True, self-loops are allowed when generating the graph.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n:class:`~networkx.classes.MultiDiGraph`\n    A `k`-out-regular multidigraph generated according to the above\n    algorithm.\n\nRaises\n------\nValueError\n    If `alpha` is not positive.\n\nNotes\n-----\nThe returned multidigraph may not be strongly connected, or even\nweakly connected.\n\nReferences\n----------\n[1]: Peterson, Nicholas R., and Boris Pittel.\n     \"Distance between two random `k`-out digraphs, with and without\n     preferential attachment.\"\n     arXiv preprint arXiv:1311.5961 (2013).\n     <https://arxiv.org/abs/1311.5961>"}, {"type": "function", "name": "networkx.random_kernel_graph", "documentation": "Returns an random graph based on the specified kernel.\n\nThe algorithm chooses each of the $[n(n-1)]/2$ possible edges with\nprobability specified by a kernel $\\kappa(x,y)$ [1]_.  The kernel\n$\\kappa(x,y)$ must be a symmetric (in $x,y$), non-negative,\nbounded function.\n\nParameters\n----------\nn : int\n    The number of nodes\nkernel_integral : function\n    Function that returns the definite integral of the kernel $\\kappa(x,y)$,\n    $F(y,a,b) := \\int_a^b \\kappa(x,y)dx$\nkernel_root: function (optional)\n    Function that returns the root $b$ of the equation $F(y,a,b) = r$.\n    If None, the root is found using :func:`scipy.optimize.brentq`\n    (this requires SciPy).\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nNotes\n-----\nThe kernel is specified through its definite integral which must be\nprovided as one of the arguments. If the integral and root of the\nkernel integral can be found in $O(1)$ time then this algorithm runs in\ntime $O(n+m)$ where m is the expected number of edges [2]_.\n\nThe nodes are set to integers from $0$ to $n-1$.\n\nExamples\n--------\nGenerate an Erd\u0151s\u2013R\u00e9nyi random graph $G(n,c/n)$, with kernel\n$\\kappa(x,y)=c$ where $c$ is the mean expected degree.\n\n>>> def integral(u, w, z):\n...     return c * (z - w)\n>>> def root(u, w, r):\n...     return r / c + w\n>>> c = 1\n>>> graph = nx.random_kernel_graph(1000, integral, root)\n\nSee Also\n--------\ngnp_random_graph\nexpected_degree_graph\n\nReferences\n----------\n.. [1] Bollob\u00e1s, B\u00e9la,  Janson, S. and Riordan, O.\n   \"The phase transition in inhomogeneous random graphs\",\n   *Random Structures Algorithms*, 31, 3--122, 2007.\n\n.. [2] Hagberg A, Lemons N (2015),\n   \"Fast Generation of Sparse Random Kernel Graphs\".\n   PLoS ONE 10(9): e0135177, 2015. doi:10.1371/journal.pone.0135177"}, {"type": "function", "name": "networkx.random_labeled_rooted_forest", "documentation": "Returns a labeled rooted forest with `n` nodes.\n\nThe returned forest is chosen uniformly at random using a\ngeneralization of Pr\u00fcfer sequences [1]_ in the form described in [2]_.\n\nParameters\n----------\nn : int\n    The number of nodes.\nseed : random_state\n   See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n:class:`networkx.Graph`\n    A `networkx.Graph` with integer nodes 0 <= node <= `n` - 1.\n    The \"roots\" graph attribute is a set of integers containing the roots.\n\nReferences\n----------\n.. [1] Knuth, Donald E. \"Another Enumeration of Trees.\"\n    Canadian Journal of Mathematics, 20 (1968): 1077-1086.\n    https://doi.org/10.4153/CJM-1968-104-8\n.. [2] Rubey, Martin. \"Counting Spanning Trees\". Diplomarbeit\n    zur Erlangung des akademischen Grades Magister der\n    Naturwissenschaften an der Formal- und Naturwissenschaftlichen\n    Fakult\u00e4t der Universit\u00e4t Wien. Wien, May 2000."}, {"type": "function", "name": "networkx.random_labeled_rooted_tree", "documentation": "Returns a labeled rooted tree with `n` nodes.\n\nThe returned tree is chosen uniformly at random from all labeled rooted trees.\n\nParameters\n----------\nn : int\n    The number of nodes\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n:class:`networkx.Graph`\n    A `networkx.Graph` with integer nodes 0 <= node <= `n` - 1.\n    The root of the tree is selected uniformly from the nodes.\n    The \"root\" graph attribute identifies the root of the tree.\n\nNotes\n-----\nThis function returns the result of :func:`random_labeled_tree`\nwith a randomly selected root.\n\nRaises\n------\nNetworkXPointlessConcept\n    If `n` is zero (because the null graph is not a tree)."}, {"type": "function", "name": "networkx.random_labeled_tree", "documentation": "Returns a labeled tree on `n` nodes chosen uniformly at random.\n\nGenerating uniformly distributed random Pr\u00fcfer sequences and\nconverting them into the corresponding trees is a straightforward\nmethod of generating uniformly distributed random labeled trees.\nThis function implements this method.\n\nParameters\n----------\nn : int\n    The number of nodes, greater than zero.\nseed : random_state\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`\n\nReturns\n-------\n :class:`networkx.Graph`\n    A `networkx.Graph` with nodes in the set {0, \u2026, *n* - 1}.\n\nRaises\n------\nNetworkXPointlessConcept\n    If `n` is zero (because the null graph is not a tree)."}, {"type": "function", "name": "networkx.random_layout", "documentation": "Position nodes uniformly at random in the unit square.\n\nFor every node, a position is generated by choosing each of dim\ncoordinates uniformly at random on the interval [0.0, 1.0).\n\nNumPy (http://scipy.org) is required for this function.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\ndim : int\n    Dimension of layout.\n\nseed : int, RandomState instance or None  optional (default=None)\n    Set the random state for deterministic node layouts.\n    If int, `seed` is the seed used by the random number generator,\n    if numpy.random.RandomState instance, `seed` is the random\n    number generator,\n    if None, the random number generator is the RandomState instance used\n    by numpy.random.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nExamples\n--------\n>>> G = nx.lollipop_graph(4, 3)\n>>> pos = nx.random_layout(G)"}, {"type": "function", "name": "networkx.random_lobster", "documentation": "Returns a random lobster graph.\n\nA lobster is a tree that reduces to a caterpillar when pruning all\nleaf nodes. A caterpillar is a tree that reduces to a path graph\nwhen pruning all leaf nodes; setting `p2` to zero produces a caterpillar.\n\nThis implementation iterates on the probabilities `p1` and `p2` to add\nedges at levels 1 and 2, respectively. Graphs are therefore constructed\niteratively with uniform randomness at each level rather than being selected\nuniformly at random from the set of all possible lobsters.\n\nParameters\n----------\nn : int\n    The expected number of nodes in the backbone\np1 : float\n    Probability of adding an edge to the backbone\np2 : float\n    Probability of adding an edge one level beyond backbone\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nRaises\n------\nNetworkXError\n    If `p1` or `p2` parameters are >= 1 because the while loops would never finish."}, {"type": "function", "name": "networkx.random_partition_graph", "documentation": "Returns the random partition graph with a partition of sizes.\n\nA partition graph is a graph of communities with sizes defined by\ns in sizes. Nodes in the same group are connected with probability\np_in and nodes of different groups are connected with probability\np_out.\n\nParameters\n----------\nsizes : list of ints\n  Sizes of groups\np_in : float\n  probability of edges with in groups\np_out : float\n  probability of edges between groups\ndirected : boolean optional, default=False\n  Whether to create a directed graph\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : NetworkX Graph or DiGraph\n  random partition graph of size sum(gs)\n\nRaises\n------\nNetworkXError\n  If p_in or p_out is not in [0,1]\n\nExamples\n--------\n>>> G = nx.random_partition_graph([10, 10, 10], 0.25, 0.01)\n>>> len(G)\n30\n>>> partition = G.graph[\"partition\"]\n>>> len(partition)\n3\n\nNotes\n-----\nThis is a generalization of the planted-l-partition described in\n[1]_.  It allows for the creation of groups of any size.\n\nThe partition is store as a graph attribute 'partition'.\n\nReferences\n----------\n.. [1] Santo Fortunato 'Community Detection in Graphs' Physical Reports\n   Volume 486, Issue 3-5 p. 75-174. https://arxiv.org/abs/0906.0612"}, {"type": "function", "name": "networkx.random_powerlaw_tree", "documentation": "Returns a tree with a power law degree distribution.\n\nParameters\n----------\nn : int\n    The number of nodes.\ngamma : float\n    Exponent of the power law.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ntries : int\n    Number of attempts to adjust the sequence to make it a tree.\n\nRaises\n------\nNetworkXError\n    If no valid sequence is found within the maximum number of\n    attempts.\n\nNotes\n-----\nA trial power law degree sequence is chosen and then elements are\nswapped with new elements from a powerlaw distribution until the\nsequence makes a tree (by checking, for example, that the number of\nedges is one smaller than the number of nodes)."}, {"type": "function", "name": "networkx.random_powerlaw_tree_sequence", "documentation": "Returns a degree sequence for a tree with a power law distribution.\n\nParameters\n----------\nn : int,\n    The number of nodes.\ngamma : float\n    Exponent of the power law.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ntries : int\n    Number of attempts to adjust the sequence to make it a tree.\n\nRaises\n------\nNetworkXError\n    If no valid sequence is found within the maximum number of\n    attempts.\n\nNotes\n-----\nA trial power law degree sequence is chosen and then elements are\nswapped with new elements from a power law distribution until\nthe sequence makes a tree (by checking, for example, that the number of\nedges is one smaller than the number of nodes)."}, {"type": "function", "name": "networkx.random_reference", "documentation": "Compute a random graph by swapping edges of a given graph.\n\nParameters\n----------\nG : graph\n    An undirected graph with 4 or more nodes.\n\nniter : integer (optional, default=1)\n    An edge is rewired approximately `niter` times.\n\nconnectivity : boolean (optional, default=True)\n    When True, ensure connectivity for the randomized graph.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : graph\n    The randomized graph.\n\nRaises\n------\nNetworkXError\n    If there are fewer than 4 nodes or 2 edges in `G`\n\nNotes\n-----\nThe implementation is adapted from the algorithm by Maslov and Sneppen\n(2002) [1]_.\n\nReferences\n----------\n.. [1] Maslov, Sergei, and Kim Sneppen.\n       \"Specificity and stability in topology of protein networks.\"\n       Science 296.5569 (2002): 910-913."}, {"type": "function", "name": "networkx.random_regular_expander_graph", "documentation": "Returns a random regular expander graph on $n$ nodes with degree $d$.\n\nAn expander graph is a sparse graph with strong connectivity properties. [1]_\n\nMore precisely the returned graph is a $(n, d, \\lambda)$-expander with\n$\\lambda = 2 \\sqrt{d - 1} + \\epsilon$, close to the Alon-Boppana bound. [2]_\n\nIn the case where $\\epsilon = 0$ it returns a Ramanujan graph.\nA Ramanujan graph has spectral gap almost as large as possible,\nwhich makes them excellent expanders. [3]_\n\nParameters\n----------\nn : int\n  The number of nodes.\nd : int\n  The degree of each node.\nepsilon : int, float, default=0\nmax_tries : int, (default: 100)\n  The number of allowed loops, also used in the maybe_regular_expander utility\nseed : (default: None)\n  Seed used to set random number generation state. See :ref`Randomness<randomness>`.\n\nRaises\n------\nNetworkXError\n    If max_tries is reached\n\nExamples\n--------\n>>> G = nx.random_regular_expander_graph(20, 4)\n>>> nx.is_regular_expander(G)\nTrue\n\nNotes\n-----\nThis loops over `maybe_regular_expander` and can be slow when\n$n$ is too big or $\\epsilon$ too small.\n\nSee Also\n--------\nmaybe_regular_expander\nis_regular_expander\n\nReferences\n----------\n.. [1] Expander graph, https://en.wikipedia.org/wiki/Expander_graph\n.. [2] Alon-Boppana bound, https://en.wikipedia.org/wiki/Alon%E2%80%93Boppana_bound\n.. [3] Ramanujan graphs, https://en.wikipedia.org/wiki/Ramanujan_graph"}, {"type": "function", "name": "networkx.random_regular_graph", "documentation": "Returns a random $d$-regular graph on $n$ nodes.\n\nA regular graph is a graph where each node has the same number of neighbors.\n\nThe resulting graph has no self-loops or parallel edges.\n\nParameters\n----------\nd : int\n  The degree of each node.\nn : integer\n  The number of nodes. The value of $n \\times d$ must be even.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nNotes\n-----\nThe nodes are numbered from $0$ to $n - 1$.\n\nKim and Vu's paper [2]_ shows that this algorithm samples in an\nasymptotically uniform way from the space of random graphs when\n$d = O(n^{1 / 3 - \\epsilon})$.\n\nRaises\n------\n\nNetworkXError\n    If $n \\times d$ is odd or $d$ is greater than or equal to $n$.\n\nReferences\n----------\n.. [1] A. Steger and N. Wormald,\n   Generating random regular graphs quickly,\n   Probability and Computing 8 (1999), 377-396, 1999.\n   https://doi.org/10.1017/S0963548399003867\n\n.. [2] Jeong Han Kim and Van H. Vu,\n   Generating random regular graphs,\n   Proceedings of the thirty-fifth ACM symposium on Theory of computing,\n   San Diego, CA, USA, pp 213--222, 2003.\n   http://portal.acm.org/citation.cfm?id=780542.780576"}, {"type": "function", "name": "networkx.random_shell_graph", "documentation": "Returns a random shell graph for the constructor given.\n\nParameters\n----------\nconstructor : list of three-tuples\n    Represents the parameters for a shell, starting at the center\n    shell.  Each element of the list must be of the form `(n, m,\n    d)`, where `n` is the number of nodes in the shell, `m` is\n    the number of edges in the shell, and `d` is the ratio of\n    inter-shell (next) edges to intra-shell edges. If `d` is zero,\n    there will be no intra-shell edges, and if `d` is one there\n    will be all possible intra-shell edges.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nExamples\n--------\n>>> constructor = [(10, 20, 0.8), (20, 40, 0.8)]\n>>> G = nx.random_shell_graph(constructor)"}, {"type": "function", "name": "networkx.random_spanning_tree", "documentation": "Sample a random spanning tree using the edges weights of `G`.\n\nThis function supports two different methods for determining the\nprobability of the graph. If ``multiplicative=True``, the probability\nis based on the product of edge weights, and if ``multiplicative=False``\nit is based on the sum of the edge weight. However, since it is\neasier to determine the total weight of all spanning trees for the\nmultiplicative version, that is significantly faster and should be used if\npossible. Additionally, setting `weight` to `None` will cause a spanning tree\nto be selected with uniform probability.\n\nThe function uses algorithm A8 in [1]_ .\n\nParameters\n----------\nG : nx.Graph\n    An undirected version of the original graph.\n\nweight : string\n    The edge key for the edge attribute holding edge weight.\n\nmultiplicative : bool, default=True\n    If `True`, the probability of each tree is the product of its edge weight\n    over the sum of the product of all the spanning trees in the graph. If\n    `False`, the probability is the sum of its edge weight over the sum of\n    the sum of weights for all spanning trees in the graph.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nnx.Graph\n    A spanning tree using the distribution defined by the weight of the tree.\n\nReferences\n----------\n.. [1] V. Kulkarni, Generating random combinatorial objects, Journal of\n   Algorithms, 11 (1990), pp. 185\u2013207"}, {"type": "function", "name": "networkx.random_tree", "documentation": "Returns a uniformly random tree on `n` nodes.\n\n.. deprecated:: 3.2\n\n   ``random_tree`` is deprecated and will be removed in NX v3.4\n   Use ``random_labeled_tree`` instead.\n\nParameters\n----------\nn : int\n    A positive integer representing the number of nodes in the tree.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkX graph\n    A tree, given as an undirected graph, whose nodes are numbers in\n    the set {0, \u2026, *n* - 1}.\n\nRaises\n------\nNetworkXPointlessConcept\n    If `n` is zero (because the null graph is not a tree).\n\nNotes\n-----\nThe current implementation of this function generates a uniformly\nrandom Pr\u00fcfer sequence then converts that to a tree via the\n:func:`~networkx.from_prufer_sequence` function. Since there is a\nbijection between Pr\u00fcfer sequences of length *n* - 2 and trees on\n*n* nodes, the tree is chosen uniformly at random from the set of\nall trees on *n* nodes.\n\nExamples\n--------\n>>> tree = nx.random_tree(n=10, seed=0)\n>>> nx.write_network_text(tree, sources=[0])\n\u2559\u2500\u2500 0\n    \u251c\u2500\u2500 3\n    \u2514\u2500\u2500 4\n        \u251c\u2500\u2500 6\n        \u2502   \u251c\u2500\u2500 1\n        \u2502   \u251c\u2500\u2500 2\n        \u2502   \u2514\u2500\u2500 7\n        \u2502       \u2514\u2500\u2500 8\n        \u2502           \u2514\u2500\u2500 5\n        \u2514\u2500\u2500 9\n\n>>> tree = nx.random_tree(n=10, seed=0, create_using=nx.DiGraph)\n>>> nx.write_network_text(tree)\n\u2559\u2500\u2500 0\n    \u251c\u2500\u257c 3\n    \u2514\u2500\u257c 4\n        \u251c\u2500\u257c 6\n        \u2502   \u251c\u2500\u257c 1\n        \u2502   \u251c\u2500\u257c 2\n        \u2502   \u2514\u2500\u257c 7\n        \u2502       \u2514\u2500\u257c 8\n        \u2502           \u2514\u2500\u257c 5\n        \u2514\u2500\u257c 9"}, {"type": "function", "name": "networkx.random_triad", "documentation": "Returns a random triad from a directed graph.\n\n.. deprecated:: 3.3\n\n   random_triad is deprecated and will be removed in version 3.5.\n   Use random sampling directly instead::\n\n      G.subgraph(random.sample(list(G), 3))\n\nParameters\n----------\nG : digraph\n   A NetworkX DiGraph\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG2 : subgraph\n   A randomly selected triad (order-3 NetworkX DiGraph)\n\nRaises\n------\nNetworkXError\n    If the input Graph has less than 3 nodes.\n\nExamples\n--------\n>>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\n>>> triad = nx.random_triad(G, seed=1)\n>>> triad.edges\nOutEdgeView([(1, 2)])"}, {"type": "function", "name": "networkx.random_unlabeled_rooted_forest", "documentation": "Returns a forest or list of forests selected at random.\n\nReturns one or more (depending on `number_of_forests`)\nunlabeled rooted forests with `n` nodes, and with no more than\n`q` nodes per tree, drawn uniformly at random.\nThe \"roots\" graph attribute identifies the roots of the forest.\n\nParameters\n----------\nn : int\n    The number of nodes\nq : int or None (default)\n    The maximum number of nodes per tree.\nnumber_of_forests : int or None (default)\n    If not None, this number of forests is generated and returned.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n:class:`networkx.Graph` or list of :class:`networkx.Graph`\n    A single `networkx.Graph` (or a list thereof, if `number_of_forests`\n    is specified) with nodes in the set {0, \u2026, *n* - 1}.\n    The \"roots\" graph attribute is a set containing the roots\n    of the trees in the forest.\n\nNotes\n-----\nThis function implements the algorithm \"Forest\" of [1]_.\nThe algorithm needs to compute some counting functions\nthat are relatively expensive: in case several trees are needed,\nit is advisable to use the `number_of_forests` optional argument\nto reuse the counting functions.\n\nRaises\n------\nValueError\n    If `n` is non-zero but `q` is zero.\n\nReferences\n----------\n.. [1] Wilf, Herbert S. \"The uniform selection of free trees.\"\n    Journal of Algorithms 2.2 (1981): 204-207.\n    https://doi.org/10.1016/0196-6774(81)90021-3"}, {"type": "function", "name": "networkx.random_unlabeled_rooted_tree", "documentation": "Returns a number of unlabeled rooted trees uniformly at random\n\nReturns one or more (depending on `number_of_trees`)\nunlabeled rooted trees with `n` nodes drawn uniformly\nat random.\n\nParameters\n----------\nn : int\n    The number of nodes\nnumber_of_trees : int or None (default)\n    If not None, this number of trees is generated and returned.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n:class:`networkx.Graph` or list of :class:`networkx.Graph`\n    A single `networkx.Graph` (or a list thereof, if `number_of_trees`\n    is specified) with nodes in the set {0, \u2026, *n* - 1}.\n    The \"root\" graph attribute identifies the root of the tree.\n\nNotes\n-----\nThe trees are generated using the \"RANRUT\" algorithm from [1]_.\nThe algorithm needs to compute some counting functions\nthat are relatively expensive: in case several trees are needed,\nit is advisable to use the `number_of_trees` optional argument\nto reuse the counting functions.\n\nRaises\n------\nNetworkXPointlessConcept\n    If `n` is zero (because the null graph is not a tree).\n\nReferences\n----------\n.. [1] Nijenhuis, Albert, and Wilf, Herbert S.\n    \"Combinatorial algorithms: for computers and calculators.\"\n    Academic Press, 1978.\n    https://doi.org/10.1016/C2013-0-11243-3"}, {"type": "function", "name": "networkx.random_unlabeled_tree", "documentation": "Returns a tree or list of trees chosen randomly.\n\nReturns one or more (depending on `number_of_trees`)\nunlabeled trees with `n` nodes drawn uniformly at random.\n\nParameters\n----------\nn : int\n    The number of nodes\nnumber_of_trees : int or None (default)\n    If not None, this number of trees is generated and returned.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n:class:`networkx.Graph` or list of :class:`networkx.Graph`\n    A single `networkx.Graph` (or a list thereof, if\n    `number_of_trees` is specified) with nodes in the set {0, \u2026, *n* - 1}.\n\nRaises\n------\nNetworkXPointlessConcept\n    If `n` is zero (because the null graph is not a tree).\n\nNotes\n-----\nThis function generates an unlabeled tree uniformly at random using\nWilf's algorithm \"Free\" of [1]_. The algorithm needs to\ncompute some counting functions that are relatively expensive:\nin case several trees are needed, it is advisable to use the\n`number_of_trees` optional argument to reuse the counting\nfunctions.\n\nReferences\n----------\n.. [1] Wilf, Herbert S. \"The uniform selection of free trees.\"\n    Journal of Algorithms 2.2 (1981): 204-207.\n    https://doi.org/10.1016/0196-6774(81)90021-3"}, {"type": "function", "name": "networkx.read_adjlist", "documentation": "Read graph in adjacency list format from path.\n\nParameters\n----------\npath : string or file\n   Filename or file handle to read.\n   Filenames ending in .gz or .bz2 will be uncompressed.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nnodetype : Python type, optional\n   Convert nodes to this type.\n\ncomments : string, optional\n   Marker for comment lines\n\ndelimiter : string, optional\n   Separator for node labels.  The default is whitespace.\n\nReturns\n-------\nG: NetworkX graph\n    The graph corresponding to the lines in adjacency list format.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_adjlist(G, \"test.adjlist\")\n>>> G = nx.read_adjlist(\"test.adjlist\")\n\nThe path can be a filehandle or a string with the name of the file. If a\nfilehandle is provided, it has to be opened in 'rb' mode.\n\n>>> fh = open(\"test.adjlist\", \"rb\")\n>>> G = nx.read_adjlist(fh)\n\nFilenames ending in .gz or .bz2 will be compressed.\n\n>>> nx.write_adjlist(G, \"test.adjlist.gz\")\n>>> G = nx.read_adjlist(\"test.adjlist.gz\")\n\nThe optional nodetype is a function to convert node strings to nodetype.\n\nFor example\n\n>>> G = nx.read_adjlist(\"test.adjlist\", nodetype=int)\n\nwill attempt to convert all nodes to integer type.\n\nSince nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.)\n\nThe optional create_using parameter indicates the type of NetworkX graph\ncreated.  The default is `nx.Graph`, an undirected graph.\nTo read the data as a directed graph use\n\n>>> G = nx.read_adjlist(\"test.adjlist\", create_using=nx.DiGraph)\n\nNotes\n-----\nThis format does not store graph or node data.\n\nSee Also\n--------\nwrite_adjlist"}, {"type": "function", "name": "networkx.read_edgelist", "documentation": "Read a graph from a list of edges.\n\nParameters\n----------\npath : file or string\n   File or filename to read. If a file is provided, it must be\n   opened in 'rb' mode.\n   Filenames ending in .gz or .bz2 will be uncompressed.\ncomments : string, optional\n   The character used to indicate the start of a comment. To specify that\n   no character should be treated as a comment, use ``comments=None``.\ndelimiter : string, optional\n   The string used to separate values.  The default is whitespace.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\nnodetype : int, float, str, Python type, optional\n   Convert node data from strings to specified type\ndata : bool or list of (label,type) tuples\n   Tuples specifying dictionary key names and types for edge data\nedgetype : int, float, str, Python type, optional OBSOLETE\n   Convert edge data from strings to specified type and use as 'weight'\nencoding: string, optional\n   Specify which encoding to use when reading file.\n\nReturns\n-------\nG : graph\n   A networkx Graph or other type specified with create_using\n\nExamples\n--------\n>>> nx.write_edgelist(nx.path_graph(4), \"test.edgelist\")\n>>> G = nx.read_edgelist(\"test.edgelist\")\n\n>>> fh = open(\"test.edgelist\", \"rb\")\n>>> G = nx.read_edgelist(fh)\n>>> fh.close()\n\n>>> G = nx.read_edgelist(\"test.edgelist\", nodetype=int)\n>>> G = nx.read_edgelist(\"test.edgelist\", create_using=nx.DiGraph)\n\nEdgelist with data in a list:\n\n>>> textline = \"1 2 3\"\n>>> fh = open(\"test.edgelist\", \"w\")\n>>> d = fh.write(textline)\n>>> fh.close()\n>>> G = nx.read_edgelist(\"test.edgelist\", nodetype=int, data=((\"weight\", float),))\n>>> list(G)\n[1, 2]\n>>> list(G.edges(data=True))\n[(1, 2, {'weight': 3.0})]\n\nSee parse_edgelist() for more examples of formatting.\n\nSee Also\n--------\nparse_edgelist\nwrite_edgelist\n\nNotes\n-----\nSince nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.)"}, {"type": "function", "name": "networkx.read_gexf", "documentation": "Read graph in GEXF format from path.\n\n\"GEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics\" [1]_.\n\nParameters\n----------\npath : file or string\n   File or file name to read.\n   File names ending in .gz or .bz2 will be decompressed.\nnode_type: Python type (default: None)\n   Convert node ids to this type if not None.\nrelabel : bool (default: False)\n   If True relabel the nodes to use the GEXF node \"label\" attribute\n   instead of the node \"id\" attribute as the NetworkX node label.\nversion : string (default: 1.2draft)\nVersion of GEFX File Format (see http://gexf.net/schema.html)\n   Supported values: \"1.1draft\", \"1.2draft\"\n\nReturns\n-------\ngraph: NetworkX graph\n    If no parallel edges are found a Graph or DiGraph is returned.\n    Otherwise a MultiGraph or MultiDiGraph is returned.\n\nNotes\n-----\nThis implementation does not support mixed graphs (directed and undirected\nedges together).\n\nReferences\n----------\n.. [1] GEXF File Format, http://gexf.net/"}, {"type": "function", "name": "networkx.read_gml", "documentation": "Read graph in GML format from `path`.\n\nParameters\n----------\npath : filename or filehandle\n    The filename or filehandle to read from.\n\nlabel : string, optional\n    If not None, the parsed nodes will be renamed according to node\n    attributes indicated by `label`. Default value: 'label'.\n\ndestringizer : callable, optional\n    A `destringizer` that recovers values stored as strings in GML. If it\n    cannot convert a string to a value, a `ValueError` is raised. Default\n    value : None.\n\nReturns\n-------\nG : NetworkX graph\n    The parsed graph.\n\nRaises\n------\nNetworkXError\n    If the input cannot be parsed.\n\nSee Also\n--------\nwrite_gml, parse_gml\nliteral_destringizer\n\nNotes\n-----\nGML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a `stringizer`/`destringizer`, the code is capable of\nwriting `int`/`float`/`str`/`dict`/`list` data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan `str` you need to explicitly supply a `stringizer`/`destringizer`.\n\nFor additional documentation on the GML file format, please see the\n`GML url <https://web.archive.org/web/20190207140002/http://www.fim.uni-passau.de/index.php?id=17297&L=1>`_.\n\nSee the module docstring :mod:`networkx.readwrite.gml` for more details.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_gml(G, \"test.gml\")\n\nGML values are interpreted as strings by default:\n\n>>> H = nx.read_gml(\"test.gml\")\n>>> H.nodes\nNodeView(('0', '1', '2', '3'))\n\nWhen a `destringizer` is provided, GML values are converted to the provided type.\nFor example, integer nodes can be recovered as shown below:\n\n>>> J = nx.read_gml(\"test.gml\", destringizer=int)\n>>> J.nodes\nNodeView((0, 1, 2, 3))"}, {"type": "function", "name": "networkx.read_graph6", "documentation": "Read simple undirected graphs in graph6 format from path.\n\nParameters\n----------\npath : file or string\n   File or filename to write.\n\nReturns\n-------\nG : Graph or list of Graphs\n   If the file contains multiple lines then a list of graphs is returned\n\nRaises\n------\nNetworkXError\n    If the string is unable to be parsed in graph6 format\n\nExamples\n--------\nYou can read a graph6 file by giving the path to the file::\n\n    >>> import tempfile\n    >>> with tempfile.NamedTemporaryFile(delete=False) as f:\n    ...     _ = f.write(b\">>graph6<<A_\\n\")\n    ...     _ = f.seek(0)\n    ...     G = nx.read_graph6(f.name)\n    >>> list(G.edges())\n    [(0, 1)]\n\nYou can also read a graph6 file by giving an open file-like object::\n\n    >>> import tempfile\n    >>> with tempfile.NamedTemporaryFile() as f:\n    ...     _ = f.write(b\">>graph6<<A_\\n\")\n    ...     _ = f.seek(0)\n    ...     G = nx.read_graph6(f)\n    >>> list(G.edges())\n    [(0, 1)]\n\nSee Also\n--------\nfrom_graph6_bytes, write_graph6\n\nReferences\n----------\n.. [1] Graph6 specification\n       <http://users.cecs.anu.edu.au/~bdm/data/formats.html>"}, {"type": "function", "name": "networkx.read_graphml", "documentation": "Read graph in GraphML format from path.\n\nParameters\n----------\npath : file or string\n   File or filename to write.\n   Filenames ending in .gz or .bz2 will be compressed.\n\nnode_type: Python type (default: str)\n   Convert node ids to this type\n\nedge_key_type: Python type (default: int)\n   Convert graphml edge ids to this type. Multigraphs use id as edge key.\n   Non-multigraphs add to edge attribute dict with name \"id\".\n\nforce_multigraph : bool (default: False)\n   If True, return a multigraph with edge keys. If False (the default)\n   return a multigraph when multiedges are in the graph.\n\nReturns\n-------\ngraph: NetworkX graph\n    If parallel edges are present or `force_multigraph=True` then\n    a MultiGraph or MultiDiGraph is returned. Otherwise a Graph/DiGraph.\n    The returned graph is directed if the file indicates it should be.\n\nNotes\n-----\nDefault node and edge attributes are not propagated to each node and edge.\nThey can be obtained from `G.graph` and applied to node and edge attributes\nif desired using something like this:\n\n>>> default_color = G.graph[\"node_default\"][\"color\"]  # doctest: +SKIP\n>>> for node, data in G.nodes(data=True):  # doctest: +SKIP\n...     if \"color\" not in data:\n...         data[\"color\"] = default_color\n>>> default_color = G.graph[\"edge_default\"][\"color\"]  # doctest: +SKIP\n>>> for u, v, data in G.edges(data=True):  # doctest: +SKIP\n...     if \"color\" not in data:\n...         data[\"color\"] = default_color\n\nThis implementation does not support mixed graphs (directed and unidirected\nedges together), hypergraphs, nested graphs, or ports.\n\nFor multigraphs the GraphML edge \"id\" will be used as the edge\nkey.  If not specified then they \"key\" attribute will be used.  If\nthere is no \"key\" attribute a default NetworkX multigraph edge key\nwill be provided.\n\nFiles with the yEd \"yfiles\" extension can be read. The type of the node's\nshape is preserved in the `shape_type` node attribute.\n\nyEd compressed files (\"file.graphmlz\" extension) can be read by renaming\nthe file to \"file.graphml.gz\"."}, {"type": "function", "name": "networkx.read_leda", "documentation": "Read graph in LEDA format from path.\n\nParameters\n----------\npath : file or string\n   File or filename to read.  Filenames ending in .gz or .bz2  will be\n   uncompressed.\n\nReturns\n-------\nG : NetworkX graph\n\nExamples\n--------\nG=nx.read_leda('file.leda')\n\nReferences\n----------\n.. [1] http://www.algorithmic-solutions.info/leda_guide/graphs/leda_native_graph_fileformat.html"}, {"type": "function", "name": "networkx.read_multiline_adjlist", "documentation": "Read graph in multi-line adjacency list format from path.\n\nParameters\n----------\npath : string or file\n   Filename or file handle to read.\n   Filenames ending in .gz or .bz2 will be uncompressed.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nnodetype : Python type, optional\n   Convert nodes to this type.\n\nedgetype : Python type, optional\n   Convert edge data to this type.\n\ncomments : string, optional\n   Marker for comment lines\n\ndelimiter : string, optional\n   Separator for node labels.  The default is whitespace.\n\nReturns\n-------\nG: NetworkX graph\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_multiline_adjlist(G, \"test.adjlist\")\n>>> G = nx.read_multiline_adjlist(\"test.adjlist\")\n\nThe path can be a file or a string with the name of the file. If a\nfile s provided, it has to be opened in 'rb' mode.\n\n>>> fh = open(\"test.adjlist\", \"rb\")\n>>> G = nx.read_multiline_adjlist(fh)\n\nFilenames ending in .gz or .bz2 will be compressed.\n\n>>> nx.write_multiline_adjlist(G, \"test.adjlist.gz\")\n>>> G = nx.read_multiline_adjlist(\"test.adjlist.gz\")\n\nThe optional nodetype is a function to convert node strings to nodetype.\n\nFor example\n\n>>> G = nx.read_multiline_adjlist(\"test.adjlist\", nodetype=int)\n\nwill attempt to convert all nodes to integer type.\n\nThe optional edgetype is a function to convert edge data strings to\nedgetype.\n\n>>> G = nx.read_multiline_adjlist(\"test.adjlist\")\n\nThe optional create_using parameter is a NetworkX graph container.\nThe default is Graph(), an undirected graph.  To read the data as\na directed graph use\n\n>>> G = nx.read_multiline_adjlist(\"test.adjlist\", create_using=nx.DiGraph)\n\nNotes\n-----\nThis format does not store graph, node, or edge data.\n\nSee Also\n--------\nwrite_multiline_adjlist"}, {"type": "function", "name": "networkx.read_pajek", "documentation": "Read graph in Pajek format from path.\n\nParameters\n----------\npath : file or string\n   File or filename to write.\n   Filenames ending in .gz or .bz2 will be uncompressed.\n\nReturns\n-------\nG : NetworkX MultiGraph or MultiDiGraph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_pajek(G, \"test.net\")\n>>> G = nx.read_pajek(\"test.net\")\n\nTo create a Graph instead of a MultiGraph use\n\n>>> G1 = nx.Graph(G)\n\nReferences\n----------\nSee http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm\nfor format information."}, {"type": "function", "name": "networkx.read_sparse6", "documentation": "Read an undirected graph in sparse6 format from path.\n\nParameters\n----------\npath : file or string\n   File or filename to write.\n\nReturns\n-------\nG : Graph/Multigraph or list of Graphs/MultiGraphs\n   If the file contains multiple lines then a list of graphs is returned\n\nRaises\n------\nNetworkXError\n    If the string is unable to be parsed in sparse6 format\n\nExamples\n--------\nYou can read a sparse6 file by giving the path to the file::\n\n    >>> import tempfile\n    >>> with tempfile.NamedTemporaryFile(delete=False) as f:\n    ...     _ = f.write(b\">>sparse6<<:An\\n\")\n    ...     _ = f.seek(0)\n    ...     G = nx.read_sparse6(f.name)\n    >>> list(G.edges())\n    [(0, 1)]\n\nYou can also read a sparse6 file by giving an open file-like object::\n\n    >>> import tempfile\n    >>> with tempfile.NamedTemporaryFile() as f:\n    ...     _ = f.write(b\">>sparse6<<:An\\n\")\n    ...     _ = f.seek(0)\n    ...     G = nx.read_sparse6(f)\n    >>> list(G.edges())\n    [(0, 1)]\n\nSee Also\n--------\nread_sparse6, from_sparse6_bytes\n\nReferences\n----------\n.. [1] Sparse6 specification\n       <https://users.cecs.anu.edu.au/~bdm/data/formats.html>"}, {"type": "function", "name": "networkx.read_weighted_edgelist", "documentation": "Read a graph as list of edges with numeric weights.\n\nParameters\n----------\npath : file or string\n   File or filename to read. If a file is provided, it must be\n   opened in 'rb' mode.\n   Filenames ending in .gz or .bz2 will be uncompressed.\ncomments : string, optional\n   The character used to indicate the start of a comment.\ndelimiter : string, optional\n   The string used to separate values.  The default is whitespace.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\nnodetype : int, float, str, Python type, optional\n   Convert node data from strings to specified type\nencoding: string, optional\n   Specify which encoding to use when reading file.\n\nReturns\n-------\nG : graph\n   A networkx Graph or other type specified with create_using\n\nNotes\n-----\nSince nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.)\n\nExample edgelist file format.\n\nWith numeric edge data::\n\n # read with\n # >>> G=nx.read_weighted_edgelist(fh)\n # source target data\n a b 1\n a c 3.14159\n d e 42\n\nSee Also\n--------\nwrite_weighted_edgelist"}, {"type": "function", "name": "networkx.reciprocity", "documentation": "Compute the reciprocity in a directed graph.\n\nThe reciprocity of a directed graph is defined as the ratio\nof the number of edges pointing in both directions to the total\nnumber of edges in the graph.\nFormally, $r = |{(u,v) \\in G|(v,u) \\in G}| / |{(u,v) \\in G}|$.\n\nThe reciprocity of a single node u is defined similarly,\nit is the ratio of the number of edges in both directions to\nthe total number of edges attached to node u.\n\nParameters\n----------\nG : graph\n   A networkx directed graph\nnodes : container of nodes, optional (default=whole graph)\n   Compute reciprocity for nodes in this container.\n\nReturns\n-------\nout : dictionary\n   Reciprocity keyed by node label.\n\nNotes\n-----\nThe reciprocity is not defined for isolated nodes.\nIn such cases this function will return None."}, {"type": "function", "name": "networkx.reconstruct_path", "documentation": "Reconstruct a path from source to target using the predecessors\ndict as returned by floyd_warshall_predecessor_and_distance\n\nParameters\n----------\nsource : node\n   Starting node for path\n\ntarget : node\n   Ending node for path\n\npredecessors: dictionary\n   Dictionary, keyed by source and target, of predecessors in the\n   shortest path, as returned by floyd_warshall_predecessor_and_distance\n\nReturns\n-------\npath : list\n   A list of nodes containing the shortest path from source to target\n\n   If source and target are the same, an empty list is returned\n\nNotes\n-----\nThis function is meant to give more applicability to the\nfloyd_warshall_predecessor_and_distance function\n\nSee Also\n--------\nfloyd_warshall_predecessor_and_distance"}, {"type": "function", "name": "networkx.recursive_simple_cycles", "documentation": "Find simple cycles (elementary circuits) of a directed graph.\n\nA `simple cycle`, or `elementary circuit`, is a closed path where\nno node appears twice. Two elementary circuits are distinct if they\nare not cyclic permutations of each other.\n\nThis version uses a recursive algorithm to build a list of cycles.\nYou should probably use the iterator version called simple_cycles().\nWarning: This recursive version uses lots of RAM!\nIt appears in NetworkX for pedagogical value.\n\nParameters\n----------\nG : NetworkX DiGraph\n   A directed graph\n\nReturns\n-------\nA list of cycles, where each cycle is represented by a list of nodes\nalong the cycle.\n\nExample:\n\n>>> edges = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 0), (2, 1), (2, 2)]\n>>> G = nx.DiGraph(edges)\n>>> nx.recursive_simple_cycles(G)\n[[0], [2], [0, 1, 2], [0, 2], [1, 2]]\n\nNotes\n-----\nThe implementation follows pp. 79-80 in [1]_.\n\nThe time complexity is $O((n+e)(c+1))$ for $n$ nodes, $e$ edges and $c$\nelementary circuits.\n\nReferences\n----------\n.. [1] Finding all the elementary circuits of a directed graph.\n   D. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.\n   https://doi.org/10.1137/0204007\n\nSee Also\n--------\nsimple_cycles, cycle_basis"}, {"type": "function", "name": "networkx.relabel_gexf_graph", "documentation": "Relabel graph using \"label\" node keyword for node label.\n\nParameters\n----------\nG : graph\n   A NetworkX graph read from GEXF data\n\nReturns\n-------\nH : graph\n  A NetworkX graph with relabeled nodes\n\nRaises\n------\nNetworkXError\n    If node labels are missing or not unique while relabel=True.\n\nNotes\n-----\nThis function relabels the nodes in a NetworkX graph with the\n\"label\" attribute.  It also handles relabeling the specific GEXF\nnode attributes \"parents\", and \"pid\"."}, {"type": "function", "name": "networkx.relabel_nodes", "documentation": "Relabel the nodes of the graph G according to a given mapping.\n\nThe original node ordering may not be preserved if `copy` is `False` and the\nmapping includes overlap between old and new labels.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nmapping : dictionary\n   A dictionary with the old labels as keys and new labels as values.\n   A partial mapping is allowed. Mapping 2 nodes to a single node is allowed.\n   Any non-node keys in the mapping are ignored.\n\ncopy : bool (optional, default=True)\n   If True return a copy, or if False relabel the nodes in place.\n\nExamples\n--------\nTo create a new graph with nodes relabeled according to a given\ndictionary:\n\n>>> G = nx.path_graph(3)\n>>> sorted(G)\n[0, 1, 2]\n>>> mapping = {0: \"a\", 1: \"b\", 2: \"c\"}\n>>> H = nx.relabel_nodes(G, mapping)\n>>> sorted(H)\n['a', 'b', 'c']\n\nNodes can be relabeled with any hashable object, including numbers\nand strings:\n\n>>> import string\n>>> G = nx.path_graph(26)  # nodes are integers 0 through 25\n>>> sorted(G)[:3]\n[0, 1, 2]\n>>> mapping = dict(zip(G, string.ascii_lowercase))\n>>> G = nx.relabel_nodes(G, mapping)  # nodes are characters a through z\n>>> sorted(G)[:3]\n['a', 'b', 'c']\n>>> mapping = dict(zip(G, range(1, 27)))\n>>> G = nx.relabel_nodes(G, mapping)  # nodes are integers 1 through 26\n>>> sorted(G)[:3]\n[1, 2, 3]\n\nTo perform a partial in-place relabeling, provide a dictionary\nmapping only a subset of the nodes, and set the `copy` keyword\nargument to False:\n\n>>> G = nx.path_graph(3)  # nodes 0-1-2\n>>> mapping = {0: \"a\", 1: \"b\"}  # 0->'a' and 1->'b'\n>>> G = nx.relabel_nodes(G, mapping, copy=False)\n>>> sorted(G, key=str)\n[2, 'a', 'b']\n\nA mapping can also be given as a function:\n\n>>> G = nx.path_graph(3)\n>>> H = nx.relabel_nodes(G, lambda x: x**2)\n>>> list(H)\n[0, 1, 4]\n\nIn a multigraph, relabeling two or more nodes to the same new node\nwill retain all edges, but may change the edge keys in the process:\n\n>>> G = nx.MultiGraph()\n>>> G.add_edge(0, 1, value=\"a\")  # returns the key for this edge\n0\n>>> G.add_edge(0, 2, value=\"b\")\n0\n>>> G.add_edge(0, 3, value=\"c\")\n0\n>>> mapping = {1: 4, 2: 4, 3: 4}\n>>> H = nx.relabel_nodes(G, mapping, copy=True)\n>>> print(H[0])\n{4: {0: {'value': 'a'}, 1: {'value': 'b'}, 2: {'value': 'c'}}}\n\nThis works for in-place relabeling too:\n\n>>> G = nx.relabel_nodes(G, mapping, copy=False)\n>>> print(G[0])\n{4: {0: {'value': 'a'}, 1: {'value': 'b'}, 2: {'value': 'c'}}}\n\nNotes\n-----\nOnly the nodes specified in the mapping will be relabeled.\nAny non-node keys in the mapping are ignored.\n\nThe keyword setting copy=False modifies the graph in place.\nRelabel_nodes avoids naming collisions by building a\ndirected graph from ``mapping`` which specifies the order of\nrelabelings. Naming collisions, such as a->b, b->c, are ordered\nsuch that \"b\" gets renamed to \"c\" before \"a\" gets renamed \"b\".\nIn cases of circular mappings (e.g. a->b, b->a), modifying the\ngraph is not possible in-place and an exception is raised.\nIn that case, use copy=True.\n\nIf a relabel operation on a multigraph would cause two or more\nedges to have the same source, target and key, the second edge must\nbe assigned a new key to retain all edges. The new key is set\nto the lowest non-negative integer not already used as a key\nfor edges between these two nodes. Note that this means non-numeric\nkeys may be replaced by numeric keys.\n\nSee Also\n--------\nconvert_node_labels_to_integers"}, {"type": "function", "name": "networkx.relaxed_caveman_graph", "documentation": "Returns a relaxed caveman graph.\n\nA relaxed caveman graph starts with `l` cliques of size `k`.  Edges are\nthen randomly rewired with probability `p` to link different cliques.\n\nParameters\n----------\nl : int\n  Number of groups\nk : int\n  Size of cliques\np : float\n  Probability of rewiring each edge.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : NetworkX Graph\n  Relaxed Caveman Graph\n\nRaises\n------\nNetworkXError\n If p is not in [0,1]\n\nExamples\n--------\n>>> G = nx.relaxed_caveman_graph(2, 3, 0.1, seed=42)\n\nReferences\n----------\n.. [1] Santo Fortunato, Community Detection in Graphs,\n   Physics Reports Volume 486, Issues 3-5, February 2010, Pages 75-174.\n   https://arxiv.org/abs/0906.0612"}, {"type": "function", "name": "networkx.rescale_layout", "documentation": "Returns scaled position array to (-scale, scale) in all axes.\n\nThe function acts on NumPy arrays which hold position information.\nEach position is one row of the array. The dimension of the space\nequals the number of columns. Each coordinate in one column.\n\nTo rescale, the mean (center) is subtracted from each axis separately.\nThen all values are scaled so that the largest magnitude value\nfrom all axes equals `scale` (thus, the aspect ratio is preserved).\nThe resulting NumPy Array is returned (order of rows unchanged).\n\nParameters\n----------\npos : numpy array\n    positions to be scaled. Each row is a position.\n\nscale : number (default: 1)\n    The size of the resulting extent in all directions.\n\nReturns\n-------\npos : numpy array\n    scaled positions. Each row is a position.\n\nSee Also\n--------\nrescale_layout_dict"}, {"type": "function", "name": "networkx.rescale_layout_dict", "documentation": "Return a dictionary of scaled positions keyed by node\n\nParameters\n----------\npos : A dictionary of positions keyed by node\n\nscale : number (default: 1)\n    The size of the resulting extent in all directions.\n\nReturns\n-------\npos : A dictionary of positions keyed by node\n\nExamples\n--------\n>>> import numpy as np\n>>> pos = {0: np.array((0, 0)), 1: np.array((1, 1)), 2: np.array((0.5, 0.5))}\n>>> nx.rescale_layout_dict(pos)\n{0: array([-1., -1.]), 1: array([1., 1.]), 2: array([0., 0.])}\n\n>>> pos = {0: np.array((0, 0)), 1: np.array((-1, 1)), 2: np.array((-0.5, 0.5))}\n>>> nx.rescale_layout_dict(pos, scale=2)\n{0: array([ 2., -2.]), 1: array([-2.,  2.]), 2: array([0., 0.])}\n\nSee Also\n--------\nrescale_layout"}, {"type": "function", "name": "networkx.resistance_distance", "documentation": "Returns the resistance distance between pairs of nodes in graph G.\n\nThe resistance distance between two nodes of a graph is akin to treating\nthe graph as a grid of resistors with a resistance equal to the provided\nweight [1]_, [2]_.\n\nIf weight is not provided, then a weight of 1 is used for all edges.\n\nIf two nodes are the same, the resistance distance is zero.\n\nParameters\n----------\nG : NetworkX graph\n   A graph\n\nnodeA : node or None, optional (default=None)\n  A node within graph G.\n  If None, compute resistance distance using all nodes as source nodes.\n\nnodeB : node or None, optional (default=None)\n  A node within graph G.\n  If None, compute resistance distance using all nodes as target nodes.\n\nweight : string or None, optional (default=None)\n   The edge data key used to compute the resistance distance.\n   If None, then each edge has weight 1.\n\ninvert_weight : boolean (default=True)\n    Proper calculation of resistance distance requires building the\n    Laplacian matrix with the reciprocal of the weight. Not required\n    if the weight is already inverted. Weight cannot be zero.\n\nReturns\n-------\nrd : dict or float\n   If `nodeA` and `nodeB` are given, resistance distance between `nodeA`\n   and `nodeB`. If `nodeA` or `nodeB` is unspecified (the default), a\n   dictionary of nodes with resistance distances as the value.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is a directed graph.\n\nNetworkXError\n    If `G` is not connected, or contains no nodes,\n    or `nodeA` is not in `G` or `nodeB` is not in `G`.\n\nExamples\n--------\n>>> G = nx.Graph([(1, 2), (1, 3), (1, 4), (3, 4), (3, 5), (4, 5)])\n>>> round(nx.resistance_distance(G, 1, 3), 10)\n0.625\n\nNotes\n-----\nThe implementation is based on Theorem A in [2]_. Self-loops are ignored.\nMulti-edges are contracted in one edge with weight equal to the harmonic sum of the weights.\n\nReferences\n----------\n.. [1] Wikipedia\n   \"Resistance distance.\"\n   https://en.wikipedia.org/wiki/Resistance_distance\n.. [2] D. J. Klein and M. Randic.\n    Resistance distance.\n    J. of Math. Chem. 12:81-95, 1993."}, {"type": "function", "name": "networkx.resource_allocation_index", "documentation": "Compute the resource allocation index of all node pairs in ebunch.\n\nResource allocation index of `u` and `v` is defined as\n\n.. math::\n\n    \\sum_{w \\in \\Gamma(u) \\cap \\Gamma(v)} \\frac{1}{|\\Gamma(w)|}\n\nwhere $\\Gamma(u)$ denotes the set of neighbors of $u$.\n\nParameters\n----------\nG : graph\n    A NetworkX undirected graph.\n\nebunch : iterable of node pairs, optional (default = None)\n    Resource allocation index will be computed for each pair of\n    nodes given in the iterable. The pairs must be given as\n    2-tuples (u, v) where u and v are nodes in the graph. If ebunch\n    is None then all nonexistent edges in the graph will be used.\n    Default value: None.\n\nReturns\n-------\npiter : iterator\n    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\n    pair of nodes and p is their resource allocation index.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is a `DiGraph`, a `Multigraph` or a `MultiDiGraph`.\n\nNodeNotFound\n    If `ebunch` has a node that is not in `G`.\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> preds = nx.resource_allocation_index(G, [(0, 1), (2, 3)])\n>>> for u, v, p in preds:\n...     print(f\"({u}, {v}) -> {p:.8f}\")\n(0, 1) -> 0.75000000\n(2, 3) -> 0.75000000\n\nReferences\n----------\n.. [1] T. Zhou, L. Lu, Y.-C. Zhang.\n   Predicting missing links via local information.\n   Eur. Phys. J. B 71 (2009) 623.\n   https://arxiv.org/pdf/0901.0553.pdf"}, {"type": "function", "name": "networkx.restricted_view", "documentation": "Returns a view of `G` with hidden nodes and edges.\n\nThe resulting subgraph filters out node `nodes` and edges `edges`.\nFiltered out nodes also filter out any of their edges.\n\nParameters\n----------\nG : NetworkX Graph\nnodes : iterable\n    An iterable of nodes. Nodes not present in `G` are ignored.\nedges : iterable\n    An iterable of edges. Edges not present in `G` are ignored.\n\nReturns\n-------\nsubgraph : SubGraph View\n    A read-only restricted view of `G` filtering out nodes and edges.\n    Changes to `G` are reflected in the view.\n\nNotes\n-----\nTo create a mutable subgraph with its own copies of nodes\nedges and attributes use `subgraph.copy()` or `Graph(subgraph)`\n\nIf you create a subgraph of a subgraph recursively you may end up\nwith a chain of subgraph views. Such chains can get quite slow\nfor lengths near 15. To avoid long chains, try to make your subgraph\nbased on the original graph.  We do not rule out chains programmatically\nso that odd cases like an `edge_subgraph` of a `restricted_view`\ncan be created.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> H = nx.restricted_view(G, [0], [(1, 2), (3, 4)])\n>>> list(H.nodes)\n[1, 2, 3, 4]\n>>> list(H.edges)\n[(2, 3)]"}, {"type": "function", "name": "networkx.reverse", "documentation": "Returns the reverse directed graph of G.\n\nParameters\n----------\nG : directed graph\n    A NetworkX directed graph\ncopy : bool\n    If True, then a new graph is returned. If False, then the graph is\n    reversed in place.\n\nReturns\n-------\nH : directed graph\n    The reversed G.\n\nRaises\n------\nNetworkXError\n    If graph is undirected.\n\nExamples\n--------\n>>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 4), (3, 5)])\n>>> G_reversed = nx.reverse(G)\n>>> G_reversed.edges()\nOutEdgeView([(2, 1), (3, 1), (3, 2), (4, 3), (5, 3)])"}, {"type": "function", "name": "networkx.reverse_view", "documentation": "View of `G` with edge directions reversed\n\n`reverse_view` returns a read-only view of the input graph where\nedge directions are reversed.\n\nIdentical to digraph.reverse(copy=False)\n\nParameters\n----------\nG : networkx.DiGraph\n\nReturns\n-------\ngraph : networkx.DiGraph\n\nExamples\n--------\n>>> G = nx.DiGraph()\n>>> G.add_edge(1, 2)\n>>> G.add_edge(2, 3)\n>>> G.edges()\nOutEdgeView([(1, 2), (2, 3)])\n\n>>> view = nx.reverse_view(G)\n>>> view.edges()\nOutEdgeView([(2, 1), (3, 2)])"}, {"type": "function", "name": "networkx.rich_club_coefficient", "documentation": "Returns the rich-club coefficient of the graph `G`.\n\nFor each degree *k*, the *rich-club coefficient* is the ratio of the\nnumber of actual to the number of potential edges for nodes with\ndegree greater than *k*:\n\n.. math::\n\n    \\phi(k) = \\frac{2 E_k}{N_k (N_k - 1)}\n\nwhere `N_k` is the number of nodes with degree larger than *k*, and\n`E_k` is the number of edges among those nodes.\n\nParameters\n----------\nG : NetworkX graph\n    Undirected graph with neither parallel edges nor self-loops.\nnormalized : bool (optional)\n    Normalize using randomized network as in [1]_\nQ : float (optional, default=100)\n    If `normalized` is True, perform `Q * m` double-edge\n    swaps, where `m` is the number of edges in `G`, to use as a\n    null-model for normalization.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nrc : dictionary\n   A dictionary, keyed by degree, with rich-club coefficient values.\n\nRaises\n------\nNetworkXError\n    If `G` has fewer than four nodes and ``normalized=True``.\n    A randomly sampled graph for normalization cannot be generated in this case.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (1, 2), (1, 3), (1, 4), (4, 5)])\n>>> rc = nx.rich_club_coefficient(G, normalized=False, seed=42)\n>>> rc[0]\n0.4\n\nNotes\n-----\nThe rich club definition and algorithm are found in [1]_.  This\nalgorithm ignores any edge weights and is not defined for directed\ngraphs or graphs with parallel edges or self loops.\n\nNormalization is done by computing the rich club coefficient for a randomly\nsampled graph with the same degree distribution as `G` by\nrepeatedly swapping the endpoints of existing edges. For graphs with fewer than 4\nnodes, it is not possible to generate a random graph with a prescribed\ndegree distribution, as the degree distribution fully determines the graph\n(hence making the coefficients trivially normalized to 1).\nThis function raises an exception in this case.\n\nEstimates for appropriate values of `Q` are found in [2]_.\n\nReferences\n----------\n.. [1] Julian J. McAuley, Luciano da Fontoura Costa,\n   and Tib\u00e9rio S. Caetano,\n   \"The rich-club phenomenon across complex network hierarchies\",\n   Applied Physics Letters Vol 91 Issue 8, August 2007.\n   https://arxiv.org/abs/physics/0701290\n.. [2] R. Milo, N. Kashtan, S. Itzkovitz, M. E. J. Newman, U. Alon,\n   \"Uniform generation of random graphs with arbitrary degree\n   sequences\", 2006. https://arxiv.org/abs/cond-mat/0312028"}, {"type": "function", "name": "networkx.ring_of_cliques", "documentation": "Defines a \"ring of cliques\" graph.\n\nA ring of cliques graph is consisting of cliques, connected through single\nlinks. Each clique is a complete graph.\n\nParameters\n----------\nnum_cliques : int\n    Number of cliques\nclique_size : int\n    Size of cliques\n\nReturns\n-------\nG : NetworkX Graph\n    ring of cliques graph\n\nRaises\n------\nNetworkXError\n    If the number of cliques is lower than 2 or\n    if the size of cliques is smaller than 2.\n\nExamples\n--------\n>>> G = nx.ring_of_cliques(8, 4)\n\nSee Also\n--------\nconnected_caveman_graph\n\nNotes\n-----\nThe `connected_caveman_graph` graph removes a link from each clique to\nconnect it with the next clique. Instead, the `ring_of_cliques` graph\nsimply adds the link without removing any link from the cliques."}, {"type": "function", "name": "networkx.rooted_product", "documentation": "Return the rooted product of graphs G and H rooted at root in H.\n\nA new graph is constructed representing the rooted product of\nthe inputted graphs, G and H, with a root in H.\nA rooted product duplicates H for each nodes in G with the root\nof H corresponding to the node in G. Nodes are renamed as the direct\nproduct of G and H. The result is a subgraph of the cartesian product.\n\nParameters\n----------\nG,H : graph\n   A NetworkX graph\nroot : node\n   A node in H\n\nReturns\n-------\nR : The rooted product of G and H with a specified root in H\n\nNotes\n-----\nThe nodes of R are the Cartesian Product of the nodes of G and H.\nThe nodes of G and H are not relabeled."}, {"type": "function", "name": "networkx.s_metric", "documentation": "Returns the s-metric [1]_ of graph.\n\nThe s-metric is defined as the sum of the products ``deg(u) * deg(v)``\nfor every edge ``(u, v)`` in `G`.\n\nParameters\n----------\nG : graph\n    The graph used to compute the s-metric.\nnormalized : bool (optional)\n    Normalize the value.\n\n    .. deprecated:: 3.2\n\n       The `normalized` keyword argument is deprecated and will be removed\n       in the future\n\nReturns\n-------\ns : float\n    The s-metric of the graph.\n\nReferences\n----------\n.. [1] Lun Li, David Alderson, John C. Doyle, and Walter Willinger,\n       Towards a Theory of Scale-Free Graphs:\n       Definition, Properties, and  Implications (Extended Version), 2005.\n       https://arxiv.org/abs/cond-mat/0501169"}, {"type": "function", "name": "networkx.scale_free_graph", "documentation": "Returns a scale-free directed graph.\n\nParameters\n----------\nn : integer\n    Number of nodes in graph\nalpha : float\n    Probability for adding a new node connected to an existing node\n    chosen randomly according to the in-degree distribution.\nbeta : float\n    Probability for adding an edge between two existing nodes.\n    One existing node is chosen randomly according the in-degree\n    distribution and the other chosen randomly according to the out-degree\n    distribution.\ngamma : float\n    Probability for adding a new node connected to an existing node\n    chosen randomly according to the out-degree distribution.\ndelta_in : float\n    Bias for choosing nodes from in-degree distribution.\ndelta_out : float\n    Bias for choosing nodes from out-degree distribution.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ninitial_graph : MultiDiGraph instance, optional\n    Build the scale-free graph starting from this initial MultiDiGraph,\n    if provided.\n\nReturns\n-------\nMultiDiGraph\n\nExamples\n--------\nCreate a scale-free graph on one hundred nodes::\n\n>>> G = nx.scale_free_graph(100)\n\nNotes\n-----\nThe sum of `alpha`, `beta`, and `gamma` must be 1.\n\nReferences\n----------\n.. [1] B. Bollob\u00e1s, C. Borgs, J. Chayes, and O. Riordan,\n       Directed scale-free graphs,\n       Proceedings of the fourteenth annual ACM-SIAM Symposium on\n       Discrete Algorithms, 132--139, 2003."}, {"type": "function", "name": "networkx.schultz_index", "documentation": "Returns the Schultz Index (of the first kind) of `G`\n\nThe *Schultz Index* [3]_ of a graph is the sum over all node pairs of\ndistances times the sum of degrees. Consider an undirected graph `G`.\nFor each node pair ``(u, v)`` compute ``dist(u, v) * (deg(u) + deg(v)``\nwhere ``dist`` is the shortest path length between two nodes and ``deg``\nis the degree of a node.\n\nThe Schultz Index is the sum of these quantities over all (unordered)\npairs of nodes.\n\nParameters\n----------\nG : NetworkX graph\n    The undirected graph of interest.\nweight : string or None, optional (default: None)\n    If None, every edge has weight 1.\n    If a string, use this edge attribute as the edge weight.\n    Any edge attribute not present defaults to 1.\n    The edge weights are used to computing shortest-path distances.\n\nReturns\n-------\nnumber\n    The first kind of Schultz Index of the graph `G`.\n\nExamples\n--------\nThe Schultz Index of the (unweighted) complete graph on *n* nodes\nequals the number of pairs of the *n* nodes times ``2 * (n - 1)``,\nsince each pair of nodes is at distance one and the sum of degree\nof two nodes is ``2 * (n - 1)``.\n\n>>> n = 10\n>>> G = nx.complete_graph(n)\n>>> nx.schultz_index(G) == (n * (n - 1) / 2) * (2 * (n - 1))\nTrue\n\nGraph that is disconnected\n\n>>> nx.schultz_index(nx.empty_graph(2))\ninf\n\nReferences\n----------\n.. [1] I. Gutman, Selected properties of the Schultz molecular topological index,\n       J. Chem. Inf. Comput. Sci. 34 (1994), 1087\u20131089.\n       https://doi.org/10.1021/ci00021a009\n.. [2] M.V. Diudeaa and I. Gutman, Wiener-Type Topological Indices,\n       Croatica Chemica Acta, 71 (1998), 21-51.\n       https://hrcak.srce.hr/132323\n.. [3] H. P. Schultz, Topological organic chemistry. 1.\n       Graph theory and topological indices of alkanes,i\n       J. Chem. Inf. Comput. Sci. 29 (1989), 239\u2013257."}, {"type": "function", "name": "networkx.second_order_centrality", "documentation": "Compute the second order centrality for nodes of G.\n\nThe second order centrality of a given node is the standard deviation of\nthe return times to that node of a perpetual random walk on G:\n\nParameters\n----------\nG : graph\n  A NetworkX connected and undirected graph.\n\nweight : string or None, optional (default=\"weight\")\n    The name of an edge attribute that holds the numerical value\n    used as a weight. If None then each edge has weight 1.\n\nReturns\n-------\nnodes : dictionary\n   Dictionary keyed by node with second order centrality as the value.\n\nExamples\n--------\n>>> G = nx.star_graph(10)\n>>> soc = nx.second_order_centrality(G)\n>>> print(sorted(soc.items(), key=lambda x: x[1])[0][0])  # pick first id\n0\n\nRaises\n------\nNetworkXException\n    If the graph G is empty, non connected or has negative weights.\n\nSee Also\n--------\nbetweenness_centrality\n\nNotes\n-----\nLower values of second order centrality indicate higher centrality.\n\nThe algorithm is from Kermarrec, Le Merrer, Sericola and Tr\u00e9dan [1]_.\n\nThis code implements the analytical version of the algorithm, i.e.,\nthere is no simulation of a random walk process involved. The random walk\nis here unbiased (corresponding to eq 6 of the paper [1]_), thus the\ncentrality values are the standard deviations for random walk return times\non the transformed input graph G (equal in-degree at each nodes by adding\nself-loops).\n\nComplexity of this implementation, made to run locally on a single machine,\nis O(n^3), with n the size of G, which makes it viable only for small\ngraphs.\n\nReferences\n----------\n.. [1] Anne-Marie Kermarrec, Erwan Le Merrer, Bruno Sericola, Gilles Tr\u00e9dan\n   \"Second order centrality: Distributed assessment of nodes criticity in\n   complex networks\", Elsevier Computer Communications 34(5):619-628, 2011."}, {"type": "function", "name": "networkx.sedgewick_maze_graph", "documentation": "Return a small maze with a cycle.\n\nThis is the maze used in Sedgewick, 3rd Edition, Part 5, Graph\nAlgorithms, Chapter 18, e.g. Figure 18.2 and following [1]_.\nNodes are numbered 0,..,7\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Small maze with a cycle\n\nReferences\n----------\n.. [1] Figure 18.2, Chapter 18, Graph Algorithms (3rd Ed), Sedgewick"}, {"type": "function", "name": "networkx.selfloop_edges", "documentation": "Returns an iterator over selfloop edges.\n\nA selfloop edge has the same node at both ends.\n\nParameters\n----------\nG : graph\n    A NetworkX graph.\ndata : string or bool, optional (default=False)\n    Return selfloop edges as two tuples (u, v) (data=False)\n    or three-tuples (u, v, datadict) (data=True)\n    or three-tuples (u, v, datavalue) (data='attrname')\nkeys : bool, optional (default=False)\n    If True, return edge keys with each edge.\ndefault : value, optional (default=None)\n    Value used for edges that don't have the requested attribute.\n    Only relevant if data is not True or False.\n\nReturns\n-------\nedgeiter : iterator over edge tuples\n    An iterator over all selfloop edges.\n\nSee Also\n--------\nnodes_with_selfloops, number_of_selfloops\n\nExamples\n--------\n>>> G = nx.MultiGraph()  # or Graph, DiGraph, MultiDiGraph, etc\n>>> ekey = G.add_edge(1, 1)\n>>> ekey = G.add_edge(1, 2)\n>>> list(nx.selfloop_edges(G))\n[(1, 1)]\n>>> list(nx.selfloop_edges(G, data=True))\n[(1, 1, {})]\n>>> list(nx.selfloop_edges(G, keys=True))\n[(1, 1, 0)]\n>>> list(nx.selfloop_edges(G, keys=True, data=True))\n[(1, 1, 0, {})]"}, {"type": "function", "name": "networkx.set_edge_attributes", "documentation": "Sets edge attributes from a given value or dictionary of values.\n\n.. Warning:: The call order of arguments `values` and `name`\n    switched between v1.x & v2.x.\n\nParameters\n----------\nG : NetworkX Graph\n\nvalues : scalar value, dict-like\n    What the edge attribute should be set to.  If `values` is\n    not a dictionary, then it is treated as a single attribute value\n    that is then applied to every edge in `G`.  This means that if\n    you provide a mutable object, like a list, updates to that object\n    will be reflected in the edge attribute for each edge.  The attribute\n    name will be `name`.\n\n    If `values` is a dict or a dict of dict, it should be keyed\n    by edge tuple to either an attribute value or a dict of attribute\n    key/value pairs used to update the edge's attributes.\n    For multigraphs, the edge tuples must be of the form ``(u, v, key)``,\n    where `u` and `v` are nodes and `key` is the edge key.\n    For non-multigraphs, the keys must be tuples of the form ``(u, v)``.\n\nname : string (optional, default=None)\n    Name of the edge attribute to set if values is a scalar.\n\nExamples\n--------\nAfter computing some property of the edges of a graph, you may want\nto assign a edge attribute to store the value of that property for\neach edge::\n\n    >>> G = nx.path_graph(3)\n    >>> bb = nx.edge_betweenness_centrality(G, normalized=False)\n    >>> nx.set_edge_attributes(G, bb, \"betweenness\")\n    >>> G.edges[1, 2][\"betweenness\"]\n    2.0\n\nIf you provide a list as the second argument, updates to the list\nwill be reflected in the edge attribute for each edge::\n\n    >>> labels = []\n    >>> nx.set_edge_attributes(G, labels, \"labels\")\n    >>> labels.append(\"foo\")\n    >>> G.edges[0, 1][\"labels\"]\n    ['foo']\n    >>> G.edges[1, 2][\"labels\"]\n    ['foo']\n\nIf you provide a dictionary of dictionaries as the second argument,\nthe entire dictionary will be used to update edge attributes::\n\n    >>> G = nx.path_graph(3)\n    >>> attrs = {(0, 1): {\"attr1\": 20, \"attr2\": \"nothing\"}, (1, 2): {\"attr2\": 3}}\n    >>> nx.set_edge_attributes(G, attrs)\n    >>> G[0][1][\"attr1\"]\n    20\n    >>> G[0][1][\"attr2\"]\n    'nothing'\n    >>> G[1][2][\"attr2\"]\n    3\n\nThe attributes of one Graph can be used to set those of another.\n\n    >>> H = nx.path_graph(3)\n    >>> nx.set_edge_attributes(H, G.edges)\n\nNote that if the dict contains edges that are not in `G`, they are\nsilently ignored::\n\n    >>> G = nx.Graph([(0, 1)])\n    >>> nx.set_edge_attributes(G, {(1, 2): {\"weight\": 2.0}})\n    >>> (1, 2) in G.edges()\n    False\n\nFor multigraphs, the `values` dict is expected to be keyed by 3-tuples\nincluding the edge key::\n\n    >>> MG = nx.MultiGraph()\n    >>> edges = [(0, 1), (0, 1)]\n    >>> MG.add_edges_from(edges)  # Returns list of edge keys\n    [0, 1]\n    >>> attributes = {(0, 1, 0): {\"cost\": 21}, (0, 1, 1): {\"cost\": 7}}\n    >>> nx.set_edge_attributes(MG, attributes)\n    >>> MG[0][1][0][\"cost\"]\n    21\n    >>> MG[0][1][1][\"cost\"]\n    7\n\nIf MultiGraph attributes are desired for a Graph, you must convert the 3-tuple\nmultiedge to a 2-tuple edge and the last multiedge's attribute value will\noverwrite the previous values. Continuing from the previous case we get::\n\n    >>> H = nx.path_graph([0, 1, 2])\n    >>> nx.set_edge_attributes(H, {(u, v): ed for u, v, ed in MG.edges.data()})\n    >>> nx.get_edge_attributes(H, \"cost\")\n    {(0, 1): 7}"}, {"type": "function", "name": "networkx.set_node_attributes", "documentation": "Sets node attributes from a given value or dictionary of values.\n\n.. Warning:: The call order of arguments `values` and `name`\n    switched between v1.x & v2.x.\n\nParameters\n----------\nG : NetworkX Graph\n\nvalues : scalar value, dict-like\n    What the node attribute should be set to.  If `values` is\n    not a dictionary, then it is treated as a single attribute value\n    that is then applied to every node in `G`.  This means that if\n    you provide a mutable object, like a list, updates to that object\n    will be reflected in the node attribute for every node.\n    The attribute name will be `name`.\n\n    If `values` is a dict or a dict of dict, it should be keyed\n    by node to either an attribute value or a dict of attribute key/value\n    pairs used to update the node's attributes.\n\nname : string (optional, default=None)\n    Name of the node attribute to set if values is a scalar.\n\nExamples\n--------\nAfter computing some property of the nodes of a graph, you may want\nto assign a node attribute to store the value of that property for\neach node::\n\n    >>> G = nx.path_graph(3)\n    >>> bb = nx.betweenness_centrality(G)\n    >>> isinstance(bb, dict)\n    True\n    >>> nx.set_node_attributes(G, bb, \"betweenness\")\n    >>> G.nodes[1][\"betweenness\"]\n    1.0\n\nIf you provide a list as the second argument, updates to the list\nwill be reflected in the node attribute for each node::\n\n    >>> G = nx.path_graph(3)\n    >>> labels = []\n    >>> nx.set_node_attributes(G, labels, \"labels\")\n    >>> labels.append(\"foo\")\n    >>> G.nodes[0][\"labels\"]\n    ['foo']\n    >>> G.nodes[1][\"labels\"]\n    ['foo']\n    >>> G.nodes[2][\"labels\"]\n    ['foo']\n\nIf you provide a dictionary of dictionaries as the second argument,\nthe outer dictionary is assumed to be keyed by node to an inner\ndictionary of node attributes for that node::\n\n    >>> G = nx.path_graph(3)\n    >>> attrs = {0: {\"attr1\": 20, \"attr2\": \"nothing\"}, 1: {\"attr2\": 3}}\n    >>> nx.set_node_attributes(G, attrs)\n    >>> G.nodes[0][\"attr1\"]\n    20\n    >>> G.nodes[0][\"attr2\"]\n    'nothing'\n    >>> G.nodes[1][\"attr2\"]\n    3\n    >>> G.nodes[2]\n    {}\n\nNote that if the dictionary contains nodes that are not in `G`, the\nvalues are silently ignored::\n\n    >>> G = nx.Graph()\n    >>> G.add_node(0)\n    >>> nx.set_node_attributes(G, {0: \"red\", 1: \"blue\"}, name=\"color\")\n    >>> G.nodes[0][\"color\"]\n    'red'\n    >>> 1 in G.nodes\n    False"}, {"type": "function", "name": "networkx.shell_layout", "documentation": "Position nodes in concentric circles.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\nnlist : list of lists\n   List of node lists for each shell.\n\nrotate : angle in radians (default=pi/len(nlist))\n   Angle by which to rotate the starting position of each shell\n   relative to the starting position of the previous shell.\n   To recreate behavior before v2.5 use rotate=0.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\ndim : int\n    Dimension of layout, currently only dim=2 is supported.\n    Other dimension values result in a ValueError.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nRaises\n------\nValueError\n    If dim != 2\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> shells = [[0], [1, 2, 3]]\n>>> pos = nx.shell_layout(G, shells)\n\nNotes\n-----\nThis algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings."}, {"type": "function", "name": "networkx.shortest_path", "documentation": "Compute shortest paths in the graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node, optional\n    Starting node for path. If not specified, compute shortest\n    paths for each possible starting node.\n\ntarget : node, optional\n    Ending node for path. If not specified, compute shortest\n    paths to all possible nodes.\n\nweight : None, string or function, optional (default = None)\n    If None, every edge has weight/distance/cost 1.\n    If a string, use this edge attribute as the edge weight.\n    Any edge attribute not present defaults to 1.\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly\n    three positional arguments: the two endpoints of an edge and\n    the dictionary of edge attributes for that edge.\n    The function must return a number.\n\nmethod : string, optional (default = 'dijkstra')\n    The algorithm to use to compute the path.\n    Supported options: 'dijkstra', 'bellman-ford'.\n    Other inputs produce a ValueError.\n    If `weight` is None, unweighted graph methods are used, and this\n    suggestion is ignored.\n\nReturns\n-------\npath: list or dictionary\n    All returned paths include both the source and target in the path.\n\n    If the source and target are both specified, return a single list\n    of nodes in a shortest path from the source to the target.\n\n    If only the source is specified, return a dictionary keyed by\n    targets with a list of nodes in a shortest path from the source\n    to one of the targets.\n\n    If only the target is specified, return a dictionary keyed by\n    sources with a list of nodes in a shortest path from one of the\n    sources to the target.\n\n    If neither the source nor target are specified return a dictionary\n    of dictionaries with path[source][target]=[list of nodes in path].\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nValueError\n    If `method` is not among the supported options.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> print(nx.shortest_path(G, source=0, target=4))\n[0, 1, 2, 3, 4]\n>>> p = nx.shortest_path(G, source=0)  # target not specified\n>>> p[3]  # shortest path from source=0 to target=3\n[0, 1, 2, 3]\n>>> p = nx.shortest_path(G, target=4)  # source not specified\n>>> p[1]  # shortest path from source=1 to target=4\n[1, 2, 3, 4]\n>>> p = dict(nx.shortest_path(G))  # source, target not specified\n>>> p[2][4]  # shortest path from source=2 to target=4\n[2, 3, 4]\n\nNotes\n-----\nThere may be more than one shortest path between a source and target.\nThis returns only one of them.\n\nSee Also\n--------\nall_pairs_shortest_path\nall_pairs_dijkstra_path\nall_pairs_bellman_ford_path\nsingle_source_shortest_path\nsingle_source_dijkstra_path\nsingle_source_bellman_ford_path"}, {"type": "function", "name": "networkx.shortest_path_length", "documentation": "Compute shortest path lengths in the graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node, optional\n    Starting node for path.\n    If not specified, compute shortest path lengths using all nodes as\n    source nodes.\n\ntarget : node, optional\n    Ending node for path.\n    If not specified, compute shortest path lengths using all nodes as\n    target nodes.\n\nweight : None, string or function, optional (default = None)\n    If None, every edge has weight/distance/cost 1.\n    If a string, use this edge attribute as the edge weight.\n    Any edge attribute not present defaults to 1.\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly\n    three positional arguments: the two endpoints of an edge and\n    the dictionary of edge attributes for that edge.\n    The function must return a number.\n\nmethod : string, optional (default = 'dijkstra')\n    The algorithm to use to compute the path length.\n    Supported options: 'dijkstra', 'bellman-ford'.\n    Other inputs produce a ValueError.\n    If `weight` is None, unweighted graph methods are used, and this\n    suggestion is ignored.\n\nReturns\n-------\nlength: int or iterator\n    If the source and target are both specified, return the length of\n    the shortest path from the source to the target.\n\n    If only the source is specified, return a dict keyed by target\n    to the shortest path length from the source to that target.\n\n    If only the target is specified, return a dict keyed by source\n    to the shortest path length from that source to the target.\n\n    If neither the source nor target are specified, return an iterator\n    over (source, dictionary) where dictionary is keyed by target to\n    shortest path length from source to that target.\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nNetworkXNoPath\n    If no path exists between source and target.\n\nValueError\n    If `method` is not among the supported options.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> nx.shortest_path_length(G, source=0, target=4)\n4\n>>> p = nx.shortest_path_length(G, source=0)  # target not specified\n>>> p[4]\n4\n>>> p = nx.shortest_path_length(G, target=4)  # source not specified\n>>> p[0]\n4\n>>> p = dict(nx.shortest_path_length(G))  # source,target not specified\n>>> p[0][4]\n4\n\nNotes\n-----\nThe length of the path is always 1 less than the number of nodes involved\nin the path since the length measures the number of edges followed.\n\nFor digraphs this returns the shortest directed path length. To find path\nlengths in the reverse direction use G.reverse(copy=False) first to flip\nthe edge orientation.\n\nSee Also\n--------\nall_pairs_shortest_path_length\nall_pairs_dijkstra_path_length\nall_pairs_bellman_ford_path_length\nsingle_source_shortest_path_length\nsingle_source_dijkstra_path_length\nsingle_source_bellman_ford_path_length"}, {"type": "function", "name": "networkx.shortest_simple_paths", "documentation": "Generate all simple paths in the graph G from source to target,\n   starting from shortest ones.\n\nA simple path is a path with no repeated nodes.\n\nIf a weighted shortest path search is to be used, no negative weights\nare allowed.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n   Starting node for path\n\ntarget : node\n   Ending node for path\n\nweight : string or function\n    If it is a string, it is the name of the edge attribute to be\n    used as a weight.\n\n    If it is a function, the weight of an edge is the value returned\n    by the function. The function must accept exactly three positional\n    arguments: the two endpoints of an edge and the dictionary of edge\n    attributes for that edge. The function must return a number.\n\n    If None all edges are considered to have unit weight. Default\n    value None.\n\nReturns\n-------\npath_generator: generator\n   A generator that produces lists of simple paths, in order from\n   shortest to longest.\n\nRaises\n------\nNetworkXNoPath\n   If no path exists between source and target.\n\nNetworkXError\n   If source or target nodes are not in the input graph.\n\nNetworkXNotImplemented\n   If the input graph is a Multi[Di]Graph.\n\nExamples\n--------\n\n>>> G = nx.cycle_graph(7)\n>>> paths = list(nx.shortest_simple_paths(G, 0, 3))\n>>> print(paths)\n[[0, 1, 2, 3], [0, 6, 5, 4, 3]]\n\nYou can use this function to efficiently compute the k shortest/best\npaths between two nodes.\n\n>>> from itertools import islice\n>>> def k_shortest_paths(G, source, target, k, weight=None):\n...     return list(\n...         islice(nx.shortest_simple_paths(G, source, target, weight=weight), k)\n...     )\n>>> for path in k_shortest_paths(G, 0, 3, 2):\n...     print(path)\n[0, 1, 2, 3]\n[0, 6, 5, 4, 3]\n\nNotes\n-----\nThis procedure is based on algorithm by Jin Y. Yen [1]_.  Finding\nthe first $K$ paths requires $O(KN^3)$ operations.\n\nSee Also\n--------\nall_shortest_paths\nshortest_path\nall_simple_paths\n\nReferences\n----------\n.. [1] Jin Y. Yen, \"Finding the K Shortest Loopless Paths in a\n   Network\", Management Science, Vol. 17, No. 11, Theory Series\n   (Jul., 1971), pp. 712-716."}, {"type": "function", "name": "networkx.sigma", "documentation": "Returns the small-world coefficient (sigma) of the given graph.\n\nThe small-world coefficient is defined as:\nsigma = C/Cr / L/Lr\nwhere C and L are respectively the average clustering coefficient and\naverage shortest path length of G. Cr and Lr are respectively the average\nclustering coefficient and average shortest path length of an equivalent\nrandom graph.\n\nA graph is commonly classified as small-world if sigma>1.\n\nParameters\n----------\nG : NetworkX graph\n    An undirected graph.\nniter : integer (optional, default=100)\n    Approximate number of rewiring per edge to compute the equivalent\n    random graph.\nnrand : integer (optional, default=10)\n    Number of random graphs generated to compute the average clustering\n    coefficient (Cr) and average shortest path length (Lr).\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nsigma : float\n    The small-world coefficient of G.\n\nNotes\n-----\nThe implementation is adapted from Humphries et al. [1]_ [2]_.\n\nReferences\n----------\n.. [1] The brainstem reticular formation is a small-world, not scale-free,\n       network M. D. Humphries, K. Gurney and T. J. Prescott,\n       Proc. Roy. Soc. B 2006 273, 503-511, doi:10.1098/rspb.2005.3354.\n.. [2] Humphries and Gurney (2008).\n       \"Network 'Small-World-Ness': A Quantitative Method for Determining\n       Canonical Network Equivalence\".\n       PLoS One. 3 (4). PMID 18446219. doi:10.1371/journal.pone.0002051."}, {"type": "function", "name": "networkx.simple_cycles", "documentation": "Find simple cycles (elementary circuits) of a graph.\n\nA `simple cycle`, or `elementary circuit`, is a closed path where\nno node appears twice.  In a directed graph, two simple cycles are distinct\nif they are not cyclic permutations of each other.  In an undirected graph,\ntwo simple cycles are distinct if they are not cyclic permutations of each\nother nor of the other's reversal.\n\nOptionally, the cycles are bounded in length.  In the unbounded case, we use\na nonrecursive, iterator/generator version of Johnson's algorithm [1]_.  In\nthe bounded case, we use a version of the algorithm of Gupta and\nSuzumura[2]_. There may be better algorithms for some cases [3]_ [4]_ [5]_.\n\nThe algorithms of Johnson, and Gupta and Suzumura, are enhanced by some\nwell-known preprocessing techniques.  When G is directed, we restrict our\nattention to strongly connected components of G, generate all simple cycles\ncontaining a certain node, remove that node, and further decompose the\nremainder into strongly connected components.  When G is undirected, we\nrestrict our attention to biconnected components, generate all simple cycles\ncontaining a particular edge, remove that edge, and further decompose the\nremainder into biconnected components.\n\nNote that multigraphs are supported by this function -- and in undirected\nmultigraphs, a pair of parallel edges is considered a cycle of length 2.\nLikewise, self-loops are considered to be cycles of length 1.  We define\ncycles as sequences of nodes; so the presence of loops and parallel edges\ndoes not change the number of simple cycles in a graph.\n\nParameters\n----------\nG : NetworkX DiGraph\n   A directed graph\n\nlength_bound : int or None, optional (default=None)\n   If length_bound is an int, generate all simple cycles of G with length at\n   most length_bound.  Otherwise, generate all simple cycles of G.\n\nYields\n------\nlist of nodes\n   Each cycle is represented by a list of nodes along the cycle.\n\nExamples\n--------\n>>> edges = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 0), (2, 1), (2, 2)]\n>>> G = nx.DiGraph(edges)\n>>> sorted(nx.simple_cycles(G))\n[[0], [0, 1, 2], [0, 2], [1, 2], [2]]\n\nTo filter the cycles so that they don't include certain nodes or edges,\ncopy your graph and eliminate those nodes or edges before calling.\nFor example, to exclude self-loops from the above example:\n\n>>> H = G.copy()\n>>> H.remove_edges_from(nx.selfloop_edges(G))\n>>> sorted(nx.simple_cycles(H))\n[[0, 1, 2], [0, 2], [1, 2]]\n\nNotes\n-----\nWhen length_bound is None, the time complexity is $O((n+e)(c+1))$ for $n$\nnodes, $e$ edges and $c$ simple circuits.  Otherwise, when length_bound > 1,\nthe time complexity is $O((c+n)(k-1)d^k)$ where $d$ is the average degree of\nthe nodes of G and $k$ = length_bound.\n\nRaises\n------\nValueError\n    when length_bound < 0.\n\nReferences\n----------\n.. [1] Finding all the elementary circuits of a directed graph.\n   D. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.\n   https://doi.org/10.1137/0204007\n.. [2] Finding All Bounded-Length Simple Cycles in a Directed Graph\n   A. Gupta and T. Suzumura https://arxiv.org/abs/2105.10094\n.. [3] Enumerating the cycles of a digraph: a new preprocessing strategy.\n   G. Loizou and P. Thanish, Information Sciences, v. 27, 163-182, 1982.\n.. [4] A search strategy for the elementary cycles of a directed graph.\n   J.L. Szwarcfiter and P.E. Lauer, BIT NUMERICAL MATHEMATICS,\n   v. 16, no. 2, 192-204, 1976.\n.. [5] Optimal Listing of Cycles and st-Paths in Undirected Graphs\n    R. Ferreira and R. Grossi and A. Marino and N. Pisanti and R. Rizzi and\n    G. Sacomoto https://arxiv.org/abs/1205.2766\n\nSee Also\n--------\ncycle_basis\nchordless_cycles"}, {"type": "function", "name": "networkx.simrank_similarity", "documentation": "Returns the SimRank similarity of nodes in the graph ``G``.\n\nSimRank is a similarity metric that says \"two objects are considered\nto be similar if they are referenced by similar objects.\" [1]_.\n\nThe pseudo-code definition from the paper is::\n\n    def simrank(G, u, v):\n        in_neighbors_u = G.predecessors(u)\n        in_neighbors_v = G.predecessors(v)\n        scale = C / (len(in_neighbors_u) * len(in_neighbors_v))\n        return scale * sum(\n            simrank(G, w, x) for w, x in product(in_neighbors_u, in_neighbors_v)\n        )\n\nwhere ``G`` is the graph, ``u`` is the source, ``v`` is the target,\nand ``C`` is a float decay or importance factor between 0 and 1.\n\nThe SimRank algorithm for determining node similarity is defined in\n[2]_.\n\nParameters\n----------\nG : NetworkX graph\n    A NetworkX graph\n\nsource : node\n    If this is specified, the returned dictionary maps each node\n    ``v`` in the graph to the similarity between ``source`` and\n    ``v``.\n\ntarget : node\n    If both ``source`` and ``target`` are specified, the similarity\n    value between ``source`` and ``target`` is returned. If\n    ``target`` is specified but ``source`` is not, this argument is\n    ignored.\n\nimportance_factor : float\n    The relative importance of indirect neighbors with respect to\n    direct neighbors.\n\nmax_iterations : integer\n    Maximum number of iterations.\n\ntolerance : float\n    Error tolerance used to check convergence. When an iteration of\n    the algorithm finds that no similarity value changes more than\n    this amount, the algorithm halts.\n\nReturns\n-------\nsimilarity : dictionary or float\n    If ``source`` and ``target`` are both ``None``, this returns a\n    dictionary of dictionaries, where keys are node pairs and value\n    are similarity of the pair of nodes.\n\n    If ``source`` is not ``None`` but ``target`` is, this returns a\n    dictionary mapping node to the similarity of ``source`` and that\n    node.\n\n    If neither ``source`` nor ``target`` is ``None``, this returns\n    the similarity value for the given pair of nodes.\n\nRaises\n------\nExceededMaxIterations\n    If the algorithm does not converge within ``max_iterations``.\n\nNodeNotFound\n    If either ``source`` or ``target`` is not in `G`.\n\nExamples\n--------\n>>> G = nx.cycle_graph(2)\n>>> nx.simrank_similarity(G)\n{0: {0: 1.0, 1: 0.0}, 1: {0: 0.0, 1: 1.0}}\n>>> nx.simrank_similarity(G, source=0)\n{0: 1.0, 1: 0.0}\n>>> nx.simrank_similarity(G, source=0, target=0)\n1.0\n\nThe result of this function can be converted to a numpy array\nrepresenting the SimRank matrix by using the node order of the\ngraph to determine which row and column represent each node.\nOther ordering of nodes is also possible.\n\n>>> import numpy as np\n>>> sim = nx.simrank_similarity(G)\n>>> np.array([[sim[u][v] for v in G] for u in G])\narray([[1., 0.],\n       [0., 1.]])\n>>> sim_1d = nx.simrank_similarity(G, source=0)\n>>> np.array([sim[0][v] for v in G])\narray([1., 0.])\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/SimRank\n.. [2] G. Jeh and J. Widom.\n       \"SimRank: a measure of structural-context similarity\",\n       In KDD'02: Proceedings of the Eighth ACM SIGKDD\n       International Conference on Knowledge Discovery and Data Mining,\n       pp. 538--543. ACM Press, 2002."}, {"type": "function", "name": "networkx.single_source_all_shortest_paths", "documentation": "Compute all shortest simple paths from the given source in the graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n   Starting node for path.\n\nweight : None, string or function, optional (default = None)\n    If None, every edge has weight/distance/cost 1.\n    If a string, use this edge attribute as the edge weight.\n    Any edge attribute not present defaults to 1.\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly\n    three positional arguments: the two endpoints of an edge and\n    the dictionary of edge attributes for that edge.\n    The function must return a number.\n\nmethod : string, optional (default = 'dijkstra')\n   The algorithm to use to compute the path lengths.\n   Supported options: 'dijkstra', 'bellman-ford'.\n   Other inputs produce a ValueError.\n   If `weight` is None, unweighted graph methods are used, and this\n   suggestion is ignored.\n\nReturns\n-------\npaths : generator of dictionary\n    A generator of all paths between source and all nodes in the graph.\n\nRaises\n------\nValueError\n    If `method` is not among the supported options.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> nx.add_path(G, [0, 1, 2, 3, 0])\n>>> dict(nx.single_source_all_shortest_paths(G, source=0))\n{0: [[0]], 1: [[0, 1]], 2: [[0, 1, 2], [0, 3, 2]], 3: [[0, 3]]}\n\nNotes\n-----\nThere may be many shortest paths between the source and target.  If G\ncontains zero-weight cycles, this function will not produce all shortest\npaths because doing so would produce infinitely many paths of unbounded\nlength -- instead, we only produce the shortest simple paths.\n\nSee Also\n--------\nshortest_path\nall_shortest_paths\nsingle_source_shortest_path\nall_pairs_shortest_path\nall_pairs_all_shortest_paths"}, {"type": "function", "name": "networkx.single_source_bellman_ford", "documentation": "Compute shortest paths and lengths in a weighted graph G.\n\nUses Bellman-Ford algorithm for shortest paths.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node label\n    Starting node for path\n\ntarget : node label, optional\n    Ending node for path\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\nReturns\n-------\ndistance, path : pair of dictionaries, or numeric and list\n    If target is None, returns a tuple of two dictionaries keyed by node.\n    The first dictionary stores distance from one of the source nodes.\n    The second stores the path from one of the sources to that node.\n    If target is not None, returns a tuple of (distance, path) where\n    distance is the distance from source to target and path is a list\n    representing the path from source to target.\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> length, path = nx.single_source_bellman_ford(G, 0)\n>>> length[4]\n4\n>>> for node in [0, 1, 2, 3, 4]:\n...     print(f\"{node}: {length[node]}\")\n0: 0\n1: 1\n2: 2\n3: 3\n4: 4\n>>> path[4]\n[0, 1, 2, 3, 4]\n>>> length, path = nx.single_source_bellman_ford(G, 0, 1)\n>>> length\n1\n>>> path\n[0, 1]\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nSee Also\n--------\nsingle_source_dijkstra\nsingle_source_bellman_ford_path\nsingle_source_bellman_ford_path_length"}, {"type": "function", "name": "networkx.single_source_bellman_ford_path", "documentation": "Compute shortest path between source and all other reachable\nnodes for a weighted graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n    Starting node for path.\n\nweight : string or function (default=\"weight\")\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\nReturns\n-------\npaths : dictionary\n    Dictionary of shortest path lengths keyed by target.\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> path = nx.single_source_bellman_ford_path(G, 0)\n>>> path[4]\n[0, 1, 2, 3, 4]\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nSee Also\n--------\nsingle_source_dijkstra, single_source_bellman_ford"}, {"type": "function", "name": "networkx.single_source_bellman_ford_path_length", "documentation": "Compute the shortest path length between source and all other\nreachable nodes for a weighted graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node label\n    Starting node for path\n\nweight : string or function (default=\"weight\")\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number.\n\nReturns\n-------\nlength : dictionary\n    Dictionary of shortest path length keyed by target\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> length = nx.single_source_bellman_ford_path_length(G, 0)\n>>> length[4]\n4\n>>> for node in [0, 1, 2, 3, 4]:\n...     print(f\"{node}: {length[node]}\")\n0: 0\n1: 1\n2: 2\n3: 3\n4: 4\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nSee Also\n--------\nsingle_source_dijkstra, single_source_bellman_ford"}, {"type": "function", "name": "networkx.single_source_dijkstra", "documentation": "Find shortest weighted paths and lengths from a source node.\n\nCompute the shortest path length between source and all other\nreachable nodes for a weighted graph.\n\nUses Dijkstra's algorithm to compute shortest paths and lengths\nbetween a source and all other reachable nodes in a weighted graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node label\n    Starting node for path\n\ntarget : node label, optional\n    Ending node for path\n\ncutoff : integer or float, optional\n    Length (sum of edge weights) at which the search is stopped.\n    If cutoff is provided, only return paths with summed weight <= cutoff.\n\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number or None to indicate a hidden edge.\n\nReturns\n-------\ndistance, path : pair of dictionaries, or numeric and list.\n    If target is None, paths and lengths to all nodes are computed.\n    The return value is a tuple of two dictionaries keyed by target nodes.\n    The first dictionary stores distance to each target node.\n    The second stores the path to each target node.\n    If target is not None, returns a tuple (distance, path), where\n    distance is the distance from source to target and path is a list\n    representing the path from source to target.\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> length, path = nx.single_source_dijkstra(G, 0)\n>>> length[4]\n4\n>>> for node in [0, 1, 2, 3, 4]:\n...     print(f\"{node}: {length[node]}\")\n0: 0\n1: 1\n2: 2\n3: 3\n4: 4\n>>> path[4]\n[0, 1, 2, 3, 4]\n>>> length, path = nx.single_source_dijkstra(G, 0, 1)\n>>> length\n1\n>>> path\n[0, 1]\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe weight function can be used to hide edges by returning None.\nSo ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\nwill find the shortest red path.\n\nBased on the Python cookbook recipe (119466) at\nhttps://code.activestate.com/recipes/119466/\n\nThis algorithm is not guaranteed to work if edge weights\nare negative or are floating point numbers\n(overflows and roundoff errors can cause problems).\n\nSee Also\n--------\nsingle_source_dijkstra_path\nsingle_source_dijkstra_path_length\nsingle_source_bellman_ford"}, {"type": "function", "name": "networkx.single_source_dijkstra_path", "documentation": "Find shortest weighted paths in G from a source node.\n\nCompute shortest path between source and all other reachable\nnodes for a weighted graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n    Starting node for path.\n\ncutoff : integer or float, optional\n    Length (sum of edge weights) at which the search is stopped.\n    If cutoff is provided, only return paths with summed weight <= cutoff.\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number or None to indicate a hidden edge.\n\nReturns\n-------\npaths : dictionary\n    Dictionary of shortest path lengths keyed by target.\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> path = nx.single_source_dijkstra_path(G, 0)\n>>> path[4]\n[0, 1, 2, 3, 4]\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe weight function can be used to hide edges by returning None.\nSo ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\nwill find the shortest red path.\n\nSee Also\n--------\nsingle_source_dijkstra, single_source_bellman_ford"}, {"type": "function", "name": "networkx.single_source_dijkstra_path_length", "documentation": "Find shortest weighted path lengths in G from a source node.\n\nCompute the shortest path length between source and all other\nreachable nodes for a weighted graph.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node label\n    Starting node for path\n\ncutoff : integer or float, optional\n    Length (sum of edge weights) at which the search is stopped.\n    If cutoff is provided, only return paths with summed weight <= cutoff.\n\nweight : string or function\n    If this is a string, then edge weights will be accessed via the\n    edge attribute with this key (that is, the weight of the edge\n    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no\n    such edge attribute exists, the weight of the edge is assumed to\n    be one.\n\n    If this is a function, the weight of an edge is the value\n    returned by the function. The function must accept exactly three\n    positional arguments: the two endpoints of an edge and the\n    dictionary of edge attributes for that edge. The function must\n    return a number or None to indicate a hidden edge.\n\nReturns\n-------\nlength : dict\n    Dict keyed by node to shortest path length from source.\n\nRaises\n------\nNodeNotFound\n    If `source` is not in `G`.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> length = nx.single_source_dijkstra_path_length(G, 0)\n>>> length[4]\n4\n>>> for node in [0, 1, 2, 3, 4]:\n...     print(f\"{node}: {length[node]}\")\n0: 0\n1: 1\n2: 2\n3: 3\n4: 4\n\nNotes\n-----\nEdge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.\n\nThe weight function can be used to hide edges by returning None.\nSo ``weight = lambda u, v, d: 1 if d['color']==\"red\" else None``\nwill find the shortest red path.\n\nSee Also\n--------\nsingle_source_dijkstra, single_source_bellman_ford_path_length"}, {"type": "function", "name": "networkx.single_source_shortest_path", "documentation": "Compute shortest path between source\nand all other nodes reachable from source.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node label\n   Starting node for path\n\ncutoff : integer, optional\n    Depth to stop the search. Only paths of length <= cutoff are returned.\n\nReturns\n-------\npaths : dictionary\n    Dictionary, keyed by target, of shortest paths.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> path = nx.single_source_shortest_path(G, 0)\n>>> path[4]\n[0, 1, 2, 3, 4]\n\nNotes\n-----\nThe shortest path is not necessarily unique. So there can be multiple\npaths between the source and each target node, all of which have the\nsame 'shortest' length. For each target node, this function returns\nonly one of those paths.\n\nSee Also\n--------\nshortest_path"}, {"type": "function", "name": "networkx.single_source_shortest_path_length", "documentation": "Compute the shortest path lengths from source to all reachable nodes.\n\nParameters\n----------\nG : NetworkX graph\n\nsource : node\n   Starting node for path\n\ncutoff : integer, optional\n    Depth to stop the search. Only paths of length <= cutoff are returned.\n\nReturns\n-------\nlengths : dict\n    Dict keyed by node to shortest path length to source.\n\nExamples\n--------\n>>> G = nx.path_graph(5)\n>>> length = nx.single_source_shortest_path_length(G, 0)\n>>> length[4]\n4\n>>> for node in length:\n...     print(f\"{node}: {length[node]}\")\n0: 0\n1: 1\n2: 2\n3: 3\n4: 4\n\nSee Also\n--------\nshortest_path_length"}, {"type": "function", "name": "networkx.single_target_shortest_path", "documentation": "Compute shortest path to target from all nodes that reach target.\n\nParameters\n----------\nG : NetworkX graph\n\ntarget : node label\n   Target node for path\n\ncutoff : integer, optional\n    Depth to stop the search. Only paths of length <= cutoff are returned.\n\nReturns\n-------\npaths : dictionary\n    Dictionary, keyed by target, of shortest paths.\n\nExamples\n--------\n>>> G = nx.path_graph(5, create_using=nx.DiGraph())\n>>> path = nx.single_target_shortest_path(G, 4)\n>>> path[0]\n[0, 1, 2, 3, 4]\n\nNotes\n-----\nThe shortest path is not necessarily unique. So there can be multiple\npaths between the source and each target node, all of which have the\nsame 'shortest' length. For each target node, this function returns\nonly one of those paths.\n\nSee Also\n--------\nshortest_path, single_source_shortest_path"}, {"type": "function", "name": "networkx.single_target_shortest_path_length", "documentation": "Compute the shortest path lengths to target from all reachable nodes.\n\nParameters\n----------\nG : NetworkX graph\n\ntarget : node\n   Target node for path\n\ncutoff : integer, optional\n    Depth to stop the search. Only paths of length <= cutoff are returned.\n\nReturns\n-------\nlengths : iterator\n    (source, shortest path length) iterator\n\nExamples\n--------\n>>> G = nx.path_graph(5, create_using=nx.DiGraph())\n>>> length = dict(nx.single_target_shortest_path_length(G, 4))\n>>> length[0]\n4\n>>> for node in range(5):\n...     print(f\"{node}: {length[node]}\")\n0: 4\n1: 3\n2: 2\n3: 1\n4: 0\n\nSee Also\n--------\nsingle_source_shortest_path_length, shortest_path_length"}, {"type": "function", "name": "networkx.snap_aggregation", "documentation": "Creates a summary graph based on attributes and connectivity.\n\nThis function uses the Summarization by Grouping Nodes on Attributes\nand Pairwise edges (SNAP) algorithm for summarizing a given\ngraph by grouping nodes by node attributes and their edge attributes\ninto supernodes in a summary graph.  This name SNAP should not be\nconfused with the Stanford Network Analysis Project (SNAP).\n\nHere is a high-level view of how this algorithm works:\n\n1) Group nodes by node attribute values.\n\n2) Iteratively split groups until all nodes in each group have edges\nto nodes in the same groups. That is, until all the groups are homogeneous\nin their member nodes' edges to other groups.  For example,\nif all the nodes in group A only have edge to nodes in group B, then the\ngroup is homogeneous and does not need to be split. If all nodes in group B\nhave edges with nodes in groups {A, C}, but some also have edges with other\nnodes in B, then group B is not homogeneous and needs to be split into\ngroups have edges with {A, C} and a group of nodes having\nedges with {A, B, C}.  This way, viewers of the summary graph can\nassume that all nodes in the group have the exact same node attributes and\nthe exact same edges.\n\n3) Build the output summary graph, where the groups are represented by\nsuper-nodes. Edges represent the edges shared between all the nodes in each\nrespective groups.\n\nA SNAP summary graph can be used to visualize graphs that are too large to display\nor visually analyze, or to efficiently identify sets of similar nodes with similar connectivity\npatterns to other sets of similar nodes based on specified node and/or edge attributes in a graph.\n\nParameters\n----------\nG: graph\n    Networkx Graph to be summarized\nnode_attributes: iterable, required\n    An iterable of the node attributes used to group nodes in the summarization process. Nodes\n    with the same values for these attributes will be grouped together in the summary graph.\nedge_attributes: iterable, optional\n    An iterable of the edge attributes considered in the summarization process.  If provided, unique\n    combinations of the attribute values found in the graph are used to\n    determine the edge types in the graph.  If not provided, all edges\n    are considered to be of the same type.\nprefix: str\n    The prefix used to denote supernodes in the summary graph. Defaults to 'Supernode-'.\nsupernode_attribute: str\n    The node attribute for recording the supernode groupings of nodes. Defaults to 'group'.\nsuperedge_attribute: str\n    The edge attribute for recording the edge types of multiple edges. Defaults to 'types'.\n\nReturns\n-------\nnetworkx.Graph: summary graph\n\nExamples\n--------\nSNAP aggregation takes a graph and summarizes it in the context of user-provided\nnode and edge attributes such that a viewer can more easily extract and\nanalyze the information represented by the graph\n\n>>> nodes = {\n...     \"A\": dict(color=\"Red\"),\n...     \"B\": dict(color=\"Red\"),\n...     \"C\": dict(color=\"Red\"),\n...     \"D\": dict(color=\"Red\"),\n...     \"E\": dict(color=\"Blue\"),\n...     \"F\": dict(color=\"Blue\"),\n... }\n>>> edges = [\n...     (\"A\", \"E\", \"Strong\"),\n...     (\"B\", \"F\", \"Strong\"),\n...     (\"C\", \"E\", \"Weak\"),\n...     (\"D\", \"F\", \"Weak\"),\n... ]\n>>> G = nx.Graph()\n>>> for node in nodes:\n...     attributes = nodes[node]\n...     G.add_node(node, **attributes)\n>>> for source, target, type in edges:\n...     G.add_edge(source, target, type=type)\n>>> node_attributes = (\"color\",)\n>>> edge_attributes = (\"type\",)\n>>> summary_graph = nx.snap_aggregation(\n...     G, node_attributes=node_attributes, edge_attributes=edge_attributes\n... )\n\nNotes\n-----\nThe summary graph produced is called a maximum Attribute-edge\ncompatible (AR-compatible) grouping.  According to [1]_, an\nAR-compatible grouping means that all nodes in each group have the same\nexact node attribute values and the same exact edges and\nedge types to one or more nodes in the same groups.  The maximal\nAR-compatible grouping is the grouping with the minimal cardinality.\n\nThe AR-compatible grouping is the most detailed grouping provided by\nany of the SNAP algorithms.\n\nReferences\n----------\n.. [1] Y. Tian, R. A. Hankins, and J. M. Patel. Efficient aggregation\n   for graph summarization. In Proc. 2008 ACM-SIGMOD Int. Conf.\n   Management of Data (SIGMOD\u201908), pages 567\u2013580, Vancouver, Canada,\n   June 2008."}, {"type": "function", "name": "networkx.soft_random_geometric_graph", "documentation": "Returns a soft random geometric graph in the unit cube.\n\nThe soft random geometric graph [1] model places `n` nodes uniformly at\nrandom in the unit cube in dimension `dim`. Two nodes of distance, `dist`,\ncomputed by the `p`-Minkowski distance metric are joined by an edge with\nprobability `p_dist` if the computed distance metric value of the nodes\nis at most `radius`, otherwise they are not joined.\n\nEdges within `radius` of each other are determined using a KDTree when\nSciPy is available. This reduces the time complexity from :math:`O(n^2)`\nto :math:`O(n)`.\n\nParameters\n----------\nn : int or iterable\n    Number of nodes or iterable of nodes\nradius: float\n    Distance threshold value\ndim : int, optional\n    Dimension of graph\npos : dict, optional\n    A dictionary keyed by node with node positions as values.\np : float, optional\n    Which Minkowski distance metric to use.\n    `p` has to meet the condition ``1 <= p <= infinity``.\n\n    If this argument is not specified, the :math:`L^2` metric\n    (the Euclidean distance metric), p = 2 is used.\n\n    This should not be confused with the `p` of an Erd\u0151s-R\u00e9nyi random\n    graph, which represents probability.\np_dist : function, optional\n    A probability density function computing the probability of\n    connecting two nodes that are of distance, dist, computed by the\n    Minkowski distance metric. The probability density function, `p_dist`,\n    must be any function that takes the metric value as input\n    and outputs a single probability value between 0-1. The scipy.stats\n    package has many probability distribution functions implemented and\n    tools for custom probability distribution definitions [2], and passing\n    the .pdf method of scipy.stats distributions can be used here.  If the\n    probability function, `p_dist`, is not supplied, the default function\n    is an exponential distribution with rate parameter :math:`\\lambda=1`.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\npos_name : string, default=\"pos\"\n    The name of the node attribute which represents the position\n    in 2D coordinates of the node in the returned graph.\n\nReturns\n-------\nGraph\n    A soft random geometric graph, undirected and without self-loops.\n    Each node has a node attribute ``'pos'`` that stores the\n    position of that node in Euclidean space as provided by the\n    ``pos`` keyword argument or, if ``pos`` was not provided, as\n    generated by this function.\n\nExamples\n--------\nDefault Graph:\n\nG = nx.soft_random_geometric_graph(50, 0.2)\n\nCustom Graph:\n\nCreate a soft random geometric graph on 100 uniformly distributed nodes\nwhere nodes are joined by an edge with probability computed from an\nexponential distribution with rate parameter :math:`\\lambda=1` if their\nEuclidean distance is at most 0.2.\n\nNotes\n-----\nThis uses a *k*-d tree to build the graph.\n\nThe `pos` keyword argument can be used to specify node positions so you\ncan create an arbitrary distribution and domain for positions.\n\nFor example, to use a 2D Gaussian distribution of node positions with mean\n(0, 0) and standard deviation 2\n\nThe scipy.stats package can be used to define the probability distribution\nwith the .pdf method used as `p_dist`.\n\n::\n\n>>> import random\n>>> import math\n>>> n = 100\n>>> pos = {i: (random.gauss(0, 2), random.gauss(0, 2)) for i in range(n)}\n>>> p_dist = lambda dist: math.exp(-dist)\n>>> G = nx.soft_random_geometric_graph(n, 0.2, pos=pos, p_dist=p_dist)\n\nReferences\n----------\n.. [1] Penrose, Mathew D. \"Connectivity of soft random geometric graphs.\"\n       The Annals of Applied Probability 26.2 (2016): 986-1028.\n.. [2] scipy.stats -\n       https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html"}, {"type": "function", "name": "networkx.spanner", "documentation": "Returns a spanner of the given graph with the given stretch.\n\nA spanner of a graph G = (V, E) with stretch t is a subgraph\nH = (V, E_S) such that E_S is a subset of E and the distance between\nany pair of nodes in H is at most t times the distance between the\nnodes in G.\n\nParameters\n----------\nG : NetworkX graph\n    An undirected simple graph.\n\nstretch : float\n    The stretch of the spanner.\n\nweight : object\n    The edge attribute to use as distance.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nNetworkX graph\n    A spanner of the given graph with the given stretch.\n\nRaises\n------\nValueError\n    If a stretch less than 1 is given.\n\nNotes\n-----\nThis function implements the spanner algorithm by Baswana and Sen,\nsee [1].\n\nThis algorithm is a randomized las vegas algorithm: The expected\nrunning time is O(km) where k = (stretch + 1) // 2 and m is the\nnumber of edges in G. The returned graph is always a spanner of the\ngiven graph with the specified stretch. For weighted graphs the\nnumber of edges in the spanner is O(k * n^(1 + 1 / k)) where k is\ndefined as above and n is the number of nodes in G. For unweighted\ngraphs the number of edges is O(n^(1 + 1 / k) + kn).\n\nReferences\n----------\n[1] S. Baswana, S. Sen. A Simple and Linear Time Randomized\nAlgorithm for Computing Sparse Spanners in Weighted Graphs.\nRandom Struct. Algorithms 30(4): 532-563 (2007)."}, {"type": "function", "name": "networkx.spectral_bisection", "documentation": "Bisect the graph using the Fiedler vector.\n\nThis method uses the Fiedler vector to bisect a graph.\nThe partition is defined by the nodes which are associated with\neither positive or negative values in the vector.\n\nParameters\n----------\nG : NetworkX Graph\n\nweight : str, optional (default: weight)\n    The data key used to determine the weight of each edge. If None, then\n    each edge has unit weight.\n\nnormalized : bool, optional (default: False)\n    Whether the normalized Laplacian matrix is used.\n\ntol : float, optional (default: 1e-8)\n    Tolerance of relative residual in eigenvalue computation.\n\nmethod : string, optional (default: 'tracemin_pcg')\n    Method of eigenvalue computation. It must be one of the tracemin\n    options shown below (TraceMIN), 'lanczos' (Lanczos iteration)\n    or 'lobpcg' (LOBPCG).\n\n    The TraceMIN algorithm uses a linear system solver. The following\n    values allow specifying the solver to be used.\n\n    =============== ========================================\n    Value           Solver\n    =============== ========================================\n    'tracemin_pcg'  Preconditioned conjugate gradient method\n    'tracemin_lu'   LU factorization\n    =============== ========================================\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nbisection : tuple of sets\n    Sets with the bisection of nodes\n\nExamples\n--------\n>>> G = nx.barbell_graph(3, 0)\n>>> nx.spectral_bisection(G)\n({0, 1, 2}, {3, 4, 5})\n\nReferences\n----------\n.. [1] M. E. J Newman 'Networks: An Introduction', pages 364-370\n   Oxford University Press 2011."}, {"type": "function", "name": "networkx.spectral_graph_forge", "documentation": "Returns a random simple graph with spectrum resembling that of `G`\n\nThis algorithm, called Spectral Graph Forge (SGF), computes the\neigenvectors of a given graph adjacency matrix, filters them and\nbuilds a random graph with a similar eigenstructure.\nSGF has been proved to be particularly useful for synthesizing\nrealistic social networks and it can also be used to anonymize\ngraph sensitive data.\n\nParameters\n----------\nG : Graph\nalpha :  float\n    Ratio representing the percentage of eigenvectors of G to consider,\n    values in [0,1].\ntransformation : string, optional\n    Represents the intended matrix linear transformation, possible values\n    are 'identity' and 'modularity'\nseed : integer, random_state, or None (default)\n    Indicator of numpy random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nH : Graph\n    A graph with a similar eigenvector structure of the input one.\n\nRaises\n------\nNetworkXError\n    If transformation has a value different from 'identity' or 'modularity'\n\nNotes\n-----\nSpectral Graph Forge (SGF) generates a random simple graph resembling the\nglobal properties of the given one.\nIt leverages the low-rank approximation of the associated adjacency matrix\ndriven by the *alpha* precision parameter.\nSGF preserves the number of nodes of the input graph and their ordering.\nThis way, nodes of output graphs resemble the properties of the input one\nand attributes can be directly mapped.\n\nIt considers the graph adjacency matrices which can optionally be\ntransformed to other symmetric real matrices (currently transformation\noptions include *identity* and *modularity*).\nThe *modularity* transformation, in the sense of Newman's modularity matrix\nallows the focusing on community structure related properties of the graph.\n\nSGF applies a low-rank approximation whose fixed rank is computed from the\nratio *alpha* of the input graph adjacency matrix dimension.\nThis step performs a filtering on the input eigenvectors similar to the low\npass filtering common in telecommunications.\n\nThe filtered values (after truncation) are used as input to a Bernoulli\nsampling for constructing a random adjacency matrix.\n\nReferences\n----------\n..  [1] L. Baldesi, C. T. Butts, A. Markopoulou, \"Spectral Graph Forge:\n    Graph Generation Targeting Modularity\", IEEE Infocom, '18.\n    https://arxiv.org/abs/1801.01715\n..  [2] M. Newman, \"Networks: an introduction\", Oxford university press,\n    2010\n\nExamples\n--------\n>>> G = nx.karate_club_graph()\n>>> H = nx.spectral_graph_forge(G, 0.3)\n>>>"}, {"type": "function", "name": "networkx.spectral_layout", "documentation": "Position nodes using the eigenvectors of the graph Laplacian.\n\nUsing the unnormalized Laplacian, the layout shows possible clusters of\nnodes which are an approximation of the ratio cut. If dim is the number of\ndimensions then the positions are the entries of the dim eigenvectors\ncorresponding to the ascending eigenvalues starting from the second one.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\nweight : string or None   optional (default='weight')\n    The edge attribute that holds the numerical value used for\n    the edge weight.  If None, then all edge weights are 1.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\ndim : int\n    Dimension of layout.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.spectral_layout(G)\n\nNotes\n-----\nDirected graphs will be considered as undirected graphs when\npositioning the nodes.\n\nFor larger graphs (>500 nodes) this will use the SciPy sparse\neigenvalue solver (ARPACK)."}, {"type": "function", "name": "networkx.spectral_ordering", "documentation": "Compute the spectral_ordering of a graph.\n\nThe spectral ordering of a graph is an ordering of its nodes where nodes\nin the same weakly connected components appear contiguous and ordered by\ntheir corresponding elements in the Fiedler vector of the component.\n\nParameters\n----------\nG : NetworkX graph\n    A graph.\n\nweight : object, optional (default: None)\n    The data key used to determine the weight of each edge. If None, then\n    each edge has unit weight.\n\nnormalized : bool, optional (default: False)\n    Whether the normalized Laplacian matrix is used.\n\ntol : float, optional (default: 1e-8)\n    Tolerance of relative residual in eigenvalue computation.\n\nmethod : string, optional (default: 'tracemin_pcg')\n    Method of eigenvalue computation. It must be one of the tracemin\n    options shown below (TraceMIN), 'lanczos' (Lanczos iteration)\n    or 'lobpcg' (LOBPCG).\n\n    The TraceMIN algorithm uses a linear system solver. The following\n    values allow specifying the solver to be used.\n\n    =============== ========================================\n    Value           Solver\n    =============== ========================================\n    'tracemin_pcg'  Preconditioned conjugate gradient method\n    'tracemin_lu'   LU factorization\n    =============== ========================================\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nspectral_ordering : NumPy array of floats.\n    Spectral ordering of nodes.\n\nRaises\n------\nNetworkXError\n    If G is empty.\n\nNotes\n-----\nEdge weights are interpreted by their absolute values. For MultiGraph's,\nweights of parallel edges are summed. Zero-weighted edges are ignored.\n\nSee Also\n--------\nlaplacian_matrix"}, {"type": "function", "name": "networkx.spiral_layout", "documentation": "Position nodes in a spiral layout.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\nscale : number (default: 1)\n    Scale factor for positions.\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\ndim : int, default=2\n    Dimension of layout, currently only dim=2 is supported.\n    Other dimension values result in a ValueError.\nresolution : float, default=0.35\n    The compactness of the spiral layout returned.\n    Lower values result in more compressed spiral layouts.\nequidistant : bool, default=False\n    If True, nodes will be positioned equidistant from each other\n    by decreasing angle further from center.\n    If False, nodes will be positioned at equal angles\n    from each other by increasing separation further from center.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nRaises\n------\nValueError\n    If dim != 2\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.spiral_layout(G)\n>>> nx.draw(G, pos=pos)\n\nNotes\n-----\nThis algorithm currently only works in two dimensions."}, {"type": "function", "name": "networkx.spring_layout", "documentation": "Position nodes using Fruchterman-Reingold force-directed algorithm.\n\nThe algorithm simulates a force-directed representation of the network\ntreating edges as springs holding nodes close, while treating nodes\nas repelling objects, sometimes called an anti-gravity force.\nSimulation continues until the positions are close to an equilibrium.\n\nThere are some hard-coded values: minimal distance between\nnodes (0.01) and \"temperature\" of 0.1 to ensure nodes don't fly away.\nDuring the simulation, `k` helps determine the distance between nodes,\nthough `scale` and `center` determine the size and place after\nrescaling occurs at the end of the simulation.\n\nFixing some nodes doesn't allow them to move in the simulation.\nIt also turns off the rescaling feature at the simulation's end.\nIn addition, setting `scale` to `None` turns off rescaling.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\nk : float (default=None)\n    Optimal distance between nodes.  If None the distance is set to\n    1/sqrt(n) where n is the number of nodes.  Increase this value\n    to move nodes farther apart.\n\npos : dict or None  optional (default=None)\n    Initial positions for nodes as a dictionary with node as keys\n    and values as a coordinate list or tuple.  If None, then use\n    random initial positions.\n\nfixed : list or None  optional (default=None)\n    Nodes to keep fixed at initial position.\n    Nodes not in ``G.nodes`` are ignored.\n    ValueError raised if `fixed` specified and `pos` not.\n\niterations : int  optional (default=50)\n    Maximum number of iterations taken\n\nthreshold: float optional (default = 1e-4)\n    Threshold for relative error in node position changes.\n    The iteration stops if the error is below this threshold.\n\nweight : string or None   optional (default='weight')\n    The edge attribute that holds the numerical value used for\n    the edge weight.  Larger means a stronger attractive force.\n    If None, then all edge weights are 1.\n\nscale : number or None (default: 1)\n    Scale factor for positions. Not used unless `fixed is None`.\n    If scale is None, no rescaling is performed.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n    Not used unless `fixed is None`.\n\ndim : int\n    Dimension of layout.\n\nseed : int, RandomState instance or None  optional (default=None)\n    Set the random state for deterministic node layouts.\n    If int, `seed` is the seed used by the random number generator,\n    if numpy.random.RandomState instance, `seed` is the random\n    number generator,\n    if None, the random number generator is the RandomState instance used\n    by numpy.random.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.spring_layout(G)\n\n# The same using longer but equivalent function name\n>>> pos = nx.fruchterman_reingold_layout(G)"}, {"type": "function", "name": "networkx.square_clustering", "documentation": "Compute the squares clustering coefficient for nodes.\n\nFor each node return the fraction of possible squares that exist at\nthe node [1]_\n\n.. math::\n   C_4(v) = \\frac{ \\sum_{u=1}^{k_v}\n   \\sum_{w=u+1}^{k_v} q_v(u,w) }{ \\sum_{u=1}^{k_v}\n   \\sum_{w=u+1}^{k_v} [a_v(u,w) + q_v(u,w)]},\n\nwhere :math:`q_v(u,w)` are the number of common neighbors of :math:`u` and\n:math:`w` other than :math:`v` (ie squares), and :math:`a_v(u,w) = (k_u -\n(1+q_v(u,w)+\\theta_{uv})) + (k_w - (1+q_v(u,w)+\\theta_{uw}))`, where\n:math:`\\theta_{uw} = 1` if :math:`u` and :math:`w` are connected and 0\notherwise. [2]_\n\nParameters\n----------\nG : graph\n\nnodes : container of nodes, optional (default=all nodes in G)\n   Compute clustering for nodes in this container.\n\nReturns\n-------\nc4 : dictionary\n   A dictionary keyed by node with the square clustering coefficient value.\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> print(nx.square_clustering(G, 0))\n1.0\n>>> print(nx.square_clustering(G))\n{0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}\n\nNotes\n-----\nWhile :math:`C_3(v)` (triangle clustering) gives the probability that\ntwo neighbors of node v are connected with each other, :math:`C_4(v)` is\nthe probability that two neighbors of node v share a common\nneighbor different from v. This algorithm can be applied to both\nbipartite and unipartite networks.\n\nReferences\n----------\n.. [1] Pedro G. Lind, Marta C. Gonz\u00e1lez, and Hans J. Herrmann. 2005\n    Cycles and clustering in bipartite networks.\n    Physical Review E (72) 056127.\n.. [2] Zhang, Peng et al. Clustering Coefficient and Community Structure of\n    Bipartite Networks. Physica A: Statistical Mechanics and its Applications 387.27 (2008): 6869\u20136875.\n    https://arxiv.org/abs/0710.0117v1"}, {"type": "function", "name": "networkx.star_graph", "documentation": "Return the star graph\n\nThe star graph consists of one center node connected to n outer nodes.\n\n.. plot::\n\n    >>> nx.draw(nx.star_graph(6))\n\nParameters\n----------\nn : int or iterable\n    If an integer, node labels are 0 to n with center 0.\n    If an iterable of nodes, the center is the first.\n    Warning: n is not checked for duplicates and if present the\n    resulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nNotes\n-----\nThe graph has n+1 nodes for integer n.\nSo star_graph(3) is the same as star_graph(range(4))."}, {"type": "function", "name": "networkx.stochastic_block_model", "documentation": "Returns a stochastic block model graph.\n\nThis model partitions the nodes in blocks of arbitrary sizes, and places\nedges between pairs of nodes independently, with a probability that depends\non the blocks.\n\nParameters\n----------\nsizes : list of ints\n    Sizes of blocks\np : list of list of floats\n    Element (r,s) gives the density of edges going from the nodes\n    of group r to nodes of group s.\n    p must match the number of groups (len(sizes) == len(p)),\n    and it must be symmetric if the graph is undirected.\nnodelist : list, optional\n    The block tags are assigned according to the node identifiers\n    in nodelist. If nodelist is None, then the ordering is the\n    range [0,sum(sizes)-1].\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ndirected : boolean optional, default=False\n    Whether to create a directed graph or not.\nselfloops : boolean optional, default=False\n    Whether to include self-loops or not.\nsparse: boolean optional, default=True\n    Use the sparse heuristic to speed up the generator.\n\nReturns\n-------\ng : NetworkX Graph or DiGraph\n    Stochastic block model graph of size sum(sizes)\n\nRaises\n------\nNetworkXError\n  If probabilities are not in [0,1].\n  If the probability matrix is not square (directed case).\n  If the probability matrix is not symmetric (undirected case).\n  If the sizes list does not match nodelist or the probability matrix.\n  If nodelist contains duplicate.\n\nExamples\n--------\n>>> sizes = [75, 75, 300]\n>>> probs = [[0.25, 0.05, 0.02], [0.05, 0.35, 0.07], [0.02, 0.07, 0.40]]\n>>> g = nx.stochastic_block_model(sizes, probs, seed=0)\n>>> len(g)\n450\n>>> H = nx.quotient_graph(g, g.graph[\"partition\"], relabel=True)\n>>> for v in H.nodes(data=True):\n...     print(round(v[1][\"density\"], 3))\n0.245\n0.348\n0.405\n>>> for v in H.edges(data=True):\n...     print(round(1.0 * v[2][\"weight\"] / (sizes[v[0]] * sizes[v[1]]), 3))\n0.051\n0.022\n0.07\n\nSee Also\n--------\nrandom_partition_graph\nplanted_partition_graph\ngaussian_random_partition_graph\ngnp_random_graph\n\nReferences\n----------\n.. [1] Holland, P. W., Laskey, K. B., & Leinhardt, S.,\n       \"Stochastic blockmodels: First steps\",\n       Social networks, 5(2), 109-137, 1983."}, {"type": "function", "name": "networkx.stochastic_graph", "documentation": "Returns a right-stochastic representation of directed graph `G`.\n\nA right-stochastic graph is a weighted digraph in which for each\nnode, the sum of the weights of all the out-edges of that node is\n1. If the graph is already weighted (for example, via a 'weight'\nedge attribute), the reweighting takes that into account.\n\nParameters\n----------\nG : directed graph\n    A :class:`~networkx.DiGraph` or :class:`~networkx.MultiDiGraph`.\n\ncopy : boolean, optional\n    If this is True, then this function returns a new graph with\n    the stochastic reweighting. Otherwise, the original graph is\n    modified in-place (and also returned, for convenience).\n\nweight : edge attribute key (optional, default='weight')\n    Edge attribute key used for reading the existing weight and\n    setting the new weight.  If no attribute with this key is found\n    for an edge, then the edge weight is assumed to be 1. If an edge\n    has a weight, it must be a positive number."}, {"type": "function", "name": "networkx.stoer_wagner", "documentation": "Returns the weighted minimum edge cut using the Stoer-Wagner algorithm.\n\nDetermine the minimum edge cut of a connected graph using the\nStoer-Wagner algorithm. In weighted cases, all weights must be\nnonnegative.\n\nThe running time of the algorithm depends on the type of heaps used:\n\n============== =============================================\nType of heap   Running time\n============== =============================================\nBinary heap    $O(n (m + n) \\log n)$\nFibonacci heap $O(nm + n^2 \\log n)$\nPairing heap   $O(2^{2 \\sqrt{\\log \\log n}} nm + n^2 \\log n)$\n============== =============================================\n\nParameters\n----------\nG : NetworkX graph\n    Edges of the graph are expected to have an attribute named by the\n    weight parameter below. If this attribute is not present, the edge is\n    considered to have unit weight.\n\nweight : string\n    Name of the weight attribute of the edges. If the attribute is not\n    present, unit weight is assumed. Default value: 'weight'.\n\nheap : class\n    Type of heap to be used in the algorithm. It should be a subclass of\n    :class:`MinHeap` or implement a compatible interface.\n\n    If a stock heap implementation is to be used, :class:`BinaryHeap` is\n    recommended over :class:`PairingHeap` for Python implementations without\n    optimized attribute accesses (e.g., CPython) despite a slower\n    asymptotic running time. For Python implementations with optimized\n    attribute accesses (e.g., PyPy), :class:`PairingHeap` provides better\n    performance. Default value: :class:`BinaryHeap`.\n\nReturns\n-------\ncut_value : integer or float\n    The sum of weights of edges in a minimum cut.\n\npartition : pair of node lists\n    A partitioning of the nodes that defines a minimum cut.\n\nRaises\n------\nNetworkXNotImplemented\n    If the graph is directed or a multigraph.\n\nNetworkXError\n    If the graph has less than two nodes, is not connected or has a\n    negative-weighted edge.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_edge(\"x\", \"a\", weight=3)\n>>> G.add_edge(\"x\", \"b\", weight=1)\n>>> G.add_edge(\"a\", \"c\", weight=3)\n>>> G.add_edge(\"b\", \"c\", weight=5)\n>>> G.add_edge(\"b\", \"d\", weight=4)\n>>> G.add_edge(\"d\", \"e\", weight=2)\n>>> G.add_edge(\"c\", \"y\", weight=2)\n>>> G.add_edge(\"e\", \"y\", weight=3)\n>>> cut_value, partition = nx.stoer_wagner(G)\n>>> cut_value\n4"}, {"type": "function", "name": "networkx.strong_product", "documentation": "Returns the strong product of G and H.\n\nThe strong product $P$ of the graphs $G$ and $H$ has a node set that\nis the Cartesian product of the node sets, $V(P)=V(G) \\times V(H)$.\n$P$ has an edge $((u,v), (x,y))$ if and only if\n$u==v$ and $(x,y)$ is an edge in $H$, or\n$x==y$ and $(u,v)$ is an edge in $G$, or\n$(u,v)$ is an edge in $G$ and $(x,y)$ is an edge in $H$.\n\nParameters\n----------\nG, H: graphs\n Networkx graphs.\n\nReturns\n-------\nP: NetworkX graph\n The Cartesian product of G and H. P will be a multi-graph if either G\n or H is a multi-graph. Will be a directed if G and H are directed,\n and undirected if G and H are undirected.\n\nRaises\n------\nNetworkXError\n If G and H are not both directed or both undirected.\n\nNotes\n-----\nNode attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> H = nx.Graph()\n>>> G.add_node(0, a1=True)\n>>> H.add_node(\"a\", a2=\"Spam\")\n>>> P = nx.strong_product(G, H)\n>>> list(P)\n[(0, 'a')]\n\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph"}, {"type": "function", "name": "networkx.strongly_connected_components", "documentation": "Generate nodes in strongly connected components of graph.\n\nParameters\n----------\nG : NetworkX Graph\n    A directed graph.\n\nReturns\n-------\ncomp : generator of sets\n    A generator of sets of nodes, one for each strongly connected\n    component of G.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is undirected.\n\nExamples\n--------\nGenerate a sorted list of strongly connected components, largest first.\n\n>>> G = nx.cycle_graph(4, create_using=nx.DiGraph())\n>>> nx.add_cycle(G, [10, 11, 12])\n>>> [len(c) for c in sorted(nx.strongly_connected_components(G), key=len, reverse=True)]\n[4, 3]\n\nIf you only want the largest component, it's more efficient to\nuse max instead of sort.\n\n>>> largest = max(nx.strongly_connected_components(G), key=len)\n\nSee Also\n--------\nconnected_components\nweakly_connected_components\nkosaraju_strongly_connected_components\n\nNotes\n-----\nUses Tarjan's algorithm[1]_ with Nuutila's modifications[2]_.\nNonrecursive version of algorithm.\n\nReferences\n----------\n.. [1] Depth-first search and linear graph algorithms, R. Tarjan\n   SIAM Journal of Computing 1(2):146-160, (1972).\n\n.. [2] On finding the strongly connected components in a directed graph.\n   E. Nuutila and E. Soisalon-Soinen\n   Information Processing Letters 49(1): 9-14, (1994).."}, {"type": "function", "name": "networkx.strongly_connected_components_recursive", "documentation": "Generate nodes in strongly connected components of graph.\n\n.. deprecated:: 3.2\n\n   This function is deprecated and will be removed in a future version of\n   NetworkX. Use `strongly_connected_components` instead.\n\nRecursive version of algorithm.\n\nParameters\n----------\nG : NetworkX Graph\n    A directed graph.\n\nReturns\n-------\ncomp : generator of sets\n    A generator of sets of nodes, one for each strongly connected\n    component of G.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is undirected.\n\nExamples\n--------\nGenerate a sorted list of strongly connected components, largest first.\n\n>>> G = nx.cycle_graph(4, create_using=nx.DiGraph())\n>>> nx.add_cycle(G, [10, 11, 12])\n>>> [\n...     len(c)\n...     for c in sorted(\n...         nx.strongly_connected_components_recursive(G), key=len, reverse=True\n...     )\n... ]\n[4, 3]\n\nIf you only want the largest component, it's more efficient to\nuse max instead of sort.\n\n>>> largest = max(nx.strongly_connected_components_recursive(G), key=len)\n\nTo create the induced subgraph of the components use:\n>>> S = [G.subgraph(c).copy() for c in nx.weakly_connected_components(G)]\n\nSee Also\n--------\nconnected_components\n\nNotes\n-----\nUses Tarjan's algorithm[1]_ with Nuutila's modifications[2]_.\n\nReferences\n----------\n.. [1] Depth-first search and linear graph algorithms, R. Tarjan\n   SIAM Journal of Computing 1(2):146-160, (1972).\n\n.. [2] On finding the strongly connected components in a directed graph.\n   E. Nuutila and E. Soisalon-Soinen\n   Information Processing Letters 49(1): 9-14, (1994).."}, {"type": "function", "name": "networkx.subgraph", "documentation": "Returns the subgraph induced on nodes in nbunch.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nnbunch : list, iterable\n   A container of nodes that will be iterated through once (thus\n   it should be an iterator or be iterable).  Each element of the\n   container should be a valid node type: any hashable type except\n   None.  If nbunch is None, return all edges data in the graph.\n   Nodes in nbunch that are not in the graph will be (quietly)\n   ignored.\n\nNotes\n-----\nsubgraph(G) calls G.subgraph()"}, {"type": "function", "name": "networkx.subgraph_centrality", "documentation": "Returns subgraph centrality for each node in G.\n\nSubgraph centrality  of a node `n` is the sum of weighted closed\nwalks of all lengths starting and ending at node `n`. The weights\ndecrease with path length. Each closed walk is associated with a\nconnected subgraph ([1]_).\n\nParameters\n----------\nG: graph\n\nReturns\n-------\nnodes : dictionary\n   Dictionary of nodes with subgraph centrality as the value.\n\nRaises\n------\nNetworkXError\n   If the graph is not undirected and simple.\n\nSee Also\n--------\nsubgraph_centrality_exp:\n    Alternative algorithm of the subgraph centrality for each node of G.\n\nNotes\n-----\nThis version of the algorithm computes eigenvalues and eigenvectors\nof the adjacency matrix.\n\nSubgraph centrality of a node `u` in G can be found using\na spectral decomposition of the adjacency matrix [1]_,\n\n.. math::\n\n   SC(u)=\\sum_{j=1}^{N}(v_{j}^{u})^2 e^{\\lambda_{j}},\n\nwhere `v_j` is an eigenvector of the adjacency matrix `A` of G\ncorresponding to the eigenvalue `\\lambda_j`.\n\nExamples\n--------\n(Example from [1]_)\n>>> G = nx.Graph(\n...     [\n...         (1, 2),\n...         (1, 5),\n...         (1, 8),\n...         (2, 3),\n...         (2, 8),\n...         (3, 4),\n...         (3, 6),\n...         (4, 5),\n...         (4, 7),\n...         (5, 6),\n...         (6, 7),\n...         (7, 8),\n...     ]\n... )\n>>> sc = nx.subgraph_centrality(G)\n>>> print([f\"{node} {sc[node]:0.2f}\" for node in sorted(sc)])\n['1 3.90', '2 3.90', '3 3.64', '4 3.71', '5 3.64', '6 3.71', '7 3.64', '8 3.90']\n\nReferences\n----------\n.. [1] Ernesto Estrada, Juan A. Rodriguez-Velazquez,\n   \"Subgraph centrality in complex networks\",\n   Physical Review E 71, 056103 (2005).\n   https://arxiv.org/abs/cond-mat/0504730"}, {"type": "function", "name": "networkx.subgraph_centrality_exp", "documentation": "Returns the subgraph centrality for each node of G.\n\nSubgraph centrality  of a node `n` is the sum of weighted closed\nwalks of all lengths starting and ending at node `n`. The weights\ndecrease with path length. Each closed walk is associated with a\nconnected subgraph ([1]_).\n\nParameters\n----------\nG: graph\n\nReturns\n-------\nnodes:dictionary\n    Dictionary of nodes with subgraph centrality as the value.\n\nRaises\n------\nNetworkXError\n    If the graph is not undirected and simple.\n\nSee Also\n--------\nsubgraph_centrality:\n    Alternative algorithm of the subgraph centrality for each node of G.\n\nNotes\n-----\nThis version of the algorithm exponentiates the adjacency matrix.\n\nThe subgraph centrality of a node `u` in G can be found using\nthe matrix exponential of the adjacency matrix of G [1]_,\n\n.. math::\n\n    SC(u)=(e^A)_{uu} .\n\nReferences\n----------\n.. [1] Ernesto Estrada, Juan A. Rodriguez-Velazquez,\n   \"Subgraph centrality in complex networks\",\n   Physical Review E 71, 056103 (2005).\n   https://arxiv.org/abs/cond-mat/0504730\n\nExamples\n--------\n(Example from [1]_)\n>>> G = nx.Graph(\n...     [\n...         (1, 2),\n...         (1, 5),\n...         (1, 8),\n...         (2, 3),\n...         (2, 8),\n...         (3, 4),\n...         (3, 6),\n...         (4, 5),\n...         (4, 7),\n...         (5, 6),\n...         (6, 7),\n...         (7, 8),\n...     ]\n... )\n>>> sc = nx.subgraph_centrality_exp(G)\n>>> print([f\"{node} {sc[node]:0.2f}\" for node in sorted(sc)])\n['1 3.90', '2 3.90', '3 3.64', '4 3.71', '5 3.64', '6 3.71', '7 3.64', '8 3.90']"}, {"type": "function", "name": "networkx.subgraph_view", "documentation": "View of `G` applying a filter on nodes and edges.\n\n`subgraph_view` provides a read-only view of the input graph that excludes\nnodes and edges based on the outcome of two filter functions `filter_node`\nand `filter_edge`.\n\nThe `filter_node` function takes one argument --- the node --- and returns\n`True` if the node should be included in the subgraph, and `False` if it\nshould not be included.\n\nThe `filter_edge` function takes two (or three arguments if `G` is a\nmulti-graph) --- the nodes describing an edge, plus the edge-key if\nparallel edges are possible --- and returns `True` if the edge should be\nincluded in the subgraph, and `False` if it should not be included.\n\nBoth node and edge filter functions are called on graph elements as they\nare queried, meaning there is no up-front cost to creating the view.\n\nParameters\n----------\nG : networkx.Graph\n    A directed/undirected graph/multigraph\n\nfilter_node : callable, optional\n    A function taking a node as input, which returns `True` if the node\n    should appear in the view.\n\nfilter_edge : callable, optional\n    A function taking as input the two nodes describing an edge (plus the\n    edge-key if `G` is a multi-graph), which returns `True` if the edge\n    should appear in the view.\n\nReturns\n-------\ngraph : networkx.Graph\n    A read-only graph view of the input graph.\n\nExamples\n--------\n>>> G = nx.path_graph(6)\n\nFilter functions operate on the node, and return `True` if the node should\nappear in the view:\n\n>>> def filter_node(n1):\n...     return n1 != 5\n>>> view = nx.subgraph_view(G, filter_node=filter_node)\n>>> view.nodes()\nNodeView((0, 1, 2, 3, 4))\n\nWe can use a closure pattern to filter graph elements based on additional\ndata --- for example, filtering on edge data attached to the graph:\n\n>>> G[3][4][\"cross_me\"] = False\n>>> def filter_edge(n1, n2):\n...     return G[n1][n2].get(\"cross_me\", True)\n>>> view = nx.subgraph_view(G, filter_edge=filter_edge)\n>>> view.edges()\nEdgeView([(0, 1), (1, 2), (2, 3), (4, 5)])\n\n>>> view = nx.subgraph_view(\n...     G,\n...     filter_node=filter_node,\n...     filter_edge=filter_edge,\n... )\n>>> view.nodes()\nNodeView((0, 1, 2, 3, 4))\n>>> view.edges()\nEdgeView([(0, 1), (1, 2), (2, 3)])"}, {"type": "function", "name": "networkx.sudoku_graph", "documentation": "Returns the n-Sudoku graph. The default value of n is 3.\n\nThe n-Sudoku graph is a graph with n^4 vertices, corresponding to the\ncells of an n^2 by n^2 grid. Two distinct vertices are adjacent if and\nonly if they belong to the same row, column, or n-by-n box.\n\nParameters\n----------\nn: integer\n   The order of the Sudoku graph, equal to the square root of the\n   number of rows. The default is 3.\n\nReturns\n-------\nNetworkX graph\n    The n-Sudoku graph Sud(n).\n\nExamples\n--------\n>>> G = nx.sudoku_graph()\n>>> G.number_of_nodes()\n81\n>>> G.number_of_edges()\n810\n>>> sorted(G.neighbors(42))\n[6, 15, 24, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44, 51, 52, 53, 60, 69, 78]\n>>> G = nx.sudoku_graph(2)\n>>> G.number_of_nodes()\n16\n>>> G.number_of_edges()\n56\n\nReferences\n----------\n.. [1] Herzberg, A. M., & Murty, M. R. (2007). Sudoku squares and chromatic\n   polynomials. Notices of the AMS, 54(6), 708-717.\n.. [2] Sander, Torsten (2009), \"Sudoku graphs are integral\",\n   Electronic Journal of Combinatorics, 16 (1): Note 25, 7pp, MR 2529816\n.. [3] Wikipedia contributors. \"Glossary of Sudoku.\" Wikipedia, The Free\n   Encyclopedia, 3 Dec. 2019. Web. 22 Dec. 2019."}, {"type": "function", "name": "networkx.symmetric_difference", "documentation": "Returns new graph with edges that exist in either G or H but not both.\n\nThe node sets of H and G must be the same.\n\nParameters\n----------\nG,H : graph\n   A NetworkX graph.  G and H must have the same node sets.\n\nReturns\n-------\nD : A new graph with the same type as G.\n\nNotes\n-----\nAttributes from the graph, nodes, and edges are not copied to the new\ngraph.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (1, 2), (1, 3)])\n>>> H = nx.Graph([(0, 1), (1, 2), (0, 3)])\n>>> R = nx.symmetric_difference(G, H)\n>>> R.nodes\nNodeView((0, 1, 2, 3))\n>>> R.edges\nEdgeView([(0, 2), (0, 3), (1, 3)])"}, {"type": "function", "name": "networkx.tadpole_graph", "documentation": "Returns the (m,n)-tadpole graph; ``C_m`` connected to ``P_n``.\n\nThis graph on m+n nodes connects a cycle of size `m` to a path of length `n`.\nIt looks like a tadpole. It is also called a kite graph or a dragon graph.\n\n.. plot::\n\n    >>> nx.draw(nx.tadpole_graph(3, 5))\n\nParameters\n----------\nm, n : int or iterable container of nodes\n    If an integer, nodes are from ``range(m)`` and ``range(m,m+n)``.\n    If a container of nodes, those nodes appear in the graph.\n    Warning: `m` and `n` are not checked for duplicates and if present the\n    resulting graph may not be as desired.\n\n    The nodes for `m` appear in the cycle graph $C_m$ and the nodes\n    for `n` appear in the path $P_n$.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkx graph\n   A cycle of size `m` connected to a path of length `n`.\n\nRaises\n------\nNetworkXError\n    If ``m < 2``. The tadpole graph is undefined for ``m<2``.\n\nNotes\n-----\nThe 2 subgraphs are joined via an edge ``(m-1, m)``.\nIf ``n=0``, this is a cycle graph.\n`m` and/or `n` can be a container of nodes instead of an integer."}, {"type": "function", "name": "networkx.tensor_product", "documentation": "Returns the tensor product of G and H.\n\nThe tensor product $P$ of the graphs $G$ and $H$ has a node set that\nis the Cartesian product of the node sets, $V(P)=V(G) \\times V(H)$.\n$P$ has an edge $((u,v), (x,y))$ if and only if $(u,x)$ is an edge in $G$\nand $(v,y)$ is an edge in $H$.\n\nTensor product is sometimes also referred to as the categorical product,\ndirect product, cardinal product or conjunction.\n\n\nParameters\n----------\nG, H: graphs\n Networkx graphs.\n\nReturns\n-------\nP: NetworkX graph\n The tensor product of G and H. P will be a multi-graph if either G\n or H is a multi-graph, will be a directed if G and H are directed,\n and undirected if G and H are undirected.\n\nRaises\n------\nNetworkXError\n If G and H are not both directed or both undirected.\n\nNotes\n-----\nNode attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> H = nx.Graph()\n>>> G.add_node(0, a1=True)\n>>> H.add_node(\"a\", a2=\"Spam\")\n>>> P = nx.tensor_product(G, H)\n>>> list(P)\n[(0, 'a')]\n\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph"}, {"type": "function", "name": "networkx.tetrahedral_graph", "documentation": "Returns the 3-regular Platonic Tetrahedral graph.\n\nTetrahedral graph has 4 nodes and 6 edges. It is a\nspecial case of the complete graph, K4, and wheel graph, W4.\nIt is one of the 5 platonic graphs [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Tetrahedral Graph\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Tetrahedron#Tetrahedral_graph"}, {"type": "function", "name": "networkx.thresholded_random_geometric_graph", "documentation": "Returns a thresholded random geometric graph in the unit cube.\n\nThe thresholded random geometric graph [1] model places `n` nodes\nuniformly at random in the unit cube of dimensions `dim`. Each node\n`u` is assigned a weight :math:`w_u`. Two nodes `u` and `v` are\njoined by an edge if they are within the maximum connection distance,\n`radius` computed by the `p`-Minkowski distance and the summation of\nweights :math:`w_u` + :math:`w_v` is greater than or equal\nto the threshold parameter `theta`.\n\nEdges within `radius` of each other are determined using a KDTree when\nSciPy is available. This reduces the time complexity from :math:`O(n^2)`\nto :math:`O(n)`.\n\nParameters\n----------\nn : int or iterable\n    Number of nodes or iterable of nodes\nradius: float\n    Distance threshold value\ntheta: float\n    Threshold value\ndim : int, optional\n    Dimension of graph\npos : dict, optional\n    A dictionary keyed by node with node positions as values.\nweight : dict, optional\n    Node weights as a dictionary of numbers keyed by node.\np : float, optional (default 2)\n    Which Minkowski distance metric to use.  `p` has to meet the condition\n    ``1 <= p <= infinity``.\n\n    If this argument is not specified, the :math:`L^2` metric\n    (the Euclidean distance metric), p = 2 is used.\n\n    This should not be confused with the `p` of an Erd\u0151s-R\u00e9nyi random\n    graph, which represents probability.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\npos_name : string, default=\"pos\"\n    The name of the node attribute which represents the position\n    in 2D coordinates of the node in the returned graph.\nweight_name : string, default=\"weight\"\n    The name of the node attribute which represents the weight\n    of the node in the returned graph.\n\nReturns\n-------\nGraph\n    A thresholded random geographic graph, undirected and without\n    self-loops.\n\n    Each node has a node attribute ``'pos'`` that stores the\n    position of that node in Euclidean space as provided by the\n    ``pos`` keyword argument or, if ``pos`` was not provided, as\n    generated by this function. Similarly, each node has a nodethre\n    attribute ``'weight'`` that stores the weight of that node as\n    provided or as generated.\n\nExamples\n--------\nDefault Graph:\n\nG = nx.thresholded_random_geometric_graph(50, 0.2, 0.1)\n\nCustom Graph:\n\nCreate a thresholded random geometric graph on 50 uniformly distributed\nnodes where nodes are joined by an edge if their sum weights drawn from\na exponential distribution with rate = 5 are >= theta = 0.1 and their\nEuclidean distance is at most 0.2.\n\nNotes\n-----\nThis uses a *k*-d tree to build the graph.\n\nThe `pos` keyword argument can be used to specify node positions so you\ncan create an arbitrary distribution and domain for positions.\n\nFor example, to use a 2D Gaussian distribution of node positions with mean\n(0, 0) and standard deviation 2\n\nIf weights are not specified they are assigned to nodes by drawing randomly\nfrom the exponential distribution with rate parameter :math:`\\lambda=1`.\nTo specify weights from a different distribution, use the `weight` keyword\nargument::\n\n::\n\n>>> import random\n>>> import math\n>>> n = 50\n>>> pos = {i: (random.gauss(0, 2), random.gauss(0, 2)) for i in range(n)}\n>>> w = {i: random.expovariate(5.0) for i in range(n)}\n>>> G = nx.thresholded_random_geometric_graph(n, 0.2, 0.1, 2, pos, w)\n\nReferences\n----------\n.. [1] http://cole-maclean.github.io/blog/files/thesis.pdf"}, {"type": "function", "name": "networkx.to_dict_of_dicts", "documentation": "Returns adjacency representation of graph as a dictionary of dictionaries.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nnodelist : list\n   Use only nodes specified in nodelist\n\nedge_data : scalar, optional\n   If provided, the value of the dictionary will be set to `edge_data` for\n   all edges. Usual values could be `1` or `True`. If `edge_data` is\n   `None` (the default), the edgedata in `G` is used, resulting in a\n   dict-of-dict-of-dicts. If `G` is a MultiGraph, the result will be a\n   dict-of-dict-of-dict-of-dicts. See Notes for an approach to customize\n   handling edge data. `edge_data` should *not* be a container.\n\nReturns\n-------\ndod : dict\n   A nested dictionary representation of `G`. Note that the level of\n   nesting depends on the type of `G` and the value of `edge_data`\n   (see Examples).\n\nSee Also\n--------\nfrom_dict_of_dicts, to_dict_of_lists\n\nNotes\n-----\nFor a more custom approach to handling edge data, try::\n\n    dod = {\n        n: {nbr: custom(n, nbr, dd) for nbr, dd in nbrdict.items()}\n        for n, nbrdict in G.adj.items()\n    }\n\nwhere `custom` returns the desired edge data for each edge between `n` and\n`nbr`, given existing edge data `dd`.\n\nExamples\n--------\n>>> G = nx.path_graph(3)\n>>> nx.to_dict_of_dicts(G)\n{0: {1: {}}, 1: {0: {}, 2: {}}, 2: {1: {}}}\n\nEdge data is preserved by default (``edge_data=None``), resulting\nin dict-of-dict-of-dicts where the innermost dictionary contains the\nedge data:\n\n>>> G = nx.Graph()\n>>> G.add_edges_from(\n...     [\n...         (0, 1, {\"weight\": 1.0}),\n...         (1, 2, {\"weight\": 2.0}),\n...         (2, 0, {\"weight\": 1.0}),\n...     ]\n... )\n>>> d = nx.to_dict_of_dicts(G)\n>>> d  # doctest: +SKIP\n{0: {1: {'weight': 1.0}, 2: {'weight': 1.0}},\n 1: {0: {'weight': 1.0}, 2: {'weight': 2.0}},\n 2: {1: {'weight': 2.0}, 0: {'weight': 1.0}}}\n>>> d[1][2][\"weight\"]\n2.0\n\nIf `edge_data` is not `None`, edge data in the original graph (if any) is\nreplaced:\n\n>>> d = nx.to_dict_of_dicts(G, edge_data=1)\n>>> d\n{0: {1: 1, 2: 1}, 1: {0: 1, 2: 1}, 2: {1: 1, 0: 1}}\n>>> d[1][2]\n1\n\nThis also applies to MultiGraphs: edge data is preserved by default:\n\n>>> G = nx.MultiGraph()\n>>> G.add_edge(0, 1, key=\"a\", weight=1.0)\n'a'\n>>> G.add_edge(0, 1, key=\"b\", weight=5.0)\n'b'\n>>> d = nx.to_dict_of_dicts(G)\n>>> d  # doctest: +SKIP\n{0: {1: {'a': {'weight': 1.0}, 'b': {'weight': 5.0}}},\n 1: {0: {'a': {'weight': 1.0}, 'b': {'weight': 5.0}}}}\n>>> d[0][1][\"b\"][\"weight\"]\n5.0\n\nBut multi edge data is lost if `edge_data` is not `None`:\n\n>>> d = nx.to_dict_of_dicts(G, edge_data=10)\n>>> d\n{0: {1: 10}, 1: {0: 10}}"}, {"type": "function", "name": "networkx.to_dict_of_lists", "documentation": "Returns adjacency representation of graph as a dictionary of lists.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nnodelist : list\n   Use only nodes specified in nodelist\n\nNotes\n-----\nCompletely ignores edge data for MultiGraph and MultiDiGraph."}, {"type": "function", "name": "networkx.to_directed", "documentation": "Returns a directed view of the graph `graph`.\n\nIdentical to graph.to_directed(as_view=True)\nNote that graph.to_directed defaults to `as_view=False`\nwhile this function always provides a view."}, {"type": "function", "name": "networkx.to_edgelist", "documentation": "Returns a list of edges in the graph.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\n\nnodelist : list\n   Use only nodes specified in nodelist"}, {"type": "function", "name": "networkx.to_graph6_bytes", "documentation": "Convert a simple undirected graph to bytes in graph6 format.\n\nParameters\n----------\nG : Graph (undirected)\n\nnodes: list or iterable\n   Nodes are labeled 0...n-1 in the order provided.  If None the ordering\n   given by ``G.nodes()`` is used.\n\nheader: bool\n   If True add '>>graph6<<' bytes to head of data.\n\nRaises\n------\nNetworkXNotImplemented\n    If the graph is directed or is a multigraph.\n\nValueError\n    If the graph has at least ``2 ** 36`` nodes; the graph6 format\n    is only defined for graphs of order less than ``2 ** 36``.\n\nExamples\n--------\n>>> nx.to_graph6_bytes(nx.path_graph(2))\nb'>>graph6<<A_\\n'\n\nSee Also\n--------\nfrom_graph6_bytes, read_graph6, write_graph6_bytes\n\nNotes\n-----\nThe returned bytes end with a newline character.\n\nThe format does not support edge or node labels, parallel edges or\nself loops. If self loops are present they are silently ignored.\n\nReferences\n----------\n.. [1] Graph6 specification\n       <http://users.cecs.anu.edu.au/~bdm/data/formats.html>"}, {"type": "function", "name": "networkx.to_latex", "documentation": "Return latex code to draw the graph(s) in `Gbunch`\n\nThe TikZ drawing utility in LaTeX is used to draw the graph(s).\nIf `Gbunch` is a graph, it is drawn in a figure environment.\nIf `Gbunch` is an iterable of graphs, each is drawn in a subfigure environment\nwithin a single figure environment.\n\nIf `as_document` is True, the figure is wrapped inside a document environment\nso that the resulting string is ready to be compiled by LaTeX. Otherwise,\nthe string is ready for inclusion in a larger tex document using ``\\include``\nor ``\\input`` statements.\n\nParameters\n==========\nGbunch : NetworkX graph or iterable of NetworkX graphs\n    The NetworkX graph to be drawn or an iterable of graphs\n    to be drawn inside subfigures of a single figure.\npos : string or list of strings\n    The name of the node attribute on `G` that holds the position of each node.\n    Positions can be sequences of length 2 with numbers for (x,y) coordinates.\n    They can also be strings to denote positions in TikZ style, such as (x, y)\n    or (angle:radius).\n    If a dict, it should be keyed by node to a position.\n    If an empty dict, a circular layout is computed by TikZ.\n    If you are drawing many graphs in subfigures, use a list of position dicts.\ntikz_options : string\n    The tikzpicture options description defining the options for the picture.\n    Often large scale options like `[scale=2]`.\ndefault_node_options : string\n    The draw options for a path of nodes. Individual node options override these.\nnode_options : string or dict\n    The name of the node attribute on `G` that holds the options for each node.\n    Or a dict keyed by node to a string holding the options for that node.\nnode_label : string or dict\n    The name of the node attribute on `G` that holds the node label (text)\n    displayed for each node. If the attribute is \"\" or not present, the node\n    itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\n    Or a dict keyed by node to a string holding the label for that node.\ndefault_edge_options : string\n    The options for the scope drawing all edges. The default is \"[-]\" for\n    undirected graphs and \"[->]\" for directed graphs.\nedge_options : string or dict\n    The name of the edge attribute on `G` that holds the options for each edge.\n    If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\n    \"loop,\" is added to the options for the self-loop edge. Hence you can\n    use \"[loop above]\" explicitly, but the default is \"[loop]\".\n    Or a dict keyed by edge to a string holding the options for that edge.\nedge_label : string or dict\n    The name of the edge attribute on `G` that holds the edge label (text)\n    displayed for each edge. If the attribute is \"\" or not present, no edge\n    label is drawn.\n    Or a dict keyed by edge to a string holding the label for that edge.\nedge_label_options : string or dict\n    The name of the edge attribute on `G` that holds the label options for\n    each edge. For example, \"[sloped,above,blue]\". The default is no options.\n    Or a dict keyed by edge to a string holding the label options for that edge.\ncaption : string\n    The caption string for the figure environment\nlatex_label : string\n    The latex label used for the figure for easy referral from the main text\nsub_captions : list of strings\n    The sub_caption string for each subfigure in the figure\nsub_latex_labels : list of strings\n    The latex label for each subfigure in the figure\nn_rows : int\n    The number of rows of subfigures to arrange for multiple graphs\nas_document : bool\n    Whether to wrap the latex code in a document environment for compiling\ndocument_wrapper : formatted text string with variable ``content``.\n    This text is called to evaluate the content embedded in a document\n    environment with a preamble setting up TikZ.\nfigure_wrapper : formatted text string\n    This text is evaluated with variables ``content``, ``caption`` and ``label``.\n    It wraps the content and if a caption is provided, adds the latex code for\n    that caption, and if a label is provided, adds the latex code for a label.\nsubfigure_wrapper : formatted text string\n    This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\n    It wraps the content and if a caption is provided, adds the latex code for\n    that caption, and if a label is provided, adds the latex code for a label.\n    The size is the vertical size of each row of subfigures as a fraction.\n\nReturns\n=======\nlatex_code : string\n    The text string which draws the desired graph(s) when compiled by LaTeX.\n\nSee Also\n========\nwrite_latex\nto_latex_raw"}, {"type": "function", "name": "networkx.to_latex_raw", "documentation": "Return a string of the LaTeX/TikZ code to draw `G`\n\nThis function produces just the code for the tikzpicture\nwithout any enclosing environment.\n\nParameters\n==========\nG : NetworkX graph\n    The NetworkX graph to be drawn\npos : string or dict (default \"pos\")\n    The name of the node attribute on `G` that holds the position of each node.\n    Positions can be sequences of length 2 with numbers for (x,y) coordinates.\n    They can also be strings to denote positions in TikZ style, such as (x, y)\n    or (angle:radius).\n    If a dict, it should be keyed by node to a position.\n    If an empty dict, a circular layout is computed by TikZ.\ntikz_options : string\n    The tikzpicture options description defining the options for the picture.\n    Often large scale options like `[scale=2]`.\ndefault_node_options : string\n    The draw options for a path of nodes. Individual node options override these.\nnode_options : string or dict\n    The name of the node attribute on `G` that holds the options for each node.\n    Or a dict keyed by node to a string holding the options for that node.\nnode_label : string or dict\n    The name of the node attribute on `G` that holds the node label (text)\n    displayed for each node. If the attribute is \"\" or not present, the node\n    itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\n    Or a dict keyed by node to a string holding the label for that node.\ndefault_edge_options : string\n    The options for the scope drawing all edges. The default is \"[-]\" for\n    undirected graphs and \"[->]\" for directed graphs.\nedge_options : string or dict\n    The name of the edge attribute on `G` that holds the options for each edge.\n    If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\n    \"loop,\" is added to the options for the self-loop edge. Hence you can\n    use \"[loop above]\" explicitly, but the default is \"[loop]\".\n    Or a dict keyed by edge to a string holding the options for that edge.\nedge_label : string or dict\n    The name of the edge attribute on `G` that holds the edge label (text)\n    displayed for each edge. If the attribute is \"\" or not present, no edge\n    label is drawn.\n    Or a dict keyed by edge to a string holding the label for that edge.\nedge_label_options : string or dict\n    The name of the edge attribute on `G` that holds the label options for\n    each edge. For example, \"[sloped,above,blue]\". The default is no options.\n    Or a dict keyed by edge to a string holding the label options for that edge.\n\nReturns\n=======\nlatex_code : string\n   The text string which draws the desired graph(s) when compiled by LaTeX.\n\nSee Also\n========\nto_latex\nwrite_latex"}, {"type": "function", "name": "networkx.to_nested_tuple", "documentation": "Returns a nested tuple representation of the given tree.\n\nThe nested tuple representation of a tree is defined\nrecursively. The tree with one node and no edges is represented by\nthe empty tuple, ``()``. A tree with ``k`` subtrees is represented\nby a tuple of length ``k`` in which each element is the nested tuple\nrepresentation of a subtree.\n\nParameters\n----------\nT : NetworkX graph\n    An undirected graph object representing a tree.\n\nroot : node\n    The node in ``T`` to interpret as the root of the tree.\n\ncanonical_form : bool\n    If ``True``, each tuple is sorted so that the function returns\n    a canonical form for rooted trees. This means \"lighter\" subtrees\n    will appear as nested tuples before \"heavier\" subtrees. In this\n    way, each isomorphic rooted tree has the same nested tuple\n    representation.\n\nReturns\n-------\ntuple\n    A nested tuple representation of the tree.\n\nNotes\n-----\nThis function is *not* the inverse of :func:`from_nested_tuple`; the\nonly guarantee is that the rooted trees are isomorphic.\n\nSee also\n--------\nfrom_nested_tuple\nto_prufer_sequence\n\nExamples\n--------\nThe tree need not be a balanced binary tree::\n\n    >>> T = nx.Graph()\n    >>> T.add_edges_from([(0, 1), (0, 2), (0, 3)])\n    >>> T.add_edges_from([(1, 4), (1, 5)])\n    >>> T.add_edges_from([(3, 6), (3, 7)])\n    >>> root = 0\n    >>> nx.to_nested_tuple(T, root)\n    (((), ()), (), ((), ()))\n\nContinuing the above example, if ``canonical_form`` is ``True``, the\nnested tuples will be sorted::\n\n    >>> nx.to_nested_tuple(T, root, canonical_form=True)\n    ((), ((), ()), ((), ()))\n\nEven the path graph can be interpreted as a tree::\n\n    >>> T = nx.path_graph(4)\n    >>> root = 0\n    >>> nx.to_nested_tuple(T, root)\n    ((((),),),)"}, {"type": "function", "name": "networkx.to_networkx_graph", "documentation": "Make a NetworkX graph from a known data structure.\n\nThe preferred way to call this is automatically\nfrom the class constructor\n\n>>> d = {0: {1: {\"weight\": 1}}}  # dict-of-dicts single edge (0,1)\n>>> G = nx.Graph(d)\n\ninstead of the equivalent\n\n>>> G = nx.from_dict_of_dicts(d)\n\nParameters\n----------\ndata : object to be converted\n\n    Current known types are:\n     any NetworkX graph\n     dict-of-dicts\n     dict-of-lists\n     container (e.g. set, list, tuple) of edges\n     iterator (e.g. itertools.chain) that produces edges\n     generator of edges\n     Pandas DataFrame (row per edge)\n     2D numpy array\n     scipy sparse array\n     pygraphviz agraph\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n\nmultigraph_input : bool (default False)\n    If True and  data is a dict_of_dicts,\n    try to create a multigraph assuming dict_of_dict_of_lists.\n    If data and create_using are both multigraphs then create\n    a multigraph from a multigraph."}, {"type": "function", "name": "networkx.to_numpy_array", "documentation": "Returns the graph adjacency matrix as a NumPy array.\n\nParameters\n----------\nG : graph\n    The NetworkX graph used to construct the NumPy array.\n\nnodelist : list, optional\n    The rows and columns are ordered according to the nodes in `nodelist`.\n    If `nodelist` is ``None``, then the ordering is produced by ``G.nodes()``.\n\ndtype : NumPy data type, optional\n    A NumPy data type used to initialize the array. If None, then the NumPy\n    default is used. The dtype can be structured if `weight=None`, in which\n    case the dtype field names are used to look up edge attributes. The\n    result is a structured array where each named field in the dtype\n    corresponds to the adjacency for that edge attribute. See examples for\n    details.\n\norder : {'C', 'F'}, optional\n    Whether to store multidimensional data in C- or Fortran-contiguous\n    (row- or column-wise) order in memory. If None, then the NumPy default\n    is used.\n\nmultigraph_weight : callable, optional\n    An function that determines how weights in multigraphs are handled.\n    The function should accept a sequence of weights and return a single\n    value. The default is to sum the weights of the multiple edges.\n\nweight : string or None optional (default = 'weight')\n    The edge attribute that holds the numerical value used for\n    the edge weight. If an edge does not have that attribute, then the\n    value 1 is used instead. `weight` must be ``None`` if a structured\n    dtype is used.\n\nnonedge : array_like (default = 0.0)\n    The value used to represent non-edges in the adjacency matrix.\n    The array values corresponding to nonedges are typically set to zero.\n    However, this could be undesirable if there are array values\n    corresponding to actual edges that also have the value zero. If so,\n    one might prefer nonedges to have some other value, such as ``nan``.\n\nReturns\n-------\nA : NumPy ndarray\n    Graph adjacency matrix\n\nRaises\n------\nNetworkXError\n    If `dtype` is a structured dtype and `G` is a multigraph\nValueError\n    If `dtype` is a structured dtype and `weight` is not `None`\n\nSee Also\n--------\nfrom_numpy_array\n\nNotes\n-----\nFor directed graphs, entry ``i, j`` corresponds to an edge from ``i`` to ``j``.\n\nEntries in the adjacency matrix are given by the `weight` edge attribute.\nWhen an edge does not have a weight attribute, the value of the entry is\nset to the number 1.  For multiple (parallel) edges, the values of the\nentries are determined by the `multigraph_weight` parameter. The default is\nto sum the weight attributes for each of the parallel edges.\n\nWhen `nodelist` does not contain every node in `G`, the adjacency matrix is\nbuilt from the subgraph of `G` that is induced by the nodes in `nodelist`.\n\nThe convention used for self-loop edges in graphs is to assign the\ndiagonal array entry value to the weight attribute of the edge\n(or the number 1 if the edge has no weight attribute). If the\nalternate convention of doubling the edge weight is desired the\nresulting NumPy array can be modified as follows:\n\n>>> import numpy as np\n>>> G = nx.Graph([(1, 1)])\n>>> A = nx.to_numpy_array(G)\n>>> A\narray([[1.]])\n>>> A[np.diag_indices_from(A)] *= 2\n>>> A\narray([[2.]])\n\nExamples\n--------\n>>> G = nx.MultiDiGraph()\n>>> G.add_edge(0, 1, weight=2)\n0\n>>> G.add_edge(1, 0)\n0\n>>> G.add_edge(2, 2, weight=3)\n0\n>>> G.add_edge(2, 2)\n1\n>>> nx.to_numpy_array(G, nodelist=[0, 1, 2])\narray([[0., 2., 0.],\n       [1., 0., 0.],\n       [0., 0., 4.]])\n\nWhen `nodelist` argument is used, nodes of `G` which do not appear in the `nodelist`\nand their edges are not included in the adjacency matrix. Here is an example:\n\n>>> G = nx.Graph()\n>>> G.add_edge(3, 1)\n>>> G.add_edge(2, 0)\n>>> G.add_edge(2, 1)\n>>> G.add_edge(3, 0)\n>>> nx.to_numpy_array(G, nodelist=[1, 2, 3])\narray([[0., 1., 1.],\n       [1., 0., 0.],\n       [1., 0., 0.]])\n\nThis function can also be used to create adjacency matrices for multiple\nedge attributes with structured dtypes:\n\n>>> G = nx.Graph()\n>>> G.add_edge(0, 1, weight=10)\n>>> G.add_edge(1, 2, cost=5)\n>>> G.add_edge(2, 3, weight=3, cost=-4.0)\n>>> dtype = np.dtype([(\"weight\", int), (\"cost\", float)])\n>>> A = nx.to_numpy_array(G, dtype=dtype, weight=None)\n>>> A[\"weight\"]\narray([[ 0, 10,  0,  0],\n       [10,  0,  1,  0],\n       [ 0,  1,  0,  3],\n       [ 0,  0,  3,  0]])\n>>> A[\"cost\"]\narray([[ 0.,  1.,  0.,  0.],\n       [ 1.,  0.,  5.,  0.],\n       [ 0.,  5.,  0., -4.],\n       [ 0.,  0., -4.,  0.]])\n\nAs stated above, the argument \"nonedge\" is useful especially when there are\nactually edges with weight 0 in the graph. Setting a nonedge value different than 0,\nmakes it much clearer to differentiate such 0-weighted edges and actual nonedge values.\n\n>>> G = nx.Graph()\n>>> G.add_edge(3, 1, weight=2)\n>>> G.add_edge(2, 0, weight=0)\n>>> G.add_edge(2, 1, weight=0)\n>>> G.add_edge(3, 0, weight=1)\n>>> nx.to_numpy_array(G, nonedge=-1.0)\narray([[-1.,  2., -1.,  1.],\n       [ 2., -1.,  0., -1.],\n       [-1.,  0., -1.,  0.],\n       [ 1., -1.,  0., -1.]])"}, {"type": "function", "name": "networkx.to_pandas_adjacency", "documentation": "Returns the graph adjacency matrix as a Pandas DataFrame.\n\nParameters\n----------\nG : graph\n    The NetworkX graph used to construct the Pandas DataFrame.\n\nnodelist : list, optional\n   The rows and columns are ordered according to the nodes in `nodelist`.\n   If `nodelist` is None, then the ordering is produced by G.nodes().\n\nmultigraph_weight : {sum, min, max}, optional\n    An operator that determines how weights in multigraphs are handled.\n    The default is to sum the weights of the multiple edges.\n\nweight : string or None, optional\n    The edge attribute that holds the numerical value used for\n    the edge weight.  If an edge does not have that attribute, then the\n    value 1 is used instead.\n\nnonedge : float, optional\n    The matrix values corresponding to nonedges are typically set to zero.\n    However, this could be undesirable if there are matrix values\n    corresponding to actual edges that also have the value zero. If so,\n    one might prefer nonedges to have some other value, such as nan.\n\nReturns\n-------\ndf : Pandas DataFrame\n   Graph adjacency matrix\n\nNotes\n-----\nFor directed graphs, entry i,j corresponds to an edge from i to j.\n\nThe DataFrame entries are assigned to the weight edge attribute. When\nan edge does not have a weight attribute, the value of the entry is set to\nthe number 1.  For multiple (parallel) edges, the values of the entries\nare determined by the 'multigraph_weight' parameter.  The default is to\nsum the weight attributes for each of the parallel edges.\n\nWhen `nodelist` does not contain every node in `G`, the matrix is built\nfrom the subgraph of `G` that is induced by the nodes in `nodelist`.\n\nThe convention used for self-loop edges in graphs is to assign the\ndiagonal matrix entry value to the weight attribute of the edge\n(or the number 1 if the edge has no weight attribute).  If the\nalternate convention of doubling the edge weight is desired the\nresulting Pandas DataFrame can be modified as follows::\n\n    >>> import pandas as pd\n    >>> G = nx.Graph([(1, 1), (2, 2)])\n    >>> df = nx.to_pandas_adjacency(G)\n    >>> df\n         1    2\n    1  1.0  0.0\n    2  0.0  1.0\n    >>> diag_idx = list(range(len(df)))\n    >>> df.iloc[diag_idx, diag_idx] *= 2\n    >>> df\n         1    2\n    1  2.0  0.0\n    2  0.0  2.0\n\nExamples\n--------\n>>> G = nx.MultiDiGraph()\n>>> G.add_edge(0, 1, weight=2)\n0\n>>> G.add_edge(1, 0)\n0\n>>> G.add_edge(2, 2, weight=3)\n0\n>>> G.add_edge(2, 2)\n1\n>>> nx.to_pandas_adjacency(G, nodelist=[0, 1, 2], dtype=int)\n   0  1  2\n0  0  2  0\n1  1  0  0\n2  0  0  4"}, {"type": "function", "name": "networkx.to_pandas_edgelist", "documentation": "Returns the graph edge list as a Pandas DataFrame.\n\nParameters\n----------\nG : graph\n    The NetworkX graph used to construct the Pandas DataFrame.\n\nsource : str or int, optional\n    A valid column name (string or integer) for the source nodes (for the\n    directed case).\n\ntarget : str or int, optional\n    A valid column name (string or integer) for the target nodes (for the\n    directed case).\n\nnodelist : list, optional\n   Use only nodes specified in nodelist\n\ndtype : dtype, default None\n    Use to create the DataFrame. Data type to force.\n    Only a single dtype is allowed. If None, infer.\n\nedge_key : str or int or None, optional (default=None)\n    A valid column name (string or integer) for the edge keys (for the\n    multigraph case). If None, edge keys are not stored in the DataFrame.\n\nReturns\n-------\ndf : Pandas DataFrame\n   Graph edge list\n\nExamples\n--------\n>>> G = nx.Graph(\n...     [\n...         (\"A\", \"B\", {\"cost\": 1, \"weight\": 7}),\n...         (\"C\", \"E\", {\"cost\": 9, \"weight\": 10}),\n...     ]\n... )\n>>> df = nx.to_pandas_edgelist(G, nodelist=[\"A\", \"C\"])\n>>> df[[\"source\", \"target\", \"cost\", \"weight\"]]\n  source target  cost  weight\n0      A      B     1       7\n1      C      E     9      10\n\n>>> G = nx.MultiGraph([(\"A\", \"B\", {\"cost\": 1}), (\"A\", \"B\", {\"cost\": 9})])\n>>> df = nx.to_pandas_edgelist(G, nodelist=[\"A\", \"C\"], edge_key=\"ekey\")\n>>> df[[\"source\", \"target\", \"cost\", \"ekey\"]]\n  source target  cost  ekey\n0      A      B     1     0\n1      A      B     9     1"}, {"type": "function", "name": "networkx.to_prufer_sequence", "documentation": "Returns the Pr\u00fcfer sequence of the given tree.\n\nA *Pr\u00fcfer sequence* is a list of *n* - 2 numbers between 0 and\n*n* - 1, inclusive. The tree corresponding to a given Pr\u00fcfer\nsequence can be recovered by repeatedly joining a node in the\nsequence with a node with the smallest potential degree according to\nthe sequence.\n\nParameters\n----------\nT : NetworkX graph\n    An undirected graph object representing a tree.\n\nReturns\n-------\nlist\n    The Pr\u00fcfer sequence of the given tree.\n\nRaises\n------\nNetworkXPointlessConcept\n    If the number of nodes in `T` is less than two.\n\nNotATree\n    If `T` is not a tree.\n\nKeyError\n    If the set of nodes in `T` is not {0, \u2026, *n* - 1}.\n\nNotes\n-----\nThere is a bijection from labeled trees to Pr\u00fcfer sequences. This\nfunction is the inverse of the :func:`from_prufer_sequence`\nfunction.\n\nSometimes Pr\u00fcfer sequences use nodes labeled from 1 to *n* instead\nof from 0 to *n* - 1. This function requires nodes to be labeled in\nthe latter form. You can use :func:`~networkx.relabel_nodes` to\nrelabel the nodes of your tree to the appropriate format.\n\nThis implementation is from [1]_ and has a running time of\n$O(n)$.\n\nSee also\n--------\nto_nested_tuple\nfrom_prufer_sequence\n\nReferences\n----------\n.. [1] Wang, Xiaodong, Lei Wang, and Yingjie Wu.\n       \"An optimal algorithm for Prufer codes.\"\n       *Journal of Software Engineering and Applications* 2.02 (2009): 111.\n       <https://doi.org/10.4236/jsea.2009.22016>\n\nExamples\n--------\nThere is a bijection between Pr\u00fcfer sequences and labeled trees, so\nthis function is the inverse of the :func:`from_prufer_sequence`\nfunction:\n\n>>> edges = [(0, 3), (1, 3), (2, 3), (3, 4), (4, 5)]\n>>> tree = nx.Graph(edges)\n>>> sequence = nx.to_prufer_sequence(tree)\n>>> sequence\n[3, 3, 3, 4]\n>>> tree2 = nx.from_prufer_sequence(sequence)\n>>> list(tree2.edges()) == edges\nTrue"}, {"type": "function", "name": "networkx.to_scipy_sparse_array", "documentation": "Returns the graph adjacency matrix as a SciPy sparse array.\n\nParameters\n----------\nG : graph\n    The NetworkX graph used to construct the sparse matrix.\n\nnodelist : list, optional\n   The rows and columns are ordered according to the nodes in `nodelist`.\n   If `nodelist` is None, then the ordering is produced by G.nodes().\n\ndtype : NumPy data-type, optional\n    A valid NumPy dtype used to initialize the array. If None, then the\n    NumPy default is used.\n\nweight : string or None   optional (default='weight')\n    The edge attribute that holds the numerical value used for\n    the edge weight.  If None then all edge weights are 1.\n\nformat : str in {'bsr', 'csr', 'csc', 'coo', 'lil', 'dia', 'dok'}\n    The type of the matrix to be returned (default 'csr').  For\n    some algorithms different implementations of sparse matrices\n    can perform better.  See [1]_ for details.\n\nReturns\n-------\nA : SciPy sparse array\n   Graph adjacency matrix.\n\nNotes\n-----\nFor directed graphs, matrix entry i,j corresponds to an edge from i to j.\n\nThe matrix entries are populated using the edge attribute held in\nparameter weight. When an edge does not have that attribute, the\nvalue of the entry is 1.\n\nFor multiple edges the matrix values are the sums of the edge weights.\n\nWhen `nodelist` does not contain every node in `G`, the adjacency matrix\nis built from the subgraph of `G` that is induced by the nodes in\n`nodelist`.\n\nThe convention used for self-loop edges in graphs is to assign the\ndiagonal matrix entry value to the weight attribute of the edge\n(or the number 1 if the edge has no weight attribute).  If the\nalternate convention of doubling the edge weight is desired the\nresulting SciPy sparse array can be modified as follows:\n\n>>> G = nx.Graph([(1, 1)])\n>>> A = nx.to_scipy_sparse_array(G)\n>>> print(A.todense())\n[[1]]\n>>> A.setdiag(A.diagonal() * 2)\n>>> print(A.toarray())\n[[2]]\n\nExamples\n--------\n>>> G = nx.MultiDiGraph()\n>>> G.add_edge(0, 1, weight=2)\n0\n>>> G.add_edge(1, 0)\n0\n>>> G.add_edge(2, 2, weight=3)\n0\n>>> G.add_edge(2, 2)\n1\n>>> S = nx.to_scipy_sparse_array(G, nodelist=[0, 1, 2])\n>>> print(S.toarray())\n[[0 2 0]\n [1 0 0]\n [0 0 4]]\n\nReferences\n----------\n.. [1] Scipy Dev. References, \"Sparse Matrices\",\n   https://docs.scipy.org/doc/scipy/reference/sparse.html"}, {"type": "function", "name": "networkx.to_sparse6_bytes", "documentation": "Convert an undirected graph to bytes in sparse6 format.\n\nParameters\n----------\nG : Graph (undirected)\n\nnodes: list or iterable\n   Nodes are labeled 0...n-1 in the order provided.  If None the ordering\n   given by ``G.nodes()`` is used.\n\nheader: bool\n   If True add '>>sparse6<<' bytes to head of data.\n\nRaises\n------\nNetworkXNotImplemented\n    If the graph is directed.\n\nValueError\n    If the graph has at least ``2 ** 36`` nodes; the sparse6 format\n    is only defined for graphs of order less than ``2 ** 36``.\n\nExamples\n--------\n>>> nx.to_sparse6_bytes(nx.path_graph(2))\nb'>>sparse6<<:An\\n'\n\nSee Also\n--------\nto_sparse6_bytes, read_sparse6, write_sparse6_bytes\n\nNotes\n-----\nThe returned bytes end with a newline character.\n\nThe format does not support edge or node labels.\n\nReferences\n----------\n.. [1] Graph6 specification\n       <https://users.cecs.anu.edu.au/~bdm/data/formats.html>"}, {"type": "function", "name": "networkx.to_undirected", "documentation": "Returns an undirected view of the graph `graph`.\n\nIdentical to graph.to_undirected(as_view=True)\nNote that graph.to_undirected defaults to `as_view=False`\nwhile this function always provides a view."}, {"type": "function", "name": "networkx.topological_generations", "documentation": "Stratifies a DAG into generations.\n\nA topological generation is node collection in which ancestors of a node in each\ngeneration are guaranteed to be in a previous generation, and any descendants of\na node are guaranteed to be in a following generation. Nodes are guaranteed to\nbe in the earliest possible generation that they can belong to.\n\nParameters\n----------\nG : NetworkX digraph\n    A directed acyclic graph (DAG)\n\nYields\n------\nsets of nodes\n    Yields sets of nodes representing each generation.\n\nRaises\n------\nNetworkXError\n    Generations are defined for directed graphs only. If the graph\n    `G` is undirected, a :exc:`NetworkXError` is raised.\n\nNetworkXUnfeasible\n    If `G` is not a directed acyclic graph (DAG) no topological generations\n    exist and a :exc:`NetworkXUnfeasible` exception is raised.  This can also\n    be raised if `G` is changed while the returned iterator is being processed\n\nRuntimeError\n    If `G` is changed while the returned iterator is being processed.\n\nExamples\n--------\n>>> DG = nx.DiGraph([(2, 1), (3, 1)])\n>>> [sorted(generation) for generation in nx.topological_generations(DG)]\n[[2, 3], [1]]\n\nNotes\n-----\nThe generation in which a node resides can also be determined by taking the\nmax-path-distance from the node to the farthest leaf node. That value can\nbe obtained with this function using `enumerate(topological_generations(G))`.\n\nSee also\n--------\ntopological_sort"}, {"type": "function", "name": "networkx.topological_sort", "documentation": "Returns a generator of nodes in topologically sorted order.\n\nA topological sort is a nonunique permutation of the nodes of a\ndirected graph such that an edge from u to v implies that u\nappears before v in the topological sort order. This ordering is\nvalid only if the graph has no directed cycles.\n\nParameters\n----------\nG : NetworkX digraph\n    A directed acyclic graph (DAG)\n\nYields\n------\nnodes\n    Yields the nodes in topological sorted order.\n\nRaises\n------\nNetworkXError\n    Topological sort is defined for directed graphs only. If the graph `G`\n    is undirected, a :exc:`NetworkXError` is raised.\n\nNetworkXUnfeasible\n    If `G` is not a directed acyclic graph (DAG) no topological sort exists\n    and a :exc:`NetworkXUnfeasible` exception is raised.  This can also be\n    raised if `G` is changed while the returned iterator is being processed\n\nRuntimeError\n    If `G` is changed while the returned iterator is being processed.\n\nExamples\n--------\nTo get the reverse order of the topological sort:\n\n>>> DG = nx.DiGraph([(1, 2), (2, 3)])\n>>> list(reversed(list(nx.topological_sort(DG))))\n[3, 2, 1]\n\nIf your DiGraph naturally has the edges representing tasks/inputs\nand nodes representing people/processes that initiate tasks, then\ntopological_sort is not quite what you need. You will have to change\nthe tasks to nodes with dependence reflected by edges. The result is\na kind of topological sort of the edges. This can be done\nwith :func:`networkx.line_graph` as follows:\n\n>>> list(nx.topological_sort(nx.line_graph(DG)))\n[(1, 2), (2, 3)]\n\nNotes\n-----\nThis algorithm is based on a description and proof in\n\"Introduction to Algorithms: A Creative Approach\" [1]_ .\n\nSee also\n--------\nis_directed_acyclic_graph, lexicographical_topological_sort\n\nReferences\n----------\n.. [1] Manber, U. (1989).\n   *Introduction to Algorithms - A Creative Approach.* Addison-Wesley."}, {"type": "function", "name": "networkx.total_spanning_tree_weight", "documentation": "Returns the total weight of all spanning trees of `G`.\n\nKirchoff's Tree Matrix Theorem [1]_, [2]_ states that the determinant of any\ncofactor of the Laplacian matrix of a graph is the number of spanning trees\nin the graph. For a weighted Laplacian matrix, it is the sum across all\nspanning trees of the multiplicative weight of each tree. That is, the\nweight of each tree is the product of its edge weights.\n\nFor unweighted graphs, the total weight equals the number of spanning trees in `G`.\n\nFor directed graphs, the total weight follows by summing over all directed\nspanning trees in `G` that start in the `root` node [3]_.\n\n.. deprecated:: 3.3\n\n   ``total_spanning_tree_weight`` is deprecated and will be removed in v3.5.\n   Use ``nx.number_of_spanning_trees(G)`` instead.\n\nParameters\n----------\nG : NetworkX Graph\n\nweight : string or None, optional (default=None)\n    The key for the edge attribute holding the edge weight.\n    If None, then each edge has weight 1.\n\nroot : node (only required for directed graphs)\n   A node in the directed graph `G`.\n\nReturns\n-------\ntotal_weight : float\n    Undirected graphs:\n        The sum of the total multiplicative weights for all spanning trees in `G`.\n    Directed graphs:\n        The sum of the total multiplicative weights for all spanning trees of `G`,\n        rooted at node `root`.\n\nRaises\n------\nNetworkXPointlessConcept\n    If `G` does not contain any nodes.\n\nNetworkXError\n    If the graph `G` is not (weakly) connected,\n    or if `G` is directed and the root node is not specified or not in G.\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> round(nx.total_spanning_tree_weight(G))\n125\n\n>>> G = nx.Graph()\n>>> G.add_edge(1, 2, weight=2)\n>>> G.add_edge(1, 3, weight=1)\n>>> G.add_edge(2, 3, weight=1)\n>>> round(nx.total_spanning_tree_weight(G, \"weight\"))\n5\n\nNotes\n-----\nSelf-loops are excluded. Multi-edges are contracted in one edge\nequal to the sum of the weights.\n\nReferences\n----------\n.. [1] Wikipedia\n   \"Kirchhoff's theorem.\"\n   https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem\n.. [2] Kirchhoff, G. R.\n    \u00dcber die Aufl\u00f6sung der Gleichungen, auf welche man\n    bei der Untersuchung der linearen Vertheilung\n    Galvanischer Str\u00f6me gef\u00fchrt wird\n    Annalen der Physik und Chemie, vol. 72, pp. 497-508, 1847.\n.. [3] Margoliash, J.\n    \"Matrix-Tree Theorem for Directed Graphs\"\n    https://www.math.uchicago.edu/~may/VIGRE/VIGRE2010/REUPapers/Margoliash.pdf"}, {"type": "function", "name": "networkx.transitive_closure", "documentation": "Returns transitive closure of a graph\n\nThe transitive closure of G = (V,E) is a graph G+ = (V,E+) such that\nfor all v, w in V there is an edge (v, w) in E+ if and only if there\nis a path from v to w in G.\n\nHandling of paths from v to v has some flexibility within this definition.\nA reflexive transitive closure creates a self-loop for the path\nfrom v to v of length 0. The usual transitive closure creates a\nself-loop only if a cycle exists (a path from v to v with length > 0).\nWe also allow an option for no self-loops.\n\nParameters\n----------\nG : NetworkX Graph\n    A directed/undirected graph/multigraph.\nreflexive : Bool or None, optional (default: False)\n    Determines when cycles create self-loops in the Transitive Closure.\n    If True, trivial cycles (length 0) create self-loops. The result\n    is a reflexive transitive closure of G.\n    If False (the default) non-trivial cycles create self-loops.\n    If None, self-loops are not created.\n\nReturns\n-------\nNetworkX graph\n    The transitive closure of `G`\n\nRaises\n------\nNetworkXError\n    If `reflexive` not in `{None, True, False}`\n\nExamples\n--------\nThe treatment of trivial (i.e. length 0) cycles is controlled by the\n`reflexive` parameter.\n\nTrivial (i.e. length 0) cycles do not create self-loops when\n``reflexive=False`` (the default)::\n\n    >>> DG = nx.DiGraph([(1, 2), (2, 3)])\n    >>> TC = nx.transitive_closure(DG, reflexive=False)\n    >>> TC.edges()\n    OutEdgeView([(1, 2), (1, 3), (2, 3)])\n\nHowever, nontrivial (i.e. length greater than 0) cycles create self-loops\nwhen ``reflexive=False`` (the default)::\n\n    >>> DG = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\n    >>> TC = nx.transitive_closure(DG, reflexive=False)\n    >>> TC.edges()\n    OutEdgeView([(1, 2), (1, 3), (1, 1), (2, 3), (2, 1), (2, 2), (3, 1), (3, 2), (3, 3)])\n\nTrivial cycles (length 0) create self-loops when ``reflexive=True``::\n\n    >>> DG = nx.DiGraph([(1, 2), (2, 3)])\n    >>> TC = nx.transitive_closure(DG, reflexive=True)\n    >>> TC.edges()\n    OutEdgeView([(1, 2), (1, 1), (1, 3), (2, 3), (2, 2), (3, 3)])\n\nAnd the third option is not to create self-loops at all when ``reflexive=None``::\n\n    >>> DG = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\n    >>> TC = nx.transitive_closure(DG, reflexive=None)\n    >>> TC.edges()\n    OutEdgeView([(1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2)])\n\nReferences\n----------\n.. [1] https://www.ics.uci.edu/~eppstein/PADS/PartialOrder.py"}, {"type": "function", "name": "networkx.transitive_closure_dag", "documentation": "Returns the transitive closure of a directed acyclic graph.\n\nThis function is faster than the function `transitive_closure`, but fails\nif the graph has a cycle.\n\nThe transitive closure of G = (V,E) is a graph G+ = (V,E+) such that\nfor all v, w in V there is an edge (v, w) in E+ if and only if there\nis a non-null path from v to w in G.\n\nParameters\n----------\nG : NetworkX DiGraph\n    A directed acyclic graph (DAG)\n\ntopo_order: list or tuple, optional\n    A topological order for G (if None, the function will compute one)\n\nReturns\n-------\nNetworkX DiGraph\n    The transitive closure of `G`\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is not directed\nNetworkXUnfeasible\n    If `G` has a cycle\n\nExamples\n--------\n>>> DG = nx.DiGraph([(1, 2), (2, 3)])\n>>> TC = nx.transitive_closure_dag(DG)\n>>> TC.edges()\nOutEdgeView([(1, 2), (1, 3), (2, 3)])\n\nNotes\n-----\nThis algorithm is probably simple enough to be well-known but I didn't find\na mention in the literature."}, {"type": "function", "name": "networkx.transitive_reduction", "documentation": "Returns transitive reduction of a directed graph\n\nThe transitive reduction of G = (V,E) is a graph G- = (V,E-) such that\nfor all v,w in V there is an edge (v,w) in E- if and only if (v,w) is\nin E and there is no path from v to w in G with length greater than 1.\n\nParameters\n----------\nG : NetworkX DiGraph\n    A directed acyclic graph (DAG)\n\nReturns\n-------\nNetworkX DiGraph\n    The transitive reduction of `G`\n\nRaises\n------\nNetworkXError\n    If `G` is not a directed acyclic graph (DAG) transitive reduction is\n    not uniquely defined and a :exc:`NetworkXError` exception is raised.\n\nExamples\n--------\nTo perform transitive reduction on a DiGraph:\n\n>>> DG = nx.DiGraph([(1, 2), (2, 3), (1, 3)])\n>>> TR = nx.transitive_reduction(DG)\n>>> list(TR.edges)\n[(1, 2), (2, 3)]\n\nTo avoid unnecessary data copies, this implementation does not return a\nDiGraph with node/edge data.\nTo perform transitive reduction on a DiGraph and transfer node/edge data:\n\n>>> DG = nx.DiGraph()\n>>> DG.add_edges_from([(1, 2), (2, 3), (1, 3)], color=\"red\")\n>>> TR = nx.transitive_reduction(DG)\n>>> TR.add_nodes_from(DG.nodes(data=True))\n>>> TR.add_edges_from((u, v, DG.edges[u, v]) for u, v in TR.edges)\n>>> list(TR.edges(data=True))\n[(1, 2, {'color': 'red'}), (2, 3, {'color': 'red'})]\n\nReferences\n----------\nhttps://en.wikipedia.org/wiki/Transitive_reduction"}, {"type": "function", "name": "networkx.transitivity", "documentation": "Compute graph transitivity, the fraction of all possible triangles\npresent in G.\n\nPossible triangles are identified by the number of \"triads\"\n(two edges with a shared vertex).\n\nThe transitivity is\n\n.. math::\n\n    T = 3\\frac{\\#triangles}{\\#triads}.\n\nParameters\n----------\nG : graph\n\nReturns\n-------\nout : float\n   Transitivity\n\nNotes\n-----\nSelf loops are ignored.\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> print(nx.transitivity(G))\n1.0"}, {"type": "function", "name": "networkx.tree_all_pairs_lowest_common_ancestor", "documentation": "Yield the lowest common ancestor for sets of pairs in a tree.\n\nParameters\n----------\nG : NetworkX directed graph (must be a tree)\n\nroot : node, optional (default: None)\n    The root of the subtree to operate on.\n    If None, assume the entire graph has exactly one source and use that.\n\npairs : iterable or iterator of pairs of nodes, optional (default: None)\n    The pairs of interest. If None, Defaults to all pairs of nodes\n    under `root` that have a lowest common ancestor.\n\nReturns\n-------\nlcas : generator of tuples `((u, v), lca)` where `u` and `v` are nodes\n    in `pairs` and `lca` is their lowest common ancestor.\n\nExamples\n--------\n>>> import pprint\n>>> G = nx.DiGraph([(1, 3), (2, 4), (1, 2)])\n>>> pprint.pprint(dict(nx.tree_all_pairs_lowest_common_ancestor(G)))\n{(1, 1): 1,\n (2, 1): 1,\n (2, 2): 2,\n (3, 1): 1,\n (3, 2): 1,\n (3, 3): 3,\n (3, 4): 1,\n (4, 1): 1,\n (4, 2): 2,\n (4, 4): 4}\n\nWe can also use `pairs` argument to specify the pairs of nodes for which we\nwant to compute lowest common ancestors. Here is an example:\n\n>>> dict(nx.tree_all_pairs_lowest_common_ancestor(G, pairs=[(1, 4), (2, 3)]))\n{(2, 3): 1, (1, 4): 1}\n\nNotes\n-----\nOnly defined on non-null trees represented with directed edges from\nparents to children. Uses Tarjan's off-line lowest-common-ancestors\nalgorithm. Runs in time $O(4 \\times (V + E + P))$ time, where 4 is the largest\nvalue of the inverse Ackermann function likely to ever come up in actual\nuse, and $P$ is the number of pairs requested (or $V^2$ if all are needed).\n\nTarjan, R. E. (1979), \"Applications of path compression on balanced trees\",\nJournal of the ACM 26 (4): 690-715, doi:10.1145/322154.322161.\n\nSee Also\n--------\nall_pairs_lowest_common_ancestor: similar routine for general DAGs\nlowest_common_ancestor: just a single pair for general DAGs"}, {"type": "function", "name": "networkx.tree_broadcast_center", "documentation": "Return the Broadcast Center of the tree `G`.\n\nThe broadcast center of a graph G denotes the set of nodes having\nminimum broadcast time [1]_. This is a linear algorithm for determining\nthe broadcast center of a tree with ``N`` nodes, as a by-product it also\ndetermines the broadcast time from the broadcast center.\n\nParameters\n----------\nG : undirected graph\n    The graph should be an undirected tree\n\nReturns\n-------\nBC : (int, set) tuple\n    minimum broadcast number of the tree, set of broadcast centers\n\nRaises\n------\nNetworkXNotImplemented\n    If the graph is directed or is a multigraph.\n\nReferences\n----------\n.. [1] Slater, P.J., Cockayne, E.J., Hedetniemi, S.T,\n   Information dissemination in trees. SIAM J.Comput. 10(4), 692\u2013701 (1981)"}, {"type": "function", "name": "networkx.tree_broadcast_time", "documentation": "Return the Broadcast Time of the tree `G`.\n\nThe minimum broadcast time of a node is defined as the minimum amount\nof time required to complete broadcasting starting from the\noriginator. The broadcast time of a graph is the maximum over\nall nodes of the minimum broadcast time from that node [1]_.\nThis function returns the minimum broadcast time of `node`.\nIf `node` is None the broadcast time for the graph is returned.\n\nParameters\n----------\nG : undirected graph\n    The graph should be an undirected tree\nnode: int, optional\n    index of starting node. If `None`, the algorithm returns the broadcast\n    time of the tree.\n\nReturns\n-------\nBT : int\n    Broadcast Time of a node in a tree\n\nRaises\n------\nNetworkXNotImplemented\n    If the graph is directed or is a multigraph.\n\nReferences\n----------\n.. [1] Harutyunyan, H. A. and Li, Z.\n    \"A Simple Construction of Broadcast Graphs.\"\n    In Computing and Combinatorics. COCOON 2019\n    (Ed. D. Z. Du and C. Tian.) Springer, pp. 240-253, 2019."}, {"type": "function", "name": "networkx.tree_data", "documentation": "Returns data in tree format that is suitable for JSON serialization\nand use in JavaScript documents.\n\nParameters\n----------\nG : NetworkX graph\n   G must be an oriented tree\n\nroot : node\n   The root of the tree\n\nident : string\n    Attribute name for storing NetworkX-internal graph data. `ident` must\n    have a different value than `children`. The default is 'id'.\n\nchildren : string\n    Attribute name for storing NetworkX-internal graph data. `children`\n    must have a different value than `ident`. The default is 'children'.\n\nReturns\n-------\ndata : dict\n   A dictionary with node-link formatted data.\n\nRaises\n------\nNetworkXError\n    If `children` and `ident` attributes are identical.\n\nExamples\n--------\n>>> from networkx.readwrite import json_graph\n>>> G = nx.DiGraph([(1, 2)])\n>>> data = json_graph.tree_data(G, root=1)\n\nTo serialize with json\n\n>>> import json\n>>> s = json.dumps(data)\n\nNotes\n-----\nNode attributes are stored in this format but keys\nfor attributes must be strings if you want to serialize with JSON.\n\nGraph and edge attributes are not stored.\n\nSee Also\n--------\ntree_graph, node_link_data, adjacency_data"}, {"type": "function", "name": "networkx.tree_graph", "documentation": "Returns graph from tree data format.\n\nParameters\n----------\ndata : dict\n    Tree formatted graph data\n\nident : string\n    Attribute name for storing NetworkX-internal graph data. `ident` must\n    have a different value than `children`. The default is 'id'.\n\nchildren : string\n    Attribute name for storing NetworkX-internal graph data. `children`\n    must have a different value than `ident`. The default is 'children'.\n\nReturns\n-------\nG : NetworkX DiGraph\n\nExamples\n--------\n>>> from networkx.readwrite import json_graph\n>>> G = nx.DiGraph([(1, 2)])\n>>> data = json_graph.tree_data(G, root=1)\n>>> H = json_graph.tree_graph(data)\n\nSee Also\n--------\ntree_data, node_link_data, adjacency_data"}, {"type": "function", "name": "networkx.triad_graph", "documentation": "Returns the triad graph with the given name.\n\nEach string in the following tuple is a valid triad name::\n\n    (\n        \"003\",\n        \"012\",\n        \"102\",\n        \"021D\",\n        \"021U\",\n        \"021C\",\n        \"111D\",\n        \"111U\",\n        \"030T\",\n        \"030C\",\n        \"201\",\n        \"120D\",\n        \"120U\",\n        \"120C\",\n        \"210\",\n        \"300\",\n    )\n\nEach triad name corresponds to one of the possible valid digraph on\nthree nodes.\n\nParameters\n----------\ntriad_name : string\n    The name of a triad, as described above.\n\nReturns\n-------\n:class:`~networkx.DiGraph`\n    The digraph on three nodes with the given name. The nodes of the\n    graph are the single-character strings 'a', 'b', and 'c'.\n\nRaises\n------\nValueError\n    If `triad_name` is not the name of a triad.\n\nSee also\n--------\ntriadic_census"}, {"type": "function", "name": "networkx.triad_type", "documentation": "Returns the sociological triad type for a triad.\n\nParameters\n----------\nG : digraph\n   A NetworkX DiGraph with 3 nodes\n\nReturns\n-------\ntriad_type : str\n   A string identifying the triad type\n\nExamples\n--------\n>>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1)])\n>>> nx.triad_type(G)\n'030C'\n>>> G.add_edge(1, 3)\n>>> nx.triad_type(G)\n'120C'\n\nNotes\n-----\nThere can be 6 unique edges in a triad (order-3 DiGraph) (so 2^^6=64 unique\ntriads given 3 nodes). These 64 triads each display exactly 1 of 16\ntopologies of triads (topologies can be permuted). These topologies are\nidentified by the following notation:\n\n{m}{a}{n}{type} (for example: 111D, 210, 102)\n\nHere:\n\n{m}     = number of mutual ties (takes 0, 1, 2, 3); a mutual tie is (0,1)\n          AND (1,0)\n{a}     = number of asymmetric ties (takes 0, 1, 2, 3); an asymmetric tie\n          is (0,1) BUT NOT (1,0) or vice versa\n{n}     = number of null ties (takes 0, 1, 2, 3); a null tie is NEITHER\n          (0,1) NOR (1,0)\n{type}  = a letter (takes U, D, C, T) corresponding to up, down, cyclical\n          and transitive. This is only used for topologies that can have\n          more than one form (eg: 021D and 021U).\n\nReferences\n----------\n.. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\n    Oxford.\n    https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf"}, {"type": "function", "name": "networkx.triadic_census", "documentation": "Determines the triadic census of a directed graph.\n\nThe triadic census is a count of how many of the 16 possible types of\ntriads are present in a directed graph. If a list of nodes is passed, then\nonly those triads are taken into account which have elements of nodelist in them.\n\nParameters\n----------\nG : digraph\n   A NetworkX DiGraph\nnodelist : list\n    List of nodes for which you want to calculate triadic census\n\nReturns\n-------\ncensus : dict\n   Dictionary with triad type as keys and number of occurrences as values.\n\nExamples\n--------\n>>> G = nx.DiGraph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1), (4, 2)])\n>>> triadic_census = nx.triadic_census(G)\n>>> for key, value in triadic_census.items():\n...     print(f\"{key}: {value}\")\n003: 0\n012: 0\n102: 0\n021D: 0\n021U: 0\n021C: 0\n111D: 0\n111U: 0\n030T: 2\n030C: 2\n201: 0\n120D: 0\n120U: 0\n120C: 0\n210: 0\n300: 0\n\nNotes\n-----\nThis algorithm has complexity $O(m)$ where $m$ is the number of edges in\nthe graph.\n\nFor undirected graphs, the triadic census can be computed by first converting\nthe graph into a directed graph using the ``G.to_directed()`` method.\nAfter this conversion, only the triad types 003, 102, 201 and 300 will be\npresent in the undirected scenario.\n\nRaises\n------\nValueError\n    If `nodelist` contains duplicate nodes or nodes not in `G`.\n    If you want to ignore this you can preprocess with `set(nodelist) & G.nodes`\n\nSee also\n--------\ntriad_graph\n\nReferences\n----------\n.. [1] Vladimir Batagelj and Andrej Mrvar, A subquadratic triad census\n    algorithm for large sparse networks with small maximum degree,\n    University of Ljubljana,\n    http://vlado.fmf.uni-lj.si/pub/networks/doc/triads/triads.pdf"}, {"type": "function", "name": "networkx.triads_by_type", "documentation": "Returns a list of all triads for each triad type in a directed graph.\nThere are exactly 16 different types of triads possible. Suppose 1, 2, 3 are three\nnodes, they will be classified as a particular triad type if their connections\nare as follows:\n\n- 003: 1, 2, 3\n- 012: 1 -> 2, 3\n- 102: 1 <-> 2, 3\n- 021D: 1 <- 2 -> 3\n- 021U: 1 -> 2 <- 3\n- 021C: 1 -> 2 -> 3\n- 111D: 1 <-> 2 <- 3\n- 111U: 1 <-> 2 -> 3\n- 030T: 1 -> 2 -> 3, 1 -> 3\n- 030C: 1 <- 2 <- 3, 1 -> 3\n- 201: 1 <-> 2 <-> 3\n- 120D: 1 <- 2 -> 3, 1 <-> 3\n- 120U: 1 -> 2 <- 3, 1 <-> 3\n- 120C: 1 -> 2 -> 3, 1 <-> 3\n- 210: 1 -> 2 <-> 3, 1 <-> 3\n- 300: 1 <-> 2 <-> 3, 1 <-> 3\n\nRefer to the :doc:`example gallery </auto_examples/graph/plot_triad_types>`\nfor visual examples of the triad types.\n\nParameters\n----------\nG : digraph\n   A NetworkX DiGraph\n\nReturns\n-------\ntri_by_type : dict\n   Dictionary with triad types as keys and lists of triads as values.\n\nExamples\n--------\n>>> G = nx.DiGraph([(1, 2), (1, 3), (2, 3), (3, 1), (5, 6), (5, 4), (6, 7)])\n>>> dict = nx.triads_by_type(G)\n>>> dict[\"120C\"][0].edges()\nOutEdgeView([(1, 2), (1, 3), (2, 3), (3, 1)])\n>>> dict[\"012\"][0].edges()\nOutEdgeView([(1, 2)])\n\nReferences\n----------\n.. [1] Snijders, T. (2012). \"Transitivity and triads.\" University of\n    Oxford.\n    https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf"}, {"type": "function", "name": "networkx.triangles", "documentation": "Compute the number of triangles.\n\nFinds the number of triangles that include a node as one vertex.\n\nParameters\n----------\nG : graph\n   A networkx graph\n\nnodes : node, iterable of nodes, or None (default=None)\n    If a singleton node, return the number of triangles for that node.\n    If an iterable, compute the number of triangles for each of those nodes.\n    If `None` (the default) compute the number of triangles for all nodes in `G`.\n\nReturns\n-------\nout : dict or int\n   If `nodes` is a container of nodes, returns number of triangles keyed by node (dict).\n   If `nodes` is a specific node, returns number of triangles for the node (int).\n\nExamples\n--------\n>>> G = nx.complete_graph(5)\n>>> print(nx.triangles(G, 0))\n6\n>>> print(nx.triangles(G))\n{0: 6, 1: 6, 2: 6, 3: 6, 4: 6}\n>>> print(list(nx.triangles(G, [0, 1]).values()))\n[6, 6]\n\nNotes\n-----\nSelf loops are ignored."}, {"type": "function", "name": "networkx.triangular_lattice_graph", "documentation": "Returns the $m$ by $n$ triangular lattice graph.\n\nThe `triangular lattice graph`_ is a two-dimensional `grid graph`_ in\nwhich each square unit has a diagonal edge (each grid unit has a chord).\n\nThe returned graph has $m$ rows and $n$ columns of triangles. Rows and\ncolumns include both triangles pointing up and down. Rows form a strip\nof constant height. Columns form a series of diamond shapes, staggered\nwith the columns on either side. Another way to state the size is that\nthe nodes form a grid of `m+1` rows and `(n + 1) // 2` columns.\nThe odd row nodes are shifted horizontally relative to the even rows.\n\nDirected graph types have edges pointed up or right.\n\nPositions of nodes are computed by default or `with_positions is True`.\nThe position of each node (embedded in a euclidean plane) is stored in\nthe graph using equilateral triangles with sidelength 1.\nThe height between rows of nodes is thus $\\sqrt(3)/2$.\nNodes lie in the first quadrant with the node $(0, 0)$ at the origin.\n\n.. _triangular lattice graph: http://mathworld.wolfram.com/TriangularGrid.html\n.. _grid graph: http://www-cs-students.stanford.edu/~amitp/game-programming/grids/\n.. _Triangular Tiling: https://en.wikipedia.org/wiki/Triangular_tiling\n\nParameters\n----------\nm : int\n    The number of rows in the lattice.\n\nn : int\n    The number of columns in the lattice.\n\nperiodic : bool (default: False)\n    If True, join the boundary vertices of the grid using periodic\n    boundary conditions. The join between boundaries is the final row\n    and column of triangles. This means there is one row and one column\n    fewer nodes for the periodic lattice. Periodic lattices require\n    `m >= 3`, `n >= 5` and are allowed but misaligned if `m` or `n` are odd\n\nwith_positions : bool (default: True)\n    Store the coordinates of each node in the graph node attribute 'pos'.\n    The coordinates provide a lattice with equilateral triangles.\n    Periodic positions shift the nodes vertically in a nonlinear way so\n    the edges don't overlap so much.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkX graph\n    The *m* by *n* triangular lattice graph."}, {"type": "function", "name": "networkx.trivial_graph", "documentation": "Return the Trivial graph with one node (with label 0) and no edges.\n\n.. plot::\n\n    >>> nx.draw(nx.trivial_graph(), with_labels=True)"}, {"type": "function", "name": "networkx.trophic_differences", "documentation": "Compute the trophic differences of the edges of a directed graph.\n\nThe trophic difference $x_ij$ for each edge is defined in Johnson et al.\n[1]_ as:\n\n.. math::\n    x_ij = s_j - s_i\n\nWhere $s_i$ is the trophic level of node $i$.\n\nParameters\n----------\nG : DiGraph\n    A directed networkx graph\n\nReturns\n-------\ndiffs : dict\n    Dictionary of edges with trophic differences as the value.\n\nReferences\n----------\n.. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\n    Munoz (2014) PNAS \"Trophic coherence determines food-web stability\""}, {"type": "function", "name": "networkx.trophic_incoherence_parameter", "documentation": "Compute the trophic incoherence parameter of a graph.\n\nTrophic coherence is defined as the homogeneity of the distribution of\ntrophic distances: the more similar, the more coherent. This is measured by\nthe standard deviation of the trophic differences and referred to as the\ntrophic incoherence parameter $q$ by [1].\n\nParameters\n----------\nG : DiGraph\n    A directed networkx graph\n\ncannibalism: Boolean\n    If set to False, self edges are not considered in the calculation\n\nReturns\n-------\ntrophic_incoherence_parameter : float\n    The trophic coherence of a graph\n\nReferences\n----------\n.. [1] Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\n    Munoz (2014) PNAS \"Trophic coherence determines food-web stability\""}, {"type": "function", "name": "networkx.trophic_levels", "documentation": "Compute the trophic levels of nodes.\n\nThe trophic level of a node $i$ is\n\n.. math::\n\n    s_i = 1 + \\frac{1}{k^{in}_i} \\sum_{j} a_{ij} s_j\n\nwhere $k^{in}_i$ is the in-degree of i\n\n.. math::\n\n    k^{in}_i = \\sum_{j} a_{ij}\n\nand nodes with $k^{in}_i = 0$ have $s_i = 1$ by convention.\n\nThese are calculated using the method outlined in Levine [1]_.\n\nParameters\n----------\nG : DiGraph\n    A directed networkx graph\n\nReturns\n-------\nnodes : dict\n    Dictionary of nodes with trophic level as the value.\n\nReferences\n----------\n.. [1] Stephen Levine (1980) J. theor. Biol. 83, 195-207"}, {"type": "function", "name": "networkx.truncated_cube_graph", "documentation": "Returns the skeleton of the truncated cube.\n\nThe truncated cube is an Archimedean solid with 14 regular\nfaces (6 octagonal and 8 triangular), 36 edges and 24 nodes [1]_.\nThe truncated cube is created by truncating (cutting off) the tips\nof the cube one third of the way into each edge [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Skeleton of the truncated cube\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Truncated_cube\n.. [2] https://www.coolmath.com/reference/polyhedra-truncated-cube"}, {"type": "function", "name": "networkx.truncated_tetrahedron_graph", "documentation": "Returns the skeleton of the truncated Platonic tetrahedron.\n\nThe truncated tetrahedron is an Archimedean solid with 4 regular hexagonal faces,\n4 equilateral triangle faces, 12 nodes and 18 edges. It can be constructed by truncating\nall 4 vertices of a regular tetrahedron at one third of the original edge length [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Skeleton of the truncated tetrahedron\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Truncated_tetrahedron"}, {"type": "function", "name": "networkx.turan_graph", "documentation": "Return the Turan Graph\n\nThe Turan Graph is a complete multipartite graph on $n$ nodes\nwith $r$ disjoint subsets. That is, edges connect each node to\nevery node not in its subset.\n\nGiven $n$ and $r$, we create a complete multipartite graph with\n$r-(n \\mod r)$ partitions of size $n/r$, rounded down, and\n$n \\mod r$ partitions of size $n/r+1$, rounded down.\n\n.. plot::\n\n    >>> nx.draw(nx.turan_graph(6, 2))\n\nParameters\n----------\nn : int\n    The number of nodes.\nr : int\n    The number of partitions.\n    Must be less than or equal to n.\n\nNotes\n-----\nMust satisfy $1 <= r <= n$.\nThe graph has $(r-1)(n^2)/(2r)$ edges, rounded down."}, {"type": "function", "name": "networkx.tutte_graph", "documentation": "Returns the Tutte graph.\n\nThe Tutte graph is a cubic polyhedral, non-Hamiltonian graph. It has\n46 nodes and 69 edges.\nIt is a counterexample to Tait's conjecture that every 3-regular polyhedron\nhas a Hamiltonian cycle.\nIt can be realized geometrically from a tetrahedron by multiply truncating\nthree of its vertices [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Tutte graph\n\nReferences\n----------\n.. [1] https://en.wikipedia.org/wiki/Tutte_graph"}, {"type": "function", "name": "networkx.tutte_polynomial", "documentation": "Returns the Tutte polynomial of `G`\n\nThis function computes the Tutte polynomial via an iterative version of\nthe deletion-contraction algorithm.\n\nThe Tutte polynomial `T_G(x, y)` is a fundamental graph polynomial invariant in\ntwo variables. It encodes a wide array of information related to the\nedge-connectivity of a graph; \"Many problems about graphs can be reduced to\nproblems of finding and evaluating the Tutte polynomial at certain values\" [1]_.\nIn fact, every deletion-contraction-expressible feature of a graph is a\nspecialization of the Tutte polynomial [2]_ (see Notes for examples).\n\nThere are several equivalent definitions; here are three:\n\nDef 1 (rank-nullity expansion): For `G` an undirected graph, `n(G)` the\nnumber of vertices of `G`, `E` the edge set of `G`, `V` the vertex set of\n`G`, and `c(A)` the number of connected components of the graph with vertex\nset `V` and edge set `A` [3]_:\n\n.. math::\n\n    T_G(x, y) = \\sum_{A \\in E} (x-1)^{c(A) - c(E)} (y-1)^{c(A) + |A| - n(G)}\n\nDef 2 (spanning tree expansion): Let `G` be an undirected graph, `T` a spanning\ntree of `G`, and `E` the edge set of `G`. Let `E` have an arbitrary strict\nlinear order `L`. Let `B_e` be the unique minimal nonempty edge cut of\n$E \\setminus T \\cup {e}$. An edge `e` is internally active with respect to\n`T` and `L` if `e` is the least edge in `B_e` according to the linear order\n`L`. The internal activity of `T` (denoted `i(T)`) is the number of edges\nin $E \\setminus T$ that are internally active with respect to `T` and `L`.\nLet `P_e` be the unique path in $T \\cup {e}$ whose source and target vertex\nare the same. An edge `e` is externally active with respect to `T` and `L`\nif `e` is the least edge in `P_e` according to the linear order `L`. The\nexternal activity of `T` (denoted `e(T)`) is the number of edges in\n$E \\setminus T$ that are externally active with respect to `T` and `L`.\nThen [4]_ [5]_:\n\n.. math::\n\n    T_G(x, y) = \\sum_{T \\text{ a spanning tree of } G} x^{i(T)} y^{e(T)}\n\nDef 3 (deletion-contraction recurrence): For `G` an undirected graph, `G-e`\nthe graph obtained from `G` by deleting edge `e`, `G/e` the graph obtained\nfrom `G` by contracting edge `e`, `k(G)` the number of cut-edges of `G`,\nand `l(G)` the number of self-loops of `G`:\n\n.. math::\n    T_G(x, y) = \\begin{cases}\n       x^{k(G)} y^{l(G)}, & \\text{if all edges are cut-edges or self-loops} \\\\\n       T_{G-e}(x, y) + T_{G/e}(x, y), & \\text{otherwise, for an arbitrary edge $e$ not a cut-edge or loop}\n    \\end{cases}\n\nParameters\n----------\nG : NetworkX graph\n\nReturns\n-------\ninstance of `sympy.core.add.Add`\n    A Sympy expression representing the Tutte polynomial for `G`.\n\nExamples\n--------\n>>> C = nx.cycle_graph(5)\n>>> nx.tutte_polynomial(C)\nx**4 + x**3 + x**2 + x + y\n\n>>> D = nx.diamond_graph()\n>>> nx.tutte_polynomial(D)\nx**3 + 2*x**2 + 2*x*y + x + y**2 + y\n\nNotes\n-----\nSome specializations of the Tutte polynomial:\n\n- `T_G(1, 1)` counts the number of spanning trees of `G`\n- `T_G(1, 2)` counts the number of connected spanning subgraphs of `G`\n- `T_G(2, 1)` counts the number of spanning forests in `G`\n- `T_G(0, 2)` counts the number of strong orientations of `G`\n- `T_G(2, 0)` counts the number of acyclic orientations of `G`\n\nEdge contraction is defined and deletion-contraction is introduced in [6]_.\nCombinatorial meaning of the coefficients is introduced in [7]_.\nUniversality, properties, and applications are discussed in [8]_.\n\nPractically, up-front computation of the Tutte polynomial may be useful when\nusers wish to repeatedly calculate edge-connectivity-related information\nabout one or more graphs.\n\nReferences\n----------\n.. [1] M. Brandt,\n   \"The Tutte Polynomial.\"\n   Talking About Combinatorial Objects Seminar, 2015\n   https://math.berkeley.edu/~brandtm/talks/tutte.pdf\n.. [2] A. Bj\u00f6rklund, T. Husfeldt, P. Kaski, M. Koivisto,\n   \"Computing the Tutte polynomial in vertex-exponential time\"\n   49th Annual IEEE Symposium on Foundations of Computer Science, 2008\n   https://ieeexplore.ieee.org/abstract/document/4691000\n.. [3] Y. Shi, M. Dehmer, X. Li, I. Gutman,\n   \"Graph Polynomials,\" p. 14\n.. [4] Y. Shi, M. Dehmer, X. Li, I. Gutman,\n   \"Graph Polynomials,\" p. 46\n.. [5] A. Ne\u0161etril, J. Goodall,\n   \"Graph invariants, homomorphisms, and the Tutte polynomial\"\n   https://iuuk.mff.cuni.cz/~andrew/Tutte.pdf\n.. [6] D. B. West,\n   \"Introduction to Graph Theory,\" p. 84\n.. [7] G. Coutinho,\n   \"A brief introduction to the Tutte polynomial\"\n   Structural Analysis of Complex Networks, 2011\n   https://homepages.dcc.ufmg.br/~gabriel/seminars/coutinho_tuttepolynomial_seminar.pdf\n.. [8] J. A. Ellis-Monaghan, C. Merino,\n   \"Graph polynomials and their applications I: The Tutte polynomial\"\n   Structural Analysis of Complex Networks, 2011\n   https://arxiv.org/pdf/0803.3079.pdf"}, {"type": "function", "name": "networkx.uniform_random_intersection_graph", "documentation": "Returns a uniform random intersection graph.\n\nParameters\n----------\nn : int\n    The number of nodes in the first bipartite set (nodes)\nm : int\n    The number of nodes in the second bipartite set (attributes)\np : float\n    Probability of connecting nodes between bipartite sets\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nSee Also\n--------\ngnp_random_graph\n\nReferences\n----------\n.. [1] K.B. Singer-Cohen, Random Intersection Graphs, 1995,\n   PhD thesis, Johns Hopkins University\n.. [2] Fill, J. A., Scheinerman, E. R., and Singer-Cohen, K. B.,\n   Random intersection graphs when m = !(n):\n   An equivalence theorem relating the evolution of the g(n, m, p)\n   and g(n, p) models. Random Struct. Algorithms 16, 2 (2000), 156\u2013176."}, {"type": "function", "name": "networkx.union", "documentation": "Combine graphs G and H. The names of nodes must be unique.\n\nA name collision between the graphs will raise an exception.\n\nA renaming facility is provided to avoid name collisions.\n\n\nParameters\n----------\nG, H : graph\n   A NetworkX graph\n\nrename : iterable , optional\n   Node names of G and H can be changed by specifying the tuple\n   rename=('G-','H-') (for example).  Node \"u\" in G is then renamed\n   \"G-u\" and \"v\" in H is renamed \"H-v\".\n\nReturns\n-------\nU : A union graph with the same type as G.\n\nSee Also\n--------\ncompose\n:func:`~networkx.Graph.update`\ndisjoint_union\n\nNotes\n-----\nTo combine graphs that have common nodes, consider compose(G, H)\nor the method, Graph.update().\n\ndisjoint_union() is similar to union() except that it avoids name clashes\nby relabeling the nodes with sequential integers.\n\nEdge and node attributes are propagated from G and H to the union graph.\nGraph attributes are also propagated, but if they are present in both G and H,\nthen the value from H is used.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (1, 2)])\n>>> H = nx.Graph([(0, 1), (0, 3), (1, 3), (1, 2)])\n>>> U = nx.union(G, H, rename=(\"G\", \"H\"))\n>>> U.nodes\nNodeView(('G0', 'G1', 'G2', 'H0', 'H1', 'H3', 'H2'))\n>>> U.edges\nEdgeView([('G0', 'G1'), ('G0', 'G2'), ('G1', 'G2'), ('H0', 'H1'), ('H0', 'H3'), ('H1', 'H3'), ('H1', 'H2')])"}, {"type": "function", "name": "networkx.union_all", "documentation": "Returns the union of all graphs.\n\nThe graphs must be disjoint, otherwise an exception is raised.\n\nParameters\n----------\ngraphs : iterable\n   Iterable of NetworkX graphs\n\nrename : iterable , optional\n   Node names of graphs can be changed by specifying the tuple\n   rename=('G-','H-') (for example).  Node \"u\" in G is then renamed\n   \"G-u\" and \"v\" in H is renamed \"H-v\". Infinite generators (like itertools.count)\n   are also supported.\n\nReturns\n-------\nU : a graph with the same type as the first graph in list\n\nRaises\n------\nValueError\n   If `graphs` is an empty list.\n\nNetworkXError\n    In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs.\n\nNotes\n-----\nFor operating on mixed type graphs, they should be converted to the same type.\n>>> G = nx.Graph()\n>>> H = nx.DiGraph()\n>>> GH = union_all([nx.DiGraph(G), H])\n\nTo force a disjoint union with node relabeling, use\ndisjoint_union_all(G,H) or convert_node_labels_to integers().\n\nGraph, edge, and node attributes are propagated to the union graph.\nIf a graph attribute is present in multiple graphs, then the value\nfrom the last graph in the list with that attribute is used.\n\nExamples\n--------\n>>> G1 = nx.Graph([(1, 2), (2, 3)])\n>>> G2 = nx.Graph([(4, 5), (5, 6)])\n>>> result_graph = nx.union_all([G1, G2])\n>>> result_graph.nodes()\nNodeView((1, 2, 3, 4, 5, 6))\n>>> result_graph.edges()\nEdgeView([(1, 2), (2, 3), (4, 5), (5, 6)])\n\nSee Also\n--------\nunion\ndisjoint_union_all"}, {"type": "function", "name": "networkx.vf2pp_all_isomorphisms", "documentation": "Yields all the possible mappings between G1 and G2.\n\nParameters\n----------\nG1, G2 : NetworkX Graph or MultiGraph instances.\n    The two graphs to check for isomorphism.\n\nnode_label : str, optional\n    The name of the node attribute to be used when comparing nodes.\n    The default is `None`, meaning node attributes are not considered\n    in the comparison. Any node that doesn't have the `node_label`\n    attribute uses `default_label` instead.\n\ndefault_label : scalar\n    Default value to use when a node doesn't have an attribute\n    named `node_label`. Default is `None`.\n\nYields\n------\ndict\n    Isomorphic mapping between the nodes in `G1` and `G2`."}, {"type": "function", "name": "networkx.vf2pp_is_isomorphic", "documentation": "Examines whether G1 and G2 are isomorphic.\n\nParameters\n----------\nG1, G2 : NetworkX Graph or MultiGraph instances.\n    The two graphs to check for isomorphism.\n\nnode_label : str, optional\n    The name of the node attribute to be used when comparing nodes.\n    The default is `None`, meaning node attributes are not considered\n    in the comparison. Any node that doesn't have the `node_label`\n    attribute uses `default_label` instead.\n\ndefault_label : scalar\n    Default value to use when a node doesn't have an attribute\n    named `node_label`. Default is `None`.\n\nReturns\n-------\nbool\n    True if the two graphs are isomorphic, False otherwise."}, {"type": "function", "name": "networkx.vf2pp_isomorphism", "documentation": "Return an isomorphic mapping between `G1` and `G2` if it exists.\n\nParameters\n----------\nG1, G2 : NetworkX Graph or MultiGraph instances.\n    The two graphs to check for isomorphism.\n\nnode_label : str, optional\n    The name of the node attribute to be used when comparing nodes.\n    The default is `None`, meaning node attributes are not considered\n    in the comparison. Any node that doesn't have the `node_label`\n    attribute uses `default_label` instead.\n\ndefault_label : scalar\n    Default value to use when a node doesn't have an attribute\n    named `node_label`. Default is `None`.\n\nReturns\n-------\ndict or None\n    Node mapping if the two graphs are isomorphic. None otherwise."}, {"type": "function", "name": "networkx.visibility_graph", "documentation": "Return a Visibility Graph of an input Time Series.\n\nA visibility graph converts a time series into a graph. The constructed graph\nuses integer nodes to indicate which event in the series the node represents.\nEdges are formed as follows: consider a bar plot of the series and view that\nas a side view of a landscape with a node at the top of each bar. An edge\nmeans that the nodes can be connected by a straight \"line-of-sight\" without\nbeing obscured by any bars between the nodes.\n\nThe resulting graph inherits several properties of the series in its structure.\nThereby, periodic series convert into regular graphs, random series convert\ninto random graphs, and fractal series convert into scale-free networks [1]_.\n\nParameters\n----------\nseries : Sequence[Number]\n   A Time Series sequence (iterable and sliceable) of numeric values\n   representing times.\n\nReturns\n-------\nNetworkX Graph\n    The Visibility Graph of the input series\n\nExamples\n--------\n>>> series_list = [range(10), [2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1, 3]]\n>>> for s in series_list:\n...     g = nx.visibility_graph(s)\n...     print(g)\nGraph with 10 nodes and 9 edges\nGraph with 12 nodes and 18 edges\n\nReferences\n----------\n.. [1] Lacasa, Lucas, Bartolo Luque, Fernando Ballesteros, Jordi Luque, and Juan Carlos Nuno.\n       \"From time series to complex networks: The visibility graph.\" Proceedings of the\n       National Academy of Sciences 105, no. 13 (2008): 4972-4975.\n       https://www.pnas.org/doi/10.1073/pnas.0709247105"}, {"type": "function", "name": "networkx.volume", "documentation": "Returns the volume of a set of nodes.\n\nThe *volume* of a set *S* is the sum of the (out-)degrees of nodes\nin *S* (taking into account parallel edges in multigraphs). [1]\n\nParameters\n----------\nG : NetworkX graph\n\nS : collection\n    A collection of nodes in `G`.\n\nweight : object\n    Edge attribute key to use as weight. If not specified, edges\n    have weight one.\n\nReturns\n-------\nnumber\n    The volume of the set of nodes represented by `S` in the graph\n    `G`.\n\nSee also\n--------\nconductance\ncut_size\nedge_expansion\nedge_boundary\nnormalized_cut_size\n\nReferences\n----------\n.. [1] David Gleich.\n       *Hierarchical Directed Spectral Graph Partitioning*.\n       <https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf>"}, {"type": "function", "name": "networkx.voronoi_cells", "documentation": "Returns the Voronoi cells centered at `center_nodes` with respect\nto the shortest-path distance metric.\n\nIf $C$ is a set of nodes in the graph and $c$ is an element of $C$,\nthe *Voronoi cell* centered at a node $c$ is the set of all nodes\n$v$ that are closer to $c$ than to any other center node in $C$ with\nrespect to the shortest-path distance metric. [1]_\n\nFor directed graphs, this will compute the \"outward\" Voronoi cells,\nas defined in [1]_, in which distance is measured from the center\nnodes to the target node. For the \"inward\" Voronoi cells, use the\n:meth:`DiGraph.reverse` method to reverse the orientation of the\nedges before invoking this function on the directed graph.\n\nParameters\n----------\nG : NetworkX graph\n\ncenter_nodes : set\n    A nonempty set of nodes in the graph `G` that represent the\n    center of the Voronoi cells.\n\nweight : string or function\n    The edge attribute (or an arbitrary function) representing the\n    weight of an edge. This keyword argument is as described in the\n    documentation for :func:`~networkx.multi_source_dijkstra_path`,\n    for example.\n\nReturns\n-------\ndictionary\n    A mapping from center node to set of all nodes in the graph\n    closer to that center node than to any other center node. The\n    keys of the dictionary are the element of `center_nodes`, and\n    the values of the dictionary form a partition of the nodes of\n    `G`.\n\nExamples\n--------\nTo get only the partition of the graph induced by the Voronoi cells,\ntake the collection of all values in the returned dictionary::\n\n    >>> G = nx.path_graph(6)\n    >>> center_nodes = {0, 3}\n    >>> cells = nx.voronoi_cells(G, center_nodes)\n    >>> partition = set(map(frozenset, cells.values()))\n    >>> sorted(map(sorted, partition))\n    [[0, 1], [2, 3, 4, 5]]\n\nRaises\n------\nValueError\n    If `center_nodes` is empty.\n\nReferences\n----------\n.. [1] Erwig, Martin. (2000),\"The graph Voronoi diagram with applications.\"\n    *Networks*, 36: 156--163.\n    https://doi.org/10.1002/1097-0037(200010)36:3<156::AID-NET2>3.0.CO;2-L"}, {"type": "function", "name": "networkx.voterank", "documentation": "Select a list of influential nodes in a graph using VoteRank algorithm\n\nVoteRank [1]_ computes a ranking of the nodes in a graph G based on a\nvoting scheme. With VoteRank, all nodes vote for each of its in-neighbors\nand the node with the highest votes is elected iteratively. The voting\nability of out-neighbors of elected nodes is decreased in subsequent turns.\n\nParameters\n----------\nG : graph\n    A NetworkX graph.\n\nnumber_of_nodes : integer, optional\n    Number of ranked nodes to extract (default all nodes).\n\nReturns\n-------\nvoterank : list\n    Ordered list of computed seeds.\n    Only nodes with positive number of votes are returned.\n\nExamples\n--------\n>>> G = nx.Graph([(0, 1), (0, 2), (0, 3), (1, 4)])\n>>> nx.voterank(G)\n[0, 1]\n\nThe algorithm can be used both for undirected and directed graphs.\nHowever, the directed version is different in two ways:\n(i) nodes only vote for their in-neighbors and\n(ii) only the voting ability of elected node and its out-neighbors are updated:\n\n>>> G = nx.DiGraph([(0, 1), (2, 1), (2, 3), (3, 4)])\n>>> nx.voterank(G)\n[2, 3]\n\nNotes\n-----\nEach edge is treated independently in case of multigraphs.\n\nReferences\n----------\n.. [1] Zhang, J.-X. et al. (2016).\n    Identifying a set of influential spreaders in complex networks.\n    Sci. Rep. 6, 27823; doi: 10.1038/srep27823."}, {"type": "function", "name": "networkx.watts_strogatz_graph", "documentation": "Returns a Watts\u2013Strogatz small-world graph.\n\nParameters\n----------\nn : int\n    The number of nodes\nk : int\n    Each node is joined with its `k` nearest neighbors in a ring\n    topology.\np : float\n    The probability of rewiring each edge\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nSee Also\n--------\nnewman_watts_strogatz_graph\nconnected_watts_strogatz_graph\n\nNotes\n-----\nFirst create a ring over $n$ nodes [1]_.  Then each node in the ring is joined\nto its $k$ nearest neighbors (or $k - 1$ neighbors if $k$ is odd).\nThen shortcuts are created by replacing some edges as follows: for each\nedge $(u, v)$ in the underlying \"$n$-ring with $k$ nearest neighbors\"\nwith probability $p$ replace it with a new edge $(u, w)$ with uniformly\nrandom choice of existing node $w$.\n\nIn contrast with :func:`newman_watts_strogatz_graph`, the random rewiring\ndoes not increase the number of edges. The rewired graph is not guaranteed\nto be connected as in :func:`connected_watts_strogatz_graph`.\n\nReferences\n----------\n.. [1] Duncan J. Watts and Steven H. Strogatz,\n   Collective dynamics of small-world networks,\n   Nature, 393, pp. 440--442, 1998."}, {"type": "function", "name": "networkx.waxman_graph", "documentation": "Returns a Waxman random graph.\n\nThe Waxman random graph model places `n` nodes uniformly at random\nin a rectangular domain. Each pair of nodes at distance `d` is\njoined by an edge with probability\n\n.. math::\n        p = \\beta \\exp(-d / \\alpha L).\n\nThis function implements both Waxman models, using the `L` keyword\nargument.\n\n* Waxman-1: if `L` is not specified, it is set to be the maximum distance\n  between any pair of nodes.\n* Waxman-2: if `L` is specified, the distance between a pair of nodes is\n  chosen uniformly at random from the interval `[0, L]`.\n\nParameters\n----------\nn : int or iterable\n    Number of nodes or iterable of nodes\nbeta: float\n    Model parameter\nalpha: float\n    Model parameter\nL : float, optional\n    Maximum distance between nodes.  If not specified, the actual distance\n    is calculated.\ndomain : four-tuple of numbers, optional\n    Domain size, given as a tuple of the form `(x_min, y_min, x_max,\n    y_max)`.\nmetric : function\n    A metric on vectors of numbers (represented as lists or\n    tuples). This must be a function that accepts two lists (or\n    tuples) as input and yields a number as output. The function\n    must also satisfy the four requirements of a `metric`_.\n    Specifically, if $d$ is the function and $x$, $y$,\n    and $z$ are vectors in the graph, then $d$ must satisfy\n\n    1. $d(x, y) \\ge 0$,\n    2. $d(x, y) = 0$ if and only if $x = y$,\n    3. $d(x, y) = d(y, x)$,\n    4. $d(x, z) \\le d(x, y) + d(y, z)$.\n\n    If this argument is not specified, the Euclidean distance metric is\n    used.\n\n    .. _metric: https://en.wikipedia.org/wiki/Metric_%28mathematics%29\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\npos_name : string, default=\"pos\"\n    The name of the node attribute which represents the position\n    in 2D coordinates of the node in the returned graph.\n\nReturns\n-------\nGraph\n    A random Waxman graph, undirected and without self-loops. Each\n    node has a node attribute ``'pos'`` that stores the position of\n    that node in Euclidean space as generated by this function.\n\nExamples\n--------\nSpecify an alternate distance metric using the ``metric`` keyword\nargument. For example, to use the \"`taxicab metric`_\" instead of the\ndefault `Euclidean metric`_::\n\n    >>> dist = lambda x, y: sum(abs(a - b) for a, b in zip(x, y))\n    >>> G = nx.waxman_graph(10, 0.5, 0.1, metric=dist)\n\n.. _taxicab metric: https://en.wikipedia.org/wiki/Taxicab_geometry\n.. _Euclidean metric: https://en.wikipedia.org/wiki/Euclidean_distance\n\nNotes\n-----\nStarting in NetworkX 2.0 the parameters alpha and beta align with their\nusual roles in the probability distribution. In earlier versions their\npositions in the expression were reversed. Their position in the calling\nsequence reversed as well to minimize backward incompatibility.\n\nReferences\n----------\n.. [1]  B. M. Waxman, *Routing of multipoint connections*.\n   IEEE J. Select. Areas Commun. 6(9),(1988) 1617--1622."}, {"type": "function", "name": "networkx.weakly_connected_components", "documentation": "Generate weakly connected components of G.\n\nParameters\n----------\nG : NetworkX graph\n    A directed graph\n\nReturns\n-------\ncomp : generator of sets\n    A generator of sets of nodes, one for each weakly connected\n    component of G.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is undirected.\n\nExamples\n--------\nGenerate a sorted list of weakly connected components, largest first.\n\n>>> G = nx.path_graph(4, create_using=nx.DiGraph())\n>>> nx.add_path(G, [10, 11, 12])\n>>> [len(c) for c in sorted(nx.weakly_connected_components(G), key=len, reverse=True)]\n[4, 3]\n\nIf you only want the largest component, it's more efficient to\nuse max instead of sort:\n\n>>> largest_cc = max(nx.weakly_connected_components(G), key=len)\n\nSee Also\n--------\nconnected_components\nstrongly_connected_components\n\nNotes\n-----\nFor directed graphs only."}, {"type": "function", "name": "networkx.weisfeiler_lehman_graph_hash", "documentation": "Return Weisfeiler Lehman (WL) graph hash.\n\nThe function iteratively aggregates and hashes neighborhoods of each node.\nAfter each node's neighbors are hashed to obtain updated node labels,\na hashed histogram of resulting labels is returned as the final hash.\n\nHashes are identical for isomorphic graphs and strong guarantees that\nnon-isomorphic graphs will get different hashes. See [1]_ for details.\n\nIf no node or edge attributes are provided, the degree of each node\nis used as its initial label.\nOtherwise, node and/or edge labels are used to compute the hash.\n\nParameters\n----------\nG : graph\n    The graph to be hashed.\n    Can have node and/or edge attributes. Can also have no attributes.\nedge_attr : string, optional (default=None)\n    The key in edge attribute dictionary to be used for hashing.\n    If None, edge labels are ignored.\nnode_attr: string, optional (default=None)\n    The key in node attribute dictionary to be used for hashing.\n    If None, and no edge_attr given, use the degrees of the nodes as labels.\niterations: int, optional (default=3)\n    Number of neighbor aggregations to perform.\n    Should be larger for larger graphs.\ndigest_size: int, optional (default=16)\n    Size (in bits) of blake2b hash digest to use for hashing node labels.\n\nReturns\n-------\nh : string\n    Hexadecimal string corresponding to hash of the input graph.\n\nExamples\n--------\nTwo graphs with edge attributes that are isomorphic, except for\ndifferences in the edge labels.\n\n>>> G1 = nx.Graph()\n>>> G1.add_edges_from(\n...     [\n...         (1, 2, {\"label\": \"A\"}),\n...         (2, 3, {\"label\": \"A\"}),\n...         (3, 1, {\"label\": \"A\"}),\n...         (1, 4, {\"label\": \"B\"}),\n...     ]\n... )\n>>> G2 = nx.Graph()\n>>> G2.add_edges_from(\n...     [\n...         (5, 6, {\"label\": \"B\"}),\n...         (6, 7, {\"label\": \"A\"}),\n...         (7, 5, {\"label\": \"A\"}),\n...         (7, 8, {\"label\": \"A\"}),\n...     ]\n... )\n\nOmitting the `edge_attr` option, results in identical hashes.\n\n>>> nx.weisfeiler_lehman_graph_hash(G1)\n'7bc4dde9a09d0b94c5097b219891d81a'\n>>> nx.weisfeiler_lehman_graph_hash(G2)\n'7bc4dde9a09d0b94c5097b219891d81a'\n\nWith edge labels, the graphs are no longer assigned\nthe same hash digest.\n\n>>> nx.weisfeiler_lehman_graph_hash(G1, edge_attr=\"label\")\n'c653d85538bcf041d88c011f4f905f10'\n>>> nx.weisfeiler_lehman_graph_hash(G2, edge_attr=\"label\")\n'3dcd84af1ca855d0eff3c978d88e7ec7'\n\nNotes\n-----\nTo return the WL hashes of each subgraph of a graph, use\n`weisfeiler_lehman_subgraph_hashes`\n\nSimilarity between hashes does not imply similarity between graphs.\n\nReferences\n----------\n.. [1] Shervashidze, Nino, Pascal Schweitzer, Erik Jan Van Leeuwen,\n   Kurt Mehlhorn, and Karsten M. Borgwardt. Weisfeiler Lehman\n   Graph Kernels. Journal of Machine Learning Research. 2011.\n   http://www.jmlr.org/papers/volume12/shervashidze11a/shervashidze11a.pdf\n\nSee also\n--------\nweisfeiler_lehman_subgraph_hashes"}, {"type": "function", "name": "networkx.weisfeiler_lehman_subgraph_hashes", "documentation": "Return a dictionary of subgraph hashes by node.\n\nDictionary keys are nodes in `G`, and values are a list of hashes.\nEach hash corresponds to a subgraph rooted at a given node u in `G`.\nLists of subgraph hashes are sorted in increasing order of depth from\ntheir root node, with the hash at index i corresponding to a subgraph\nof nodes at most i edges distance from u. Thus, each list will contain\n`iterations` elements - a hash for a subgraph at each depth. If\n`include_initial_labels` is set to `True`, each list will additionally\nhave contain a hash of the initial node label (or equivalently a\nsubgraph of depth 0) prepended, totalling ``iterations + 1`` elements.\n\nThe function iteratively aggregates and hashes neighborhoods of each node.\nThis is achieved for each step by replacing for each node its label from\nthe previous iteration with its hashed 1-hop neighborhood aggregate.\nThe new node label is then appended to a list of node labels for each\nnode.\n\nTo aggregate neighborhoods for a node $u$ at each step, all labels of\nnodes adjacent to $u$ are concatenated. If the `edge_attr` parameter is set,\nlabels for each neighboring node are prefixed with the value of this attribute\nalong the connecting edge from this neighbor to node $u$. The resulting string\nis then hashed to compress this information into a fixed digest size.\n\nThus, at the $i$-th iteration, nodes within $i$ hops influence any given\nhashed node label. We can therefore say that at depth $i$ for node $u$\nwe have a hash for a subgraph induced by the $i$-hop neighborhood of $u$.\n\nThe output can be used to to create general Weisfeiler-Lehman graph kernels,\nor generate features for graphs or nodes - for example to generate 'words' in\na graph as seen in the 'graph2vec' algorithm.\nSee [1]_ & [2]_ respectively for details.\n\nHashes are identical for isomorphic subgraphs and there exist strong\nguarantees that non-isomorphic graphs will get different hashes.\nSee [1]_ for details.\n\nIf no node or edge attributes are provided, the degree of each node\nis used as its initial label.\nOtherwise, node and/or edge labels are used to compute the hash.\n\nParameters\n----------\nG : graph\n    The graph to be hashed.\n    Can have node and/or edge attributes. Can also have no attributes.\nedge_attr : string, optional (default=None)\n    The key in edge attribute dictionary to be used for hashing.\n    If None, edge labels are ignored.\nnode_attr : string, optional (default=None)\n    The key in node attribute dictionary to be used for hashing.\n    If None, and no edge_attr given, use the degrees of the nodes as labels.\n    If None, and edge_attr is given, each node starts with an identical label.\niterations : int, optional (default=3)\n    Number of neighbor aggregations to perform.\n    Should be larger for larger graphs.\ndigest_size : int, optional (default=16)\n    Size (in bits) of blake2b hash digest to use for hashing node labels.\n    The default size is 16 bits.\ninclude_initial_labels : bool, optional (default=False)\n    If True, include the hashed initial node label as the first subgraph\n    hash for each node.\n\nReturns\n-------\nnode_subgraph_hashes : dict\n    A dictionary with each key given by a node in G, and each value given\n    by the subgraph hashes in order of depth from the key node.\n\nExamples\n--------\nFinding similar nodes in different graphs:\n\n>>> G1 = nx.Graph()\n>>> G1.add_edges_from([(1, 2), (2, 3), (2, 4), (3, 5), (4, 6), (5, 7), (6, 7)])\n>>> G2 = nx.Graph()\n>>> G2.add_edges_from([(1, 3), (2, 3), (1, 6), (1, 5), (4, 6)])\n>>> g1_hashes = nx.weisfeiler_lehman_subgraph_hashes(G1, iterations=3, digest_size=8)\n>>> g2_hashes = nx.weisfeiler_lehman_subgraph_hashes(G2, iterations=3, digest_size=8)\n\nEven though G1 and G2 are not isomorphic (they have different numbers of edges),\nthe hash sequence of depth 3 for node 1 in G1 and node 5 in G2 are similar:\n\n>>> g1_hashes[1]\n['a93b64973cfc8897', 'db1b43ae35a1878f', '57872a7d2059c1c0']\n>>> g2_hashes[5]\n['a93b64973cfc8897', 'db1b43ae35a1878f', '1716d2a4012fa4bc']\n\nThe first 2 WL subgraph hashes match. From this we can conclude that it's very\nlikely the neighborhood of 2 hops around these nodes are isomorphic.\n\nHowever the 3-hop neighborhoods of ``G1`` and ``G2`` are not isomorphic since the\n3rd hashes in the lists above are not equal.\n\nThese nodes may be candidates to be classified together since their local topology\nis similar.\n\nNotes\n-----\nTo hash the full graph when subgraph hashes are not needed, use\n`weisfeiler_lehman_graph_hash` for efficiency.\n\nSimilarity between hashes does not imply similarity between graphs.\n\nReferences\n----------\n.. [1] Shervashidze, Nino, Pascal Schweitzer, Erik Jan Van Leeuwen,\n   Kurt Mehlhorn, and Karsten M. Borgwardt. Weisfeiler Lehman\n   Graph Kernels. Journal of Machine Learning Research. 2011.\n   http://www.jmlr.org/papers/volume12/shervashidze11a/shervashidze11a.pdf\n.. [2] Annamalai Narayanan, Mahinthan Chandramohan, Rajasekar Venkatesan,\n   Lihui Chen, Yang Liu and Shantanu Jaiswa. graph2vec: Learning\n   Distributed Representations of Graphs. arXiv. 2017\n   https://arxiv.org/pdf/1707.05005.pdf\n\nSee also\n--------\nweisfeiler_lehman_graph_hash"}, {"type": "function", "name": "networkx.wheel_graph", "documentation": "Return the wheel graph\n\nThe wheel graph consists of a hub node connected to a cycle of (n-1) nodes.\n\n.. plot::\n\n    >>> nx.draw(nx.wheel_graph(5))\n\nParameters\n----------\nn : int or iterable\n    If an integer, node labels are 0 to n with center 0.\n    If an iterable of nodes, the center is the first.\n    Warning: n is not checked for duplicates and if present the\n    resulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nNode labels are the integers 0 to n - 1."}, {"type": "function", "name": "networkx.wiener_index", "documentation": "Returns the Wiener index of the given graph.\n\nThe *Wiener index* of a graph is the sum of the shortest-path\n(weighted) distances between each pair of reachable nodes.\nFor pairs of nodes in undirected graphs, only one orientation\nof the pair is counted.\n\nParameters\n----------\nG : NetworkX graph\n\nweight : string or None, optional (default: None)\n    If None, every edge has weight 1.\n    If a string, use this edge attribute as the edge weight.\n    Any edge attribute not present defaults to 1.\n    The edge weights are used to computing shortest-path distances.\n\nReturns\n-------\nnumber\n    The Wiener index of the graph `G`.\n\nRaises\n------\nNetworkXError\n    If the graph `G` is not connected.\n\nNotes\n-----\nIf a pair of nodes is not reachable, the distance is assumed to be\ninfinity. This means that for graphs that are not\nstrongly-connected, this function returns ``inf``.\n\nThe Wiener index is not usually defined for directed graphs, however\nthis function uses the natural generalization of the Wiener index to\ndirected graphs.\n\nExamples\n--------\nThe Wiener index of the (unweighted) complete graph on *n* nodes\nequals the number of pairs of the *n* nodes, since each pair of\nnodes is at distance one::\n\n    >>> n = 10\n    >>> G = nx.complete_graph(n)\n    >>> nx.wiener_index(G) == n * (n - 1) / 2\n    True\n\nGraphs that are not strongly-connected have infinite Wiener index::\n\n    >>> G = nx.empty_graph(2)\n    >>> nx.wiener_index(G)\n    inf\n\nReferences\n----------\n.. [1] `Wikipedia: Wiener Index <https://en.wikipedia.org/wiki/Wiener_index>`_"}, {"type": "function", "name": "networkx.windmill_graph", "documentation": "Generate a windmill graph.\nA windmill graph is a graph of `n` cliques each of size `k` that are all\njoined at one node.\nIt can be thought of as taking a disjoint union of `n` cliques of size `k`,\nselecting one point from each, and contracting all of the selected points.\nAlternatively, one could generate `n` cliques of size `k-1` and one node\nthat is connected to all other nodes in the graph.\n\nParameters\n----------\nn : int\n    Number of cliques\nk : int\n    Size of cliques\n\nReturns\n-------\nG : NetworkX Graph\n    windmill graph with n cliques of size k\n\nRaises\n------\nNetworkXError\n    If the number of cliques is less than two\n    If the size of the cliques are less than two\n\nExamples\n--------\n>>> G = nx.windmill_graph(4, 5)\n\nNotes\n-----\nThe node labeled `0` will be the node connected to all other nodes.\nNote that windmill graphs are usually denoted `Wd(k,n)`, so the parameters\nare in the opposite order as the parameters of this method."}, {"type": "function", "name": "networkx.within_inter_cluster", "documentation": "Compute the ratio of within- and inter-cluster common neighbors\nof all node pairs in ebunch.\n\nFor two nodes `u` and `v`, if a common neighbor `w` belongs to the\nsame community as them, `w` is considered as within-cluster common\nneighbor of `u` and `v`. Otherwise, it is considered as\ninter-cluster common neighbor of `u` and `v`. The ratio between the\nsize of the set of within- and inter-cluster common neighbors is\ndefined as the WIC measure. [1]_\n\nParameters\n----------\nG : graph\n    A NetworkX undirected graph.\n\nebunch : iterable of node pairs, optional (default = None)\n    The WIC measure will be computed for each pair of nodes given in\n    the iterable. The pairs must be given as 2-tuples (u, v) where\n    u and v are nodes in the graph. If ebunch is None then all\n    nonexistent edges in the graph will be used.\n    Default value: None.\n\ndelta : float, optional (default = 0.001)\n    Value to prevent division by zero in case there is no\n    inter-cluster common neighbor between two nodes. See [1]_ for\n    details. Default value: 0.001.\n\ncommunity : string, optional (default = 'community')\n    Nodes attribute name containing the community information.\n    G[u][community] identifies which community u belongs to. Each\n    node belongs to at most one community. Default value: 'community'.\n\nReturns\n-------\npiter : iterator\n    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\n    pair of nodes and p is their WIC measure.\n\nRaises\n------\nNetworkXNotImplemented\n    If `G` is a `DiGraph`, a `Multigraph` or a `MultiDiGraph`.\n\nNetworkXAlgorithmError\n    - If `delta` is less than or equal to zero.\n    - If no community information is available for a node in `ebunch` or in `G` (if `ebunch` is `None`).\n\nNodeNotFound\n    If `ebunch` has a node that is not in `G`.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_edges_from([(0, 1), (0, 2), (0, 3), (1, 4), (2, 4), (3, 4)])\n>>> G.nodes[0][\"community\"] = 0\n>>> G.nodes[1][\"community\"] = 1\n>>> G.nodes[2][\"community\"] = 0\n>>> G.nodes[3][\"community\"] = 0\n>>> G.nodes[4][\"community\"] = 0\n>>> preds = nx.within_inter_cluster(G, [(0, 4)])\n>>> for u, v, p in preds:\n...     print(f\"({u}, {v}) -> {p:.8f}\")\n(0, 4) -> 1.99800200\n>>> preds = nx.within_inter_cluster(G, [(0, 4)], delta=0.5)\n>>> for u, v, p in preds:\n...     print(f\"({u}, {v}) -> {p:.8f}\")\n(0, 4) -> 1.33333333\n\nReferences\n----------\n.. [1] Jorge Carlos Valverde-Rebaza and Alneu de Andrade Lopes.\n   Link prediction in complex networks based on cluster information.\n   In Proceedings of the 21st Brazilian conference on Advances in\n   Artificial Intelligence (SBIA'12)\n   https://doi.org/10.1007/978-3-642-34459-6_10"}, {"type": "function", "name": "networkx.write_adjlist", "documentation": "Write graph G in single-line adjacency-list format to path.\n\n\nParameters\n----------\nG : NetworkX graph\n\npath : string or file\n   Filename or file handle for data output.\n   Filenames ending in .gz or .bz2 will be compressed.\n\ncomments : string, optional\n   Marker for comment lines\n\ndelimiter : string, optional\n   Separator for node labels\n\nencoding : string, optional\n   Text encoding.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_adjlist(G, \"test.adjlist\")\n\nThe path can be a filehandle or a string with the name of the file. If a\nfilehandle is provided, it has to be opened in 'wb' mode.\n\n>>> fh = open(\"test.adjlist\", \"wb\")\n>>> nx.write_adjlist(G, fh)\n\nNotes\n-----\nThe default `delimiter=\" \"` will result in unexpected results if node names contain\nwhitespace characters. To avoid this problem, specify an alternate delimiter when spaces are\nvalid in node names.\nNB: This option is not available for data that isn't user-generated.\n\nThis format does not store graph, node, or edge data.\n\nSee Also\n--------\nread_adjlist, generate_adjlist"}, {"type": "function", "name": "networkx.write_edgelist", "documentation": "Write graph as a list of edges.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\npath : file or string\n   File or filename to write. If a file is provided, it must be\n   opened in 'wb' mode. Filenames ending in .gz or .bz2 will be compressed.\ncomments : string, optional\n   The character used to indicate the start of a comment\ndelimiter : string, optional\n   The string used to separate values.  The default is whitespace.\ndata : bool or list, optional\n   If False write no edge data.\n   If True write a string representation of the edge data dictionary..\n   If a list (or other iterable) is provided, write the  keys specified\n   in the list.\nencoding: string, optional\n   Specify which encoding to use when writing file.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_edgelist(G, \"test.edgelist\")\n>>> G = nx.path_graph(4)\n>>> fh = open(\"test.edgelist\", \"wb\")\n>>> nx.write_edgelist(G, fh)\n>>> nx.write_edgelist(G, \"test.edgelist.gz\")\n>>> nx.write_edgelist(G, \"test.edgelist.gz\", data=False)\n\n>>> G = nx.Graph()\n>>> G.add_edge(1, 2, weight=7, color=\"red\")\n>>> nx.write_edgelist(G, \"test.edgelist\", data=False)\n>>> nx.write_edgelist(G, \"test.edgelist\", data=[\"color\"])\n>>> nx.write_edgelist(G, \"test.edgelist\", data=[\"color\", \"weight\"])\n\nSee Also\n--------\nread_edgelist\nwrite_weighted_edgelist"}, {"type": "function", "name": "networkx.write_gexf", "documentation": "Write G in GEXF format to path.\n\n\"GEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics\" [1]_.\n\nNode attributes are checked according to the version of the GEXF\nschemas used for parameters which are not user defined,\ne.g. visualization 'viz' [2]_. See example for usage.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\npath : file or string\n   File or file name to write.\n   File names ending in .gz or .bz2 will be compressed.\nencoding : string (optional, default: 'utf-8')\n   Encoding for text data.\nprettyprint : bool (optional, default: True)\n   If True use line breaks and indenting in output XML.\nversion: string (optional, default: '1.2draft')\n   The version of GEXF to be used for nodes attributes checking\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_gexf(G, \"test.gexf\")\n\n# visualization data\n>>> G.nodes[0][\"viz\"] = {\"size\": 54}\n>>> G.nodes[0][\"viz\"][\"position\"] = {\"x\": 0, \"y\": 1}\n>>> G.nodes[0][\"viz\"][\"color\"] = {\"r\": 0, \"g\": 0, \"b\": 256}\n\n\nNotes\n-----\nThis implementation does not support mixed graphs (directed and undirected\nedges together).\n\nThe node id attribute is set to be the string of the node label.\nIf you want to specify an id use set it as node data, e.g.\nnode['a']['id']=1 to set the id of node 'a' to 1.\n\nReferences\n----------\n.. [1] GEXF File Format, http://gexf.net/\n.. [2] GEXF schema, http://gexf.net/schema.html"}, {"type": "function", "name": "networkx.write_gml", "documentation": "Write a graph `G` in GML format to the file or file handle `path`.\n\nParameters\n----------\nG : NetworkX graph\n    The graph to be converted to GML.\n\npath : filename or filehandle\n    The filename or filehandle to write. Files whose names end with .gz or\n    .bz2 will be compressed.\n\nstringizer : callable, optional\n    A `stringizer` which converts non-int/non-float/non-dict values into\n    strings. If it cannot convert a value into a string, it should raise a\n    `ValueError` to indicate that. Default value: None.\n\nRaises\n------\nNetworkXError\n    If `stringizer` cannot convert a value into a string, or the value to\n    convert is not a string while `stringizer` is None.\n\nSee Also\n--------\nread_gml, generate_gml\nliteral_stringizer\n\nNotes\n-----\nGraph attributes named 'directed', 'multigraph', 'node' or\n'edge', node attributes named 'id' or 'label', edge attributes\nnamed 'source' or 'target' (or 'key' if `G` is a multigraph)\nare ignored because these attribute names are used to encode the graph\nstructure.\n\nGML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a `stringizer`/`destringizer`, the code is capable of\nwriting `int`/`float`/`str`/`dict`/`list` data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan `str` you need to explicitly supply a `stringizer`/`destringizer`.\n\nNote that while we allow non-standard GML to be read from a file, we make\nsure to write GML format. In particular, underscores are not allowed in\nattribute names.\nFor additional documentation on the GML file format, please see the\n`GML url <https://web.archive.org/web/20190207140002/http://www.fim.uni-passau.de/index.php?id=17297&L=1>`_.\n\nSee the module docstring :mod:`networkx.readwrite.gml` for more details.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_gml(G, \"test.gml\")\n\nFilenames ending in .gz or .bz2 will be compressed.\n\n>>> nx.write_gml(G, \"test.gml.gz\")"}, {"type": "function", "name": "networkx.write_graph6", "documentation": "Write a simple undirected graph to a path in graph6 format.\n\nParameters\n----------\nG : Graph (undirected)\n\npath : str\n   The path naming the file to which to write the graph.\n\nnodes: list or iterable\n   Nodes are labeled 0...n-1 in the order provided.  If None the ordering\n   given by ``G.nodes()`` is used.\n\nheader: bool\n   If True add '>>graph6<<' string to head of data\n\nRaises\n------\nNetworkXNotImplemented\n    If the graph is directed or is a multigraph.\n\nValueError\n    If the graph has at least ``2 ** 36`` nodes; the graph6 format\n    is only defined for graphs of order less than ``2 ** 36``.\n\nExamples\n--------\nYou can write a graph6 file by giving the path to a file::\n\n    >>> import tempfile\n    >>> with tempfile.NamedTemporaryFile(delete=False) as f:\n    ...     nx.write_graph6(nx.path_graph(2), f.name)\n    ...     _ = f.seek(0)\n    ...     print(f.read())\n    b'>>graph6<<A_\\n'\n\nSee Also\n--------\nfrom_graph6_bytes, read_graph6\n\nNotes\n-----\nThe function writes a newline character after writing the encoding\nof the graph.\n\nThe format does not support edge or node labels, parallel edges or\nself loops.  If self loops are present they are silently ignored.\n\nReferences\n----------\n.. [1] Graph6 specification\n       <http://users.cecs.anu.edu.au/~bdm/data/formats.html>"}, {"type": "function", "name": "networkx.write_graphml", "documentation": "Write G in GraphML XML format to path\n\nThis function uses the LXML framework and should be faster than\nthe version using the xml library.\n\nParameters\n----------\nG : graph\n   A networkx graph\npath : file or string\n   File or filename to write.\n   Filenames ending in .gz or .bz2 will be compressed.\nencoding : string (optional)\n   Encoding for text data.\nprettyprint : bool (optional)\n   If True use line breaks and indenting in output XML.\ninfer_numeric_types : boolean\n   Determine if numeric types should be generalized.\n   For example, if edges have both int and float 'weight' attributes,\n   we infer in GraphML that both are floats.\nnamed_key_ids : bool (optional)\n   If True use attr.name as value for key elements' id attribute.\nedge_id_from_attribute : dict key (optional)\n    If provided, the graphml edge id is set by looking up the corresponding\n    edge data attribute keyed by this parameter. If `None` or the key does not exist in edge data,\n    the edge id is set by the edge key if `G` is a MultiGraph, else the edge id is left unset.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_graphml_lxml(G, \"fourpath.graphml\")\n\nNotes\n-----\nThis implementation does not support mixed graphs (directed\nand unidirected edges together) hyperedges, nested graphs, or ports."}, {"type": "function", "name": "networkx.write_graphml_lxml", "documentation": "Write G in GraphML XML format to path\n\nThis function uses the LXML framework and should be faster than\nthe version using the xml library.\n\nParameters\n----------\nG : graph\n   A networkx graph\npath : file or string\n   File or filename to write.\n   Filenames ending in .gz or .bz2 will be compressed.\nencoding : string (optional)\n   Encoding for text data.\nprettyprint : bool (optional)\n   If True use line breaks and indenting in output XML.\ninfer_numeric_types : boolean\n   Determine if numeric types should be generalized.\n   For example, if edges have both int and float 'weight' attributes,\n   we infer in GraphML that both are floats.\nnamed_key_ids : bool (optional)\n   If True use attr.name as value for key elements' id attribute.\nedge_id_from_attribute : dict key (optional)\n    If provided, the graphml edge id is set by looking up the corresponding\n    edge data attribute keyed by this parameter. If `None` or the key does not exist in edge data,\n    the edge id is set by the edge key if `G` is a MultiGraph, else the edge id is left unset.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_graphml_lxml(G, \"fourpath.graphml\")\n\nNotes\n-----\nThis implementation does not support mixed graphs (directed\nand unidirected edges together) hyperedges, nested graphs, or ports."}, {"type": "function", "name": "networkx.write_graphml_xml", "documentation": "Write G in GraphML XML format to path\n\nParameters\n----------\nG : graph\n   A networkx graph\npath : file or string\n   File or filename to write.\n   Filenames ending in .gz or .bz2 will be compressed.\nencoding : string (optional)\n   Encoding for text data.\nprettyprint : bool (optional)\n   If True use line breaks and indenting in output XML.\ninfer_numeric_types : boolean\n   Determine if numeric types should be generalized.\n   For example, if edges have both int and float 'weight' attributes,\n   we infer in GraphML that both are floats.\nnamed_key_ids : bool (optional)\n   If True use attr.name as value for key elements' id attribute.\nedge_id_from_attribute : dict key (optional)\n    If provided, the graphml edge id is set by looking up the corresponding\n    edge data attribute keyed by this parameter. If `None` or the key does not exist in edge data,\n    the edge id is set by the edge key if `G` is a MultiGraph, else the edge id is left unset.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_graphml(G, \"test.graphml\")\n\nNotes\n-----\nThis implementation does not support mixed graphs (directed\nand unidirected edges together) hyperedges, nested graphs, or ports."}, {"type": "function", "name": "networkx.write_latex", "documentation": "Write the latex code to draw the graph(s) onto `path`.\n\nThis convenience function creates the latex drawing code as a string\nand writes that to a file ready to be compiled when `as_document` is True\nor ready to be ``import`` ed or ``include`` ed into your main LaTeX document.\n\nThe `path` argument can be a string filename or a file handle to write to.\n\nParameters\n----------\nGbunch : NetworkX graph or iterable of NetworkX graphs\n    If Gbunch is a graph, it is drawn in a figure environment.\n    If Gbunch is an iterable of graphs, each is drawn in a subfigure\n    environment within a single figure environment.\npath : filename\n    Filename or file handle to write to\noptions : dict\n    By default, TikZ is used with options: (others are ignored)::\n\n        pos : string or dict or list\n            The name of the node attribute on `G` that holds the position of each node.\n            Positions can be sequences of length 2 with numbers for (x,y) coordinates.\n            They can also be strings to denote positions in TikZ style, such as (x, y)\n            or (angle:radius).\n            If a dict, it should be keyed by node to a position.\n            If an empty dict, a circular layout is computed by TikZ.\n            If you are drawing many graphs in subfigures, use a list of position dicts.\n        tikz_options : string\n            The tikzpicture options description defining the options for the picture.\n            Often large scale options like `[scale=2]`.\n        default_node_options : string\n            The draw options for a path of nodes. Individual node options override these.\n        node_options : string or dict\n            The name of the node attribute on `G` that holds the options for each node.\n            Or a dict keyed by node to a string holding the options for that node.\n        node_label : string or dict\n            The name of the node attribute on `G` that holds the node label (text)\n            displayed for each node. If the attribute is \"\" or not present, the node\n            itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\n            Or a dict keyed by node to a string holding the label for that node.\n        default_edge_options : string\n            The options for the scope drawing all edges. The default is \"[-]\" for\n            undirected graphs and \"[->]\" for directed graphs.\n        edge_options : string or dict\n            The name of the edge attribute on `G` that holds the options for each edge.\n            If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\n            \"loop,\" is added to the options for the self-loop edge. Hence you can\n            use \"[loop above]\" explicitly, but the default is \"[loop]\".\n            Or a dict keyed by edge to a string holding the options for that edge.\n        edge_label : string or dict\n            The name of the edge attribute on `G` that holds the edge label (text)\n            displayed for each edge. If the attribute is \"\" or not present, no edge\n            label is drawn.\n            Or a dict keyed by edge to a string holding the label for that edge.\n        edge_label_options : string or dict\n            The name of the edge attribute on `G` that holds the label options for\n            each edge. For example, \"[sloped,above,blue]\". The default is no options.\n            Or a dict keyed by edge to a string holding the label options for that edge.\n        caption : string\n            The caption string for the figure environment\n        latex_label : string\n            The latex label used for the figure for easy referral from the main text\n        sub_captions : list of strings\n            The sub_caption string for each subfigure in the figure\n        sub_latex_labels : list of strings\n            The latex label for each subfigure in the figure\n        n_rows : int\n            The number of rows of subfigures to arrange for multiple graphs\n        as_document : bool\n            Whether to wrap the latex code in a document environment for compiling\n        document_wrapper : formatted text string with variable ``content``.\n            This text is called to evaluate the content embedded in a document\n            environment with a preamble setting up the TikZ syntax.\n        figure_wrapper : formatted text string\n            This text is evaluated with variables ``content``, ``caption`` and ``label``.\n            It wraps the content and if a caption is provided, adds the latex code for\n            that caption, and if a label is provided, adds the latex code for a label.\n        subfigure_wrapper : formatted text string\n            This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\n            It wraps the content and if a caption is provided, adds the latex code for\n            that caption, and if a label is provided, adds the latex code for a label.\n            The size is the vertical size of each row of subfigures as a fraction.\n\nSee Also\n========\nto_latex"}, {"type": "function", "name": "networkx.write_multiline_adjlist", "documentation": "Write the graph G in multiline adjacency list format to path\n\nParameters\n----------\nG : NetworkX graph\n\npath : string or file\n   Filename or file handle to write to.\n   Filenames ending in .gz or .bz2 will be compressed.\n\ncomments : string, optional\n   Marker for comment lines\n\ndelimiter : string, optional\n   Separator for node labels\n\nencoding : string, optional\n   Text encoding.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_multiline_adjlist(G, \"test.adjlist\")\n\nThe path can be a file handle or a string with the name of the file. If a\nfile handle is provided, it has to be opened in 'wb' mode.\n\n>>> fh = open(\"test.adjlist\", \"wb\")\n>>> nx.write_multiline_adjlist(G, fh)\n\nFilenames ending in .gz or .bz2 will be compressed.\n\n>>> nx.write_multiline_adjlist(G, \"test.adjlist.gz\")\n\nSee Also\n--------\nread_multiline_adjlist"}, {"type": "function", "name": "networkx.write_network_text", "documentation": "Creates a nice text representation of a graph\n\nThis works via a depth-first traversal of the graph and writing a line for\neach unique node encountered. Non-tree edges are written to the right of\neach node, and connection to a non-tree edge is indicated with an ellipsis.\nThis representation works best when the input graph is a forest, but any\ngraph can be represented.\n\nParameters\n----------\ngraph : nx.DiGraph | nx.Graph\n    Graph to represent\n\npath : string or file or callable or None\n   Filename or file handle for data output.\n   if a function, then it will be called for each generated line.\n   if None, this will default to \"sys.stdout.write\"\n\nwith_labels : bool | str\n    If True will use the \"label\" attribute of a node to display if it\n    exists otherwise it will use the node value itself. If given as a\n    string, then that attribute name will be used instead of \"label\".\n    Defaults to True.\n\nsources : List\n    Specifies which nodes to start traversal from. Note: nodes that are not\n    reachable from one of these sources may not be shown. If unspecified,\n    the minimal set of nodes needed to reach all others will be used.\n\nmax_depth : int | None\n    The maximum depth to traverse before stopping. Defaults to None.\n\nascii_only : Boolean\n    If True only ASCII characters are used to construct the visualization\n\nend : string\n    The line ending character\n\nvertical_chains : Boolean\n    If True, chains of nodes will be drawn vertically when possible.\n\nExamples\n--------\n>>> graph = nx.balanced_tree(r=2, h=2, create_using=nx.DiGraph)\n>>> nx.write_network_text(graph)\n\u2559\u2500\u2500 0\n    \u251c\u2500\u257c 1\n    \u2502   \u251c\u2500\u257c 3\n    \u2502   \u2514\u2500\u257c 4\n    \u2514\u2500\u257c 2\n        \u251c\u2500\u257c 5\n        \u2514\u2500\u257c 6\n\n>>> # A near tree with one non-tree edge\n>>> graph.add_edge(5, 1)\n>>> nx.write_network_text(graph)\n\u2559\u2500\u2500 0\n    \u251c\u2500\u257c 1 \u257e 5\n    \u2502   \u251c\u2500\u257c 3\n    \u2502   \u2514\u2500\u257c 4\n    \u2514\u2500\u257c 2\n        \u251c\u2500\u257c 5\n        \u2502   \u2514\u2500\u257c  ...\n        \u2514\u2500\u257c 6\n\n>>> graph = nx.cycle_graph(5)\n>>> nx.write_network_text(graph)\n\u2559\u2500\u2500 0\n    \u251c\u2500\u2500 1\n    \u2502   \u2514\u2500\u2500 2\n    \u2502       \u2514\u2500\u2500 3\n    \u2502           \u2514\u2500\u2500 4 \u2500 0\n    \u2514\u2500\u2500  ...\n\n>>> graph = nx.cycle_graph(5, nx.DiGraph)\n>>> nx.write_network_text(graph, vertical_chains=True)\n\u2559\u2500\u2500 0 \u257e 4\n    \u257d\n    1\n    \u257d\n    2\n    \u257d\n    3\n    \u257d\n    4\n    \u2514\u2500\u257c  ...\n\n>>> nx.write_network_text(graph, vertical_chains=True, ascii_only=True)\n+-- 0 <- 4\n    !\n    1\n    !\n    2\n    !\n    3\n    !\n    4\n    L->  ...\n\n>>> graph = nx.generators.barbell_graph(4, 2)\n>>> nx.write_network_text(graph, vertical_chains=False)\n\u2559\u2500\u2500 4\n    \u251c\u2500\u2500 5\n    \u2502   \u2514\u2500\u2500 6\n    \u2502       \u251c\u2500\u2500 7\n    \u2502       \u2502   \u251c\u2500\u2500 8 \u2500 6\n    \u2502       \u2502   \u2502   \u2514\u2500\u2500 9 \u2500 6, 7\n    \u2502       \u2502   \u2514\u2500\u2500  ...\n    \u2502       \u2514\u2500\u2500  ...\n    \u2514\u2500\u2500 3\n        \u251c\u2500\u2500 0\n        \u2502   \u251c\u2500\u2500 1 \u2500 3\n        \u2502   \u2502   \u2514\u2500\u2500 2 \u2500 0, 3\n        \u2502   \u2514\u2500\u2500  ...\n        \u2514\u2500\u2500  ...\n>>> nx.write_network_text(graph, vertical_chains=True)\n\u2559\u2500\u2500 4\n    \u251c\u2500\u2500 5\n    \u2502   \u2502\n    \u2502   6\n    \u2502   \u251c\u2500\u2500 7\n    \u2502   \u2502   \u251c\u2500\u2500 8 \u2500 6\n    \u2502   \u2502   \u2502   \u2502\n    \u2502   \u2502   \u2502   9 \u2500 6, 7\n    \u2502   \u2502   \u2514\u2500\u2500  ...\n    \u2502   \u2514\u2500\u2500  ...\n    \u2514\u2500\u2500 3\n        \u251c\u2500\u2500 0\n        \u2502   \u251c\u2500\u2500 1 \u2500 3\n        \u2502   \u2502   \u2502\n        \u2502   \u2502   2 \u2500 0, 3\n        \u2502   \u2514\u2500\u2500  ...\n        \u2514\u2500\u2500  ...\n\n>>> graph = nx.complete_graph(5, create_using=nx.Graph)\n>>> nx.write_network_text(graph)\n\u2559\u2500\u2500 0\n    \u251c\u2500\u2500 1\n    \u2502   \u251c\u2500\u2500 2 \u2500 0\n    \u2502   \u2502   \u251c\u2500\u2500 3 \u2500 0, 1\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 4 \u2500 0, 1, 2\n    \u2502   \u2502   \u2514\u2500\u2500  ...\n    \u2502   \u2514\u2500\u2500  ...\n    \u2514\u2500\u2500  ...\n\n>>> graph = nx.complete_graph(3, create_using=nx.DiGraph)\n>>> nx.write_network_text(graph)\n\u2559\u2500\u2500 0 \u257e 1, 2\n    \u251c\u2500\u257c 1 \u257e 2\n    \u2502   \u251c\u2500\u257c 2 \u257e 0\n    \u2502   \u2502   \u2514\u2500\u257c  ...\n    \u2502   \u2514\u2500\u257c  ...\n    \u2514\u2500\u257c  ..."}, {"type": "function", "name": "networkx.write_pajek", "documentation": "Write graph in Pajek format to path.\n\nParameters\n----------\nG : graph\n   A Networkx graph\npath : file or string\n   File or filename to write.\n   Filenames ending in .gz or .bz2 will be compressed.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_pajek(G, \"test.net\")\n\nWarnings\n--------\nOptional node attributes and edge attributes must be non-empty strings.\nOtherwise it will not be written into the file. You will need to\nconvert those attributes to strings if you want to keep them.\n\nReferences\n----------\nSee http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm\nfor format information."}, {"type": "function", "name": "networkx.write_sparse6", "documentation": "Write graph G to given path in sparse6 format.\n\nParameters\n----------\nG : Graph (undirected)\n\npath : file or string\n   File or filename to write\n\nnodes: list or iterable\n   Nodes are labeled 0...n-1 in the order provided.  If None the ordering\n   given by G.nodes() is used.\n\nheader: bool\n   If True add '>>sparse6<<' string to head of data\n\nRaises\n------\nNetworkXError\n    If the graph is directed\n\nExamples\n--------\nYou can write a sparse6 file by giving the path to the file::\n\n    >>> import tempfile\n    >>> with tempfile.NamedTemporaryFile(delete=False) as f:\n    ...     nx.write_sparse6(nx.path_graph(2), f.name)\n    ...     print(f.read())\n    b'>>sparse6<<:An\\n'\n\nYou can also write a sparse6 file by giving an open file-like object::\n\n    >>> with tempfile.NamedTemporaryFile() as f:\n    ...     nx.write_sparse6(nx.path_graph(2), f)\n    ...     _ = f.seek(0)\n    ...     print(f.read())\n    b'>>sparse6<<:An\\n'\n\nSee Also\n--------\nread_sparse6, from_sparse6_bytes\n\nNotes\n-----\nThe format does not support edge or node labels.\n\nReferences\n----------\n.. [1] Sparse6 specification\n       <https://users.cecs.anu.edu.au/~bdm/data/formats.html>"}, {"type": "function", "name": "networkx.write_weighted_edgelist", "documentation": "Write graph G as a list of edges with numeric weights.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\npath : file or string\n   File or filename to write. If a file is provided, it must be\n   opened in 'wb' mode.\n   Filenames ending in .gz or .bz2 will be compressed.\ncomments : string, optional\n   The character used to indicate the start of a comment\ndelimiter : string, optional\n   The string used to separate values.  The default is whitespace.\nencoding: string, optional\n   Specify which encoding to use when writing file.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_edge(1, 2, weight=7)\n>>> nx.write_weighted_edgelist(G, \"test.weighted.edgelist\")\n\nSee Also\n--------\nread_edgelist\nwrite_edgelist\nread_weighted_edgelist"}]