[{"type": "class", "name": "cdlib.AttrNodeClustering", "documentation": "Attribute Node Communities representation.\n\n:param communities: list of communities\n:param graph: a networkx/igraph object\n:param method_name: community discovery algorithm name\n:param coms_labels: dictionary specifying for each community the frequency of the attribute values\n:param method_parameters: configuration for the community discovery algorithm used\n:param overlap: boolean, whether the partition is overlapping or not"}, {"type": "method", "name": "cdlib.AttrNodeClustering._Clustering__convert_back_to_original_nodes_names_if_needed", "documentation": "If original nodes are int and we converted the graph to igraph, they were transformed to int. So we need to\ntransform them back to int\n:return:"}, {"type": "method", "name": "cdlib.AttrNodeClustering._NodeClustering__check_graph", "documentation": null}, {"type": "method", "name": "cdlib.AttrNodeClustering.__init__", "documentation": "Communities representation.\n\n:param communities: list of communities (community: list of nodes)\n:param method_name: algorithms discovery algorithm name\n:param overlap: boolean, whether the partition is overlapping or not"}, {"type": "method", "name": "cdlib.AttrNodeClustering.adjusted_mutual_information", "documentation": "Adjusted Mutual Information between two clusterings.\n\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings :math:`U` and :math:`V`, the AMI is given as::\n\n    AMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won't change the\nscore value in any way.\n\nThis metric is furthermore symmetric: switching ``label_true`` with\n``label_pred`` will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\n\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n\n:param clustering: NodeClustering object\n:return: AMI score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.adjusted_mutual_information(leiden_communities)\n\n:Reference:\n\n1. Vinh, N. X., Epps, J., & Bailey, J. (2010). **Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance.** Journal of Machine Learning Research, 11(Oct), 2837-2854."}, {"type": "method", "name": "cdlib.AttrNodeClustering.adjusted_rand_index", "documentation": "Rand index adjusted for chance.\n\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\n\nThe raw RI score is then \"adjusted for chance\" into the ARI score\nusing the following scheme::\n\n    ARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\n\nARI is a symmetric measure::\n\n    adjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n:param clustering: NodeClustering object\n:return: ARI score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.adjusted_rand_index(leiden_communities)\n\n\n:Reference:\n\n1. Hubert, L., & Arabie, P. (1985). **Comparing partitions**. Journal of classification, 2(1), 193-218."}, {"type": "method", "name": "cdlib.AttrNodeClustering.average_internal_degree", "documentation": "The average internal degree of the algorithms set.\n\n.. math:: f(S) = \\frac{2m_S}{n_S}\n\nwhere :math:`m_S` is the number of algorithms internal edges and :math:`n_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.average_internal_degree()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.avg_distance", "documentation": "Average distance.\n\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.avg_distance()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.avg_embeddedness", "documentation": "Average embeddedness of nodes within the community.\n\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n.. math:: emb(n,C) = \\frac{k_n^C}{k_n}\n\nThe average embeddedness of a community C is:\n\n.. math:: avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> ave = communities.avg_embeddedness()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.avg_odf", "documentation": "Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n.. math:: \\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\n\nwhere :math:`E` is the graph edge set, :math:`v` is a node in :math:`S`, :math:`d(u)` is the degree of :math:`u` and :math:`n_S` is the set of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.avg_odf()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.avg_transitivity", "documentation": "Average transitivity.\n\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.avg_transitivity()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.conductance", "documentation": "Fraction of total edge volume that points outside the algorithms.\n\n.. math:: f(S) = \\frac{c_S}{2 m_S+c_S}\n\nwhere :math:`c_S` is the number of algorithms nodes and, :math:`m_S` is the number of algorithms edges\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.conductance()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.cut_ratio", "documentation": "Fraction of existing edges (out of all possible edges) leaving the algorithms.\n\n..math:: f(S) = \\frac{c_S}{n_S (n \u2212 n_S)}\n\nwhere :math:`c_S` is the number of algorithms nodes and, :math:`n_S` is the number of edges on the algorithms boundary\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.cut_ratio()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.edges_inside", "documentation": "Number of edges internal to the algorithms.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.edges_inside()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.erdos_renyi_modularity", "documentation": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability :math:`p`.\n\n.. math:: Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\n\nwhere :math:`m` is the number of graph edges, :math:`m_S` is the number of algorithms edges, :math:`l_S` is the number of edges from nodes in S to nodes outside S.\n\n\n:return: the Erdos-Renyi modularity score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.erdos_renyi_modularity()\n\n:References:\n\nErdos, P., & Renyi, A. (1959). **On random graphs I.** Publ. Math. Debrecen, 6, 290-297."}, {"type": "method", "name": "cdlib.AttrNodeClustering.expansion", "documentation": "Number of edges per algorithms node that point outside the cluster.\n\n.. math:: f(S) = \\frac{c_S}{n_S}\n\nwhere :math:`n_S` is the number of edges on the algorithms boundary, :math:`c_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.expansion()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.f1", "documentation": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n\n:param clustering: NodeClustering object\n:return: F1 score (harmonic mean of precision and recall)\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.f1(leiden_communities)\n\n\n:Reference:\n\n1. Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). **A novel approach to evaluate algorithms detection internal on ground truth.** In Complex Networks VII (pp. 133-144). Springer, Cham."}, {"type": "method", "name": "cdlib.AttrNodeClustering.flake_odf", "documentation": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n.. math:: f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\n\nwhere :math:`E` is the graph edge set, :math:`v` is a node in :math:`S`, :math:`d(u)` is the degree of :math:`u` and :math:`n_S` is the set of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.flake_odf()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.fraction_over_median_degree", "documentation": "Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n.. math:: f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\n\n\nwhere :math:`d_m` is the internal degree median value\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.fraction_over_median_degree()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.get_description", "documentation": "Return a description of the clustering, with the name of the method and its numeric parameters.\n\n:param parameters_to_display: parameters to display. By default, all float parameters.\n:param precision: precision used to plot parameters. default: 3\n:return: a string description of the method."}, {"type": "method", "name": "cdlib.AttrNodeClustering.hub_dominance", "documentation": "Hub dominance.\n\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.hub_dominance()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.internal_edge_density", "documentation": "The internal density of the algorithms set.\n\n.. math:: f(S) = \\frac{m_S}{n_S(n_S\u22121)/2}\n\nwhere :math:`m_S` is the number of algorithms internal edges and :math:`n_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.internal_edge_density()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.link_modularity", "documentation": "Quality function designed for directed graphs with overlapping communities.\n\n:return: the link modularity score\n\n:Example:\n\n>>> from cdlib import evaluation\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.link_modularity()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.max_odf", "documentation": "Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n.. math:: max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\n\nwhere :math:`E` is the graph edge set, :math:`v` is a node in :math:`S` and :math:`d(u)` is the degree of :math:`u`\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.max_odf()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.modularity_density", "documentation": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms :math:`C` in partition :math:`S`, it uses the average modularity degree calculated by :math:`d(C) = d^{int(C)} \u2212 d^{ext(C)}` where :math:`d^{int(C)}` and :math:`d^{ext(C)}` are the average internal and external degrees of :math:`C` respectively to evaluate the fitness of :math:`C` in its network.\nFinally, the modularity density can be calculated as follows:\n\n.. math:: Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\n\nwhere :math:`n_C` is the number of nodes in C, :math:`k^{int}_{iC}` is the degree of node i within :math:`C` and :math:`k^{out}_{iC}` is the deree of node i outside :math:`C`.\n\n\n:return: the modularity density score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.modularity_density()\n\n:References:\n\nLi, Z., Zhang, S., Wang, R. S., Zhang, X. S., & Chen, L. (2008). **Quantitative function for algorithms detection.** Physical review E, 77(3), 036109."}, {"type": "method", "name": "cdlib.AttrNodeClustering.modularity_overlap", "documentation": "Determines the Overlapping Modularity of a partition C on a graph G.\n\nOverlapping Modularity is defined as\n\n.. math:: M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\n\n:param weight: label identifying the edge weight parameter name (if present), default None\n:return: FitnessResult object\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.modularity_overlap()\n\n:References:\n\n1. A. Lazar, D. Abel and T. Vicsek, \"Modularity measure of networks with overlapping communities\"  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"}, {"type": "method", "name": "cdlib.AttrNodeClustering.newman_girvan_modularity", "documentation": "Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\n\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n.. math:: Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\n\nwhere :math:`m` is the number of graph edges, :math:`m_S` is the number of algorithms edges, :math:`l_S` is the number of edges from nodes in S to nodes outside S.\n\n\n:return: the Newman-Girvan modularity score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.newman_girvan_modularity()\n\n:References:\n\nNewman, M.E.J. & Girvan, M. **Finding and evaluating algorithms structure in networks.** Physical Review E 69, 26113(2004)."}, {"type": "method", "name": "cdlib.AttrNodeClustering.nf1", "documentation": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n\n:param clustering: NodeClustering object\n:return: MatchingResult instance\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.nf1(leiden_communities)\n\n\n:Reference:\n\n1. Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). **A novel approach to evaluate algorithms detection internal on ground truth.**\n\n2. Rossetti, G. (2017). : **RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks.** 5(6), 893-912."}, {"type": "method", "name": "cdlib.AttrNodeClustering.normalized_cut", "documentation": "Normalized variant of the Cut-Ratio\n\n.. math:: : f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\n\nwhere :math:`m` is the number of graph edges, :math:`m_S` is the number of algorithms internal edges and :math:`c_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.normalized_cut()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.normalized_mutual_information", "documentation": "Normalized Mutual Information between two clusterings.\n\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by ``sqrt(H(labels_true) * H(labels_pred))``\n\n:param clustering: NodeClustering object\n:return: normalized mutual information score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.normalized_mutual_information(leiden_communities)"}, {"type": "method", "name": "cdlib.AttrNodeClustering.omega", "documentation": "Index of resemblance for overlapping, complete coverage, network clusterings.\n\n:param clustering: NodeClustering object\n:return: omega index\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.omega(leiden_communities)\n\n\n:Reference:\n\n1. Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. **Using the omega index for evaluating abstractive algorithms detection.** In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."}, {"type": "method", "name": "cdlib.AttrNodeClustering.overlapping_normalized_mutual_information_LFK", "documentation": "Overlapping Normalized Mutual Information between two clusterings.\n\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n\n:param clustering: NodeClustering object\n:return: onmi score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)\n\n:Reference:\n\n1. Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."}, {"type": "method", "name": "cdlib.AttrNodeClustering.overlapping_normalized_mutual_information_MGH", "documentation": "Overlapping Normalized Mutual Information between two clusterings.\n\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n\n:param clustering: NodeClustering object\n:param normalization: one of \"max\" or \"LFK\". Default \"max\" (corresponds to the main method described in the article)\n:return: onmi score\n\n:Example:\n\n>>> from cdlib import evaluation, algorithms\n>>> g = nx.karate_club_graph()\n>>> louvain_communities = algorithms.louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> evaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)\n:Reference:\n\n1. McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"}, {"type": "method", "name": "cdlib.AttrNodeClustering.purity", "documentation": "Purity is the product of the frequencies of the most frequent labels carried by the nodes within the communities\n:return: FitnessResult object"}, {"type": "method", "name": "cdlib.AttrNodeClustering.scaled_density", "documentation": "Scaled density.\n\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.scaled_density()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.significance", "documentation": "Significance estimates how likely a partition of dense communities appear in a random graph.\n\n:return: the significance score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.significance()\n\n\n:References:\n\nTraag, V. A., Aldecoa, R., & Delvenne, J. C. (2015). **Detecting communities using asymptotical surprise.** Physical Review E, 92(2), 022816."}, {"type": "method", "name": "cdlib.AttrNodeClustering.size", "documentation": "Size is the number of nodes in the community\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.size()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.surprise", "documentation": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\n\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n\n:return: the surprise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.surprise()\n\n:References:\n\nTraag, V. A., Aldecoa, R., & Delvenne, J. C. (2015). **Detecting communities using asymptotical surprise.** Physical Review E, 92(2), 022816."}, {"type": "method", "name": "cdlib.AttrNodeClustering.to_json", "documentation": "Generate a JSON representation of the algorithms object\n\n:return: a JSON formatted string representing the object"}, {"type": "method", "name": "cdlib.AttrNodeClustering.to_node_community_map", "documentation": "Generate a <node, list(communities)> representation of the current clustering\n\n:return: dict of the form <node, list(communities)>"}, {"type": "method", "name": "cdlib.AttrNodeClustering.triangle_participation_ratio", "documentation": "Fraction of algorithms nodes that belong to a triad.\n\n.. math:: f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\n\nwhere :math:`n_S` is the set of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.triangle_participation_ratio()"}, {"type": "method", "name": "cdlib.AttrNodeClustering.variation_of_information", "documentation": "Variation of Information among two nodes partitions.\n\n$$ H(p)+H(q)-2MI(p, q) $$\n\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n\n:param clustering: NodeClustering object\n:return: VI score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.variation_of_information(leiden_communities)\n\n\n:Reference:\n\n1. Meila, M. (2007). **Comparing clusterings - an information based distance.** Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"}, {"type": "method", "name": "cdlib.AttrNodeClustering.z_modularity", "documentation": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n\n:return: the z-modularity score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.z_modularity()\n\n\n:References:\n\nMiyauchi, Atsushi, and Yasushi Kawase. **Z-score-based modularity for algorithms detection in networks.** PloS one 11.1 (2016): e0147805."}, {"type": "class", "name": "cdlib.BiNodeClustering", "documentation": "Bipartite Node Communities representation.\n\n:param left_communities: list of left communities\n:param right_communities: list of right communities\n:param graph: a networkx/igraph object\n:param method_name: community discovery algorithm name\n:param method_parameters: configuration for the community discovery algorithm used\n:param overlap: boolean, whether the partition is overlapping or not"}, {"type": "method", "name": "cdlib.BiNodeClustering._Clustering__convert_back_to_original_nodes_names_if_needed", "documentation": "If original nodes are int and we converted the graph to igraph, they were transformed to int. So we need to\ntransform them back to int\n:return:"}, {"type": "method", "name": "cdlib.BiNodeClustering._NodeClustering__check_graph", "documentation": null}, {"type": "method", "name": "cdlib.BiNodeClustering.__init__", "documentation": "Communities representation.\n\n:param communities: list of communities (community: list of nodes)\n:param method_name: algorithms discovery algorithm name\n:param overlap: boolean, whether the partition is overlapping or not"}, {"type": "method", "name": "cdlib.BiNodeClustering.adjusted_mutual_information", "documentation": "Adjusted Mutual Information between two clusterings.\n\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings :math:`U` and :math:`V`, the AMI is given as::\n\n    AMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won't change the\nscore value in any way.\n\nThis metric is furthermore symmetric: switching ``label_true`` with\n``label_pred`` will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\n\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n\n:param clustering: NodeClustering object\n:return: AMI score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.adjusted_mutual_information(leiden_communities)\n\n:Reference:\n\n1. Vinh, N. X., Epps, J., & Bailey, J. (2010). **Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance.** Journal of Machine Learning Research, 11(Oct), 2837-2854."}, {"type": "method", "name": "cdlib.BiNodeClustering.adjusted_rand_index", "documentation": "Rand index adjusted for chance.\n\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\n\nThe raw RI score is then \"adjusted for chance\" into the ARI score\nusing the following scheme::\n\n    ARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\n\nARI is a symmetric measure::\n\n    adjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n:param clustering: NodeClustering object\n:return: ARI score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.adjusted_rand_index(leiden_communities)\n\n\n:Reference:\n\n1. Hubert, L., & Arabie, P. (1985). **Comparing partitions**. Journal of classification, 2(1), 193-218."}, {"type": "method", "name": "cdlib.BiNodeClustering.average_internal_degree", "documentation": "The average internal degree of the algorithms set.\n\n.. math:: f(S) = \\frac{2m_S}{n_S}\n\nwhere :math:`m_S` is the number of algorithms internal edges and :math:`n_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.average_internal_degree()"}, {"type": "method", "name": "cdlib.BiNodeClustering.avg_distance", "documentation": "Average distance.\n\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.avg_distance()"}, {"type": "method", "name": "cdlib.BiNodeClustering.avg_embeddedness", "documentation": "Average embeddedness of nodes within the community.\n\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n.. math:: emb(n,C) = \\frac{k_n^C}{k_n}\n\nThe average embeddedness of a community C is:\n\n.. math:: avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> ave = communities.avg_embeddedness()"}, {"type": "method", "name": "cdlib.BiNodeClustering.avg_odf", "documentation": "Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n.. math:: \\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\n\nwhere :math:`E` is the graph edge set, :math:`v` is a node in :math:`S`, :math:`d(u)` is the degree of :math:`u` and :math:`n_S` is the set of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.avg_odf()"}, {"type": "method", "name": "cdlib.BiNodeClustering.avg_transitivity", "documentation": "Average transitivity.\n\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.avg_transitivity()"}, {"type": "method", "name": "cdlib.BiNodeClustering.conductance", "documentation": "Fraction of total edge volume that points outside the algorithms.\n\n.. math:: f(S) = \\frac{c_S}{2 m_S+c_S}\n\nwhere :math:`c_S` is the number of algorithms nodes and, :math:`m_S` is the number of algorithms edges\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.conductance()"}, {"type": "method", "name": "cdlib.BiNodeClustering.cut_ratio", "documentation": "Fraction of existing edges (out of all possible edges) leaving the algorithms.\n\n..math:: f(S) = \\frac{c_S}{n_S (n \u2212 n_S)}\n\nwhere :math:`c_S` is the number of algorithms nodes and, :math:`n_S` is the number of edges on the algorithms boundary\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.cut_ratio()"}, {"type": "method", "name": "cdlib.BiNodeClustering.edges_inside", "documentation": "Number of edges internal to the algorithms.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.edges_inside()"}, {"type": "method", "name": "cdlib.BiNodeClustering.erdos_renyi_modularity", "documentation": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability :math:`p`.\n\n.. math:: Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\n\nwhere :math:`m` is the number of graph edges, :math:`m_S` is the number of algorithms edges, :math:`l_S` is the number of edges from nodes in S to nodes outside S.\n\n\n:return: the Erdos-Renyi modularity score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.erdos_renyi_modularity()\n\n:References:\n\nErdos, P., & Renyi, A. (1959). **On random graphs I.** Publ. Math. Debrecen, 6, 290-297."}, {"type": "method", "name": "cdlib.BiNodeClustering.expansion", "documentation": "Number of edges per algorithms node that point outside the cluster.\n\n.. math:: f(S) = \\frac{c_S}{n_S}\n\nwhere :math:`n_S` is the number of edges on the algorithms boundary, :math:`c_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.expansion()"}, {"type": "method", "name": "cdlib.BiNodeClustering.f1", "documentation": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n\n:param clustering: NodeClustering object\n:return: F1 score (harmonic mean of precision and recall)\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.f1(leiden_communities)\n\n\n:Reference:\n\n1. Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). **A novel approach to evaluate algorithms detection internal on ground truth.** In Complex Networks VII (pp. 133-144). Springer, Cham."}, {"type": "method", "name": "cdlib.BiNodeClustering.flake_odf", "documentation": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n.. math:: f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\n\nwhere :math:`E` is the graph edge set, :math:`v` is a node in :math:`S`, :math:`d(u)` is the degree of :math:`u` and :math:`n_S` is the set of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.flake_odf()"}, {"type": "method", "name": "cdlib.BiNodeClustering.fraction_over_median_degree", "documentation": "Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n.. math:: f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\n\n\nwhere :math:`d_m` is the internal degree median value\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.fraction_over_median_degree()"}, {"type": "method", "name": "cdlib.BiNodeClustering.get_description", "documentation": "Return a description of the clustering, with the name of the method and its numeric parameters.\n\n:param parameters_to_display: parameters to display. By default, all float parameters.\n:param precision: precision used to plot parameters. default: 3\n:return: a string description of the method."}, {"type": "method", "name": "cdlib.BiNodeClustering.hub_dominance", "documentation": "Hub dominance.\n\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.hub_dominance()"}, {"type": "method", "name": "cdlib.BiNodeClustering.internal_edge_density", "documentation": "The internal density of the algorithms set.\n\n.. math:: f(S) = \\frac{m_S}{n_S(n_S\u22121)/2}\n\nwhere :math:`m_S` is the number of algorithms internal edges and :math:`n_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.internal_edge_density()"}, {"type": "method", "name": "cdlib.BiNodeClustering.link_modularity", "documentation": "Quality function designed for directed graphs with overlapping communities.\n\n:return: the link modularity score\n\n:Example:\n\n>>> from cdlib import evaluation\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.link_modularity()"}, {"type": "method", "name": "cdlib.BiNodeClustering.max_odf", "documentation": "Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n.. math:: max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\n\nwhere :math:`E` is the graph edge set, :math:`v` is a node in :math:`S` and :math:`d(u)` is the degree of :math:`u`\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.max_odf()"}, {"type": "method", "name": "cdlib.BiNodeClustering.modularity_density", "documentation": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms :math:`C` in partition :math:`S`, it uses the average modularity degree calculated by :math:`d(C) = d^{int(C)} \u2212 d^{ext(C)}` where :math:`d^{int(C)}` and :math:`d^{ext(C)}` are the average internal and external degrees of :math:`C` respectively to evaluate the fitness of :math:`C` in its network.\nFinally, the modularity density can be calculated as follows:\n\n.. math:: Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\n\nwhere :math:`n_C` is the number of nodes in C, :math:`k^{int}_{iC}` is the degree of node i within :math:`C` and :math:`k^{out}_{iC}` is the deree of node i outside :math:`C`.\n\n\n:return: the modularity density score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.modularity_density()\n\n:References:\n\nLi, Z., Zhang, S., Wang, R. S., Zhang, X. S., & Chen, L. (2008). **Quantitative function for algorithms detection.** Physical review E, 77(3), 036109."}, {"type": "method", "name": "cdlib.BiNodeClustering.modularity_overlap", "documentation": "Determines the Overlapping Modularity of a partition C on a graph G.\n\nOverlapping Modularity is defined as\n\n.. math:: M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\n\n:param weight: label identifying the edge weight parameter name (if present), default None\n:return: FitnessResult object\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.modularity_overlap()\n\n:References:\n\n1. A. Lazar, D. Abel and T. Vicsek, \"Modularity measure of networks with overlapping communities\"  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"}, {"type": "method", "name": "cdlib.BiNodeClustering.newman_girvan_modularity", "documentation": "Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\n\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n.. math:: Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\n\nwhere :math:`m` is the number of graph edges, :math:`m_S` is the number of algorithms edges, :math:`l_S` is the number of edges from nodes in S to nodes outside S.\n\n\n:return: the Newman-Girvan modularity score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.newman_girvan_modularity()\n\n:References:\n\nNewman, M.E.J. & Girvan, M. **Finding and evaluating algorithms structure in networks.** Physical Review E 69, 26113(2004)."}, {"type": "method", "name": "cdlib.BiNodeClustering.nf1", "documentation": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n\n:param clustering: NodeClustering object\n:return: MatchingResult instance\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.nf1(leiden_communities)\n\n\n:Reference:\n\n1. Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). **A novel approach to evaluate algorithms detection internal on ground truth.**\n\n2. Rossetti, G. (2017). : **RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks.** 5(6), 893-912."}, {"type": "method", "name": "cdlib.BiNodeClustering.normalized_cut", "documentation": "Normalized variant of the Cut-Ratio\n\n.. math:: : f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\n\nwhere :math:`m` is the number of graph edges, :math:`m_S` is the number of algorithms internal edges and :math:`c_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.normalized_cut()"}, {"type": "method", "name": "cdlib.BiNodeClustering.normalized_mutual_information", "documentation": "Normalized Mutual Information between two clusterings.\n\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by ``sqrt(H(labels_true) * H(labels_pred))``\n\n:param clustering: NodeClustering object\n:return: normalized mutual information score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.normalized_mutual_information(leiden_communities)"}, {"type": "method", "name": "cdlib.BiNodeClustering.omega", "documentation": "Index of resemblance for overlapping, complete coverage, network clusterings.\n\n:param clustering: NodeClustering object\n:return: omega index\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.omega(leiden_communities)\n\n\n:Reference:\n\n1. Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. **Using the omega index for evaluating abstractive algorithms detection.** In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."}, {"type": "method", "name": "cdlib.BiNodeClustering.overlapping_normalized_mutual_information_LFK", "documentation": "Overlapping Normalized Mutual Information between two clusterings.\n\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n\n:param clustering: NodeClustering object\n:return: onmi score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)\n\n:Reference:\n\n1. Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."}, {"type": "method", "name": "cdlib.BiNodeClustering.overlapping_normalized_mutual_information_MGH", "documentation": "Overlapping Normalized Mutual Information between two clusterings.\n\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n\n:param clustering: NodeClustering object\n:param normalization: one of \"max\" or \"LFK\". Default \"max\" (corresponds to the main method described in the article)\n:return: onmi score\n\n:Example:\n\n>>> from cdlib import evaluation, algorithms\n>>> g = nx.karate_club_graph()\n>>> louvain_communities = algorithms.louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> evaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)\n:Reference:\n\n1. McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"}, {"type": "method", "name": "cdlib.BiNodeClustering.scaled_density", "documentation": "Scaled density.\n\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.scaled_density()"}, {"type": "method", "name": "cdlib.BiNodeClustering.significance", "documentation": "Significance estimates how likely a partition of dense communities appear in a random graph.\n\n:return: the significance score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.significance()\n\n\n:References:\n\nTraag, V. A., Aldecoa, R., & Delvenne, J. C. (2015). **Detecting communities using asymptotical surprise.** Physical Review E, 92(2), 022816."}, {"type": "method", "name": "cdlib.BiNodeClustering.size", "documentation": "Size is the number of nodes in the community\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.size()"}, {"type": "method", "name": "cdlib.BiNodeClustering.surprise", "documentation": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\n\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n\n:return: the surprise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.surprise()\n\n:References:\n\nTraag, V. A., Aldecoa, R., & Delvenne, J. C. (2015). **Detecting communities using asymptotical surprise.** Physical Review E, 92(2), 022816."}, {"type": "method", "name": "cdlib.BiNodeClustering.to_json", "documentation": "Generate a JSON representation of the algorithms object\n\n:return: a JSON formatted string representing the object"}, {"type": "method", "name": "cdlib.BiNodeClustering.to_node_community_map", "documentation": "Generate a <node, list(communities)> representation of the current clustering\n\n:return: dict of the form <node, list(communities)>"}, {"type": "method", "name": "cdlib.BiNodeClustering.triangle_participation_ratio", "documentation": "Fraction of algorithms nodes that belong to a triad.\n\n.. math:: f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\n\nwhere :math:`n_S` is the set of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.triangle_participation_ratio()"}, {"type": "method", "name": "cdlib.BiNodeClustering.variation_of_information", "documentation": "Variation of Information among two nodes partitions.\n\n$$ H(p)+H(q)-2MI(p, q) $$\n\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n\n:param clustering: NodeClustering object\n:return: VI score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.variation_of_information(leiden_communities)\n\n\n:Reference:\n\n1. Meila, M. (2007). **Comparing clusterings - an information based distance.** Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"}, {"type": "method", "name": "cdlib.BiNodeClustering.z_modularity", "documentation": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n\n:return: the z-modularity score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.z_modularity()\n\n\n:References:\n\nMiyauchi, Atsushi, and Yasushi Kawase. **Z-score-based modularity for algorithms detection in networks.** PloS one 11.1 (2016): e0147805."}, {"type": "class", "name": "cdlib.EdgeClustering", "documentation": "Edge Clustering representation.\n\n:param communities: list of communities\n:param graph: a networkx/igraph object\n:param method_name: community discovery algorithm name\n:param method_parameters: configuration for the community discovery algorithm used\n:param overlap: boolean, whether the partition is overlapping or not"}, {"type": "method", "name": "cdlib.EdgeClustering._Clustering__convert_back_to_original_nodes_names_if_needed", "documentation": "If original nodes are int and we converted the graph to igraph, they were transformed to int. So we need to\ntransform them back to int\n:return:"}, {"type": "method", "name": "cdlib.EdgeClustering.__init__", "documentation": "Communities representation.\n\n:param communities: list of communities (community: list of nodes)\n:param method_name: algorithms discovery algorithm name\n:param overlap: boolean, whether the partition is overlapping or not"}, {"type": "method", "name": "cdlib.EdgeClustering.get_description", "documentation": "Return a description of the clustering, with the name of the method and its numeric parameters.\n\n:param parameters_to_display: parameters to display. By default, all float parameters.\n:param precision: precision used to plot parameters. default: 3\n:return: a string description of the method."}, {"type": "method", "name": "cdlib.EdgeClustering.to_edge_community_map", "documentation": "Generate a <edge, list(communities)> representation of the current clustering\n\n:return: dict of the form <edge, list(communities)>"}, {"type": "method", "name": "cdlib.EdgeClustering.to_json", "documentation": "Generate a JSON representation of the algorithms object\n\n:return: a JSON formatted string representing the object"}, {"type": "class", "name": "cdlib.FuzzyNodeClustering", "documentation": "Fuzzy Node Communities representation.\n\n:param communities: list of communities\n:param node_allocation: dictionary specifying for each node the allocation of probability toward the communities it is placed in\n:param graph: a networkx/igraph object\n:param method_name: community discovery algorithm name\n:param method_parameters: configuration for the community discovery algorithm used\n:param overlap: boolean, whether the partition is overlapping or not"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering._Clustering__convert_back_to_original_nodes_names_if_needed", "documentation": "If original nodes are int and we converted the graph to igraph, they were transformed to int. So we need to\ntransform them back to int\n:return:"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering._NodeClustering__check_graph", "documentation": null}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.__init__", "documentation": "Communities representation.\n\n:param communities: list of communities (community: list of nodes)\n:param method_name: algorithms discovery algorithm name\n:param overlap: boolean, whether the partition is overlapping or not"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.adjusted_mutual_information", "documentation": "Adjusted Mutual Information between two clusterings.\n\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings :math:`U` and :math:`V`, the AMI is given as::\n\n    AMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won't change the\nscore value in any way.\n\nThis metric is furthermore symmetric: switching ``label_true`` with\n``label_pred`` will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\n\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n\n:param clustering: NodeClustering object\n:return: AMI score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.adjusted_mutual_information(leiden_communities)\n\n:Reference:\n\n1. Vinh, N. X., Epps, J., & Bailey, J. (2010). **Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance.** Journal of Machine Learning Research, 11(Oct), 2837-2854."}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.adjusted_rand_index", "documentation": "Rand index adjusted for chance.\n\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\n\nThe raw RI score is then \"adjusted for chance\" into the ARI score\nusing the following scheme::\n\n    ARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\n\nARI is a symmetric measure::\n\n    adjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n:param clustering: NodeClustering object\n:return: ARI score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.adjusted_rand_index(leiden_communities)\n\n\n:Reference:\n\n1. Hubert, L., & Arabie, P. (1985). **Comparing partitions**. Journal of classification, 2(1), 193-218."}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.average_internal_degree", "documentation": "The average internal degree of the algorithms set.\n\n.. math:: f(S) = \\frac{2m_S}{n_S}\n\nwhere :math:`m_S` is the number of algorithms internal edges and :math:`n_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.average_internal_degree()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.avg_distance", "documentation": "Average distance.\n\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.avg_distance()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.avg_embeddedness", "documentation": "Average embeddedness of nodes within the community.\n\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n.. math:: emb(n,C) = \\frac{k_n^C}{k_n}\n\nThe average embeddedness of a community C is:\n\n.. math:: avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> ave = communities.avg_embeddedness()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.avg_odf", "documentation": "Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n.. math:: \\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\n\nwhere :math:`E` is the graph edge set, :math:`v` is a node in :math:`S`, :math:`d(u)` is the degree of :math:`u` and :math:`n_S` is the set of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.avg_odf()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.avg_transitivity", "documentation": "Average transitivity.\n\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.avg_transitivity()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.conductance", "documentation": "Fraction of total edge volume that points outside the algorithms.\n\n.. math:: f(S) = \\frac{c_S}{2 m_S+c_S}\n\nwhere :math:`c_S` is the number of algorithms nodes and, :math:`m_S` is the number of algorithms edges\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.conductance()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.cut_ratio", "documentation": "Fraction of existing edges (out of all possible edges) leaving the algorithms.\n\n..math:: f(S) = \\frac{c_S}{n_S (n \u2212 n_S)}\n\nwhere :math:`c_S` is the number of algorithms nodes and, :math:`n_S` is the number of edges on the algorithms boundary\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.cut_ratio()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.edges_inside", "documentation": "Number of edges internal to the algorithms.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.edges_inside()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.erdos_renyi_modularity", "documentation": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability :math:`p`.\n\n.. math:: Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\n\nwhere :math:`m` is the number of graph edges, :math:`m_S` is the number of algorithms edges, :math:`l_S` is the number of edges from nodes in S to nodes outside S.\n\n\n:return: the Erdos-Renyi modularity score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.erdos_renyi_modularity()\n\n:References:\n\nErdos, P., & Renyi, A. (1959). **On random graphs I.** Publ. Math. Debrecen, 6, 290-297."}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.expansion", "documentation": "Number of edges per algorithms node that point outside the cluster.\n\n.. math:: f(S) = \\frac{c_S}{n_S}\n\nwhere :math:`n_S` is the number of edges on the algorithms boundary, :math:`c_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.expansion()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.f1", "documentation": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n\n:param clustering: NodeClustering object\n:return: F1 score (harmonic mean of precision and recall)\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.f1(leiden_communities)\n\n\n:Reference:\n\n1. Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). **A novel approach to evaluate algorithms detection internal on ground truth.** In Complex Networks VII (pp. 133-144). Springer, Cham."}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.flake_odf", "documentation": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n.. math:: f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\n\nwhere :math:`E` is the graph edge set, :math:`v` is a node in :math:`S`, :math:`d(u)` is the degree of :math:`u` and :math:`n_S` is the set of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.flake_odf()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.fraction_over_median_degree", "documentation": "Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n.. math:: f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\n\n\nwhere :math:`d_m` is the internal degree median value\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.fraction_over_median_degree()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.get_description", "documentation": "Return a description of the clustering, with the name of the method and its numeric parameters.\n\n:param parameters_to_display: parameters to display. By default, all float parameters.\n:param precision: precision used to plot parameters. default: 3\n:return: a string description of the method."}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.hub_dominance", "documentation": "Hub dominance.\n\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.hub_dominance()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.internal_edge_density", "documentation": "The internal density of the algorithms set.\n\n.. math:: f(S) = \\frac{m_S}{n_S(n_S\u22121)/2}\n\nwhere :math:`m_S` is the number of algorithms internal edges and :math:`n_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.internal_edge_density()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.link_modularity", "documentation": "Quality function designed for directed graphs with overlapping communities.\n\n:return: the link modularity score\n\n:Example:\n\n>>> from cdlib import evaluation\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.link_modularity()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.max_odf", "documentation": "Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n.. math:: max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\n\nwhere :math:`E` is the graph edge set, :math:`v` is a node in :math:`S` and :math:`d(u)` is the degree of :math:`u`\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.max_odf()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.modularity_density", "documentation": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms :math:`C` in partition :math:`S`, it uses the average modularity degree calculated by :math:`d(C) = d^{int(C)} \u2212 d^{ext(C)}` where :math:`d^{int(C)}` and :math:`d^{ext(C)}` are the average internal and external degrees of :math:`C` respectively to evaluate the fitness of :math:`C` in its network.\nFinally, the modularity density can be calculated as follows:\n\n.. math:: Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\n\nwhere :math:`n_C` is the number of nodes in C, :math:`k^{int}_{iC}` is the degree of node i within :math:`C` and :math:`k^{out}_{iC}` is the deree of node i outside :math:`C`.\n\n\n:return: the modularity density score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.modularity_density()\n\n:References:\n\nLi, Z., Zhang, S., Wang, R. S., Zhang, X. S., & Chen, L. (2008). **Quantitative function for algorithms detection.** Physical review E, 77(3), 036109."}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.modularity_overlap", "documentation": "Determines the Overlapping Modularity of a partition C on a graph G.\n\nOverlapping Modularity is defined as\n\n.. math:: M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\n\n:param weight: label identifying the edge weight parameter name (if present), default None\n:return: FitnessResult object\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.modularity_overlap()\n\n:References:\n\n1. A. Lazar, D. Abel and T. Vicsek, \"Modularity measure of networks with overlapping communities\"  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.newman_girvan_modularity", "documentation": "Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\n\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n.. math:: Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\n\nwhere :math:`m` is the number of graph edges, :math:`m_S` is the number of algorithms edges, :math:`l_S` is the number of edges from nodes in S to nodes outside S.\n\n\n:return: the Newman-Girvan modularity score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.newman_girvan_modularity()\n\n:References:\n\nNewman, M.E.J. & Girvan, M. **Finding and evaluating algorithms structure in networks.** Physical Review E 69, 26113(2004)."}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.nf1", "documentation": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n\n:param clustering: NodeClustering object\n:return: MatchingResult instance\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.nf1(leiden_communities)\n\n\n:Reference:\n\n1. Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). **A novel approach to evaluate algorithms detection internal on ground truth.**\n\n2. Rossetti, G. (2017). : **RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks.** 5(6), 893-912."}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.normalized_cut", "documentation": "Normalized variant of the Cut-Ratio\n\n.. math:: : f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\n\nwhere :math:`m` is the number of graph edges, :math:`m_S` is the number of algorithms internal edges and :math:`c_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.normalized_cut()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.normalized_mutual_information", "documentation": "Normalized Mutual Information between two clusterings.\n\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by ``sqrt(H(labels_true) * H(labels_pred))``\n\n:param clustering: NodeClustering object\n:return: normalized mutual information score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.normalized_mutual_information(leiden_communities)"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.omega", "documentation": "Index of resemblance for overlapping, complete coverage, network clusterings.\n\n:param clustering: NodeClustering object\n:return: omega index\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.omega(leiden_communities)\n\n\n:Reference:\n\n1. Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. **Using the omega index for evaluating abstractive algorithms detection.** In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.overlapping_normalized_mutual_information_LFK", "documentation": "Overlapping Normalized Mutual Information between two clusterings.\n\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n\n:param clustering: NodeClustering object\n:return: onmi score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)\n\n:Reference:\n\n1. Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.overlapping_normalized_mutual_information_MGH", "documentation": "Overlapping Normalized Mutual Information between two clusterings.\n\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n\n:param clustering: NodeClustering object\n:param normalization: one of \"max\" or \"LFK\". Default \"max\" (corresponds to the main method described in the article)\n:return: onmi score\n\n:Example:\n\n>>> from cdlib import evaluation, algorithms\n>>> g = nx.karate_club_graph()\n>>> louvain_communities = algorithms.louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> evaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)\n:Reference:\n\n1. McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.scaled_density", "documentation": "Scaled density.\n\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.scaled_density()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.significance", "documentation": "Significance estimates how likely a partition of dense communities appear in a random graph.\n\n:return: the significance score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.significance()\n\n\n:References:\n\nTraag, V. A., Aldecoa, R., & Delvenne, J. C. (2015). **Detecting communities using asymptotical surprise.** Physical Review E, 92(2), 022816."}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.size", "documentation": "Size is the number of nodes in the community\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.size()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.surprise", "documentation": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\n\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n\n:return: the surprise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.surprise()\n\n:References:\n\nTraag, V. A., Aldecoa, R., & Delvenne, J. C. (2015). **Detecting communities using asymptotical surprise.** Physical Review E, 92(2), 022816."}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.to_json", "documentation": "Generate a JSON representation of the algorithms object\n\n:return: a JSON formatted string representing the object"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.to_node_community_map", "documentation": "Generate a <node, list(communities)> representation of the current clustering\n\n:return: dict of the form <node, list(communities)>"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.triangle_participation_ratio", "documentation": "Fraction of algorithms nodes that belong to a triad.\n\n.. math:: f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\n\nwhere :math:`n_S` is the set of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.triangle_participation_ratio()"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.variation_of_information", "documentation": "Variation of Information among two nodes partitions.\n\n$$ H(p)+H(q)-2MI(p, q) $$\n\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n\n:param clustering: NodeClustering object\n:return: VI score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.variation_of_information(leiden_communities)\n\n\n:Reference:\n\n1. Meila, M. (2007). **Comparing clusterings - an information based distance.** Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"}, {"type": "method", "name": "cdlib.FuzzyNodeClustering.z_modularity", "documentation": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n\n:return: the z-modularity score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.z_modularity()\n\n\n:References:\n\nMiyauchi, Atsushi, and Yasushi Kawase. **Z-score-based modularity for algorithms detection in networks.** PloS one 11.1 (2016): e0147805."}, {"type": "class", "name": "cdlib.NamedClustering", "documentation": "Node Communities representation.\n\n:param communities: dict of named communities <community_id, node_list>\n:param graph: a networkx/igraph object\n:param method_name: community discovery algorithm name\n:param method_parameters: configuration for the community discovery algorithm used\n:param overlap: boolean, whether the partition is overlapping or not"}, {"type": "method", "name": "cdlib.NamedClustering._Clustering__convert_back_to_original_nodes_names_if_needed", "documentation": "If original nodes are int and we converted the graph to igraph, they were transformed to int. So we need to\ntransform them back to int\n:return:"}, {"type": "method", "name": "cdlib.NamedClustering.__init__", "documentation": "Communities representation.\n\n:param communities: list of communities (community: list of nodes)\n:param method_name: algorithms discovery algorithm name\n:param overlap: boolean, whether the partition is overlapping or not"}, {"type": "method", "name": "cdlib.NamedClustering.get_description", "documentation": "Return a description of the clustering, with the name of the method and its numeric parameters.\n\n:param parameters_to_display: parameters to display. By default, all float parameters.\n:param precision: precision used to plot parameters. default: 3\n:return: a string description of the method."}, {"type": "method", "name": "cdlib.NamedClustering.to_json", "documentation": "Generate a JSON representation of the algorithms object\n\n:return: a JSON formatted string representing the object"}, {"type": "class", "name": "cdlib.NodeClustering", "documentation": "Node Communities representation.\n\n:param communities: list of communities\n:param graph: a networkx/igraph object\n:param method_name: community discovery algorithm name\n:param method_parameters: configuration for the community discovery algorithm used\n:param overlap: boolean, whether the partition is overlapping or not"}, {"type": "method", "name": "cdlib.NodeClustering._Clustering__convert_back_to_original_nodes_names_if_needed", "documentation": "If original nodes are int and we converted the graph to igraph, they were transformed to int. So we need to\ntransform them back to int\n:return:"}, {"type": "method", "name": "cdlib.NodeClustering._NodeClustering__check_graph", "documentation": null}, {"type": "method", "name": "cdlib.NodeClustering.__init__", "documentation": "Communities representation.\n\n:param communities: list of communities (community: list of nodes)\n:param method_name: algorithms discovery algorithm name\n:param overlap: boolean, whether the partition is overlapping or not"}, {"type": "method", "name": "cdlib.NodeClustering.adjusted_mutual_information", "documentation": "Adjusted Mutual Information between two clusterings.\n\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings :math:`U` and :math:`V`, the AMI is given as::\n\n    AMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won't change the\nscore value in any way.\n\nThis metric is furthermore symmetric: switching ``label_true`` with\n``label_pred`` will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\n\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n\n:param clustering: NodeClustering object\n:return: AMI score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.adjusted_mutual_information(leiden_communities)\n\n:Reference:\n\n1. Vinh, N. X., Epps, J., & Bailey, J. (2010). **Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance.** Journal of Machine Learning Research, 11(Oct), 2837-2854."}, {"type": "method", "name": "cdlib.NodeClustering.adjusted_rand_index", "documentation": "Rand index adjusted for chance.\n\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\n\nThe raw RI score is then \"adjusted for chance\" into the ARI score\nusing the following scheme::\n\n    ARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\n\nARI is a symmetric measure::\n\n    adjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n:param clustering: NodeClustering object\n:return: ARI score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.adjusted_rand_index(leiden_communities)\n\n\n:Reference:\n\n1. Hubert, L., & Arabie, P. (1985). **Comparing partitions**. Journal of classification, 2(1), 193-218."}, {"type": "method", "name": "cdlib.NodeClustering.average_internal_degree", "documentation": "The average internal degree of the algorithms set.\n\n.. math:: f(S) = \\frac{2m_S}{n_S}\n\nwhere :math:`m_S` is the number of algorithms internal edges and :math:`n_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.average_internal_degree()"}, {"type": "method", "name": "cdlib.NodeClustering.avg_distance", "documentation": "Average distance.\n\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.avg_distance()"}, {"type": "method", "name": "cdlib.NodeClustering.avg_embeddedness", "documentation": "Average embeddedness of nodes within the community.\n\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n.. math:: emb(n,C) = \\frac{k_n^C}{k_n}\n\nThe average embeddedness of a community C is:\n\n.. math:: avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> ave = communities.avg_embeddedness()"}, {"type": "method", "name": "cdlib.NodeClustering.avg_odf", "documentation": "Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n.. math:: \\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\n\nwhere :math:`E` is the graph edge set, :math:`v` is a node in :math:`S`, :math:`d(u)` is the degree of :math:`u` and :math:`n_S` is the set of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.avg_odf()"}, {"type": "method", "name": "cdlib.NodeClustering.avg_transitivity", "documentation": "Average transitivity.\n\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.avg_transitivity()"}, {"type": "method", "name": "cdlib.NodeClustering.conductance", "documentation": "Fraction of total edge volume that points outside the algorithms.\n\n.. math:: f(S) = \\frac{c_S}{2 m_S+c_S}\n\nwhere :math:`c_S` is the number of algorithms nodes and, :math:`m_S` is the number of algorithms edges\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.conductance()"}, {"type": "method", "name": "cdlib.NodeClustering.cut_ratio", "documentation": "Fraction of existing edges (out of all possible edges) leaving the algorithms.\n\n..math:: f(S) = \\frac{c_S}{n_S (n \u2212 n_S)}\n\nwhere :math:`c_S` is the number of algorithms nodes and, :math:`n_S` is the number of edges on the algorithms boundary\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.cut_ratio()"}, {"type": "method", "name": "cdlib.NodeClustering.edges_inside", "documentation": "Number of edges internal to the algorithms.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.edges_inside()"}, {"type": "method", "name": "cdlib.NodeClustering.erdos_renyi_modularity", "documentation": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability :math:`p`.\n\n.. math:: Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\n\nwhere :math:`m` is the number of graph edges, :math:`m_S` is the number of algorithms edges, :math:`l_S` is the number of edges from nodes in S to nodes outside S.\n\n\n:return: the Erdos-Renyi modularity score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.erdos_renyi_modularity()\n\n:References:\n\nErdos, P., & Renyi, A. (1959). **On random graphs I.** Publ. Math. Debrecen, 6, 290-297."}, {"type": "method", "name": "cdlib.NodeClustering.expansion", "documentation": "Number of edges per algorithms node that point outside the cluster.\n\n.. math:: f(S) = \\frac{c_S}{n_S}\n\nwhere :math:`n_S` is the number of edges on the algorithms boundary, :math:`c_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.expansion()"}, {"type": "method", "name": "cdlib.NodeClustering.f1", "documentation": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n\n:param clustering: NodeClustering object\n:return: F1 score (harmonic mean of precision and recall)\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.f1(leiden_communities)\n\n\n:Reference:\n\n1. Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). **A novel approach to evaluate algorithms detection internal on ground truth.** In Complex Networks VII (pp. 133-144). Springer, Cham."}, {"type": "method", "name": "cdlib.NodeClustering.flake_odf", "documentation": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n.. math:: f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\n\nwhere :math:`E` is the graph edge set, :math:`v` is a node in :math:`S`, :math:`d(u)` is the degree of :math:`u` and :math:`n_S` is the set of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.flake_odf()"}, {"type": "method", "name": "cdlib.NodeClustering.fraction_over_median_degree", "documentation": "Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n.. math:: f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\n\n\nwhere :math:`d_m` is the internal degree median value\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.fraction_over_median_degree()"}, {"type": "method", "name": "cdlib.NodeClustering.get_description", "documentation": "Return a description of the clustering, with the name of the method and its numeric parameters.\n\n:param parameters_to_display: parameters to display. By default, all float parameters.\n:param precision: precision used to plot parameters. default: 3\n:return: a string description of the method."}, {"type": "method", "name": "cdlib.NodeClustering.hub_dominance", "documentation": "Hub dominance.\n\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.hub_dominance()"}, {"type": "method", "name": "cdlib.NodeClustering.internal_edge_density", "documentation": "The internal density of the algorithms set.\n\n.. math:: f(S) = \\frac{m_S}{n_S(n_S\u22121)/2}\n\nwhere :math:`m_S` is the number of algorithms internal edges and :math:`n_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.internal_edge_density()"}, {"type": "method", "name": "cdlib.NodeClustering.link_modularity", "documentation": "Quality function designed for directed graphs with overlapping communities.\n\n:return: the link modularity score\n\n:Example:\n\n>>> from cdlib import evaluation\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.link_modularity()"}, {"type": "method", "name": "cdlib.NodeClustering.max_odf", "documentation": "Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n.. math:: max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\n\nwhere :math:`E` is the graph edge set, :math:`v` is a node in :math:`S` and :math:`d(u)` is the degree of :math:`u`\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.max_odf()"}, {"type": "method", "name": "cdlib.NodeClustering.modularity_density", "documentation": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms :math:`C` in partition :math:`S`, it uses the average modularity degree calculated by :math:`d(C) = d^{int(C)} \u2212 d^{ext(C)}` where :math:`d^{int(C)}` and :math:`d^{ext(C)}` are the average internal and external degrees of :math:`C` respectively to evaluate the fitness of :math:`C` in its network.\nFinally, the modularity density can be calculated as follows:\n\n.. math:: Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\n\nwhere :math:`n_C` is the number of nodes in C, :math:`k^{int}_{iC}` is the degree of node i within :math:`C` and :math:`k^{out}_{iC}` is the deree of node i outside :math:`C`.\n\n\n:return: the modularity density score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.modularity_density()\n\n:References:\n\nLi, Z., Zhang, S., Wang, R. S., Zhang, X. S., & Chen, L. (2008). **Quantitative function for algorithms detection.** Physical review E, 77(3), 036109."}, {"type": "method", "name": "cdlib.NodeClustering.modularity_overlap", "documentation": "Determines the Overlapping Modularity of a partition C on a graph G.\n\nOverlapping Modularity is defined as\n\n.. math:: M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\n\n:param weight: label identifying the edge weight parameter name (if present), default None\n:return: FitnessResult object\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.modularity_overlap()\n\n:References:\n\n1. A. Lazar, D. Abel and T. Vicsek, \"Modularity measure of networks with overlapping communities\"  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"}, {"type": "method", "name": "cdlib.NodeClustering.newman_girvan_modularity", "documentation": "Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\n\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n.. math:: Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\n\nwhere :math:`m` is the number of graph edges, :math:`m_S` is the number of algorithms edges, :math:`l_S` is the number of edges from nodes in S to nodes outside S.\n\n\n:return: the Newman-Girvan modularity score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.newman_girvan_modularity()\n\n:References:\n\nNewman, M.E.J. & Girvan, M. **Finding and evaluating algorithms structure in networks.** Physical Review E 69, 26113(2004)."}, {"type": "method", "name": "cdlib.NodeClustering.nf1", "documentation": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n\n:param clustering: NodeClustering object\n:return: MatchingResult instance\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.nf1(leiden_communities)\n\n\n:Reference:\n\n1. Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). **A novel approach to evaluate algorithms detection internal on ground truth.**\n\n2. Rossetti, G. (2017). : **RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks.** 5(6), 893-912."}, {"type": "method", "name": "cdlib.NodeClustering.normalized_cut", "documentation": "Normalized variant of the Cut-Ratio\n\n.. math:: : f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\n\nwhere :math:`m` is the number of graph edges, :math:`m_S` is the number of algorithms internal edges and :math:`c_S` is the number of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.normalized_cut()"}, {"type": "method", "name": "cdlib.NodeClustering.normalized_mutual_information", "documentation": "Normalized Mutual Information between two clusterings.\n\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by ``sqrt(H(labels_true) * H(labels_pred))``\n\n:param clustering: NodeClustering object\n:return: normalized mutual information score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.normalized_mutual_information(leiden_communities)"}, {"type": "method", "name": "cdlib.NodeClustering.omega", "documentation": "Index of resemblance for overlapping, complete coverage, network clusterings.\n\n:param clustering: NodeClustering object\n:return: omega index\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.omega(leiden_communities)\n\n\n:Reference:\n\n1. Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. **Using the omega index for evaluating abstractive algorithms detection.** In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."}, {"type": "method", "name": "cdlib.NodeClustering.overlapping_normalized_mutual_information_LFK", "documentation": "Overlapping Normalized Mutual Information between two clusterings.\n\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n\n:param clustering: NodeClustering object\n:return: onmi score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)\n\n:Reference:\n\n1. Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."}, {"type": "method", "name": "cdlib.NodeClustering.overlapping_normalized_mutual_information_MGH", "documentation": "Overlapping Normalized Mutual Information between two clusterings.\n\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n\n:param clustering: NodeClustering object\n:param normalization: one of \"max\" or \"LFK\". Default \"max\" (corresponds to the main method described in the article)\n:return: onmi score\n\n:Example:\n\n>>> from cdlib import evaluation, algorithms\n>>> g = nx.karate_club_graph()\n>>> louvain_communities = algorithms.louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> evaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)\n:Reference:\n\n1. McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"}, {"type": "method", "name": "cdlib.NodeClustering.scaled_density", "documentation": "Scaled density.\n\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n\n:param summary: boolean. If **True** it is returned an aggregated score for the partition is returned, otherwise individual-community ones. Default **True**.\n:return: If **summary==True** a FitnessResult object, otherwise a list of floats.\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> from cdlib import evaluation\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> scd = communities.scaled_density()"}, {"type": "method", "name": "cdlib.NodeClustering.significance", "documentation": "Significance estimates how likely a partition of dense communities appear in a random graph.\n\n:return: the significance score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.significance()\n\n\n:References:\n\nTraag, V. A., Aldecoa, R., & Delvenne, J. C. (2015). **Detecting communities using asymptotical surprise.** Physical Review E, 92(2), 022816."}, {"type": "method", "name": "cdlib.NodeClustering.size", "documentation": "Size is the number of nodes in the community\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\nExample:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.size()"}, {"type": "method", "name": "cdlib.NodeClustering.surprise", "documentation": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\n\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n\n:return: the surprise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.surprise()\n\n:References:\n\nTraag, V. A., Aldecoa, R., & Delvenne, J. C. (2015). **Detecting communities using asymptotical surprise.** Physical Review E, 92(2), 022816."}, {"type": "method", "name": "cdlib.NodeClustering.to_json", "documentation": "Generate a JSON representation of the algorithms object\n\n:return: a JSON formatted string representing the object"}, {"type": "method", "name": "cdlib.NodeClustering.to_node_community_map", "documentation": "Generate a <node, list(communities)> representation of the current clustering\n\n:return: dict of the form <node, list(communities)>"}, {"type": "method", "name": "cdlib.NodeClustering.triangle_participation_ratio", "documentation": "Fraction of algorithms nodes that belong to a triad.\n\n.. math:: f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\n\nwhere :math:`n_S` is the set of algorithms nodes.\n\n:param summary: (optional, default True) if **True**, an overall summary is returned for the partition (min, max, avg, std); if **False** a list of community-wise score\n:return: a FitnessResult object/a list of community-wise score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.triangle_participation_ratio()"}, {"type": "method", "name": "cdlib.NodeClustering.variation_of_information", "documentation": "Variation of Information among two nodes partitions.\n\n$$ H(p)+H(q)-2MI(p, q) $$\n\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n\n:param clustering: NodeClustering object\n:return: VI score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> leiden_communities = algorithms.leiden(g)\n>>> mod = communities.variation_of_information(leiden_communities)\n\n\n:Reference:\n\n1. Meila, M. (2007). **Comparing clusterings - an information based distance.** Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"}, {"type": "method", "name": "cdlib.NodeClustering.z_modularity", "documentation": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n\n:return: the z-modularity score\n\n:Example:\n\n>>> from cdlib.algorithms import louvain\n>>> g = nx.karate_club_graph()\n>>> communities = louvain(g)\n>>> mod = communities.z_modularity()\n\n\n:References:\n\nMiyauchi, Atsushi, and Yasushi Kawase. **Z-score-based modularity for algorithms detection in networks.** PloS one 11.1 (2016): e0147805."}, {"type": "class", "name": "cdlib.TemporalClustering", "documentation": null}, {"type": "method", "name": "cdlib.TemporalClustering.__init__", "documentation": "Temporal Communities representation"}, {"type": "method", "name": "cdlib.TemporalClustering.add_clustering", "documentation": "Add to the Temporal Clustering the communities observed at a given time\n\n:param clustering: a Clustering object\n:param time: time of observation"}, {"type": "method", "name": "cdlib.TemporalClustering.add_matching", "documentation": "Add a precomputed matching of the communities.\n\n:param matching: a list of tuples [(Ti_Ca, Tj_Cb, score), ... ].\n        Community names needs to satisfy the pattern {tid}_{cid}, where tid is the time of observation and\n        cid is the position of the community within the Clustering object."}, {"type": "method", "name": "cdlib.TemporalClustering.clustering_stability_trend", "documentation": "Returns the trend for community stability.\nThe stability index is computed for temporally adjacent clustering pairs.\n\n:param method: a comparison score taking as input two Clustering objects (e.g., NMI, NF1, ARI...)\n:return: a list of floats"}, {"type": "method", "name": "cdlib.TemporalClustering.community_matching", "documentation": "Reconstruct community matches across adjacent observations using a provided similarity function.\n\n:param method: a set similarity function with co-domain in [0,1] (e.g., Jaccard)\n:param two_sided: boolean.\n                    Whether the match has to be applied only from the past to the future (False, default)\n                    or even from the future to the past (True)\n:return: a list of tuples [(Ti_Ca, Tj_Cb, score), ... ].\n        Community names are assigned following the pattern {tid}_{cid}, where tid is the time of observation and\n        cid is the position of the community within the Clustering object."}, {"type": "method", "name": "cdlib.TemporalClustering.get_clustering_at", "documentation": "Returns the clustering observed at a given time\n\n:param time: the time of observation\n:return: a Clustering object"}, {"type": "method", "name": "cdlib.TemporalClustering.get_community", "documentation": "Returns the nodes within a given temporal community\n\n:param cid: community id of the form {tid}_{cid}, where tid is the time of observation and\n        cid is the position of the community within the Clustering object.\n:return: list of nodes within cid"}, {"type": "method", "name": "cdlib.TemporalClustering.get_explicit_community_match", "documentation": "Return an explicit matching of computed communities (if it exists)\n\n:return: a list of tuple [(Ti_Ca, Tj_Cb, score), ... ].\n        Community names are assigned following the pattern {tid}_{cid}, where tid is the time of observation and\n        cid is the position of the community within the Clustering object."}, {"type": "method", "name": "cdlib.TemporalClustering.get_observation_ids", "documentation": "Returns the list of temporal ids for the available clusterings\n:return: a list of temporal ids"}, {"type": "method", "name": "cdlib.TemporalClustering.has_explicit_match", "documentation": "Checks if the algorithm provided an explicit match of temporal communities\n\n:return: a list of tuple [(Ti_Ca, Tj_Cb, score), ... ].\n        Community names are assigned following the pattern {tid}_{cid}, where tid is the time of observation and\n        cid is the position of the community within the Clustering object."}, {"type": "method", "name": "cdlib.TemporalClustering.lifecycle_polytree", "documentation": "Reconstruct the poly-tree representing communities lifecycles using a provided similarity function.\n\n:param method: a set similarity function with co-domain in [0,1] (e.g., Jaccard)\n:param two_sided: boolean.\n                    Whether the match has to be applied only from the past to the future (False, default)\n                    or even from the future to the past (True)\n:return: a networkx DiGraph object.\n        Nodes represent communities, their ids are assigned following the pattern {tid}_{cid},\n        where tid is the time of observation and\n        cid is the position of the community within the Clustering object."}, {"type": "method", "name": "cdlib.TemporalClustering.to_json", "documentation": "Generate a JSON representation of the TemporalClustering object\n\n:return: a JSON formatted string representing the object"}]