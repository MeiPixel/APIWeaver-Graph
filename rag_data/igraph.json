[{"type": "class", "name": "igraph.ARPACKOptions", "documentation": "Class representing the parameters of the ARPACK module.\n\nARPACK is a Fortran implementation of the implicitly restarted\nArnoldi method, an algorithm for calculating some of the\neigenvalues and eigenvectors of a given matrix. igraph uses this\npackage occasionally, and this class can be used to fine-tune the\nbehaviour of ARPACK in such cases.\n\nThe class has several attributes which are not documented here,\nsince they are usually of marginal use to the ordinary user.\nSee the source code of the original ARPACK Fortran package\n(especially the file C{dsaupd.f}) for a detailed explanation of the\nparameters. Only the most basic attributes are explained here. Most\nof them are read only unless stated otherwise.\n\n - C{bmat}: type of the eigenproblem solved. C{'I'} means standard\n   eigenproblem (A*x = lambda*x), C{'G'} means generalized\n   eigenproblem (A*x = lambda*B*x).\n\n - C{n}: dimension of the eigenproblem\n\n - C{tol}: precision. If less than or equal to zero, the standard\n   machine precision is used as computed by the LAPACK utility\n   called C{dlamch}. This can be modified.\n\n - C{mxiter}: maximum number of update iterations to take. This\n   can be modified. You can also use C{maxiter}.\n\n - C{iter}: actual number of update iterations taken\n\n - C{numop}: total number of OP*x operations\n\n - C{numopb}: total number of B*x operations if C{bmat} is C{'G'}\n\n - C{numreo}: total number of steps of re-orthogonalization"}, {"type": "class", "name": "igraph.AdvancedGradientPalette", "documentation": "Advanced gradient that consists of more than two base colors.\n\nExample:\n\n  >>> pal = AdvancedGradientPalette([\"red\", \"black\", \"blue\"], n=9)\n  >>> pal.get(2)\n  (0.5, 0.0, 0.0, 1.0)\n  >>> pal.get(7)\n  (0.0, 0.0, 0.75, 1.0)"}, {"type": "method", "name": "igraph.AdvancedGradientPalette.__getitem__", "documentation": "Returns the given color from the palette.\n\nValues are cached: if the specific value given has already been\nlooked up, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@note: you shouldn't override this method in subclasses, override\n  L{_get} instead. If you override this method, lookups in the\n  L{known_colors} dict won't work, so you won't be able to refer to\n  colors by names or RGBA quadruplets, only by integer indices. The\n  caching functionality will disappear as well. However,\n  feel free to override this method if this is exactly the behaviour\n  you want.\n\n@param v: the color to be retrieved. If it is an integer, it is\n  passed to L{Palette._get} to be translated to an RGBA quadruplet.\n  Otherwise it is passed to L{color_name_to_rgb()} to determine the\n  RGBA values.\n\n@return: the color as an RGBA quadruplet"}, {"type": "method", "name": "igraph.AdvancedGradientPalette.__init__", "documentation": "Creates an advanced gradient palette\n\n@param colors: the colors in the gradient.\n@param indices: the color indices belonging to the given colors. If\n  C{None}, the colors are distributed equidistantly\n@param n: the total number of colors in the palette"}, {"type": "method", "name": "igraph.AdvancedGradientPalette.__len__", "documentation": "Returns the number of colors in this palette"}, {"type": "method", "name": "igraph.AdvancedGradientPalette.__plot__", "documentation": "Plots the colors of the palette on the given Cairo context/mpl Axes\n\nSupported keywork arguments in both Cairo and matplotlib are:\n\n  - C{orientation}: the orientation of the palette. Must be one of\n    the following values: C{left-right}, C{bottom-top}, C{right-left}\n    or C{top-bottom}. Possible aliases: C{horizontal} = C{left-right},\n    C{vertical} = C{bottom-top}, C{lr} = C{left-right},\n    C{rl} = C{right-left}, C{tb} = C{top-bottom}, C{bt} = C{bottom-top}.\n    The default is C{left-right}.\n\nAdditional supported keyword arguments in Cairo are:\n\n  - C{border_width}: line width of the border shown around the palette.\n    If zero or negative, the border is turned off. Default is C{1}.\n\n  - C{grid_width}: line width of the grid that separates palette cells.\n    If zero or negative, the grid is turned off. The grid is also\n    turned off if the size of a cell is less than three times the given\n    line width. Default is C{0}.  Fractional widths are also allowed.\n\nKeyword arguments in matplotlib are passes to Axes.imshow."}, {"type": "method", "name": "igraph.AdvancedGradientPalette.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.AdvancedGradientPalette._get", "documentation": "Returns the color corresponding to the given color index.\n\n@param v: numerical index of the color to be retrieved\n@return: a 4-tuple containing the RGBA values"}, {"type": "method", "name": "igraph.AdvancedGradientPalette.clear_cache", "documentation": "Clears the result cache.\n\nThe return values of L{Palette.get} are cached. Use this method\nto clear the cache."}, {"type": "method", "name": "igraph.AdvancedGradientPalette.get", "documentation": "Returns the given color from the palette.\n\nValues are cached: if the specific value given has already been\nlooked up, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@note: you shouldn't override this method in subclasses, override\n  L{_get} instead. If you override this method, lookups in the\n  L{known_colors} dict won't work, so you won't be able to refer to\n  colors by names or RGBA quadruplets, only by integer indices. The\n  caching functionality will disappear as well. However,\n  feel free to override this method if this is exactly the behaviour\n  you want.\n\n@param v: the color to be retrieved. If it is an integer, it is\n  passed to L{Palette._get} to be translated to an RGBA quadruplet.\n  Otherwise it is passed to L{color_name_to_rgb()} to determine the\n  RGBA values.\n\n@return: the color as an RGBA quadruplet"}, {"type": "method", "name": "igraph.AdvancedGradientPalette.get_many", "documentation": "Returns multiple colors from the palette.\n\nValues are cached: if the specific value given has already been\nlooked upon, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@param colors: the list of colors to be retrieved. The palette class\n  tries to make an educated guess here: if it is not possible to\n  interpret the value you passed here as a list of colors, the\n  class will simply try to interpret it as a single color by\n  forwarding the value to L{Palette.get}.\n@return: the colors as a list of RGBA quadruplets. The result will\n  be a list even if you passed a single color index or color name."}, {"type": "class", "name": "igraph.BFSIter", "documentation": "igraph BFS iterator object"}, {"type": "class", "name": "igraph.BoundingBox", "documentation": "Class representing a bounding box (a rectangular area) that\nencloses some objects."}, {"type": "method", "name": "igraph.BoundingBox.__and__", "documentation": "Returns the intersection of this rectangle with another.\n\nExample::\n\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.intersection(r2)\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2 & r1\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2.intersection(r1) == r1.intersection(r2)\n    True\n    >>> r1.intersection(r3)\n    Rectangle(0.0, 0.0, 0.0, 0.0)"}, {"type": "method", "name": "igraph.BoundingBox.__bool__", "documentation": null}, {"type": "method", "name": "igraph.BoundingBox.__eq__", "documentation": "Return self==value."}, {"type": "method", "name": "igraph.BoundingBox.__hash__", "documentation": "Return hash(self)."}, {"type": "method", "name": "igraph.BoundingBox.__init__", "documentation": "Creates a rectangle.\n\nThe corners of the rectangle can be specified by either a tuple\n(four items, two for each corner, respectively), four separate numbers\n(X and Y coordinates for each corner) or two separate numbers (width\nand height, the upper left corner is assumed to be at (0,0))"}, {"type": "method", "name": "igraph.BoundingBox.__ior__", "documentation": "Replaces this bounding box with the union of itself and\nanother.\n\nExample::\n\n    >>> box1 = BoundingBox(10, 20, 50, 60)\n    >>> box2 = BoundingBox(70, 40, 100, 90)\n    >>> box1 |= box2\n    >>> print(box1)\n    BoundingBox(10.0, 20.0, 100.0, 90.0)"}, {"type": "method", "name": "igraph.BoundingBox.__ne__", "documentation": "Return self!=value."}, {"type": "method", "name": "igraph.BoundingBox.__or__", "documentation": "Takes the union of this bounding box with another.\n\nThe result is a bounding box which encloses both bounding\nboxes.\n\nExample::\n\n    >>> box1 = BoundingBox(10, 20, 50, 60)\n    >>> box2 = BoundingBox(70, 40, 100, 90)\n    >>> box1 | box2\n    BoundingBox(10.0, 20.0, 100.0, 90.0)"}, {"type": "method", "name": "igraph.BoundingBox.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.BoundingBox.contract", "documentation": "Contracts the rectangle by the given margins.\n\n@return: a new L{Rectangle} object."}, {"type": "method", "name": "igraph.BoundingBox.expand", "documentation": "Expands the rectangle by the given margins.\n\n@return: a new L{Rectangle} object."}, {"type": "method", "name": "igraph.BoundingBox.intersection", "documentation": "Returns the intersection of this rectangle with another.\n\nExample::\n\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.intersection(r2)\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2 & r1\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2.intersection(r1) == r1.intersection(r2)\n    True\n    >>> r1.intersection(r3)\n    Rectangle(0.0, 0.0, 0.0, 0.0)"}, {"type": "method", "name": "igraph.BoundingBox.isdisjoint", "documentation": "Returns C{True} if the two rectangles have no intersection.\n\nExample::\n\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.isdisjoint(r2)\n    False\n    >>> r2.isdisjoint(r1)\n    False\n    >>> r1.isdisjoint(r3)\n    True\n    >>> r3.isdisjoint(r1)\n    True"}, {"type": "method", "name": "igraph.BoundingBox.isempty", "documentation": "Returns C{True} if the rectangle is empty (i.e. it has zero\nwidth and height).\n\nExample::\n\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(70, 70, 90, 90)\n    >>> r1.isempty()\n    False\n    >>> r2.isempty()\n    False\n    >>> r1.intersection(r2).isempty()\n    True"}, {"type": "method", "name": "igraph.BoundingBox.translate", "documentation": "Translates the rectangle in-place.\n\nExample:\n\n    >>> r = Rectangle(10, 20, 50, 70)\n    >>> r.translate(30, -10)\n    >>> r\n    Rectangle(40.0, 10.0, 80.0, 60.0)\n\n@param dx: the X coordinate of the translation vector\n@param dy: the Y coordinate of the translation vector"}, {"type": "method", "name": "igraph.BoundingBox.union", "documentation": "Returns the union of this rectangle with another.\n\nThe resulting rectangle is the smallest rectangle that contains both\nrectangles.\n\nExample::\n\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.union(r2)\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r2 | r1\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r2.union(r1) == r1.union(r2)\n    True\n    >>> r1.union(r3)\n    Rectangle(10.0, 10.0, 90.0, 90.0)"}, {"type": "class", "name": "igraph.CairoGraphDrawer", "documentation": "Class implementing the default visualisation of a graph.\n\nThe default visualisation of a graph draws the nodes on a 2D plane\naccording to a given L{Layout}, then draws a straight or curved\nedge between nodes connected by edges. This is the visualisation\nused when one invokes the L{plot()} function on a L{Graph} object.\n\nSee L{Graph.__plot__()} for the keyword arguments understood by\nthis drawer."}, {"type": "method", "name": "igraph.CairoGraphDrawer.__init__", "documentation": "Constructs the graph drawer and associates it to the given\nCairo context and the given L{BoundingBox}.\n\n@param context: the context on which we will draw\n@param bbox:    the bounding box within which we will draw.\n                Can be anything accepted by the constructor\n                of L{BoundingBox} (i.e., a 2-tuple, a 4-tuple\n                or a L{BoundingBox} object).\n@param vertex_drawer_factory: a factory method that returns an\n                L{AbstractCairoVertexDrawer} instance bound to a\n                given Cairo context. The factory method must take\n                four parameters: the Cairo context, the bounding\n                box of the drawing area, the palette to be\n                used for drawing colored vertices, and the graph layout.\n                The default vertex drawer is L{CairoVertexDrawer}.\n@param edge_drawer_factory: a factory method that returns an\n                L{AbstractCairoEdgeDrawer} instance bound to a\n                given Cairo context. The factory method must take\n                two parameters: the Cairo context and the palette\n                to be used for drawing colored edges. You can use\n                any of the actual L{AbstractEdgeDrawer}\n                implementations here to control the style of\n                edges drawn by igraph. The default edge drawer is\n                L{CairoArrowEdgeDrawer}.\n@param label_drawer_factory: a factory method that returns a\n                L{CairoTextDrawer} instance bound to a given Cairo\n                context. The method must take one parameter: the\n                Cairo context. The default label drawer is\n                L{CairoTextDrawer}."}, {"type": "method", "name": "igraph.CairoGraphDrawer._determine_edge_order", "documentation": "Returns the order in which the edge of the given graph have to be\ndrawn, assuming that the relevant keyword arguments (C{edge_order} and\nC{edge_order_by}) are given in C{kwds} as a dictionary. If neither\nC{edge_order} nor C{edge_order_by} is present in C{kwds}, this\nfunction returns C{None} to indicate that the graph drawer is free to\nchoose the most convenient edge ordering."}, {"type": "method", "name": "igraph.CairoGraphDrawer._determine_vertex_order", "documentation": "Returns the order in which the vertices of the given graph have to be\ndrawn, assuming that the relevant keyword arguments (C{vertex_order} and\nC{vertex_order_by}) are given in C{kwds} as a dictionary. If neither\nC{vertex_order} nor C{vertex_order_by} is present in C{kwds}, this\nfunction returns C{None} to indicate that the graph drawer is free to\nchoose the most convenient vertex ordering."}, {"type": "method", "name": "igraph.CairoGraphDrawer._mark_point", "documentation": "Marks the given point with a small circle on the canvas.\nUsed primarily for debugging purposes.\n\n@param x: the X coordinate of the point to mark\n@param y: the Y coordinate of the point to mark\n@param color: the color of the marker. It can be a\n  3-tuple (RGB components, alpha=0.5), a 4-tuple\n  (RGBA components) or an index where zero means red, 1 means\n  green, 2 means blue and so on.\n@param size: the diameter of the marker."}, {"type": "method", "name": "igraph.CairoGraphDrawer.draw", "documentation": "Abstract method, must be implemented in derived classes."}, {"type": "method", "name": "igraph.CairoGraphDrawer.ensure_layout", "documentation": "Helper method that ensures that I{layout} is an instance\nof L{Layout}. If it is not, the method will try to convert\nit to a L{Layout} according to the following rules:\n\n  - If I{layout} is a string, it is assumed to be a name\n    of an igraph layout, and it will be passed on to the\n    C{layout} method of the given I{graph} if I{graph} is\n    not C{None}.\n\n  - If I{layout} is C{None} and I{graph} has a \"layout\"\n    attribute, call this same function with the value of that\n    attribute.\n\n  - If I{layout} is C{None} and I{graph} does not have a \"layout\"\n    attribute, the C{layout} method of I{graph} will be invoked\n    with no parameters, which will call the default layout algorithm.\n\n  - Otherwise, I{layout} will be passed on to the constructor\n    of L{Layout}. This handles lists of lists, lists of tuples\n    and such.\n\nIf I{layout} is already a L{Layout} instance, it will still\nbe copied and a copy will be returned. This is because graph\ndrawers are allowed to transform the layout for their purposes,\nand we don't want the transformation to propagate back to the\ncaller."}, {"type": "class", "name": "igraph.ClusterColoringPalette", "documentation": "A palette suitable for coloring vertices when plotting a clustering.\n\nThis palette tries to make sure that the colors are easily distinguishable.\nThis is achieved by using a set of base colors and their lighter and darker\nvariants, depending on the number of elements in the palette.\n\nWhen the desired size of the palette is less than or equal to the number of\nbase colors (denoted by M{n}), only the bsae colors will be used. When the\nsize of the palette is larger than M{n} but less than M{2*n}, the base colors\nand their lighter variants will be used. Between M{2*n} and M{3*n}, the\nbase colors and their lighter and darker variants will be used. Above M{3*n},\nmore darker and lighter variants will be generated, but this makes the individual\ncolors less and less distinguishable."}, {"type": "method", "name": "igraph.ClusterColoringPalette.__getitem__", "documentation": "Returns the given color from the palette.\n\nValues are cached: if the specific value given has already been\nlooked up, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@note: you shouldn't override this method in subclasses, override\n  L{_get} instead. If you override this method, lookups in the\n  L{known_colors} dict won't work, so you won't be able to refer to\n  colors by names or RGBA quadruplets, only by integer indices. The\n  caching functionality will disappear as well. However,\n  feel free to override this method if this is exactly the behaviour\n  you want.\n\n@param v: the color to be retrieved. If it is an integer, it is\n  passed to L{Palette._get} to be translated to an RGBA quadruplet.\n  Otherwise it is passed to L{color_name_to_rgb()} to determine the\n  RGBA values.\n\n@return: the color as an RGBA quadruplet"}, {"type": "method", "name": "igraph.ClusterColoringPalette.__init__", "documentation": "Creates the palette backed by the given list. The list must contain\nRGBA quadruplets or color names, which will be resolved first by\nL{color_name_to_rgba()}. Anything that is understood by\nL{color_name_to_rgba()} is OK here."}, {"type": "method", "name": "igraph.ClusterColoringPalette.__len__", "documentation": "Returns the number of colors in this palette"}, {"type": "method", "name": "igraph.ClusterColoringPalette.__plot__", "documentation": "Plots the colors of the palette on the given Cairo context/mpl Axes\n\nSupported keywork arguments in both Cairo and matplotlib are:\n\n  - C{orientation}: the orientation of the palette. Must be one of\n    the following values: C{left-right}, C{bottom-top}, C{right-left}\n    or C{top-bottom}. Possible aliases: C{horizontal} = C{left-right},\n    C{vertical} = C{bottom-top}, C{lr} = C{left-right},\n    C{rl} = C{right-left}, C{tb} = C{top-bottom}, C{bt} = C{bottom-top}.\n    The default is C{left-right}.\n\nAdditional supported keyword arguments in Cairo are:\n\n  - C{border_width}: line width of the border shown around the palette.\n    If zero or negative, the border is turned off. Default is C{1}.\n\n  - C{grid_width}: line width of the grid that separates palette cells.\n    If zero or negative, the grid is turned off. The grid is also\n    turned off if the size of a cell is less than three times the given\n    line width. Default is C{0}.  Fractional widths are also allowed.\n\nKeyword arguments in matplotlib are passes to Axes.imshow."}, {"type": "method", "name": "igraph.ClusterColoringPalette.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.ClusterColoringPalette._get", "documentation": "This method will only be called if the requested color index is\noutside the size of the palette. In that case, we throw an exception"}, {"type": "method", "name": "igraph.ClusterColoringPalette.clear_cache", "documentation": "Clears the result cache.\n\nThe return values of L{Palette.get} are cached. Use this method\nto clear the cache."}, {"type": "method", "name": "igraph.ClusterColoringPalette.get", "documentation": "Returns the given color from the palette.\n\nValues are cached: if the specific value given has already been\nlooked up, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@note: you shouldn't override this method in subclasses, override\n  L{_get} instead. If you override this method, lookups in the\n  L{known_colors} dict won't work, so you won't be able to refer to\n  colors by names or RGBA quadruplets, only by integer indices. The\n  caching functionality will disappear as well. However,\n  feel free to override this method if this is exactly the behaviour\n  you want.\n\n@param v: the color to be retrieved. If it is an integer, it is\n  passed to L{Palette._get} to be translated to an RGBA quadruplet.\n  Otherwise it is passed to L{color_name_to_rgb()} to determine the\n  RGBA values.\n\n@return: the color as an RGBA quadruplet"}, {"type": "method", "name": "igraph.ClusterColoringPalette.get_many", "documentation": "Returns multiple colors from the palette.\n\nValues are cached: if the specific value given has already been\nlooked upon, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@param colors: the list of colors to be retrieved. The palette class\n  tries to make an educated guess here: if it is not possible to\n  interpret the value you passed here as a list of colors, the\n  class will simply try to interpret it as a single color by\n  forwarding the value to L{Palette.get}.\n@return: the colors as a list of RGBA quadruplets. The result will\n  be a list even if you passed a single color index or color name."}, {"type": "class", "name": "igraph.Clustering", "documentation": "Class representing a clustering of an arbitrary ordered set.\n\nThis is now used as a base for L{VertexClustering}, but it might be\nuseful for other purposes as well.\n\nMembers of an individual cluster can be accessed by the C{[]} operator:\n\n  >>> cl = Clustering([0,0,0,0,1,1,1,2,2,2,2])\n  >>> cl[0]\n  [0, 1, 2, 3]\n\nThe membership vector can be accessed by the C{membership} property:\n\n  >>> cl.membership\n  [0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2]\n\nThe number of clusters can be retrieved by the C{len} function:\n\n  >>> len(cl)\n  3\n\nYou can iterate over the clustering object as if it were a regular list\nof clusters:\n\n  >>> for cluster in cl:\n  ...     print(\" \".join(str(idx) for idx in cluster))\n  ...\n  0 1 2 3\n  4 5 6\n  7 8 9 10\n\nIf you need all the clusters at once as lists, you can simply convert\nthe clustering object to a list:\n\n  >>> cluster_list = list(cl)\n  >>> print(cluster_list)\n  [[0, 1, 2, 3], [4, 5, 6], [7, 8, 9, 10]]"}, {"type": "method", "name": "igraph.Clustering.__getitem__", "documentation": "Returns the members of the specified cluster.\n\n@param idx: the index of the cluster\n@return: the members of the specified cluster as a list\n@raise IndexError: if the index is out of bounds"}, {"type": "method", "name": "igraph.Clustering.__init__", "documentation": "Constructor.\n\n@param membership: the membership list -- that is, the cluster\n  index in which each element of the set belongs to.\n@param params: additional parameters to be stored in this\n  object's dictionary."}, {"type": "method", "name": "igraph.Clustering.__iter__", "documentation": "Iterates over the clusters in this clustering.\n\nThis method will return a generator that generates the clusters\none by one."}, {"type": "method", "name": "igraph.Clustering.__len__", "documentation": "Returns the number of clusters.\n\n@return: the number of clusters"}, {"type": "method", "name": "igraph.Clustering.__str__", "documentation": "Return str(self)."}, {"type": "method", "name": "igraph.Clustering._formatted_cluster_iterator", "documentation": "Iterates over the clusters and formats them into a string to be\npresented in the summary."}, {"type": "method", "name": "igraph.Clustering.as_cover", "documentation": "Returns a L{Cover} that contains the same clusters as this clustering."}, {"type": "method", "name": "igraph.Clustering.compare_to", "documentation": "Compares this clustering to another one using some similarity or\ndistance metric.\n\nThis is a convenience method that simply calls L{compare_communities}\nwith the two clusterings as arguments. Any extra positional or keyword\nargument is also forwarded to L{compare_communities}."}, {"type": "method", "name": "igraph.Clustering.size", "documentation": "Returns the size of a given cluster.\n\n@param idx: the cluster in which we are interested."}, {"type": "method", "name": "igraph.Clustering.size_histogram", "documentation": "Returns the histogram of cluster sizes.\n\n@param bin_width: the bin width of the histogram\n@return: a L{Histogram} object"}, {"type": "method", "name": "igraph.Clustering.sizes", "documentation": "Returns the size of given clusters.\n\nThe indices are given as positional arguments. If there are no\npositional arguments, the function will return the sizes of all clusters."}, {"type": "method", "name": "igraph.Clustering.summary", "documentation": "Returns the summary of the clustering.\n\nThe summary includes the number of items and clusters, and also the\nlist of members for each of the clusters if the verbosity is nonzero.\n\n@param verbosity: determines whether the cluster members should be\n  printed. Zero verbosity prints the number of items and clusters only.\n@return: the summary of the clustering as a string."}, {"type": "class", "name": "igraph.CohesiveBlocks", "documentation": "The cohesive block structure of a graph.\n\nInstances of this type are created by\nL{Graph.cohesive_blocks()<GraphBase.cohesive_blocks()>}. See the\ndocumentation of L{Graph.cohesive_blocks()<GraphBase.cohesive_blocks()>}\nfor an explanation of what cohesive blocks are.\n\nThis class provides a few more methods that make handling of cohesive\nblock structures easier."}, {"type": "method", "name": "igraph.CohesiveBlocks.__getitem__", "documentation": "Returns the cluster with the given index."}, {"type": "method", "name": "igraph.CohesiveBlocks.__init__", "documentation": "Constructs a new cohesive block structure for the given graph.\n\nIf any of I{blocks}, I{cohesion} or I{parent} is C{None}, all the\narguments will be ignored and\nL{Graph.cohesive_blocks()<GraphBase.cohesive_blocks()>} will be called\nto calculate the cohesive blocks. Otherwise, these three variables\nshould describe the *result* of a cohesive block structure calculation.\nChances are that you never have to construct L{CohesiveBlocks}\ninstances directly, just use\nL{Graph.cohesive_blocks()<GraphBase.cohesive_blocks()>}.\n\n@param graph: the graph itself\n@param blocks: a list containing the blocks; each block is described\n  as a list containing vertex IDs.\n@param cohesion: the cohesion of each block. The length of this list\n  must be equal to the length of I{blocks}.\n@param parent: the parent block of each block. Negative values or\n  C{None} mean that there is no parent block for that block. There\n  should be only one parent block, which covers the entire graph.\n@see: Graph.cohesive_blocks()"}, {"type": "method", "name": "igraph.CohesiveBlocks.__iter__", "documentation": "Iterates over the clusters in this cover."}, {"type": "method", "name": "igraph.CohesiveBlocks.__len__", "documentation": "Returns the number of clusters in this cover."}, {"type": "method", "name": "igraph.CohesiveBlocks.__plot__", "documentation": "Plots the cohesive block structure to the given Cairo context or\nmatplotlib Axes.\n\nSince a L{CohesiveBlocks} instance is also a L{VertexCover}, keyword\narguments accepted by L{VertexCover.__plot__()} are also accepted here.\nThe only difference is that the vertices are colored according to their\nmaximal cohesions by default, and groups are marked by colored blobs\nexcept the last group which encapsulates the whole graph.\n\nSee the documentation of L{VertexCover.__plot__()} for more details."}, {"type": "method", "name": "igraph.CohesiveBlocks.__str__", "documentation": "Returns a string representation of the cover."}, {"type": "method", "name": "igraph.CohesiveBlocks._formatted_cluster_iterator", "documentation": "Iterates over the clusters and formats them into a string to be\npresented in the summary."}, {"type": "method", "name": "igraph.CohesiveBlocks._resolve_names_in_clusters", "documentation": null}, {"type": "method", "name": "igraph.CohesiveBlocks.cohesion", "documentation": "Returns the cohesion of the group with the given index."}, {"type": "method", "name": "igraph.CohesiveBlocks.cohesions", "documentation": "Returns the list of cohesion values for each group."}, {"type": "method", "name": "igraph.CohesiveBlocks.crossing", "documentation": "Returns a boolean vector where element M{i} is C{True} iff edge\nM{i} lies between clusters, C{False} otherwise."}, {"type": "method", "name": "igraph.CohesiveBlocks.hierarchy", "documentation": "Returns a new graph that describes the hierarchical relationships\nbetween the groups.\n\nThe new graph will be a directed tree; an edge will point from\nvertex M{i} to vertex M{j} if group M{i} is a superset of group M{j}.\nIn other words, the edges point downwards."}, {"type": "method", "name": "igraph.CohesiveBlocks.max_cohesion", "documentation": "Finds the maximum cohesion score among all the groups that contain\nthe given vertex."}, {"type": "method", "name": "igraph.CohesiveBlocks.max_cohesions", "documentation": "For each vertex in the graph, returns the maximum cohesion score\namong all the groups that contain the vertex."}, {"type": "method", "name": "igraph.CohesiveBlocks.parent", "documentation": "Returns the parent group index of the group with the given index\nor C{None} if the given group is the root."}, {"type": "method", "name": "igraph.CohesiveBlocks.parents", "documentation": "Returns the list of parent group indices for each group or C{None}\nif the given group is the root."}, {"type": "method", "name": "igraph.CohesiveBlocks.size", "documentation": "Returns the size of a given cluster.\n\n@param idx: the cluster in which we are interested."}, {"type": "method", "name": "igraph.CohesiveBlocks.size_histogram", "documentation": "Returns the histogram of cluster sizes.\n\n@param bin_width: the bin width of the histogram\n@return: a L{Histogram} object"}, {"type": "method", "name": "igraph.CohesiveBlocks.sizes", "documentation": "Returns the size of given clusters.\n\nThe indices are given as positional arguments. If there are no\npositional arguments, the function will return the sizes of all clusters."}, {"type": "method", "name": "igraph.CohesiveBlocks.subgraph", "documentation": "Get the subgraph belonging to a given cluster.\n\nPrecondition: the vertex set of the graph hasn't been modified since the\nmoment the cover was constructed.\n\n@param idx: the cluster index\n@return: a copy of the subgraph"}, {"type": "method", "name": "igraph.CohesiveBlocks.subgraphs", "documentation": "Gets all the subgraphs belonging to each of the clusters.\n\nPrecondition: the vertex set of the graph hasn't been modified since the\nmoment the cover was constructed.\n\n@return: a list containing copies of the subgraphs"}, {"type": "method", "name": "igraph.CohesiveBlocks.summary", "documentation": "Returns the summary of the cover.\n\nThe summary includes the number of items and clusters, and also the\nlist of members for each of the clusters if the verbosity is nonzero.\n\n@param verbosity: determines whether the cluster members should be\n  printed. Zero verbosity prints the number of items and clusters only.\n@return: the summary of the cover as a string."}, {"type": "class", "name": "igraph.Configuration", "documentation": "Class representing igraph configuration details.\n\nNote that there is one primary instance of this class, which is used by\nigraph itself to retrieve configuration parameters when needed. You can\naccess this instance with the L{instance()} method. You I{may} construct\nother instances by invoking the constructor directly, but these instances\nwill I{not} affect igraph's behaviour. If you are interested in configuring\nigraph, use L{igraph.config} to get hold of the singleton instance and then\nmodify it.\n\nGeneral ideas\n=============\n\nThe configuration of igraph is stored in the form of name-value pairs.\nThis object provides an interface to the configuration data using the\nsyntax known from dict:\n\n  >>> c = Configuration()\n  >>> c[\"general.verbose\"] = True\n  >>> print(c[\"general.verbose\"])\n  True\n\nConfiguration keys are organized into sections, and the name to be used\nfor a given key is always in the form C{section.keyname}, like\nC{general.verbose} in the example above. In that case, C{general} is the\nname of the configuration section, and C{verbose} is the name of the key.\nIf the name of the section is omitted, it defaults to C{general}, so\nC{general.verbose} can be referred to as C{verbose}:\n\n  >>> c = Configuration()\n  >>> c[\"verbose\"] = True\n  >>> print(c[\"general.verbose\"])\n  True\n\nUser-level configuration is stored in C{~/.igraphrc} per default on Linux\nand Mac OS X systems, or in C{C:\\Documents and Settings\\username\\.igraphrc}\non Windows systems. However, this configuration is read only when C{igraph}\nis launched through its shell interface defined in L{igraph.app.shell}.\nThis behaviour might change before version 1.0.\n\nKnown configuration keys\n========================\n\nThe known configuration keys are presented below, sorted by section. When\nreferring to them in program code, don't forget to add the section name,\nexpect in the case of section C{general}.\n\nGeneral settings\n----------------\n\nThese settings are all stored in section C{general}.\n\n    - B{shells}: the list of preferred Python shells to be used with the\n      command-line C{igraph} script. The shells in the list are tried one\n      by one until any of them is found on the system. C{igraph} functions\n      are then imported into the main namespace of the shell and the shell\n      is launched. Known shells and their respective class names to be\n      used can be found in L{igraph.app.shell}. Example:\n      C{IPythonShell, ClassicPythonShell}. This is the default, by the way.\n    - B{verbose}: whether L{igraph} should talk more than really necessary.\n      For instance, if set to C{True}, some functions display progress bars.\n\nPlotting settings\n-----------------\n\nThese settings specify the default values used by plotting functions.\nThey are all stored in section C{plotting}.\n\n    - B{backend}: either \"cairo\" if you want to use Cairo for plotting\n      or \"matplotlib\" if you want to use the Matplotlib plotting backend.\n\n    - B{layout}: default graph layout algorithm to be used.\n\n    - B{mark_groups}: whether to mark the clusters by polygons when\n      plotting a clustering object.\n\n    - B{palette}: default palette to be used for converting integer\n      numbers to colors. See L{colors.Palette} for more information.\n      Valid palette names are stored in C{colors.palettes}.\n\n    - B{wrap_labels}: whether to try to wrap the labels of the\n      vertices automatically if they don't fit within the vertex.\n      Default: C{False}.\n\nShell settings\n--------------\n\nThese settings specify options for external environments in which igraph is\nembedded (e.g., IPython and its Qt console). These settings are stored in\nsection C{shell}.\n\n    - B{ipython.inlining.Plot}: whether to show instances of the\n      L{Plot<drawing.Plot>} class\n      inline in IPython's console if the console supports it. Default: C{True}"}, {"type": "method", "name": "igraph.Configuration.__contains__", "documentation": "Checks whether the given configuration item is set.\n\n@param item: the configuration key to check.\n@return: C{True} if the key has an associated value, C{False} otherwise."}, {"type": "method", "name": "igraph.Configuration.__delitem__", "documentation": "Deletes the given item from the configuration.\n\nIf the item has a default value, the default value is written back instead\nof the current value. Without a default value, the item is really deleted."}, {"type": "method", "name": "igraph.Configuration.__getitem__", "documentation": "Returns the given configuration item.\n\n@param item: the configuration key to retrieve.\n@return: the configuration value"}, {"type": "method", "name": "igraph.Configuration.__init__", "documentation": "Creates a new configuration instance.\n\n@param filename: file or file-like object to be read. Can be omitted."}, {"type": "method", "name": "igraph.Configuration.__setitem__", "documentation": "Sets the given configuration item.\n\n@param item: the configuration key to set\n@param value: the new value of the configuration key"}, {"type": "method", "name": "igraph.Configuration._get", "documentation": "Internal function that returns the value of a given key in a\ngiven section."}, {"type": "method", "name": "igraph.Configuration._item_to_section_key", "documentation": "Converts an item description to a section-key pair.\n\n@param item: the item to be converted\n@return: if C{item} contains a period (C{.}), it is split into two parts\n  at the first period, then the two parts are returned, so the part before\n  the period is the section. If C{item} does not contain a period, the\n  section is assumed to be C{general}, and the second part of the returned\n  pair contains C{item} unchanged"}, {"type": "method", "name": "igraph.Configuration.has_key", "documentation": "Checks if the configuration has a given key.\n\n@param item: the key being sought"}, {"type": "method", "name": "igraph.Configuration.instance", "documentation": "Returns the single instance of the configuration object."}, {"type": "method", "name": "igraph.Configuration.load", "documentation": "Loads the configuration from the given file.\n\n@param stream: name of a file or a file object. The configuration will be loaded\n  from here. Can be omitted, in this case, the user-level configuration is\n  loaded."}, {"type": "method", "name": "igraph.Configuration.save", "documentation": "Saves the configuration.\n\n@param stream: name of a file or a file-like object. The configuration\n    will be saved there. Can be omitted, in this case, the user-level\n    configuration file will be overwritten."}, {"type": "class", "name": "igraph.Cover", "documentation": "Class representing a cover of an arbitrary ordered set.\n\nCovers are similar to clusterings, but each element of the set may\nbelong to more than one cluster in a cover, and elements not belonging\nto any cluster are also allowed.\n\nL{Cover} instances provide a similar API as L{Clustering} instances;\nfor instance, iterating over a L{Cover} will iterate over the clusters\njust like with a regular L{Clustering} instance. However, they are not\nderived from each other or from a common superclass, and there might\nbe functions that exist only in one of them or the other.\n\nClusters of an individual cover can be accessed by the C{[]} operator:\n\n  >>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])\n  >>> cl[0]\n  [0, 1, 2, 3]\n\nThe membership vector can be accessed by the C{membership} property.\nNote that contrary to L{Clustering} instances, the membership vector\nwill contain lists that contain the cluster indices each item belongs\nto:\n\n  >>> cl.membership\n  [[0, 2], [0, 2], [0, 1], [0, 1], [1], [], [2]]\n\nThe number of clusters can be retrieved by the C{len} function:\n\n  >>> len(cl)\n  3\n\nYou can iterate over the cover as if it were a regular list of\nclusters:\n\n  >>> for cluster in cl:\n  ...     print(\" \".join(str(idx) for idx in cluster))\n  ...\n  0 1 2 3\n  2 3 4\n  0 1 6\n\nIf you need all the clusters at once as lists, you can simply convert\nthe cover to a list:\n\n  >>> cluster_list = list(cl)\n  >>> print(cluster_list)\n  [[0, 1, 2, 3], [2, 3, 4], [0, 1, 6]]\n\nL{Clustering} objects can readily be converted to L{Cover} objects\nusing the constructor:\n\n  >>> clustering = Clustering([0, 0, 0, 0, 1, 1, 1, 2, 2, 2])\n  >>> cover = Cover(clustering)\n  >>> list(clustering) == list(cover)\n  True"}, {"type": "method", "name": "igraph.Cover.__getitem__", "documentation": "Returns the cluster with the given index."}, {"type": "method", "name": "igraph.Cover.__init__", "documentation": "Constructs a cover with the given clusters.\n\n@param clusters: the clusters in this cover, as a list or iterable.\n  Each cluster is specified by a list or tuple that contains the\n  IDs of the items in this cluster. IDs start from zero.\n\n@param n: the total number of elements in the set that is covered\n  by this cover. If it is less than the number of unique elements\n  found in all the clusters, we will simply use the number of unique\n  elements, so it is safe to leave this at zero. You only have to\n  specify this parameter if there are some elements that are covered\n  by none of the clusters."}, {"type": "method", "name": "igraph.Cover.__iter__", "documentation": "Iterates over the clusters in this cover."}, {"type": "method", "name": "igraph.Cover.__len__", "documentation": "Returns the number of clusters in this cover."}, {"type": "method", "name": "igraph.Cover.__str__", "documentation": "Returns a string representation of the cover."}, {"type": "method", "name": "igraph.Cover._formatted_cluster_iterator", "documentation": "Iterates over the clusters and formats them into a string to be\npresented in the summary."}, {"type": "method", "name": "igraph.Cover.size", "documentation": "Returns the size of a given cluster.\n\n@param idx: the cluster in which we are interested."}, {"type": "method", "name": "igraph.Cover.size_histogram", "documentation": "Returns the histogram of cluster sizes.\n\n@param bin_width: the bin width of the histogram\n@return: a L{Histogram} object"}, {"type": "method", "name": "igraph.Cover.sizes", "documentation": "Returns the size of given clusters.\n\nThe indices are given as positional arguments. If there are no\npositional arguments, the function will return the sizes of all clusters."}, {"type": "method", "name": "igraph.Cover.summary", "documentation": "Returns the summary of the cover.\n\nThe summary includes the number of items and clusters, and also the\nlist of members for each of the clusters if the verbosity is nonzero.\n\n@param verbosity: determines whether the cluster members should be\n  printed. Zero verbosity prints the number of items and clusters only.\n@return: the summary of the cover as a string."}, {"type": "class", "name": "igraph.Cut", "documentation": "A cut of a given graph.\n\nThis is a simple class used to represent cuts returned by\nL{Graph.mincut()}, L{Graph.all_st_cuts()} and other functions\nthat calculate cuts.\n\nA cut is a special vertex clustering with only two clusters.\nBesides the usual L{VertexClustering} methods, it also has the\nfollowing attributes:\n\n  - C{value} - the value (capacity) of the cut. It is equal to\n    the number of edges if there are no capacities on the\n    edges.\n\n  - C{partition} - vertex IDs in the parts created\n    after removing edges in the cut\n\n  - C{cut} - edge IDs in the cut\n\n  - C{es} - an edge selector restricted to the edges\n    in the cut.\n\nYou can use indexing on this object to obtain lists of vertex IDs\nfor both sides of the partition.\n\nThis class is usually not instantiated directly, everything\nis taken care of by the functions that return cuts.\n\nExamples:\n\n  >>> from igraph import Graph\n  >>> g = Graph.Ring(20)\n  >>> mc = g.mincut()\n  >>> print(mc.value)\n  2.0\n  >>> print(min(len(x) for x in mc))\n  1\n  >>> mc.es[\"color\"] = \"red\""}, {"type": "method", "name": "igraph.Cut.FromAttribute", "documentation": "Creates a vertex clustering based on the value of a vertex attribute.\n\nVertices having the same attribute will correspond to the same cluster.\n\n@param graph: the graph on which we are working\n@param attribute: name of the attribute on which the clustering\n    is based.\n@param intervals: for numeric attributes, you can either pass a single\n    number or a list of numbers here. A single number means that the\n    vertices will be put in bins of that width and vertices ending up\n    in the same bin will be in the same cluster. A list of numbers\n    specify the bin positions explicitly; e.g., C{[10, 20, 30]} means\n    that there will be four categories: vertices with the attribute\n    value less than 10, between 10 and 20, between 20 and 30 and over 30.\n    Intervals are closed from the left and open from the right.\n@param params: additional parameters to be stored in this object.\n\n@return: a new VertexClustering object"}, {"type": "method", "name": "igraph.Cut.__getitem__", "documentation": "Returns the members of the specified cluster.\n\n@param idx: the index of the cluster\n@return: the members of the specified cluster as a list\n@raise IndexError: if the index is out of bounds"}, {"type": "method", "name": "igraph.Cut.__init__", "documentation": "Initializes the cut.\n\nThis should not be called directly, everything is taken care of by\nthe functions that return cuts."}, {"type": "method", "name": "igraph.Cut.__iter__", "documentation": "Iterates over the clusters in this clustering.\n\nThis method will return a generator that generates the clusters\none by one."}, {"type": "method", "name": "igraph.Cut.__len__", "documentation": "Returns the number of clusters.\n\n@return: the number of clusters"}, {"type": "method", "name": "igraph.Cut.__plot__", "documentation": "Plots the clustering to the given Cairo context or matplotlib Axes.\n\nThis is done by calling L{Graph.__plot__()} with the same arguments, but\ncoloring the graph vertices according to the current clustering (unless\noverridden by the C{vertex_color} argument explicitly).\n\nThis method understands all the positional and keyword arguments that\nare understood by L{Graph.__plot__()}, only the differences will be\nhighlighted here:\n\n  - C{mark_groups}: whether to highlight some of the vertex groups by\n    colored polygons. Besides the values accepted by L{Graph.__plot__}\n    (i.e., a dict mapping colors to vertex indices, a list containing\n    lists of vertex indices, or C{False}), the following are also\n    accepted:\n\n      - C{True}: all the groups will be highlighted, the colors matching\n        the corresponding color indices from the current palette\n        (see the C{palette} keyword argument of L{Graph.__plot__}).\n\n      - A dict mapping cluster indices or tuples of vertex indices to\n        color names.  The given clusters or vertex groups will be\n        highlighted by the given colors.\n\n      - A list of cluster indices. This is equivalent to passing a\n        dict mapping numeric color indices from the current palette\n        to cluster indices; therefore, the cluster referred to by element\n        I{i} of the list will be highlighted by color I{i} from the\n        palette.\n\n    The value of the C{plotting.mark_groups} configuration key is also\n    taken into account here; if that configuration key is C{True} and\n    C{mark_groups} is not given explicitly, it will automatically be set\n    to C{True}.\n\n    In place of lists of vertex indices, you may also use L{VertexSeq}\n    instances.\n\n    In place of color names, you may also use color indices into the\n    current palette. C{None} as a color name will mean that the\n    corresponding group is ignored.\n\n  - C{palette}: the palette used to resolve numeric color indices to RGBA\n    values. By default, this is an instance of L{ClusterColoringPalette}.\n\n@see: L{Graph.__plot__()} for more supported keyword arguments."}, {"type": "method", "name": "igraph.Cut.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.Cut.__str__", "documentation": "Return str(self)."}, {"type": "method", "name": "igraph.Cut._formatted_cluster_iterator", "documentation": "Iterates over the clusters and formats them into a string to be\npresented in the summary."}, {"type": "method", "name": "igraph.Cut._recalculate_modularity_safe", "documentation": "Recalculates the stored modularity value and swallows all exceptions\nraised by the modularity function (if any).\n\n@return: the new modularity score or C{None} if the modularity function\ncould not be calculated."}, {"type": "method", "name": "igraph.Cut.as_cover", "documentation": "Returns a L{VertexCover} that contains the same clusters as this\nclustering."}, {"type": "method", "name": "igraph.Cut.cluster_graph", "documentation": "Returns a graph where each cluster is contracted into a single\nvertex.\n\nIn the resulting graph, vertex M{i} represents cluster M{i} in this\nclustering. Vertex M{i} and M{j} will be connected if there was\nat least one connected vertex pair M{(a, b)} in the original graph such\nthat vertex M{a} was in cluster M{i} and vertex M{b} was in cluster\nM{j}.\n\n@param combine_vertices: specifies how to derive the attributes of\n  the vertices in the new graph from the attributes of the old ones.\n  See L{Graph.contract_vertices()<igraph._igraph.GraphBase.contract_vertices>}\n  for more details.\n@param combine_edges: specifies how to derive the attributes of the\n  edges in the new graph from the attributes of the old ones. See\n  L{Graph.simplify()<igraph._igraph.GraphBase.simplify>} for more details.\n  If you specify C{False} here, edges will not be combined, and the\n  number of edges between the vertices representing the original\n  clusters will be equal to the number of edges between the members of\n  those clusters in the original graph.\n\n@return: the new graph."}, {"type": "method", "name": "igraph.Cut.compare_to", "documentation": "Compares this clustering to another one using some similarity or\ndistance metric.\n\nThis is a convenience method that simply calls L{compare_communities}\nwith the two clusterings as arguments. Any extra positional or keyword\nargument is also forwarded to L{compare_communities}."}, {"type": "method", "name": "igraph.Cut.crossing", "documentation": "Returns a boolean vector where element M{i} is C{True} iff edge\nM{i} lies between clusters, C{False} otherwise."}, {"type": "method", "name": "igraph.Cut.giant", "documentation": "Returns the largest cluster of the clustered graph.\n\nThe largest cluster is a cluster for which no larger cluster exists in\nthe clustering. It may also be known as the I{giant community} if the\nclustering represents the result of a community detection function.\n\nPrecondition: the vertex set of the graph hasn't been modified since the\nmoment the cover was constructed.\n\n@note: there can be multiple largest clusters, this method will return\n  the copy of an arbitrary one if there are multiple largest clusters.\n\n@return: a copy of the largest cluster."}, {"type": "method", "name": "igraph.Cut.recalculate_modularity", "documentation": "Recalculates the stored modularity value.\n\nThis method must be called before querying the modularity score of the\nclustering through the class member C{modularity} or C{q} if the\ngraph has been modified (edges have been added or removed) since the\ncreation of the L{VertexClustering} object.\n\n@return: the new modularity score"}, {"type": "method", "name": "igraph.Cut.size", "documentation": "Returns the size of a given cluster.\n\n@param idx: the cluster in which we are interested."}, {"type": "method", "name": "igraph.Cut.size_histogram", "documentation": "Returns the histogram of cluster sizes.\n\n@param bin_width: the bin width of the histogram\n@return: a L{Histogram} object"}, {"type": "method", "name": "igraph.Cut.sizes", "documentation": "Returns the size of given clusters.\n\nThe indices are given as positional arguments. If there are no\npositional arguments, the function will return the sizes of all clusters."}, {"type": "method", "name": "igraph.Cut.subgraph", "documentation": "Get the subgraph belonging to a given cluster.\n\nPrecondition: the vertex set of the graph hasn't been modified since the\nmoment the cover was constructed.\n\n@param idx: the cluster index\n@return: a copy of the subgraph"}, {"type": "method", "name": "igraph.Cut.subgraphs", "documentation": "Gets all the subgraphs belonging to each of the clusters.\n\nPrecondition: the vertex set of the graph hasn't been modified since the\nmoment the cover was constructed.\n\n@return: a list containing copies of the subgraphs"}, {"type": "method", "name": "igraph.Cut.summary", "documentation": "Returns the summary of the clustering.\n\nThe summary includes the number of items and clusters, and also the\nlist of members for each of the clusters if the verbosity is nonzero.\n\n@param verbosity: determines whether the cluster members should be\n  printed. Zero verbosity prints the number of items and clusters only.\n@return: the summary of the clustering as a string."}, {"type": "class", "name": "igraph.DFSIter", "documentation": "igraph DFS iterator object"}, {"type": "class", "name": "igraph.DefaultGraphDrawer", "documentation": "Class implementing the default visualisation of a graph.\n\nThe default visualisation of a graph draws the nodes on a 2D plane\naccording to a given L{Layout}, then draws a straight or curved\nedge between nodes connected by edges. This is the visualisation\nused when one invokes the L{plot()} function on a L{Graph} object.\n\nSee L{Graph.__plot__()} for the keyword arguments understood by\nthis drawer."}, {"type": "method", "name": "igraph.DefaultGraphDrawer.__init__", "documentation": "Constructs the graph drawer and associates it to the given\nCairo context and the given L{BoundingBox}.\n\n@param context: the context on which we will draw\n@param bbox:    the bounding box within which we will draw.\n                Can be anything accepted by the constructor\n                of L{BoundingBox} (i.e., a 2-tuple, a 4-tuple\n                or a L{BoundingBox} object).\n@param vertex_drawer_factory: a factory method that returns an\n                L{AbstractCairoVertexDrawer} instance bound to a\n                given Cairo context. The factory method must take\n                four parameters: the Cairo context, the bounding\n                box of the drawing area, the palette to be\n                used for drawing colored vertices, and the graph layout.\n                The default vertex drawer is L{CairoVertexDrawer}.\n@param edge_drawer_factory: a factory method that returns an\n                L{AbstractCairoEdgeDrawer} instance bound to a\n                given Cairo context. The factory method must take\n                two parameters: the Cairo context and the palette\n                to be used for drawing colored edges. You can use\n                any of the actual L{AbstractEdgeDrawer}\n                implementations here to control the style of\n                edges drawn by igraph. The default edge drawer is\n                L{CairoArrowEdgeDrawer}.\n@param label_drawer_factory: a factory method that returns a\n                L{CairoTextDrawer} instance bound to a given Cairo\n                context. The method must take one parameter: the\n                Cairo context. The default label drawer is\n                L{CairoTextDrawer}."}, {"type": "method", "name": "igraph.DefaultGraphDrawer._determine_edge_order", "documentation": "Returns the order in which the edge of the given graph have to be\ndrawn, assuming that the relevant keyword arguments (C{edge_order} and\nC{edge_order_by}) are given in C{kwds} as a dictionary. If neither\nC{edge_order} nor C{edge_order_by} is present in C{kwds}, this\nfunction returns C{None} to indicate that the graph drawer is free to\nchoose the most convenient edge ordering."}, {"type": "method", "name": "igraph.DefaultGraphDrawer._determine_vertex_order", "documentation": "Returns the order in which the vertices of the given graph have to be\ndrawn, assuming that the relevant keyword arguments (C{vertex_order} and\nC{vertex_order_by}) are given in C{kwds} as a dictionary. If neither\nC{vertex_order} nor C{vertex_order_by} is present in C{kwds}, this\nfunction returns C{None} to indicate that the graph drawer is free to\nchoose the most convenient vertex ordering."}, {"type": "method", "name": "igraph.DefaultGraphDrawer._mark_point", "documentation": "Marks the given point with a small circle on the canvas.\nUsed primarily for debugging purposes.\n\n@param x: the X coordinate of the point to mark\n@param y: the Y coordinate of the point to mark\n@param color: the color of the marker. It can be a\n  3-tuple (RGB components, alpha=0.5), a 4-tuple\n  (RGBA components) or an index where zero means red, 1 means\n  green, 2 means blue and so on.\n@param size: the diameter of the marker."}, {"type": "method", "name": "igraph.DefaultGraphDrawer.draw", "documentation": "Abstract method, must be implemented in derived classes."}, {"type": "method", "name": "igraph.DefaultGraphDrawer.ensure_layout", "documentation": "Helper method that ensures that I{layout} is an instance\nof L{Layout}. If it is not, the method will try to convert\nit to a L{Layout} according to the following rules:\n\n  - If I{layout} is a string, it is assumed to be a name\n    of an igraph layout, and it will be passed on to the\n    C{layout} method of the given I{graph} if I{graph} is\n    not C{None}.\n\n  - If I{layout} is C{None} and I{graph} has a \"layout\"\n    attribute, call this same function with the value of that\n    attribute.\n\n  - If I{layout} is C{None} and I{graph} does not have a \"layout\"\n    attribute, the C{layout} method of I{graph} will be invoked\n    with no parameters, which will call the default layout algorithm.\n\n  - Otherwise, I{layout} will be passed on to the constructor\n    of L{Layout}. This handles lists of lists, lists of tuples\n    and such.\n\nIf I{layout} is already a L{Layout} instance, it will still\nbe copied and a copy will be returned. This is because graph\ndrawers are allowed to transform the layout for their purposes,\nand we don't want the transformation to propagate back to the\ncaller."}, {"type": "class", "name": "igraph.Dendrogram", "documentation": "The hierarchical clustering (dendrogram) of some dataset.\n\nA hierarchical clustering means that we know not only the way the\nelements are separated into groups, but also the exact history of\nhow individual elements were joined into larger subgroups.\n\nThis class internally represents the hierarchy by a matrix with n rows\nand 2 columns -- or more precisely, a list of lists of size 2. This is\nexactly the same as the original format used by C{igraph}'s C core.\nThe M{i}th row of the matrix contains the indices of the two clusters\nbeing joined in time step M{i}. The joint group will be represented by\nthe ID M{n+i}, with M{i} starting from one. The ID of the joint group\nwill be referenced in the upcoming steps instead of any of its individual\nmembers. So, IDs less than or equal to M{n} (where M{n} is the number of\nrows in the matrix) mean the original members of the dataset (with ID\nfrom 0 to M{n}), while IDs up from M{n+1} mean joint groups. As an\nexample, take a look at the dendrogram and the internal representation of\na given clustering of five nodes::\n\n  0 -+\n     |\n  1 -+-+\n       |\n  2 ---+-+        <====>   [[0, 1], [3, 4], [2, 5], [6, 7]]\n         |\n  3 -+   |\n     |   |\n  4 -+---+---"}, {"type": "method", "name": "igraph.Dendrogram.__init__", "documentation": "Creates a hierarchical clustering.\n\n@param merges: the merge history either in matrix or tuple format"}, {"type": "method", "name": "igraph.Dendrogram.__plot__", "documentation": "Draws the dendrogram on the given Cairo context or matplotlib Axes.\n\nSupported keyword arguments are:\n\n  - C{orientation}: the orientation of the dendrogram. Must be one of\n    the following values: C{left-right}, C{bottom-top}, C{right-left}\n    or C{top-bottom}. Individual elements are always placed at the\n    former edge and merges are performed towards the latter edge.\n    Possible aliases: C{horizontal} = C{left-right},\n    C{vertical} = C{bottom-top}, C{lr} = C{left-right},\n    C{rl} = C{right-left}, C{tb} = C{top-bottom}, C{bt} = C{bottom-top}.\n    The default is C{left-right}."}, {"type": "method", "name": "igraph.Dendrogram.__str__", "documentation": "Return str(self)."}, {"type": "method", "name": "igraph.Dendrogram._convert_matrix_to_tuple_repr", "documentation": "Converts the matrix representation of a clustering to a tuple\nrepresentation.\n\n@param merges: the matrix representation of the clustering\n@return: the tuple representation of the clustering"}, {"type": "method", "name": "igraph.Dendrogram._traverse_inorder", "documentation": "Conducts an inorder traversal of the merge tree.\n\nThe inorder traversal returns the nodes on the last level in the order\nthey should be drawn so that no edges cross each other.\n\n@return: the result of the inorder traversal in a list."}, {"type": "method", "name": "igraph.Dendrogram.format", "documentation": "Formats the dendrogram in a foreign format.\n\nCurrently only the Newick format is supported.\n\nExample:\n\n    >>> d = Dendrogram([(2, 3), (0, 1), (4, 5)])\n    >>> d.format()\n    '((2,3)4,(0,1)5)6;'\n    >>> d.names = list(\"ABCDEFG\")\n    >>> d.format()\n    '((C,D)E,(A,B)F)G;'"}, {"type": "method", "name": "igraph.Dendrogram.summary", "documentation": "Returns the summary of the dendrogram.\n\nThe summary includes the number of leafs and branches, and also an\nASCII art representation of the dendrogram unless it is too large.\n\n@param verbosity: determines whether the ASCII representation of the\n  dendrogram should be printed. Zero verbosity prints only the number\n  of leafs and branches.\n@param max_leaf_count: the maximal number of leafs to print in the\n  ASCII representation. If the dendrogram has more leafs than this\n  limit, the ASCII representation will not be printed even if the\n  verbosity is larger than or equal to 1.\n@return: the summary of the dendrogram as a string."}, {"type": "class", "name": "igraph.DyadCensus", "documentation": "Dyad census of a graph.\n\nThis is a pretty simple class - basically it is a tuple, but it allows\nthe user to refer to its individual items by the names C{mutual} (or\nC{mut}), C{asymmetric} (or C{asy} or C{asym} or C{asymm}) and C{null}.\n\nExamples:\n\n  >>> from igraph import Graph\n  >>> g=Graph.Erdos_Renyi(100, 0.2, directed=True)\n  >>> dc=g.dyad_census()\n  >>> print(dc.mutual)            #doctest:+SKIP\n  179\n  >>> print(dc[\"asym\"])           #doctest:+SKIP\n  1609\n  >>> print(tuple(dc), list(dc))  #doctest:+SKIP\n  (179, 1609, 3162) [179, 1609, 3162]\n  >>> print(sorted(dc.as_dict().items()))  #doctest:+ELLIPSIS\n  [('asymmetric', ...), ('mutual', ...), ('null', ...)]"}, {"type": "method", "name": "igraph.DyadCensus.__getattr__", "documentation": null}, {"type": "method", "name": "igraph.DyadCensus.__getitem__", "documentation": "Return self[key]."}, {"type": "method", "name": "igraph.DyadCensus.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.DyadCensus.__str__", "documentation": "Return str(self)."}, {"type": "method", "name": "igraph.DyadCensus.as_dict", "documentation": "Converts the dyad census to a dict using the known dyad names."}, {"type": "class", "name": "igraph.Edge", "documentation": "Class representing a single edge in a graph.\n\nThe edge is referenced by its index, so if the underlying graph\nchanges, the semantics of the edge object might change as well\n(if the edge indices are altered in the original graph).\n\nThe attributes of the edge can be accessed by using the edge\nas a hash:\n\n  >>> e[\"weight\"] = 2                  #doctest: +SKIP\n  >>> print(e[\"weight\"])               #doctest: +SKIP\n  2"}, {"type": "class", "name": "igraph.EdgeSeq", "documentation": "Class representing a sequence of edges in the graph.\n\nThis class is most easily accessed by the C{es} field of the\nL{Graph} object, which returns an ordered sequence of all edges in\nthe graph. The edge sequence can be refined by invoking the\nL{EdgeSeq.select()} method. L{EdgeSeq.select()} can also be\naccessed by simply calling the L{EdgeSeq} object.\n\nAn alternative way to create an edge sequence referring to a given\ngraph is to use the constructor directly:\n\n  >>> g = Graph.Full(3)\n  >>> es = EdgeSeq(g)\n  >>> restricted_es = EdgeSeq(g, [0, 1])\n\nThe individual edges can be accessed by indexing the edge sequence\nobject. It can be used as an iterable as well, or even in a list\ncomprehension:\n\n  >>> g=Graph.Full(3)\n  >>> for e in g.es:\n  ...   print(e.tuple)\n  ...\n  (0, 1)\n  (0, 2)\n  (1, 2)\n  >>> [max(e.tuple) for e in g.es]\n  [1, 2, 2]\n\nThe edge sequence can also be used as a dictionary where the keys are the\nattribute names. The values corresponding to the keys are the values\nof the given attribute of every edge in the graph:\n\n  >>> g=Graph.Full(3)\n  >>> for idx, e in enumerate(g.es):\n  ...   e[\"weight\"] = idx*(idx+1)\n  ...\n  >>> g.es[\"weight\"]\n  [0, 2, 6]\n  >>> g.es[\"weight\"] = range(3)\n  >>> g.es[\"weight\"]\n  [0, 1, 2]\n\nIf you specify a sequence that is shorter than the number of edges in\nthe EdgeSeq, the sequence is reused:\n\n  >>> g = Graph.Tree(7, 2)\n  >>> g.es[\"color\"] = [\"red\", \"green\"]\n  >>> g.es[\"color\"]\n  ['red', 'green', 'red', 'green', 'red', 'green']\n\nYou can even pass a single string or integer, it will be considered as a\nsequence of length 1:\n\n  >>> g.es[\"color\"] = \"red\"\n  >>> g.es[\"color\"]\n  ['red', 'red', 'red', 'red', 'red', 'red']\n\nSome methods of the edge sequences are simply proxy methods to the\ncorresponding methods in the L{Graph} object. One such example is\nC{EdgeSeq.is_multiple()}:\n\n  >>> g=Graph(3, [(0,1), (1,0), (1,2)])\n  >>> g.es.is_multiple()\n  [False, True, False]\n  >>> g.es.is_multiple() == g.is_multiple()\n  True"}, {"type": "method", "name": "igraph.EdgeSeq.__call__", "documentation": "Shorthand notation to select()\n\nThis method simply passes all its arguments to L{EdgeSeq.select()}."}, {"type": "method", "name": "igraph.EdgeSeq.attributes", "documentation": "Returns the list of all the edge attributes in the graph\nassociated to this edge sequence."}, {"type": "method", "name": "igraph.EdgeSeq.count_multiple", "documentation": "Proxy method to L{Graph.count_multiple()}\n\nThis method calls the C{count_multiple()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.count_multiple() for details."}, {"type": "method", "name": "igraph.EdgeSeq.delete", "documentation": "Proxy method to L{Graph.delete_edges()}\n\nThis method calls the C{delete_edges()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.delete_edges() for details."}, {"type": "method", "name": "igraph.EdgeSeq.edge_betweenness", "documentation": "Proxy method to L{Graph.edge_betweenness()}\n\nThis method calls the C{edge_betweenness()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.edge_betweenness() for details."}, {"type": "method", "name": "igraph.EdgeSeq.find", "documentation": "Returns the first edge of the edge sequence that matches some\ncriteria.\n\nThe selection criteria are equal to the ones allowed by L{VertexSeq.select}.\nSee L{VertexSeq.select} for more details.\n\nFor instance, to find the first edge with weight larger than 5 in graph C{g}:\n\n    >>> g.es.find(weight_gt=5)           #doctest:+SKIP"}, {"type": "method", "name": "igraph.EdgeSeq.is_loop", "documentation": "Proxy method to L{Graph.is_loop()}\n\nThis method calls the C{is_loop()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.is_loop() for details."}, {"type": "method", "name": "igraph.EdgeSeq.is_multiple", "documentation": "Proxy method to L{Graph.is_multiple()}\n\nThis method calls the C{is_multiple()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.is_multiple() for details."}, {"type": "method", "name": "igraph.EdgeSeq.is_mutual", "documentation": "Proxy method to L{Graph.is_mutual()}\n\nThis method calls the C{is_mutual()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.is_mutual() for details."}, {"type": "method", "name": "igraph.EdgeSeq.select", "documentation": "Selects a subset of the edge sequence based on some criteria\n\nThe selection criteria can be specified by the positional and the\nkeyword arguments. Positional arguments are always processed before\nkeyword arguments.\n\n  - If the first positional argument is C{None}, an empty sequence is\n    returned.\n\n  - If the first positional argument is a callable object, the object\n    will be called for every edge in the sequence. If it returns\n    C{True}, the edge will be included, otherwise it will\n    be excluded.\n\n  - If the first positional argument is an iterable, it must return\n    integers and they will be considered as indices of the current\n    edge set (NOT the whole edge set of the graph -- the\n    difference matters when one filters an edge set that has\n    already been filtered by a previous invocation of\n    L{EdgeSeq.select()}. In this case, the indices do not refer\n    directly to the edges of the graph but to the elements of\n    the filtered edge sequence.\n\n  - If the first positional argument is an integer, all remaining\n    arguments are expected to be integers. They are considered as\n    indices of the current edge set again.\n\nKeyword arguments can be used to filter the edges based on their\nattributes and properties. The name of the keyword specifies the name\nof the attribute and the filtering operator, they should be\nconcatenated by an underscore (C{_}) character. Attribute names can\nalso contain underscores, but operator names don't, so the operator is\nalways the largest trailing substring of the keyword name that does not\ncontain an underscore. Possible operators are:\n\n  - C{eq}: equal to\n\n  - C{ne}: not equal to\n\n  - C{lt}: less than\n\n  - C{gt}: greater than\n\n  - C{le}: less than or equal to\n\n  - C{ge}: greater than or equal to\n\n  - C{in}: checks if the value of an attribute is in a given list\n\n  - C{notin}: checks if the value of an attribute is not in a given\n    list\n\nFor instance, if you want to filter edges with a numeric C{weight}\nproperty larger than 50, you have to write:\n\n  >>> g.es.select(weight_gt=50)            #doctest: +SKIP\n\nSimilarly, to filter edges whose C{type} is in a list of predefined\ntypes:\n\n  >>> list_of_types = [\"inhibitory\", \"excitatory\"]\n  >>> g.es.select(type_in=list_of_types)   #doctest: +SKIP\n\nIf the operator is omitted, it defaults to C{eq}. For instance, the\nfollowing selector selects edges whose C{type} property is\nC{intracluster}:\n\n  >>> g.es.select(type=\"intracluster\")     #doctest: +SKIP\n\nIn the case of an unknown operator, it is assumed that the\nrecognized operator is part of the attribute name and the actual\noperator is C{eq}.\n\nKeyword arguments are treated specially if they start with an\nunderscore (C{_}). These are not real attributes but refer to specific\nproperties of the edges, e.g., their centrality.  The rules are as\nfollows:\n\n  1. C{_source} or {_from} means the source vertex of an edge. For\n     undirected graphs, only the C{eq} operator is supported and it\n     is treated as {_incident} (since undirected graphs have no notion\n     of edge directionality).\n\n  2. C{_target} or {_to} means the target vertex of an edge. For\n     undirected graphs, only the C{eq} operator is supported and it\n     is treated as {_incident} (since undirected graphs have no notion\n     of edge directionality).\n\n  3. C{_within} ignores the operator and checks whether both endpoints\n     of the edge lie within a specified set.\n\n  4. C{_between} ignores the operator and checks whether I{one}\n     endpoint of the edge lies within a specified set and the I{other}\n     endpoint lies within another specified set. The two sets must be\n     given as a tuple.\n\n  5. C{_incident} ignores the operator and checks whether the edge is\n     incident on a specific vertex or a set of vertices.\n\n  6. Otherwise, the rest of the name is interpreted as a method of the\n     L{Graph} object. This method is called with the edge sequence as\n     its first argument (all others left at default values) and edges\n     are filtered according to the value returned by the method.\n\nFor instance, if you want to exclude edges with a betweenness\ncentrality less than 2:\n\n  >>> g = Graph.Famous(\"zachary\")\n  >>> excl = g.es.select(_edge_betweenness_ge = 2)\n\nTo select edges originating from vertices 2 and 4:\n\n  >>> edges = g.es.select(_source_in = [2, 4])\n\nTo select edges lying entirely within the subgraph spanned by vertices\n2, 3, 4 and 7:\n\n  >>> edges = g.es.select(_within = [2, 3, 4, 7])\n\nTo select edges with one endpoint in the vertex set containing vertices\n2, 3, 4 and 7 and the other endpoint in the vertex set containing\nvertices 8 and 9:\n\n  >>> edges = g.es.select(_between = ([2, 3, 4, 7], [8, 9]))\n\nFor properties that take a long time to be computed (e.g., betweenness\ncentrality for large graphs), it is advised to calculate the values\nin advance and store it in a graph attribute. The same applies when\nyou are selecting based on the same property more than once in the\nsame C{select()} call to avoid calculating it twice unnecessarily.\nFor instance, the following would calculate betweenness centralities\ntwice:\n\n  >>> edges = g.es.select(_edge_betweenness_gt=10,       # doctest:+SKIP\n  ...                     _edge_betweenness_lt=30)\n\nIt is advised to use this instead:\n\n  >>> g.es[\"bs\"] = g.edge_betweenness()\n  >>> edges = g.es.select(bs_gt=10, bs_lt=30)\n\n@return: the new, filtered edge sequence"}, {"type": "method", "name": "igraph.EdgeSeq.subgraph", "documentation": "Proxy method to L{Graph.subgraph_edges()}\n\nThis method calls the C{subgraph_edges()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.subgraph_edges() for details."}, {"type": "class", "name": "igraph.FittedPowerLaw", "documentation": "Result of fitting a power-law to a vector of samples\n\nExample:\n\n    >>> result = power_law_fit([1, 2, 3, 4, 5, 6])\n    >>> result                   # doctest:+ELLIPSIS\n    FittedPowerLaw(continuous=False, alpha=2.42..., xmin=3.0, L=-7.54..., D=0.21..., p=0.993...)\n    >>> print(result)            # doctest:+ELLIPSIS\n    Fitted power-law distribution on discrete data\n    <BLANKLINE>\n    Exponent (alpha)  = 2.42...\n    Cutoff (xmin)     = 3.000000\n    <BLANKLINE>\n    Log-likelihood    = -7.54...\n    <BLANKLINE>\n    H0: data was drawn from the fitted distribution\n    <BLANKLINE>\n    KS test statistic = 0.21...\n    p-value           = 0.993...\n    <BLANKLINE>\n    H0 could not be rejected at significance level 0.05\n    >>> result.alpha             # doctest:+ELLIPSIS\n    2.42...\n    >>> result.xmin\n    3.0\n    >>> result.continuous\n    False"}, {"type": "method", "name": "igraph.FittedPowerLaw.__init__", "documentation": "Initialize self.  See help(type(self)) for accurate signature."}, {"type": "method", "name": "igraph.FittedPowerLaw.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.FittedPowerLaw.__str__", "documentation": "Return str(self)."}, {"type": "method", "name": "igraph.FittedPowerLaw.summary", "documentation": "Returns the summary of the power law fit.\n\n@param significance: the significance level of the Kolmogorov-Smirnov test\n  used to decide whether the input data could have come from the fitted\n  distribution\n@return: the summary as a string"}, {"type": "class", "name": "igraph.Flow", "documentation": "A flow of a given graph.\n\nThis is a simple class used to represent flows returned by\nL{Graph.maxflow}. It has the following attributes:\n\n  - C{graph} - the graph on which this flow is defined\n\n  - C{value} - the value (capacity) of the flow\n\n  - C{flow} - the flow values on each edge. For directed graphs,\n    this is simply a list where element M{i} corresponds to the\n    flow on edge M{i}. For undirected graphs, the direction of\n    the flow is not constrained (since the edges are undirected),\n    hence positive flow always means a flow from the smaller vertex\n    ID to the larger, while negative flow means a flow from the\n    larger vertex ID to the smaller.\n\n  - C{cut} - edge IDs in the minimal cut corresponding to\n    the flow.\n\n  - C{partition} - vertex IDs in the parts created\n    after removing edges in the cut\n\n  - C{es} - an edge selector restricted to the edges\n    in the cut.\n\nThis class is usually not instantiated directly, everything\nis taken care of by L{Graph.maxflow}.\n\nExamples:\n\n  >>> from igraph import Graph\n  >>> g = Graph.Ring(20)\n  >>> mf = g.maxflow(0, 10)\n  >>> print(mf.value)\n  2.0\n  >>> mf.es[\"color\"] = \"red\""}, {"type": "method", "name": "igraph.Flow.FromAttribute", "documentation": "Creates a vertex clustering based on the value of a vertex attribute.\n\nVertices having the same attribute will correspond to the same cluster.\n\n@param graph: the graph on which we are working\n@param attribute: name of the attribute on which the clustering\n    is based.\n@param intervals: for numeric attributes, you can either pass a single\n    number or a list of numbers here. A single number means that the\n    vertices will be put in bins of that width and vertices ending up\n    in the same bin will be in the same cluster. A list of numbers\n    specify the bin positions explicitly; e.g., C{[10, 20, 30]} means\n    that there will be four categories: vertices with the attribute\n    value less than 10, between 10 and 20, between 20 and 30 and over 30.\n    Intervals are closed from the left and open from the right.\n@param params: additional parameters to be stored in this object.\n\n@return: a new VertexClustering object"}, {"type": "method", "name": "igraph.Flow.__getitem__", "documentation": "Returns the members of the specified cluster.\n\n@param idx: the index of the cluster\n@return: the members of the specified cluster as a list\n@raise IndexError: if the index is out of bounds"}, {"type": "method", "name": "igraph.Flow.__init__", "documentation": "Initializes the flow.\n\nThis should not be called directly, everything is\ntaken care of by L{Graph.maxflow}."}, {"type": "method", "name": "igraph.Flow.__iter__", "documentation": "Iterates over the clusters in this clustering.\n\nThis method will return a generator that generates the clusters\none by one."}, {"type": "method", "name": "igraph.Flow.__len__", "documentation": "Returns the number of clusters.\n\n@return: the number of clusters"}, {"type": "method", "name": "igraph.Flow.__plot__", "documentation": "Plots the clustering to the given Cairo context or matplotlib Axes.\n\nThis is done by calling L{Graph.__plot__()} with the same arguments, but\ncoloring the graph vertices according to the current clustering (unless\noverridden by the C{vertex_color} argument explicitly).\n\nThis method understands all the positional and keyword arguments that\nare understood by L{Graph.__plot__()}, only the differences will be\nhighlighted here:\n\n  - C{mark_groups}: whether to highlight some of the vertex groups by\n    colored polygons. Besides the values accepted by L{Graph.__plot__}\n    (i.e., a dict mapping colors to vertex indices, a list containing\n    lists of vertex indices, or C{False}), the following are also\n    accepted:\n\n      - C{True}: all the groups will be highlighted, the colors matching\n        the corresponding color indices from the current palette\n        (see the C{palette} keyword argument of L{Graph.__plot__}).\n\n      - A dict mapping cluster indices or tuples of vertex indices to\n        color names.  The given clusters or vertex groups will be\n        highlighted by the given colors.\n\n      - A list of cluster indices. This is equivalent to passing a\n        dict mapping numeric color indices from the current palette\n        to cluster indices; therefore, the cluster referred to by element\n        I{i} of the list will be highlighted by color I{i} from the\n        palette.\n\n    The value of the C{plotting.mark_groups} configuration key is also\n    taken into account here; if that configuration key is C{True} and\n    C{mark_groups} is not given explicitly, it will automatically be set\n    to C{True}.\n\n    In place of lists of vertex indices, you may also use L{VertexSeq}\n    instances.\n\n    In place of color names, you may also use color indices into the\n    current palette. C{None} as a color name will mean that the\n    corresponding group is ignored.\n\n  - C{palette}: the palette used to resolve numeric color indices to RGBA\n    values. By default, this is an instance of L{ClusterColoringPalette}.\n\n@see: L{Graph.__plot__()} for more supported keyword arguments."}, {"type": "method", "name": "igraph.Flow.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.Flow.__str__", "documentation": "Return str(self)."}, {"type": "method", "name": "igraph.Flow._formatted_cluster_iterator", "documentation": "Iterates over the clusters and formats them into a string to be\npresented in the summary."}, {"type": "method", "name": "igraph.Flow._recalculate_modularity_safe", "documentation": "Recalculates the stored modularity value and swallows all exceptions\nraised by the modularity function (if any).\n\n@return: the new modularity score or C{None} if the modularity function\ncould not be calculated."}, {"type": "method", "name": "igraph.Flow.as_cover", "documentation": "Returns a L{VertexCover} that contains the same clusters as this\nclustering."}, {"type": "method", "name": "igraph.Flow.cluster_graph", "documentation": "Returns a graph where each cluster is contracted into a single\nvertex.\n\nIn the resulting graph, vertex M{i} represents cluster M{i} in this\nclustering. Vertex M{i} and M{j} will be connected if there was\nat least one connected vertex pair M{(a, b)} in the original graph such\nthat vertex M{a} was in cluster M{i} and vertex M{b} was in cluster\nM{j}.\n\n@param combine_vertices: specifies how to derive the attributes of\n  the vertices in the new graph from the attributes of the old ones.\n  See L{Graph.contract_vertices()<igraph._igraph.GraphBase.contract_vertices>}\n  for more details.\n@param combine_edges: specifies how to derive the attributes of the\n  edges in the new graph from the attributes of the old ones. See\n  L{Graph.simplify()<igraph._igraph.GraphBase.simplify>} for more details.\n  If you specify C{False} here, edges will not be combined, and the\n  number of edges between the vertices representing the original\n  clusters will be equal to the number of edges between the members of\n  those clusters in the original graph.\n\n@return: the new graph."}, {"type": "method", "name": "igraph.Flow.compare_to", "documentation": "Compares this clustering to another one using some similarity or\ndistance metric.\n\nThis is a convenience method that simply calls L{compare_communities}\nwith the two clusterings as arguments. Any extra positional or keyword\nargument is also forwarded to L{compare_communities}."}, {"type": "method", "name": "igraph.Flow.crossing", "documentation": "Returns a boolean vector where element M{i} is C{True} iff edge\nM{i} lies between clusters, C{False} otherwise."}, {"type": "method", "name": "igraph.Flow.giant", "documentation": "Returns the largest cluster of the clustered graph.\n\nThe largest cluster is a cluster for which no larger cluster exists in\nthe clustering. It may also be known as the I{giant community} if the\nclustering represents the result of a community detection function.\n\nPrecondition: the vertex set of the graph hasn't been modified since the\nmoment the cover was constructed.\n\n@note: there can be multiple largest clusters, this method will return\n  the copy of an arbitrary one if there are multiple largest clusters.\n\n@return: a copy of the largest cluster."}, {"type": "method", "name": "igraph.Flow.recalculate_modularity", "documentation": "Recalculates the stored modularity value.\n\nThis method must be called before querying the modularity score of the\nclustering through the class member C{modularity} or C{q} if the\ngraph has been modified (edges have been added or removed) since the\ncreation of the L{VertexClustering} object.\n\n@return: the new modularity score"}, {"type": "method", "name": "igraph.Flow.size", "documentation": "Returns the size of a given cluster.\n\n@param idx: the cluster in which we are interested."}, {"type": "method", "name": "igraph.Flow.size_histogram", "documentation": "Returns the histogram of cluster sizes.\n\n@param bin_width: the bin width of the histogram\n@return: a L{Histogram} object"}, {"type": "method", "name": "igraph.Flow.sizes", "documentation": "Returns the size of given clusters.\n\nThe indices are given as positional arguments. If there are no\npositional arguments, the function will return the sizes of all clusters."}, {"type": "method", "name": "igraph.Flow.subgraph", "documentation": "Get the subgraph belonging to a given cluster.\n\nPrecondition: the vertex set of the graph hasn't been modified since the\nmoment the cover was constructed.\n\n@param idx: the cluster index\n@return: a copy of the subgraph"}, {"type": "method", "name": "igraph.Flow.subgraphs", "documentation": "Gets all the subgraphs belonging to each of the clusters.\n\nPrecondition: the vertex set of the graph hasn't been modified since the\nmoment the cover was constructed.\n\n@return: a list containing copies of the subgraphs"}, {"type": "method", "name": "igraph.Flow.summary", "documentation": "Returns the summary of the clustering.\n\nThe summary includes the number of items and clusters, and also the\nlist of members for each of the clusters if the verbosity is nonzero.\n\n@param verbosity: determines whether the cluster members should be\n  printed. Zero verbosity prints the number of items and clusters only.\n@return: the summary of the clustering as a string."}, {"type": "class", "name": "igraph.GradientPalette", "documentation": "Base class for gradient palettes\n\nGradient palettes contain a gradient between two given colors.\n\nExample:\n\n  >>> pal = GradientPalette(\"red\", \"blue\", 5)\n  >>> pal.get(0)\n  (1.0, 0.0, 0.0, 1.0)\n  >>> pal.get(2)\n  (0.5, 0.0, 0.5, 1.0)\n  >>> pal.get(4)\n  (0.0, 0.0, 1.0, 1.0)"}, {"type": "method", "name": "igraph.GradientPalette.__getitem__", "documentation": "Returns the given color from the palette.\n\nValues are cached: if the specific value given has already been\nlooked up, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@note: you shouldn't override this method in subclasses, override\n  L{_get} instead. If you override this method, lookups in the\n  L{known_colors} dict won't work, so you won't be able to refer to\n  colors by names or RGBA quadruplets, only by integer indices. The\n  caching functionality will disappear as well. However,\n  feel free to override this method if this is exactly the behaviour\n  you want.\n\n@param v: the color to be retrieved. If it is an integer, it is\n  passed to L{Palette._get} to be translated to an RGBA quadruplet.\n  Otherwise it is passed to L{color_name_to_rgb()} to determine the\n  RGBA values.\n\n@return: the color as an RGBA quadruplet"}, {"type": "method", "name": "igraph.GradientPalette.__init__", "documentation": "Creates a gradient palette.\n\n@param color1: the color where the gradient starts.\n@param color2: the color where the gradient ends.\n@param n: the number of colors in the palette."}, {"type": "method", "name": "igraph.GradientPalette.__len__", "documentation": "Returns the number of colors in this palette"}, {"type": "method", "name": "igraph.GradientPalette.__plot__", "documentation": "Plots the colors of the palette on the given Cairo context/mpl Axes\n\nSupported keywork arguments in both Cairo and matplotlib are:\n\n  - C{orientation}: the orientation of the palette. Must be one of\n    the following values: C{left-right}, C{bottom-top}, C{right-left}\n    or C{top-bottom}. Possible aliases: C{horizontal} = C{left-right},\n    C{vertical} = C{bottom-top}, C{lr} = C{left-right},\n    C{rl} = C{right-left}, C{tb} = C{top-bottom}, C{bt} = C{bottom-top}.\n    The default is C{left-right}.\n\nAdditional supported keyword arguments in Cairo are:\n\n  - C{border_width}: line width of the border shown around the palette.\n    If zero or negative, the border is turned off. Default is C{1}.\n\n  - C{grid_width}: line width of the grid that separates palette cells.\n    If zero or negative, the grid is turned off. The grid is also\n    turned off if the size of a cell is less than three times the given\n    line width. Default is C{0}.  Fractional widths are also allowed.\n\nKeyword arguments in matplotlib are passes to Axes.imshow."}, {"type": "method", "name": "igraph.GradientPalette.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.GradientPalette._get", "documentation": "Returns the color corresponding to the given color index.\n\n@param v: numerical index of the color to be retrieved\n@return: a 4-tuple containing the RGBA values"}, {"type": "method", "name": "igraph.GradientPalette.clear_cache", "documentation": "Clears the result cache.\n\nThe return values of L{Palette.get} are cached. Use this method\nto clear the cache."}, {"type": "method", "name": "igraph.GradientPalette.get", "documentation": "Returns the given color from the palette.\n\nValues are cached: if the specific value given has already been\nlooked up, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@note: you shouldn't override this method in subclasses, override\n  L{_get} instead. If you override this method, lookups in the\n  L{known_colors} dict won't work, so you won't be able to refer to\n  colors by names or RGBA quadruplets, only by integer indices. The\n  caching functionality will disappear as well. However,\n  feel free to override this method if this is exactly the behaviour\n  you want.\n\n@param v: the color to be retrieved. If it is an integer, it is\n  passed to L{Palette._get} to be translated to an RGBA quadruplet.\n  Otherwise it is passed to L{color_name_to_rgb()} to determine the\n  RGBA values.\n\n@return: the color as an RGBA quadruplet"}, {"type": "method", "name": "igraph.GradientPalette.get_many", "documentation": "Returns multiple colors from the palette.\n\nValues are cached: if the specific value given has already been\nlooked upon, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@param colors: the list of colors to be retrieved. The palette class\n  tries to make an educated guess here: if it is not possible to\n  interpret the value you passed here as a list of colors, the\n  class will simply try to interpret it as a single color by\n  forwarding the value to L{Palette.get}.\n@return: the colors as a list of RGBA quadruplets. The result will\n  be a list even if you passed a single color index or color name."}, {"type": "class", "name": "igraph.Graph", "documentation": "Generic graph.\n\nThis class is built on top of L{GraphBase}, so the order of the\nmethods in the generated API documentation is a little bit obscure:\ninherited methods come after the ones implemented directly in the\nsubclass. L{Graph} provides many functions that L{GraphBase} does not,\nmostly because these functions are not speed critical and they were\neasier to implement in Python than in pure C. An example is the\nattribute handling in the constructor: the constructor of L{Graph}\naccepts three dictionaries corresponding to the graph, vertex and edge\nattributes while the constructor of L{GraphBase} does not. This extension\nwas needed to make L{Graph} serializable through the C{pickle} module.\nL{Graph} also overrides some functions from L{GraphBase} to provide a\nmore convenient interface; e.g., layout functions return a L{Layout}\ninstance from L{Graph} instead of a list of coordinate pairs.\n\nGraphs can also be indexed by strings or pairs of vertex indices or vertex\nnames.  When a graph is indexed by a string, the operation translates to\nthe retrieval, creation, modification or deletion of a graph attribute:\n\n  >>> g = Graph.Full(3)\n  >>> g[\"name\"] = \"Triangle graph\"\n  >>> g[\"name\"]\n  'Triangle graph'\n  >>> del g[\"name\"]\n\nWhen a graph is indexed by a pair of vertex indices or names, the graph\nitself is treated as an adjacency matrix and the corresponding cell of\nthe matrix is returned:\n\n  >>> g = Graph.Full(3)\n  >>> g.vs[\"name\"] = [\"A\", \"B\", \"C\"]\n  >>> g[1, 2]\n  1\n  >>> g[\"A\", \"B\"]\n  1\n  >>> g[\"A\", \"B\"] = 0\n  >>> g.ecount()\n  2\n\nAssigning values different from zero or one to the adjacency matrix will\nbe translated to one, unless the graph is weighted, in which case the\nnumbers will be treated as weights:\n\n  >>> g.is_weighted()\n  False\n  >>> g[\"A\", \"B\"] = 2\n  >>> g[\"A\", \"B\"]\n  1\n  >>> g.es[\"weight\"] = 1.0\n  >>> g.is_weighted()\n  True\n  >>> g[\"A\", \"B\"] = 2\n  >>> g[\"A\", \"B\"]\n  2\n  >>> g.es[\"weight\"]\n  [1.0, 1.0, 2]"}, {"type": "method", "name": "igraph.Graph.Adjacency", "documentation": "Generates a graph from its adjacency matrix.\n\n@param matrix: the adjacency matrix. Possible types are:\n  - a list of lists\n  - a numpy 2D array or matrix (will be converted to list of lists)\n  - a scipy.sparse matrix (will be converted to a COO matrix, but not\n    to a dense matrix)\n  - a pandas.DataFrame (column/row names must match, and will be used\n    as vertex names).\n@param mode: the mode to be used. Possible values are:\n  - C{\"directed\"} - the graph will be directed and a matrix element\n    specifies the number of edges between two vertices.\n  - C{\"undirected\"} - the graph will be undirected and a matrix element\n    specifies the number of edges between two vertices. The matrix must\n    be symmetric.\n  - C{\"max\"} - undirected graph will be created and the number of\n    edges between vertex M{i} and M{j} is M{max(A(i,j), A(j,i))}\n  - C{\"min\"} - like C{\"max\"}, but with M{min(A(i,j), A(j,i))}\n  - C{\"plus\"}  - like C{\"max\"}, but with M{A(i,j) + A(j,i)}\n  - C{\"upper\"} - undirected graph with the upper right triangle of\n    the matrix (including the diagonal)\n  - C{\"lower\"} - undirected graph with the lower left triangle of\n    the matrix (including the diagonal)\n@param loops: specifies how to handle loop edges. When C{False} or\n    C{\"ignore\"}, the diagonal of the adjacency matrix will be ignored. When\n    C{True} or C{\"once\"}, the diagonal is assumed to contain the multiplicity\n    of the corresponding loop edge. When C{\"twice\"}, the diagonal is assumed\n    to contain I{twice} the multiplicity of the corresponding loop edge."}, {"type": "method", "name": "igraph.Graph.Biadjacency", "documentation": "Creates a bipartite graph from a bipartite adjacency matrix.\n\nExample:\n\n>>> g = Graph.Biadjacency([[0, 1, 1], [1, 1, 0]])\n\n@param matrix: the bipartite adjacency matrix.\n@param directed: whether to create a directed graph.\n@param mode: defines the direction of edges in the graph. If\n  C{\"out\"}, then edges go from vertices of the first kind\n  (corresponding to rows of the matrix) to vertices of the\n  second kind (the columns of the matrix). If C{\"in\"}, the\n  opposite direction is used. C{\"all\"} creates mutual edges.\n  Ignored for undirected graphs.\n@param multiple: defines what to do with non-zero entries in the\n  matrix. If C{False}, non-zero entries will create an edge no matter\n  what the value is. If C{True}, non-zero entries are rounded up to\n  the nearest integer and this will be the number of multiple edges\n  created.\n@param weighted: defines whether to create a weighted graph from the\n  adjacency matrix. If it is c{None} then an unweighted graph is created\n  and the multiple argument is used to determine the edges of the graph.\n  If it is a string then for every non-zero matrix entry, an edge is created\n  and the value of the entry is added as an edge attribute named by the\n  weighted argument. If it is C{True} then a weighted graph is created and\n  the name of the edge attribute will be C{\"weight\"}.\n\n@raise ValueError: if the weighted and multiple are passed together.\n\n@return: the graph with a binary vertex attribute named C{\"type\"} that\n  stores the vertex classes."}, {"type": "method", "name": "igraph.Graph.Bipartite", "documentation": "Creates a bipartite graph with the given vertex types and edges.\nThis is similar to the default constructor of the graph, the\nonly difference is that it checks whether all the edges go\nbetween the two vertex classes and it assigns the type vector\nto a C{type} attribute afterwards.\n\nExamples:\n\n>>> g = Graph.Bipartite([0, 1, 0, 1], [(0, 1), (2, 3), (0, 3)])\n>>> g.is_bipartite()\nTrue\n>>> g.vs[\"type\"]\n[False, True, False, True]\n\n@param types: the vertex types as a boolean list. Anything that\n  evaluates to C{False} will denote a vertex of the first kind,\n  anything that evaluates to C{True} will denote a vertex of the\n  second kind.\n@param edges: the edges as a list of tuples.\n@param directed: whether to create a directed graph. Bipartite\n  networks are usually undirected, so the default is C{False}\n\n@return: the graph with a binary vertex attribute named C{\"type\"} that\n  stores the vertex classes."}, {"type": "method", "name": "igraph.Graph.DataFrame", "documentation": "Generates a graph from one or two dataframes.\n\n@param edges: pandas DataFrame containing edges and metadata. The first\n  two columns of this DataFrame contain the source and target vertices\n  for each edge. These indicate the vertex IDs as nonnegative integers\n  rather than vertex names unless C{use_vids} is False. Further columns\n  may contain edge attributes.\n@param directed: whether the graph is directed\n@param vertices: None (default) or pandas DataFrame containing vertex\n  metadata. The DataFrame's index must contain the vertex IDs as a\n  sequence of intergers from 0 to C{len(vertices) - 1}. If C{use_vids}\n  is C{False}, the first column must contain the unique vertex names.\n  Vertex names should be strings for full compatibility, but many functions\n  will work if you set the name with any hashable object. All other columns\n  will be added as vertex attributes by column name.\n@param use_vids: whether to interpret the first two columns of the C{edges}\n  argument as vertex ids (0-based integers) instead of vertex names.\n  If this argument is set to True and the first two columns of C{edges}\n  are not integers, an error is thrown.\n\n@return: the graph\n\nVertex names in either the C{edges} or C{vertices} arguments that are set\nto NaN (not a number) will be set to the string \"NA\". That might lead\nto unexpected behaviour: fill your NaNs with values before calling this\nfunction to mitigate."}, {"type": "method", "name": "igraph.Graph.DictDict", "documentation": "Constructs a graph from a dict-of-dicts representation.\n\nEach key can be an integer or a string and represent a vertex. Each value\nis a dict representing edges (outgoing if the graph is directed) from that\nvertex. Each dict key is an integer/string for a target vertex, such that\nan edge will be created between those two vertices. Integers are\ninterpreted as vertex_ids from 0 (as used in igraph), strings are\ninterpreted as vertex names, in which case vertices are given separate\nnumeric ids. Each value is a dictionary of edge attributes for that edge.\n\nExample:\n\n  >>> {'Alice': {'Bob': {'weight': 1.5}, 'David': {'weight': 2}}}\n\ncreates a graph with three vertices (Alice, Bob, and David) and two edges:\n\n  - Alice - Bob (with weight 1.5)\n  - Alice - David (with weight 2)\n\n@param edges: the dict of dict of dicts specifying the edges and their\n  attributes\n@param directed: whether to create a directed graph\n@param vertex_name_attr: vertex attribute that will store the names\n\n@returns: a Graph object"}, {"type": "method", "name": "igraph.Graph.DictList", "documentation": "Constructs a graph from a list-of-dictionaries representation.\n\nThis function is useful when you have two lists of dictionaries, one for\nvertices and one for edges, each containing their attributes (e.g. name,\nweight). Of course, the edge dictionary must also contain two special keys\nthat indicate the source and target vertices connected by that edge.\nNon-list iterables should work as long as they yield dictionaries or\ndict-like objects (they should have the 'items' and '__getitem__' methods).\nFor instance, a database query result is likely to be fit as long as it's\niterable and yields dict-like objects with every iteration.\n\n@param vertices: the list of dictionaries for the vertices or C{None} if\n  there are no special attributes assigned to vertices and we\n  should simply use the edge list of dicts to infer vertex names.\n@param edges: the list of dictionaries for the edges. Each dict must have\n  at least the two keys specified by edge_foreign_keys to label the source\n  and target vertices, while additional items will be treated as edge\n  attributes.\n@param directed: whether the constructed graph will be directed\n@param vertex_name_attr: the name of the distinguished key in the\n  dicts in the vertex data source that contains the vertex names.\n  Ignored if C{vertices} is C{None}.\n@param edge_foreign_keys: tuple specifying the attributes in each edge\n  dictionary that contain the source (1st) and target (2nd) vertex names.\n  These items of each dictionary are also added as edge_attributes.\n@param iterative: whether to add the edges to the graph one by one,\n  iteratively, or to build a large edge list first and use that to\n  construct the graph. The latter approach is faster but it may\n  not be suitable if your dataset is large. The default is to\n  add the edges in a batch from an edge list.\n@return: the graph that was constructed\n\nExample:\n\n>>> vertices = [{'name': 'apple'}, {'name': 'pear'}, {'name': 'peach'}]\n>>> edges = [{'source': 'apple', 'target': 'pear', 'weight': 1.2},\n...          {'source': 'apple', 'target': 'peach', 'weight': 0.9}]\n>>> g = Graph.DictList(vertices, edges)\n\nThe graph has three vertices with names and two edges with weights."}, {"type": "method", "name": "igraph.Graph.Formula", "documentation": "Graph.Formula(formula = None, attr = \"name\", simplify = True)\n\nGenerates a graph from a graph formula\n\nA graph formula is a simple string representation of a graph.\nIt is very handy for creating small graphs quickly. The string\nconsists of vertex names separated by edge operators. An edge\noperator is a sequence of dashes (C{-}) that may or may not\nstart with an arrowhead (C{<} at the beginning of the sequence\nor C{>} at the end of the sequence). The edge operators can\nbe arbitrarily long, i.e., you may use as many dashes to draw\nthem as you like. This makes a total of four different edge\noperators:\n\n  - C{-----} makes an undirected edge\n  - C{<----} makes a directed edge pointing from the vertex\n    on the right hand side of the operator to the vertex on\n    the left hand side\n  - C{---->} is the opposite of C{<----}\n  - C{<--->} creates a mutual directed edge pair between\n    the two vertices\n\nIf you only use the undirected edge operator (C{-----}),\nthe graph will be undirected. Otherwise it will be directed.\nVertex names used in the formula will be assigned to the\nC{name} vertex attribute of the graph.\n\nSome simple examples:\n\n  >>> from igraph import Graph\n  >>> print(Graph.Formula())          # empty graph\n  IGRAPH UN-- 0 0 --\n  + attr: name (v)\n  >>> g = Graph.Formula(\"A-B\")        # undirected graph\n  >>> g.vs[\"name\"]\n  ['A', 'B']\n  >>> print(g)\n  IGRAPH UN-- 2 1 --\n  + attr: name (v)\n  + edges (vertex names):\n  A--B\n  >>> g.get_edgelist()\n  [(0, 1)]\n  >>> g2 = Graph.Formula(\"A-----------B\")\n  >>> g2.isomorphic(g)\n  True\n  >>> g = Graph.Formula(\"A  --->  B\") # directed graph\n  >>> g.vs[\"name\"]\n  ['A', 'B']\n  >>> print(g)\n  IGRAPH DN-- 2 1 --\n  + attr: name (v)\n  + edges (vertex names):\n  A->B\n\nIf you have many disconnected componnets, you can separate them\nwith commas. You can also specify isolated vertices:\n\n  >>> g = Graph.Formula(\"A--B, C--D, E--F, G--H, I, J, K\")\n  >>> print(\", \".join(g.vs[\"name\"]))\n  A, B, C, D, E, F, G, H, I, J, K\n  >>> g.connected_components().membership\n  [0, 0, 1, 1, 2, 2, 3, 3, 4, 5, 6]\n\nThe colon (C{:}) operator can be used to specify vertex sets.\nIf an edge operator connects two vertex sets, then every vertex\nfrom the first vertex set will be connected to every vertex in\nthe second set:\n\n  >>> g = Graph.Formula(\"A:B:C:D --- E:F:G\")\n  >>> g.isomorphic(Graph.Full_Bipartite(4, 3))\n  True\n\nNote that you have to quote vertex names if they include spaces\nor special characters:\n\n  >>> g = Graph.Formula('\"this is\" +- \"a silly\" -+ \"graph here\"')\n  >>> g.vs[\"name\"]\n  ['this is', 'a silly', 'graph here']\n\n@param formula: the formula itself\n@param attr: name of the vertex attribute where the vertex names\n             will be stored\n@param simplify: whether to simplify the constructed graph\n@return: the constructed graph:"}, {"type": "method", "name": "igraph.Graph.Full_Bipartite", "documentation": "Generates a full bipartite graph (directed or undirected, with or\nwithout loops).\n\n>>> g = Graph.Full_Bipartite(2, 3)\n>>> g.is_bipartite()\nTrue\n>>> g.vs[\"type\"]\n[False, False, True, True, True]\n\n@param n1: the number of vertices of the first kind.\n@param n2: the number of vertices of the second kind.\n@param directed: whether tp generate a directed graph.\n@param mode: if C{\"out\"}, then all vertices of the first kind are\n  connected to the others; C{\"in\"} specifies the opposite direction,\n  C{\"all\"} creates mutual edges. Ignored for undirected graphs.\n\n@return: the graph with a binary vertex attribute named C{\"type\"} that\n  stores the vertex classes."}, {"type": "method", "name": "igraph.Graph.GRG", "documentation": "Generates a random geometric graph.\n\nThe algorithm drops the vertices randomly on the 2D unit square and\nconnects them if they are closer to each other than the given radius.\nThe coordinates of the vertices are stored in the vertex attributes C{x}\nand C{y}.\n\n@param n: The number of vertices in the graph\n@param radius: The given radius\n@param torus: This should be C{True} if we want to use a torus instead of a\n  square."}, {"type": "method", "name": "igraph.Graph.Incidence", "documentation": "Deprecated alias to L{Graph.Biadjacency()}."}, {"type": "method", "name": "igraph.Graph.ListDict", "documentation": "Constructs a graph from a dict-of-lists representation.\n\nThis function is used to construct a graph from a dictionary of\nlists. Other, non-list sequences (e.g. tuples) and lazy iterators are\nare accepted. For each key x, its corresponding value must be a sequence of\nmultiple values y: the edge (x,y) will be created in the graph. x and y\nmust be either one of:\n\n  - two integers: the vertices with those ids will be connected\n  - two strings: the vertices with those names will be connected\n\nIf names are used, the order of vertices is not guaranteed, and each\nvertex will be given the vertex_name_attr attribute.\n\n@param edges: the dict of sequences describing the edges\n@param directed: whether to create a directed graph\n@param vertex_name_attr: vertex attribute that will store the names\n\n@returns: a Graph object\n\nExample:\n\n>>> mydict = {'apple': ['pear', 'peach'], 'pear': ['peach']}\n>>> g = Graph.ListDict(mydict)\n\n# The graph has three vertices with names and three edges connecting\n# each pair."}, {"type": "method", "name": "igraph.Graph.Load", "documentation": "Unified reading function for graphs.\n\nThis method tries to identify the format of the graph given in\nthe first parameter and calls the corresponding reader method.\n\nThe remaining arguments are passed to the reader method without\nany changes.\n\n@param f: the file containing the graph to be loaded\n@param format: the format of the file (if known in advance).\n  C{None} means auto-detection. Possible values are: C{\"ncol\"}\n  (NCOL format), C{\"lgl\"} (LGL format), C{\"graphdb\"} (GraphDB\n  format), C{\"graphml\"}, C{\"graphmlz\"} (GraphML and gzipped\n  GraphML format), C{\"gml\"} (GML format), C{\"net\"}, C{\"pajek\"}\n  (Pajek format), C{\"dimacs\"} (DIMACS format), C{\"edgelist\"},\n  C{\"edges\"} or C{\"edge\"} (edge list), C{\"adjacency\"}\n  (adjacency matrix), C{\"dl\"} (DL format used by UCINET),\n  C{\"pickle\"} (Python pickled format),\n  C{\"picklez\"} (gzipped Python pickled format)\n@raises IOError: if the file format can't be identified and\n  none was given."}, {"type": "method", "name": "igraph.Graph.Random_Bipartite", "documentation": "Generates a random bipartite graph with the given number of vertices and\nedges (if m is given), or with the given number of vertices and the given\nconnection probability (if p is given).\n\nIf m is given but p is not, the generated graph will have n1 vertices of\ntype 1, n2 vertices of type 2 and m randomly selected edges between them. If\np is given but m is not, the generated graph will have n1 vertices of type 1\nand n2 vertices of type 2, and each edge will exist between them with\nprobability p.\n\n@param n1: the number of vertices of type 1.\n@param n2: the number of vertices of type 2.\n@param p: the probability of edges. If given, C{m} must be missing.\n@param m: the number of edges. If given, C{p} must be missing.\n@param directed: whether to generate a directed graph.\n@param neimode: if the graph is directed, specifies how the edges will be\n  generated. If it is C{\"all\"}, edges will be generated in both directions\n  (from type 1 to type 2 and vice versa) independently. If it is C{\"out\"}\n  edges will always point from type 1 to type 2. If it is C{\"in\"}, edges\n  will always point from type 2 to type 1. This argument is ignored for\n  undirected graphs."}, {"type": "method", "name": "igraph.Graph.Read", "documentation": "Unified reading function for graphs.\n\nThis method tries to identify the format of the graph given in\nthe first parameter and calls the corresponding reader method.\n\nThe remaining arguments are passed to the reader method without\nany changes.\n\n@param f: the file containing the graph to be loaded\n@param format: the format of the file (if known in advance).\n  C{None} means auto-detection. Possible values are: C{\"ncol\"}\n  (NCOL format), C{\"lgl\"} (LGL format), C{\"graphdb\"} (GraphDB\n  format), C{\"graphml\"}, C{\"graphmlz\"} (GraphML and gzipped\n  GraphML format), C{\"gml\"} (GML format), C{\"net\"}, C{\"pajek\"}\n  (Pajek format), C{\"dimacs\"} (DIMACS format), C{\"edgelist\"},\n  C{\"edges\"} or C{\"edge\"} (edge list), C{\"adjacency\"}\n  (adjacency matrix), C{\"dl\"} (DL format used by UCINET),\n  C{\"pickle\"} (Python pickled format),\n  C{\"picklez\"} (gzipped Python pickled format)\n@raises IOError: if the file format can't be identified and\n  none was given."}, {"type": "method", "name": "igraph.Graph.Read_Adjacency", "documentation": "Constructs a graph based on an adjacency matrix from the given file.\n\nAdditional positional and keyword arguments not mentioned here are\npassed intact to L{Graph.Adjacency}.\n\n@param f: the name of the file to be read or a file object\n@param sep: the string that separates the matrix elements in a row.\n  C{None} means an arbitrary sequence of whitespace characters.\n@param comment_char: lines starting with this string are treated\n  as comments.\n@param attribute: an edge attribute name where the edge weights are\n  stored in the case of a weighted adjacency matrix. If C{None},\n  no weights are stored, values larger than 1 are considered as\n  edge multiplicities.\n@return: the created graph"}, {"type": "method", "name": "igraph.Graph.Read_DIMACS", "documentation": "Reads a graph from a file conforming to the DIMACS minimum-cost flow\nfile format.\n\nFor the exact definition of the format, see\nU{http://lpsolve.sourceforge.net/5.5/DIMACS.htm}.\n\nRestrictions compared to the official description of the format are\nas follows:\n\n  - igraph's DIMACS reader requires only three fields in an arc\n    definition, describing the edge's source and target node and\n    its capacity.\n  - Source vertices are identified by 's' in the FLOW field, target\n    vertices are identified by 't'.\n  - Node indices start from 1. Only a single source and target node\n    is allowed.\n\n@param f: the name of the file or a Python file handle\n@param directed: whether the generated graph should be directed.\n@return: the generated graph. The indices of the source and target\n  vertices are attached as graph attributes C{source} and C{target},\n  the edge capacities are stored in the C{capacity} edge attribute."}, {"type": "method", "name": "igraph.Graph.Read_GraphMLz", "documentation": "Reads a graph from a zipped GraphML file.\n\n@param f: the name of the file\n@param index: if the GraphML file contains multiple graphs,\n  specified the one that should be loaded. Graph indices\n  start from zero, so if you want to load the first graph,\n  specify 0 here.\n@return: the loaded graph object"}, {"type": "method", "name": "igraph.Graph.Read_Pickle", "documentation": "Reads a graph from Python pickled format\n\n@param fname: the name of the file, a stream to read from, or\n  a string containing the pickled data.\n@return: the created graph object."}, {"type": "method", "name": "igraph.Graph.Read_Picklez", "documentation": "Reads a graph from compressed Python pickled format, uncompressing\nit on-the-fly.\n\n@param fname: the name of the file or a stream to read from.\n@return: the created graph object."}, {"type": "method", "name": "igraph.Graph.TupleList", "documentation": "Constructs a graph from a list-of-tuples representation.\n\nThis representation assumes that the edges of the graph are encoded\nin a list of tuples (or lists). Each item in the list must have at least\ntwo elements, which specify the source and the target vertices of the edge.\nThe remaining elements (if any) specify the edge attributes of that edge,\nwhere the names of the edge attributes originate from the C{edge_attrs}\nlist. The names of the vertices will be stored in the vertex attribute\ngiven by C{vertex_name_attr}.\n\nThe default parameters of this function are suitable for creating\nunweighted graphs from lists where each item contains the source vertex\nand the target vertex. If you have a weighted graph, you can use items\nwhere the third item contains the weight of the edge by setting\nC{edge_attrs} to C{\"weight\"} or C{[\"weight\"]}. If you have even more\nedge attributes, add them to the end of each item in the C{edges}\nlist and also specify the corresponding edge attribute names in\nC{edge_attrs} as a list.\n\n@param edges: the data source for the edges. This must be a list\n  where each item is a tuple (or list) containing at least two\n  items: the name of the source and the target vertex. Note that\n  names will be assigned to the C{name} vertex attribute (or another\n  vertex attribute if C{vertex_name_attr} is specified), even if\n  all the vertex names in the list are in fact numbers.\n@param directed: whether the constructed graph will be directed\n@param vertex_name_attr: the name of the vertex attribute that will\n  contain the vertex names.\n@param edge_attrs: the names of the edge attributes that are filled\n  with the extra items in the edge list (starting from index 2, since\n  the first two items are the source and target vertices). If C{None}\n  or an empty sequence, only the source and target vertices will be\n  extracted and additional tuple items will be ignored. If a string, it is\n  interpreted as a single edge attribute.\n@param weights: alternative way to specify that the graph is\n  weighted. If you set C{weights} to C{true} and C{edge_attrs} is\n  not given, it will be assumed that C{edge_attrs} is C{[\"weight\"]}\n  and igraph will parse the third element from each item into an\n  edge weight. If you set C{weights} to a string, it will be assumed\n  that C{edge_attrs} contains that string only, and igraph will\n  store the edge weights in that attribute.\n@return: the graph that was constructed"}, {"type": "method", "name": "igraph.Graph.Weighted_Adjacency", "documentation": "Generates a graph from its weighted adjacency matrix.\n\nOnly edges with a non-zero weight are created.\n\n@param matrix: the adjacency matrix. Possible types are:\n  - a list of lists\n  - a numpy 2D array or matrix (will be converted to list of lists)\n  - a scipy.sparse matrix (will be converted to a COO matrix, but not\n    to a dense matrix)\n@param mode: the mode to be used. Possible values are:\n  - C{\"directed\"} - the graph will be directed and a matrix element\n    specifies the weight of the corresponding edge.\n  - C{\"undirected\"} - the graph will be undirected and a matrix element\n    specifies the weight of the corresponding edge. The matrix must\n    be symmetric.\n  - C{\"max\"}   - undirected graph will be created and the weight of the\n    edge between vertex M{i} and M{j} is M{max(A(i,j), A(j,i))}\n  - C{\"min\"}   - like C{\"max\"}, but with M{min(A(i,j), A(j,i))}\n  - C{\"plus\"}  - like C{\"max\"}, but with M{A(i,j) + A(j,i)}\n  - C{\"upper\"} - undirected graph with the upper right triangle of\n    the matrix (including the diagonal)\n  - C{\"lower\"} - undirected graph with the lower left triangle of\n    the matrix (including the diagonal)\n\n  These values can also be given as strings without the C{ADJ} prefix.\n@param attr: the name of the edge attribute that stores the edge\n  weights.\n@param loops: specifies how to handle loop edges. When C{False} or\n    C{\"ignore\"}, the diagonal of the adjacency matrix will be ignored. When\n    C{True} or C{\"once\"}, the diagonal is assumed to contain the weight of the\n    corresponding loop edge. When C{\"twice\"}, the diagonal is assumed to\n    contain I{twice} the weight of the corresponding loop edge."}, {"type": "method", "name": "igraph.Graph.__add__", "documentation": "Copies the graph and extends the copy depending on the type of\nthe other object given.\n\n@param other: if it is an integer, the copy is extended by the given\n  number of vertices. If it is a string, the copy is extended by a\n  single vertex whose C{name} attribute will be equal to the given\n  string. If it is a tuple with two elements, the copy\n  is extended by a single edge. If it is a list of tuples, the copy\n  is extended by multiple edges. If it is a L{Graph}, a disjoint\n  union is performed."}, {"type": "method", "name": "igraph.Graph.__and__", "documentation": "Graph intersection operator.\n\n@param other: the other graph to take the intersection with.\n@return: the intersected graph."}, {"type": "method", "name": "igraph.Graph.__bool__", "documentation": "Returns True if the graph has at least one vertex, False otherwise."}, {"type": "method", "name": "igraph.Graph.__coerce__", "documentation": "Coercion rules.\n\nThis method is needed to allow the graph to react to additions\nwith lists, tuples, integers, strings, vertices, edges and so on."}, {"type": "method", "name": "igraph.Graph.__iadd__", "documentation": "In-place addition (disjoint union).\n\n@see: L{__add__}"}, {"type": "method", "name": "igraph.Graph.__init__", "documentation": "__init__(n=0, edges=None, directed=False, graph_attrs=None,\nvertex_attrs=None, edge_attrs=None)\n\nConstructs a graph from scratch.\n\n@keyword n: the number of vertices. Can be omitted, the default is\n  zero. Note that if the edge list contains vertices with indexes\n  larger than or equal to M{n}, then the number of vertices will\n  be adjusted accordingly.\n@keyword edges: the edge list where every list item is a pair of\n  integers. If any of the integers is larger than M{n-1}, the number\n  of vertices is adjusted accordingly. C{None} means no edges.\n@keyword directed: whether the graph should be directed\n@keyword graph_attrs: the attributes of the graph as a dictionary.\n@keyword vertex_attrs: the attributes of the vertices as a dictionary.\n  The keys of the dictionary must be the names of the attributes; the\n  values must be iterables with exactly M{n} items where M{n} is the\n  number of vertices.\n@keyword edge_attrs: the attributes of the edges as a dictionary. The\n  keys of the dictionary must be the names of the attributes; the values\n  must be iterables with exactly M{m} items where M{m} is the number of\n  edges."}, {"type": "method", "name": "igraph.Graph.__isub__", "documentation": "In-place subtraction (difference).\n\n@see: L{__sub__}"}, {"type": "method", "name": "igraph.Graph.__mul__", "documentation": "Copies exact replicas of the original graph an arbitrary number of\ntimes.\n\n@param other: if it is an integer, multiplies the graph by creating the\n  given number of identical copies and taking the disjoint union of\n  them."}, {"type": "method", "name": "igraph.Graph.__or__", "documentation": "Graph union operator.\n\n@param other: the other graph to take the union with.\n@return: the union graph."}, {"type": "method", "name": "igraph.Graph.__plot__", "documentation": "Plots the graph to the given Cairo context or matplotlib Axes.\n\nThe visual style of vertices and edges can be modified at three\nplaces in the following order of precedence (lower indices override\nhigher indices):\n\n  1. Keyword arguments of this function (or of L{plot()} which is\n     passed intact to C{Graph.__plot__()}.\n\n  2. Vertex or edge attributes, specified later in the list of\n     keyword arguments.\n\n  3. igraph-wide plotting defaults (see\n     L{igraph.config.Configuration})\n\n  4. Built-in defaults.\n\nE.g., if the C{vertex_size} keyword attribute is not present,\nbut there exists a vertex attribute named C{size}, the sizes of\nthe vertices will be specified by that attribute.\n\nBesides the usual self-explanatory plotting parameters (C{context},\nC{bbox}, C{palette}), it accepts the following keyword arguments:\n\n  - C{autocurve}: whether to use curves instead of straight lines for\n    multiple edges on the graph plot. This argument may be C{True}\n    or C{False}; when omitted, C{True} is assumed for graphs with\n    less than 10.000 edges and C{False} otherwise.\n\n  - C{drawer_factory}: a subclass of L{AbstractCairoGraphDrawer}\n    which will be used to draw the graph. You may also provide\n    a function here which takes two arguments: the Cairo context\n    to draw on and a bounding box (an instance of L{BoundingBox}).\n    If this keyword argument is missing, igraph will use the\n    default graph drawer which should be suitable for most purposes.\n    It is safe to omit this keyword argument unless you need to use\n    a specific graph drawer.\n\n  - C{keep_aspect_ratio}: whether to keep the aspect ratio of the layout\n    that igraph calculates to place the nodes. C{True} means that the\n    layout will be scaled proportionally to fit into the bounding box\n    where the graph is to be drawn but the aspect ratio will be kept\n    the same (potentially leaving empty space next to, below or above\n    the graph). C{False} means that the layout will be scaled independently\n    along the X and Y axis in order to fill the entire bounding box.\n    The default is C{False}.\n\n  - C{layout}: the layout to be used. If not an instance of\n    L{Layout}, it will be passed to L{layout} to calculate\n    the layout. Note that if you want a deterministic layout that\n    does not change with every plot, you must either use a\n    deterministic layout function (like L{GraphBase.layout_circle}) or\n    calculate the layout in advance and pass a L{Layout} object here.\n\n  - C{margin}: the top, right, bottom, left margins as a 4-tuple.\n    If it has less than 4 elements or is a single float, the elements\n    will be re-used until the length is at least 4.\n\n  - C{mark_groups}: whether to highlight some of the vertex groups by\n    colored polygons. This argument can be one of the following:\n\n      - C{False}: no groups will be highlighted\n\n      - C{True}: only valid if the object plotted is a\n        L{VertexClustering} or L{VertexCover}. The vertex groups in the\n        clutering or cover will be highlighted such that the i-th\n        group will be colored by the i-th color from the current\n        palette. If used when plotting a graph, it will throw an error.\n\n      - A dict mapping tuples of vertex indices to color names.\n        The given vertex groups will be highlighted by the given\n        colors.\n\n      - A list containing pairs or an iterable yielding pairs, where\n        the first element of each pair is a list of vertex indices and\n        the second element is a color.\n\n      - A L{VertexClustering} or L{VertexCover} instance. The vertex\n        groups in the clustering or cover will be highlighted such that\n        the i-th group will be colored by the i-th color from the\n        current palette.\n\n    In place of lists of vertex indices, you may also use L{VertexSeq}\n    instances.\n\n    In place of color names, you may also use color indices into the\n    current palette. C{None} as a color name will mean that the\n    corresponding group is ignored.\n\n  - C{vertex_size}: size of the vertices. The corresponding vertex\n    attribute is called C{size}. The default is 10. Vertex sizes\n    are measured in the unit of the Cairo context on which igraph\n    is drawing.\n\n  - C{vertex_color}: color of the vertices. The corresponding vertex\n    attribute is C{color}, the default is red.  Colors can be\n    specified either by common X11 color names (see the source\n    code of L{igraph.drawing.colors} for a list of known colors), by\n    3-tuples of floats (ranging between 0 and 255 for the R, G and\n    B components), by CSS-style string specifications (C{#rrggbb})\n    or by integer color indices of the specified palette.\n\n  - C{vertex_frame_color}: color of the frame (i.e. stroke) of the\n    vertices. The corresponding vertex attribute is C{frame_color},\n    the default is black. See C{vertex_color} for the possible ways\n    of specifying a color.\n\n  - C{vertex_frame_width}: the width of the frame (i.e. stroke) of the\n    vertices. The corresponding vertex attribute is C{frame_width}.\n    The default is 1. Vertex frame widths are measured in the unit of the\n    Cairo context on which igraph is drawing.\n\n  - C{vertex_shape}: shape of the vertices. Alternatively it can\n    be specified by the C{shape} vertex attribute. Possibilities\n    are: C{square}, {circle}, {triangle}, {triangle-down} or\n    C{hidden}. See the source code of L{igraph.drawing} for a\n    list of alternative shape names that are also accepted and\n    mapped to these.\n\n  - C{vertex_label}: labels drawn next to the vertices.\n    The corresponding vertex attribute is C{label}.\n\n  - C{vertex_label_dist}: distance of the midpoint of the vertex\n    label from the center of the corresponding vertex.\n    The corresponding vertex attribute is C{label_dist}.\n\n  - C{vertex_label_color}: color of the label. Corresponding\n    vertex attribute: C{label_color}. See C{vertex_color} for\n    color specification syntax.\n\n  - C{vertex_label_size}: font size of the label, specified\n    in the unit of the Cairo context on which we are drawing.\n    Corresponding vertex attribute: C{label_size}.\n\n  - C{vertex_label_angle}: the direction of the line connecting\n    the midpoint of the vertex with the midpoint of the label.\n    This can be used to position the labels relative to the\n    vertices themselves in conjunction with C{vertex_label_dist}.\n    Corresponding vertex attribute: C{label_angle}. The\n    default is C{-math.pi/2}.\n\n  - C{vertex_order}: drawing order of the vertices. This must be\n    a list or tuple containing vertex indices; vertices are then\n    drawn according to this order.\n\n  - C{vertex_order_by}: an alternative way to specify the drawing\n    order of the vertices; this attribute is interpreted as the name\n    of a vertex attribute, and vertices are drawn such that those\n    with a smaller attribute value are drawn first. You may also\n    reverse the order by passing a tuple here; the first element of\n    the tuple should be the name of the attribute, the second element\n    specifies whether the order is reversed (C{True}, C{False},\n    C{\"asc\"} and C{\"desc\"} are accepted values).\n\n  - C{edge_color}: color of the edges. The corresponding edge\n    attribute is C{color}, the default is red. See C{vertex_color}\n    for color specification syntax.\n\n  - C{edge_curved}: whether the edges should be curved. Positive\n    numbers correspond to edges curved in a counter-clockwise\n    direction, negative numbers correspond to edges curved in a\n    clockwise direction. Zero represents straight edges. C{True}\n    is interpreted as 0.5, C{False} is interpreted as 0. The\n    default is 0 which makes all the edges straight.\n\n  - C{edge_width}: width of the edges in the default unit of the\n    Cairo context on which we are drawing. The corresponding\n    edge attribute is C{width}, the default is 1.\n\n  - C{edge_arrow_size}: arrow size of the edges. The\n    corresponding edge attribute is C{arrow_size}, the default\n    is 1.\n\n  - C{edge_arrow_width}: width of the arrowhead on the edge. The\n    corresponding edge attribute is C{arrow_width}, the default\n    is 1.\n\n  - C{edge_order}: drawing order of the edges. This must be\n    a list or tuple containing edge indices; edges are then\n    drawn according to this order.\n\n  - C{edge_order_by}: an alternative way to specify the drawing\n    order of the edges; this attribute is interpreted as the name\n    of an edge attribute, and edges are drawn such that those\n    with a smaller attribute value are drawn first. You may also\n    reverse the order by passing a tuple here; the first element of\n    the tuple should be the name of the attribute, the second element\n    specifies whether the order is reversed (C{True}, C{False},\n    C{\"asc\"} and C{\"desc\"} are accepted values)."}, {"type": "method", "name": "igraph.Graph.__reduce__", "documentation": "Support for pickling."}, {"type": "method", "name": "igraph.Graph.__str__", "documentation": "Returns a string representation of the graph.\n\nBehind the scenes, this method constructs a L{GraphSummary}\ninstance and invokes its C{__str__} method with a verbosity of 1\nand attribute printing turned off.\n\nSee the documentation of L{GraphSummary} for more details about the\noutput."}, {"type": "method", "name": "igraph.Graph.__sub__", "documentation": "Removes the given object(s) from the graph\n\n@param other: if it is an integer, removes the vertex with the given\n  ID from the graph (note that the remaining vertices will get\n  re-indexed!). If it is a tuple, removes the given edge. If it is\n  a graph, takes the difference of the two graphs. Accepts\n  lists of integers or lists of tuples as well, but they can't be\n  mixed! Also accepts L{Edge} and L{EdgeSeq} objects."}, {"type": "method", "name": "igraph.Graph._reconstruct", "documentation": "Reconstructs a Graph object from Python's pickled format.\n\nThis method is for internal use only, it should not be called\ndirectly."}, {"type": "method", "name": "igraph.Graph.add_edge", "documentation": "Adds a single edge to the graph.\n\nKeyword arguments (except the source and target arguments) will be\nassigned to the edge as attributes.\n\nThe performance cost of adding a single edge or several edges\nto a graph is similar. Thus, when adding several edges, a single\nC{add_edges()} call is more efficient than multiple C{add_edge()} calls.\n\n@param source: the source vertex of the edge or its name.\n@param target: the target vertex of the edge or its name.\n\n@return: the newly added edge as an L{Edge} object. Use\n    C{add_edges([(source, target)])} if you don't need the L{Edge}\n    object and want to avoid the overhead of creating it."}, {"type": "method", "name": "igraph.Graph.add_edges", "documentation": "Adds some edges to the graph.\n\n@param es: the list of edges to be added. Every edge is represented\n  with a tuple containing the vertex IDs or names of the two\n  endpoints. Vertices are enumerated from zero.\n@param attributes: dict of sequences, each of length equal to the\n  number of edges to be added, containing the attributes of the new\n  edges."}, {"type": "method", "name": "igraph.Graph.add_vertex", "documentation": "Adds a single vertex to the graph. Keyword arguments will be assigned\nas vertex attributes. Note that C{name} as a keyword argument is treated\nspecially; if a graph has C{name} as a vertex attribute, it allows one\nto refer to vertices by their names in most places where igraph expects\na vertex ID.\n\n@return: the newly added vertex as a L{Vertex} object. Use\n    C{add_vertices(1)} if you don't need the L{Vertex} object and want\n    to avoid the overhead of creating t."}, {"type": "method", "name": "igraph.Graph.add_vertices", "documentation": "Adds some vertices to the graph.\n\nNote that if C{n} is a sequence of strings, indicating the names of the\nnew vertices, and attributes has a key C{name}, the two conflict. In\nthat case the attribute will be applied.\n\n@param n: the number of vertices to be added, or the name of a single\n  vertex to be added, or a sequence of strings, each corresponding to the\n  name of a vertex to be added. Names will be assigned to the C{name}\n  vertex attribute.\n@param attributes: dict of sequences, each of length equal to the\n  number of vertices to be added, containing the attributes of the new\n  vertices. If n is a string (so a single vertex is added), then the\n  values of this dict are the attributes themselves, but if n=1 then\n  they have to be lists of length 1."}, {"type": "method", "name": "igraph.Graph.all_st_cuts", "documentation": "Returns all the cuts between the source and target vertices in a\ndirected graph.\n\nThis function lists all edge-cuts between a source and a target vertex.\nEvery cut is listed exactly once.\n\nB{Reference}: JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in\ngraphs. I{Algorithmica} 15, 351-372, 1996.\n\n@param source: the source vertex ID\n@param target: the target vertex ID\n@return: a list of L{Cut} objects."}, {"type": "method", "name": "igraph.Graph.all_st_mincuts", "documentation": "Returns all the mincuts between the source and target vertices in a\ndirected graph.\n\nThis function lists all minimum edge-cuts between a source and a target\nvertex.\n\nB{Reference}: JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in\ngraphs. I{Algorithmica} 15, 351-372, 1996.\n\n@param source: the source vertex ID\n@param target: the target vertex ID\n@param capacity: the edge capacities (weights). If C{None}, all\n  edges have equal weight. May also be an attribute name.\n@return: a list of L{Cut} objects."}, {"type": "method", "name": "igraph.Graph.are_connected", "documentation": "Deprecated alias to L{Graph.are_adjacent()}."}, {"type": "method", "name": "igraph.Graph.as_directed", "documentation": "Returns a directed copy of this graph. Arguments are passed on\nto L{GraphBase.to_directed()} that is invoked on the copy."}, {"type": "method", "name": "igraph.Graph.as_undirected", "documentation": "Returns an undirected copy of this graph. Arguments are passed on\nto L{GraphBase.to_undirected()} that is invoked on the copy."}, {"type": "method", "name": "igraph.Graph.biconnected_components", "documentation": "Calculates the biconnected components of the graph.\n\n@param return_articulation_points: whether to return the articulation\n  points as well\n@return: a L{VertexCover} object describing the biconnected components,\n  and optionally the list of articulation points as well"}, {"type": "method", "name": "igraph.Graph.bipartite_projection", "documentation": "Projects a bipartite graph into two one-mode graphs. Edge directions\nare ignored while projecting.\n\nExamples:\n\n>>> g = Graph.Full_Bipartite(10, 5)\n>>> g1, g2 = g.bipartite_projection()\n>>> g1.isomorphic(Graph.Full(10))\nTrue\n>>> g2.isomorphic(Graph.Full(5))\nTrue\n\n@param types: an igraph vector containing the vertex types, or an\n  attribute name. Anything that evalulates to C{False} corresponds to\n  vertices of the first kind, everything else to the second kind.\n@param multiplicity: if C{True}, then igraph keeps the multiplicity of\n  the edges in the projection in an edge attribute called C{\"weight\"}.\n  E.g., if there is an A-C-B and an A-D-B triplet in the bipartite\n  graph and there is no other X (apart from X=B and X=D) for which an\n  A-X-B triplet would exist in the bipartite graph, the multiplicity\n  of the A-B edge in the projection will be 2.\n@param probe1: this argument can be used to specify the order of the\n  projections in the resulting list. If given and non-negative, then\n  it is considered as a vertex ID; the projection containing the\n  vertex will be the first one in the result.\n@param which: this argument can be used to specify which of the two\n  projections should be returned if only one of them is needed. Passing\n  0 here means that only the first projection is returned, while 1 means\n  that only the second projection is returned. (Note that we use 0 and 1\n  because Python indexing is zero-based). C{False} is equivalent to 0 and\n  C{True} is equivalent to 1. Any other value means that both projections\n  will be returned in a tuple.\n@return: a tuple containing the two projected one-mode graphs if C{which}\n  is not 1 or 2, or the projected one-mode graph specified by the\n  C{which} argument if its value is 0, 1, C{False} or C{True}."}, {"type": "method", "name": "igraph.Graph.bipartite_projection_size", "documentation": "Calculates the number of vertices and edges in the bipartite\nprojections of this graph according to the specified vertex types.\nThis is useful if you have a bipartite graph and you want to estimate\nthe amount of memory you would need to calculate the projections\nthemselves.\n\n@param types: an igraph vector containing the vertex types, or an\n  attribute name. Anything that evalulates to C{False} corresponds to\n  vertices of the first kind, everything else to the second kind.\n@return: a 4-tuple containing the number of vertices and edges in the\n  first projection, followed by the number of vertices and edges in the\n  second projection."}, {"type": "method", "name": "igraph.Graph.blocks", "documentation": "Calculates the biconnected components of the graph.\n\n@param return_articulation_points: whether to return the articulation\n  points as well\n@return: a L{VertexCover} object describing the biconnected components,\n  and optionally the list of articulation points as well"}, {"type": "method", "name": "igraph.Graph.clear", "documentation": "Clears the graph, deleting all vertices, edges, and attributes.\n\n@see: L{GraphBase.delete_vertices} and L{Graph.delete_edges}."}, {"type": "method", "name": "igraph.Graph.clusters", "documentation": "Deprecated alias to L{Graph.connected_components()}."}, {"type": "method", "name": "igraph.Graph.cohesive_blocks", "documentation": "Calculates the cohesive block structure of the graph.\n\nCohesive blocking is a method of determining hierarchical subsets of graph\nvertices based on their structural cohesion (i.e. vertex connectivity).\nFor a given graph G, a subset of its vertices S is said to be maximally\nk-cohesive if there is no superset of S with vertex connectivity greater\nthan or equal to k. Cohesive blocking is a process through which, given a\nk-cohesive set of vertices, maximally l-cohesive subsets are recursively\nidentified with l > k. Thus a hierarchy of vertex subsets is obtained in\nthe end, with the entire graph G at its root.\n\n@return: an instance of L{CohesiveBlocks}. See the documentation of\n  L{CohesiveBlocks} for more information.\n@see: L{CohesiveBlocks}"}, {"type": "method", "name": "igraph.Graph.community_edge_betweenness", "documentation": "Community structure based on the betweenness of the edges in the\nnetwork.\n\nThe idea is that the betweenness of the edges connecting two\ncommunities is typically high, as many of the shortest paths between\nnodes in separate communities go through them. So we gradually remove\nthe edge with the highest betweenness and recalculate the betweennesses\nafter every removal. This way sooner or later the network falls of to\nseparate components. The result of the clustering will be represented\nby a dendrogram.\n\n@param clusters: the number of clusters we would like to see. This\n  practically defines the \"level\" where we \"cut\" the dendrogram to\n  get the membership vector of the vertices. If C{None}, the dendrogram\n  is cut at the level that maximizes the modularity when the graph is\n  unweighted; otherwise the dendrogram is cut at at a single cluster\n  (because cluster count selection based on modularities does not make\n  sense for this method if not all the weights are equal).\n@param directed: whether the directionality of the edges should be\n  taken into account or not.\n@param weights: name of an edge attribute or a list containing\n  edge weights.\n@return: a L{VertexDendrogram} object, initally cut at the maximum\n  modularity or at the desired number of clusters."}, {"type": "method", "name": "igraph.Graph.community_fastgreedy", "documentation": "Community structure based on the greedy optimization of modularity.\n\nThis algorithm merges individual nodes into communities in a way that\ngreedily maximizes the modularity score of the graph. It can be proven\nthat if no merge can increase the current modularity score, the\nalgorithm can be stopped since no further increase can be achieved.\n\nThis algorithm is said to run almost in linear time on sparse graphs.\n\nB{Reference}: A Clauset, MEJ Newman and C Moore: Finding community structure\nin very large networks. I{Phys Rev E} 70, 066111 (2004).\n\n@param weights: edge attribute name or a list containing edge\n  weights\n@return: an appropriate L{VertexDendrogram} object."}, {"type": "method", "name": "igraph.Graph.community_infomap", "documentation": "Finds the community structure of the network according to the Infomap\nmethod of Martin Rosvall and Carl T. Bergstrom.\n\nB{References}\n\n  - M. Rosvall and C. T. Bergstrom: Maps of information flow reveal\n    community structure in complex networks, I{PNAS} 105, 1118 (2008).\n    U{http://dx.doi.org/10.1073/pnas.0706851105},\n    U{http://arxiv.org/abs/0707.0609}.\n  - M. Rosvall, D. Axelsson, and C. T. Bergstrom: The map equation,\n    I{Eur Phys. J Special Topics} 178, 13 (2009).\n    U{http://dx.doi.org/10.1140/epjst/e2010-01179-1},\n    U{http://arxiv.org/abs/0906.1405}.\n\n@param edge_weights: name of an edge attribute or a list containing\n  edge weights.\n@param vertex_weights: name of a vertex attribute or a list containing\n  vertex weights.\n@param trials: the number of attempts to partition the network.\n@return: an appropriate L{VertexClustering} object with an extra attribute\n  called C{codelength} that stores the code length determined by the\n  algorithm."}, {"type": "method", "name": "igraph.Graph.community_label_propagation", "documentation": "Finds the community structure of the graph according to the label\npropagation method of Raghavan et al.\n\nInitially, each vertex is assigned a different label. After that,\neach vertex chooses the dominant label in its neighbourhood in each\niteration. Ties are broken randomly and the order in which the\nvertices are updated is randomized before every iteration. The\nalgorithm ends when vertices reach a consensus.\n\nNote that since ties are broken randomly, there is no guarantee that\nthe algorithm returns the same community structure after each run.\nIn fact, they frequently differ. See the paper of Raghavan et al.\non how to come up with an aggregated community structure.\n\nAlso note that the community _labels_ (numbers) have no semantic meaning\nand igraph is free to re-number communities. If you use fixed labels,\nigraph may still re-number the communities, but co-community membership\nconstraints will be respected: if you had two vertices with fixed labels\nthat belonged to the same community, they will still be in the same\ncommunity at the end. Similarly, if you had two vertices with fixed\nlabels that belonged to different communities, they will still be in\ndifferent communities at the end.\n\nB{Reference}: Raghavan, U.N. and Albert, R. and Kumara, S. Near linear\ntime algorithm to detect community structures in large-scale networks.\nI{Phys Rev} E 76:036106, 2007. U{http://arxiv.org/abs/0709.2938}.\n\n@param weights: name of an edge attribute or a list containing\n  edge weights\n@param initial: name of a vertex attribute or a list containing\n  the initial vertex labels. Labels are identified by integers from\n  zero to M{n-1} where M{n} is the number of vertices. Negative\n  numbers may also be present in this vector, they represent unlabeled\n  vertices.\n@param fixed: a list of booleans for each vertex. C{True} corresponds\n  to vertices whose labeling should not change during the algorithm.\n  It only makes sense if initial labels are also given. Unlabeled\n  vertices cannot be fixed. It may also be the name of a vertex\n  attribute; each attribute value will be interpreted as a Boolean.\n@return: an appropriate L{VertexClustering} object."}, {"type": "method", "name": "igraph.Graph.community_leading_eigenvector", "documentation": "Newman's leading eigenvector method for detecting community structure.\n\nThis is the proper implementation of the recursive, divisive algorithm:\neach split is done by maximizing the modularity regarding the\noriginal network.\n\nB{Reference}: MEJ Newman: Finding community structure in networks using the\neigenvectors of matrices, arXiv:physics/0605087\n\n@param clusters: the desired number of communities. If C{None}, the\n  algorithm tries to do as many splits as possible. Note that the\n  algorithm won't split a community further if the signs of the leading\n  eigenvector are all the same, so the actual number of discovered\n  communities can be less than the desired one.\n@param weights: name of an edge attribute or a list containing\n  edge weights.\n@param arpack_options: an L{ARPACKOptions} object used to fine-tune\n  the ARPACK eigenvector calculation. If omitted, the module-level\n  variable called C{arpack_options} is used.\n@return: an appropriate L{VertexClustering} object."}, {"type": "method", "name": "igraph.Graph.community_leiden", "documentation": "Finds the community structure of the graph using the Leiden\nalgorithm of Traag, van Eck & Waltman.\n\nB{Reference}: Traag, V. A., Waltman, L., & van Eck, N. J. (2019). From Louvain\nto Leiden: guaranteeing well-connected communities. I{Scientific Reports},\n9(1), 5233. doi: 10.1038/s41598-019-41695-z\n\n@param objective_function: whether to use the Constant Potts\n  Model (CPM) or modularity. Must be either C{\"CPM\"} or C{\"modularity\"}.\n@param weights: edge weights to be used. Can be a sequence or\n  iterable or even an edge attribute name.\n@param resolution: the resolution parameter to use. Higher resolutions\n  lead to more smaller communities, while lower resolutions lead to fewer\n  larger communities.\n@param beta: parameter affecting the randomness in the Leiden\n  algorithm. This affects only the refinement step of the algorithm.\n@param initial_membership: if provided, the Leiden algorithm\n  will try to improve this provided membership. If no argument is\n  provided, the aglorithm simply starts from the singleton partition.\n@param n_iterations: the number of iterations to iterate the Leiden\n  algorithm. Each iteration may improve the partition further. Using\n  a negative number of iterations will run until a stable iteration is\n  encountered (i.e. the quality was not increased during that\n  iteration).\n@param node_weights: the node weights used in the Leiden algorithm.\n  If this is not provided, it will be automatically determined on the\n  basis of whether you want to use CPM or modularity. If you do provide\n  this, please make sure that you understand what you are doing.\n@return: an appropriate L{VertexClustering} object with an extra attribute\n  called C{quality} that stores the value of the internal quality function\n  optimized by the algorithm."}, {"type": "method", "name": "igraph.Graph.community_multilevel", "documentation": "Community structure based on the multilevel algorithm of\nBlondel et al.\n\nThis is a bottom-up algorithm: initially every vertex belongs to a\nseparate community, and vertices are moved between communities\niteratively in a way that maximizes the vertices' local contribution\nto the overall modularity score. When a consensus is reached (i.e. no\nsingle move would increase the modularity score), every community in\nthe original graph is shrunk to a single vertex (while keeping the\ntotal weight of the incident edges) and the process continues on the\nnext level. The algorithm stops when it is not possible to increase\nthe modularity anymore after shrinking the communities to vertices.\n\nThis algorithm is said to run almost in linear time on sparse graphs.\n\nB{Reference}: VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast\nunfolding of community hierarchies in large networks, I{J Stat Mech}\nP10008 (2008). U{http://arxiv.org/abs/0803.0476}\n\n@param weights: edge attribute name or a list containing edge\n  weights\n@param return_levels: if C{True}, the communities at each level are\n  returned in a list. If C{False}, only the community structure with\n  the best modularity is returned.\n@param resolution: the resolution parameter to use in the modularity\n  measure. Smaller values result in a smaller number of larger clusters,\n  while higher values yield a large number of small clusters. The classical\n  modularity measure assumes a resolution parameter of 1.\n@return: a list of L{VertexClustering} objects, one corresponding to\n  each level (if C{return_levels} is C{True}), or a L{VertexClustering}\n  corresponding to the best modularity."}, {"type": "method", "name": "igraph.Graph.community_optimal_modularity", "documentation": "Calculates the optimal modularity score of the graph and the\ncorresponding community structure.\n\nThis function uses the GNU Linear Programming Kit to solve a large\ninteger optimization problem in order to find the optimal modularity\nscore and the corresponding community structure, therefore it is\nunlikely to work for graphs larger than a few (less than a hundred)\nvertices. Consider using one of the heuristic approaches instead if\nyou have such a large graph.\n\n@return: the calculated membership vector and the corresponding\n  modularity in a tuple."}, {"type": "method", "name": "igraph.Graph.community_spinglass", "documentation": "Finds the community structure of the graph according to the\nspinglass community detection method of Reichardt & Bornholdt.\n\nB{References}\n\n  - Reichardt J and Bornholdt S: Statistical mechanics of community\n    detection. I{Phys Rev E} 74:016110 (2006).\n    U{http://arxiv.org/abs/cond-mat/0603718}.\n\n  - Traag VA and Bruggeman J: Community detection in networks\n    with positive and negative links. I{Phys Rev E} 80:036115 (2009).\n    U{http://arxiv.org/abs/0811.2329}.\n\n@keyword weights: edge weights to be used. Can be a sequence or\n  iterable or even an edge attribute name.\n@keyword spins: integer, the number of spins to use. This is the\n  upper limit for the number of communities. It is not a problem\n  to supply a (reasonably) big number here, in which case some\n  spin states will be unpopulated.\n@keyword parupdate: whether to update the spins of the vertices in\n  parallel (synchronously) or not\n@keyword start_temp: the starting temperature\n@keyword stop_temp: the stop temperature\n@keyword cool_fact: cooling factor for the simulated annealing\n@keyword update_rule: specifies the null model of the simulation.\n  Possible values are C{\"config\"} (a random graph with the same\n  vertex degrees as the input graph) or C{\"simple\"} (a random\n  graph with the same number of edges)\n@keyword gamma: the gamma argument of the algorithm, specifying the\n  balance between the importance of present and missing edges\n  within a community. The default value of 1.0 assigns equal\n  importance to both of them.\n@keyword implementation: currently igraph contains two implementations\n  of the spinglass community detection algorithm. The faster\n  original implementation is the default. The other implementation\n  is able to take into account negative weights, this can be\n  chosen by setting C{implementation} to C{\"neg\"}\n@keyword lambda_: the lambda argument of the algorithm, which\n  specifies the balance between the importance of present and missing\n  negatively weighted edges within a community. Smaller values of\n  lambda lead to communities with less negative intra-connectivity.\n  If the argument is zero, the algorithm reduces to a graph coloring\n  algorithm, using the number of spins as colors. This argument is\n  ignored if the original implementation is used. Note the underscore\n  at the end of the argument name; this is due to the fact that\n  lambda is a reserved keyword in Python.\n@return: an appropriate L{VertexClustering} object."}, {"type": "method", "name": "igraph.Graph.community_walktrap", "documentation": "Community detection algorithm of Latapy & Pons, based on random\nwalks.\n\nThe basic idea of the algorithm is that short random walks tend to stay\nin the same community. The result of the clustering will be represented\nas a dendrogram.\n\nB{Reference}: Pascal Pons, Matthieu Latapy: Computing communities in large\nnetworks using random walks, U{http://arxiv.org/abs/physics/0512106}.\n\n@param weights: name of an edge attribute or a list containing\n  edge weights\n@param steps: length of random walks to perform\n\n@return: a L{VertexDendrogram} object, initially cut at the maximum\n  modularity."}, {"type": "method", "name": "igraph.Graph.components", "documentation": "Calculates the (strong or weak) connected components for\na given graph.\n\n@param mode: must be either C{\"strong\"} or C{\"weak\"}, depending on the\n  connected components being sought. Optional, defaults to C{\"strong\"}.\n@return: a L{VertexClustering} object"}, {"type": "method", "name": "igraph.Graph.connected_components", "documentation": "Calculates the (strong or weak) connected components for\na given graph.\n\n@param mode: must be either C{\"strong\"} or C{\"weak\"}, depending on the\n  connected components being sought. Optional, defaults to C{\"strong\"}.\n@return: a L{VertexClustering} object"}, {"type": "method", "name": "igraph.Graph.count_automorphisms_vf2", "documentation": "Returns the number of automorphisms of the graph.\n\nThis function simply calls C{count_isomorphisms_vf2} with the graph\nitgraph. See C{count_isomorphisms_vf2} for an explanation of the\nparameters.\n\n@return: the number of automorphisms of the graph\n@see: Graph.count_isomorphisms_vf2"}, {"type": "method", "name": "igraph.Graph.degree_distribution", "documentation": "Calculates the degree distribution of the graph.\n\nUnknown keyword arguments are directly passed to L{GraphBase.degree}.\n\n@param bin_width: the bin width of the histogram\n@return: a histogram representing the degree distribution of the\n  graph."}, {"type": "method", "name": "igraph.Graph.delete_edges", "documentation": "Deletes some edges from the graph.\n\nThe set of edges to be deleted is determined by the positional and\nkeyword arguments. If the function is called without any arguments,\nall edges are deleted. If any keyword argument is present, or the\nfirst positional argument is callable, an edge sequence is derived by\ncalling L{EdgeSeq.select} with the same positional and keyword\narguments. Edges in the derived edge sequence will be removed.\nOtherwise, the first positional argument is considered as follows:\n\nDeprecation notice: C{delete_edges(None)} has been replaced by\nC{delete_edges()} - with no arguments - since igraph 0.8.3.\n\n  - C{None} - deletes all edges (deprecated since 0.8.3)\n  - a single integer - deletes the edge with the given ID\n  - a list of integers - deletes the edges denoted by the given IDs\n  - a list of 2-tuples - deletes the edges denoted by the given\n    source-target vertex pairs. When multiple edges are present\n    between a given source-target vertex pair, only one is removed."}, {"type": "method", "name": "igraph.Graph.dfs", "documentation": "Conducts a depth first search (DFS) on the graph.\n\n@param vid: the root vertex ID\n@param mode: either C{\"in\"} or C{\"out\"} or C{\"all\"}, ignored\n  for undirected graphs.\n@return: a tuple with the following items:\n   - The vertex IDs visited (in order)\n   - The parent of every vertex in the DFS"}, {"type": "method", "name": "igraph.Graph.disjoint_union", "documentation": "Creates the disjoint union of two (or more) graphs.\n\n@param other: graph or list of graphs to be united with the current one.\n@return: the disjoint union graph"}, {"type": "method", "name": "igraph.Graph.dyad_census", "documentation": "Calculates the dyad census of the graph.\n\nDyad census means classifying each pair of vertices of a directed\ngraph into three categories: mutual (there is an edge from I{a} to\nI{b} and also from I{b} to I{a}), asymmetric (there is an edge\nfrom I{a} to I{b} or from I{b} to I{a} but not the other way round)\nand null (there is no connection between I{a} and I{b}).\n\nB{Reference}: Holland, P.W. and Leinhardt, S. A Method for Detecting\nStructure in Sociometric Data. I{American Journal of Sociology}, 70,\n492-513, 1970.\n\n@return: a L{DyadCensus} object."}, {"type": "method", "name": "igraph.Graph.from_graph_tool", "documentation": "Converts the graph from graph-tool\n\n@param g: graph-tool Graph"}, {"type": "method", "name": "igraph.Graph.from_networkx", "documentation": "Converts the graph from networkx\n\nVertex names will be stored as a vertex_attr_hashable attribute (usually\n\"_nx_name\", but see below). Because igraph stored vertices in an\nordered manner, vertices will get new IDs from 0 up. In case of\nmultigraphs, each edge will have an \"_nx_multiedge_key\" attribute, to\ndistinguish edges that connect the same two vertices.\n\n@param g: networkx Graph or DiGraph\n@param vertex_attr_hashable: attribute used to store the Python\n    hashable used by networkx to identify each vertex. The default value\n    '_nx_name' ensures lossless round trip conversions to/from networkx. An\n    alternative choice is 'name': in that case, using strings for vertex\n    names is recommended and, if the graph is re-exported to networkx,\n    Graph.to_networkx(vertex_attr_hashable=\"name\") must be used to recover\n    the correct vertex nomenclature in the exported network."}, {"type": "method", "name": "igraph.Graph.get_adjacency", "documentation": "Returns the adjacency matrix of a graph.\n\n@param type: either C{GET_ADJACENCY_LOWER} (uses the lower\n  triangle of the matrix) or C{GET_ADJACENCY_UPPER}\n  (uses the upper triangle) or C{GET_ADJACENCY_BOTH}\n  (uses both parts). Ignored for directed graphs.\n@param attribute: if C{None}, returns the ordinary adjacency\n  matrix. When the name of a valid edge attribute is given\n  here, the matrix returned will contain the default value\n  at the places where there is no edge or the value of the\n  given attribute where there is an edge. Multiple edges are\n  not supported, the value written in the matrix in this case\n  will be unpredictable. This parameter is ignored if\n  I{eids} is C{True}\n@param default: the default value written to the cells in the\n  case of adjacency matrices with attributes.\n@param eids: specifies whether the edge IDs should be returned\n  in the adjacency matrix. Since zero is a valid edge ID, the\n  cells in the matrix that correspond to unconnected vertex\n  pairs will contain -1 instead of 0 if I{eids} is C{True}.\n  If I{eids} is C{False}, the number of edges will be returned\n  in the matrix for each vertex pair.\n@return: the adjacency matrix as a L{Matrix}."}, {"type": "method", "name": "igraph.Graph.get_adjacency_sparse", "documentation": "Returns the adjacency matrix of a graph as a SciPy CSR matrix.\n\n@param attribute: if C{None}, returns the ordinary adjacency\n  matrix. When the name of a valid edge attribute is given\n  here, the matrix returned will contain the default value\n  at the places where there is no edge or the value of the\n  given attribute where there is an edge.\n@return: the adjacency matrix as a C{scipy.sparse.csr_matrix}."}, {"type": "method", "name": "igraph.Graph.get_adjlist", "documentation": "Returns the adjacency list representation of the graph.\n\nThe adjacency list representation is a list of lists. Each item of the\nouter list belongs to a single vertex of the graph. The inner list\ncontains the neighbors of the given vertex.\n\n@param mode: if C{\"out\"}, returns the successors of the vertex. If\n  C{\"in\"}, returns the predecessors of the vertex. If C{\"all\"}, both\n  the predecessors and the successors will be returned. Ignored\n  for undirected graphs."}, {"type": "method", "name": "igraph.Graph.get_all_simple_paths", "documentation": "Calculates all the simple paths from a given node to some other nodes\n(or all of them) in a graph.\n\nA path is simple if its vertices are unique, i.e. no vertex is visited\nmore than once.\n\nNote that potentially there are exponentially many paths between two\nvertices of a graph, especially if your graph is lattice-like. In this\ncase, you may run out of memory when using this function.\n\n@param v: the source for the calculated paths\n@param to: a vertex selector describing the destination for the calculated\n  paths. This can be a single vertex ID, a list of vertex IDs, a single\n  vertex name, a list of vertex names or a L{VertexSeq} object. C{None}\n  means all the vertices.\n@param cutoff: maximum length of path that is considered. If negative,\n  paths of all lengths are considered.\n@param mode: the directionality of the paths. C{\"in\"} means to calculate\n  incoming paths, C{\"out\"} means to calculate outgoing paths, C{\"all\"} means\n  to calculate both ones.\n@return: all of the simple paths from the given node to every other\n  reachable node in the graph in a list. Note that in case of mode=C{\"in\"},\n  the vertices in a path are returned in reversed order!"}, {"type": "method", "name": "igraph.Graph.get_automorphisms_vf2", "documentation": "Returns all the automorphisms of the graph\n\nThis function simply calls C{get_isomorphisms_vf2} with the graph\nitgraph. See C{get_isomorphisms_vf2} for an explanation of the\nparameters.\n\n@return: a list of lists, each item containing a possible mapping\n  of the graph vertices to itgraph according to the automorphism\n@see: Graph.get_isomorphisms_vf2"}, {"type": "method", "name": "igraph.Graph.get_biadjacency", "documentation": "Returns the bipartite adjacency matrix of a bipartite graph. The\nbipartite adjacency matrix is an M{n} times M{m} matrix, where M{n} and\nM{m} are the number of vertices in the two vertex classes.\n\n@param types: an igraph vector containing the vertex types, or an\n  attribute name. Anything that evalulates to C{False} corresponds to\n  vertices of the first kind, everything else to the second kind.\n@return: the bipartite adjacency matrix and two lists in a triplet. The\n  first list defines the mapping between row indices of the matrix and the\n  original vertex IDs. The second list is the same for the column indices."}, {"type": "method", "name": "igraph.Graph.get_edge_dataframe", "documentation": "Export edges with attributes to pandas.DataFrame\n\nIf you want to use source and target vertex IDs as index, you can do:\n\n>>> from string import ascii_letters\n>>> graph = Graph.GRG(25, 0.4)\n>>> graph.vs[\"name\"] = ascii_letters[:graph.vcount()]\n>>> df = graph.get_edge_dataframe()\n>>> df.set_index(['source', 'target'], inplace=True)\n\nThe index will be a pandas.MultiIndex. You can use the C{drop=False}\noption to keep the C{source} and C{target} columns.\n\nIf you want to use vertex names in the source and target columns:\n\n>>> df = graph.get_edge_dataframe()\n>>> df_vert = graph.get_vertex_dataframe()\n>>> df['source'].replace(df_vert['name'], inplace=True)\n>>> df['target'].replace(df_vert['name'], inplace=True)\n>>> df_vert.set_index('name', inplace=True)  # Optional\n\n@return: a pandas.DataFrame representing edges and their attributes.\n  The index uses edge IDs, from 0 to M - 1 where M is the number of\n  edges. The first two columns of the dataframe represent the IDs of\n  source and target vertices for each edge. These columns have names\n  \"source\" and \"target\". If your edges have attributes with the same\n  names, they will be present in the dataframe, but not in the first\n  two columns."}, {"type": "method", "name": "igraph.Graph.get_incidence", "documentation": "Deprecated alias to L{Graph.get_biadjacency()}."}, {"type": "method", "name": "igraph.Graph.get_inclist", "documentation": "Returns the incidence list representation of the graph.\n\nThe incidence list representation is a list of lists. Each\nitem of the outer list belongs to a single vertex of the graph.\nThe inner list contains the IDs of the incident edges of the\ngiven vertex.\n\n@param mode: if C{\"out\"}, returns the successors of the vertex. If\n  C{\"in\"}, returns the predecessors of the vertex. If C{\"all\"}, both\n  the predecessors and the successors will be returned. Ignored\n  for undirected graphs."}, {"type": "method", "name": "igraph.Graph.get_vertex_dataframe", "documentation": "Export vertices with attributes to pandas.DataFrame\n\nIf you want to use vertex names as index, you can do:\n\n>>> from string import ascii_letters\n>>> graph = Graph.GRG(25, 0.4)\n>>> graph.vs[\"name\"] = ascii_letters[:graph.vcount()]\n>>> df = graph.get_vertex_dataframe()\n>>> df.set_index('name', inplace=True)\n\n@return: a pandas.DataFrame representing vertices and their attributes.\n  The index uses vertex IDs, from 0 to N - 1 where N is the number of\n  vertices."}, {"type": "method", "name": "igraph.Graph.gomory_hu_tree", "documentation": "Calculates the Gomory-Hu tree of an undirected graph with optional\nedge capacities.\n\nThe Gomory-Hu tree is a concise representation of the value of all the\nmaximum flows (or minimum cuts) in a graph. The vertices of the tree\ncorrespond exactly to the vertices of the original graph in the same order.\nEdges of the Gomory-Hu tree are annotated by flow values.  The value of\nthe maximum flow (or minimum cut) between an arbitrary (u,v) vertex\npair in the original graph is then given by the minimum flow value (i.e.\nedge annotation) along the shortest path between u and v in the\nGomory-Hu tree.\n\n@param capacity: the edge capacities (weights). If C{None}, all\n  edges have equal weight. May also be an attribute name.\n@param flow: the name of the edge attribute in the returned graph\n  in which the flow values will be stored.\n@return: the Gomory-Hu tree as a L{Graph} object."}, {"type": "method", "name": "igraph.Graph.indegree", "documentation": "Returns the in-degrees in a list.\n\nSee L{GraphBase.degree} for possible arguments."}, {"type": "method", "name": "igraph.Graph.intersection", "documentation": "Creates the intersection of two (or more) graphs.\n\n@param other: graph or list of graphs to be intersected with\n  the current one.\n@param byname: whether to use vertex names instead of ids. See\n  L{igraph.operators.intersection} for details.\n@return: the intersection graph"}, {"type": "method", "name": "igraph.Graph.is_named", "documentation": "Returns whether the graph is named.\n\nA graph is named if and only if it has a C{\"name\"} vertex attribute."}, {"type": "method", "name": "igraph.Graph.is_weighted", "documentation": "Returns whether the graph is weighted.\n\nA graph is weighted if and only if it has a C{\"weight\"} edge attribute."}, {"type": "method", "name": "igraph.Graph.k_core", "documentation": "Returns some k-cores of the graph.\n\nThe method accepts an arbitrary number of arguments representing\nthe desired indices of the M{k}-cores to be returned. The arguments\ncan also be lists or tuples. The result is a single L{Graph} object\nif an only integer argument was given, otherwise the result is a\nlist of L{Graph} objects representing the desired k-cores in the\norder the arguments were specified. If no argument is given, returns\nall M{k}-cores in increasing order of M{k}."}, {"type": "method", "name": "igraph.Graph.layout", "documentation": "Returns the layout of the graph according to a layout algorithm.\n\nParameters and keyword arguments not specified here are passed to the\nlayout algorithm directly. See the documentation of the layout\nalgorithms for the explanation of these parameters.\n\nRegistered layout names understood by this method are:\n\n  - C{auto}, C{automatic}: automatic layout\n    (see L{Graph.layout_auto})\n\n  - C{bipartite}: bipartite layout (see L{GraphBase.layout_bipartite})\n\n  - C{circle}, C{circular}: circular layout\n    (see L{GraphBase.layout_circle})\n\n  - C{dh}, C{davidson_harel}: Davidson-Harel layout (see\n    L{GraphBase.layout_davidson_harel})\n\n  - C{drl}: DrL layout for large graphs (see L{GraphBase.layout_drl})\n\n  - C{drl_3d}: 3D DrL layout for large graphs\n    (see L{GraphBase.layout_drl})\n\n  - C{fr}, C{fruchterman_reingold}: Fruchterman-Reingold layout\n    (see L{GraphBase.layout_fruchterman_reingold}).\n\n  - C{fr_3d}, C{fr3d}, C{fruchterman_reingold_3d}: 3D Fruchterman-\n    Reingold layout (see L{GraphBase.layout_fruchterman_reingold}).\n\n  - C{grid}: regular grid layout in 2D (see L{GraphBase.layout_grid})\n\n  - C{grid_3d}: regular grid layout in 3D (see L{GraphBase.layout_grid})\n\n  - C{graphopt}: the graphopt algorithm (see L{GraphBase.layout_graphopt})\n\n  - C{kk}, C{kamada_kawai}: Kamada-Kawai layout\n    (see L{GraphBase.layout_kamada_kawai})\n\n  - C{kk_3d}, C{kk3d}, C{kamada_kawai_3d}: 3D Kamada-Kawai layout\n    (see L{GraphBase.layout_kamada_kawai})\n\n  - C{lgl}, C{large}, C{large_graph}: Large Graph Layout\n    (see L{GraphBase.layout_lgl})\n\n  - C{mds}: multidimensional scaling layout (see L{GraphBase.layout_mds})\n\n  - C{random}: random layout (see L{GraphBase.layout_random})\n\n  - C{random_3d}: random 3D layout (see L{GraphBase.layout_random})\n\n  - C{rt}, C{tree}, C{reingold_tilford}: Reingold-Tilford tree\n    layout (see L{GraphBase.layout_reingold_tilford})\n\n  - C{rt_circular}, C{reingold_tilford_circular}: circular\n    Reingold-Tilford tree layout\n    (see L{GraphBase.layout_reingold_tilford_circular})\n\n  - C{sphere}, C{spherical}, C{circle_3d}, C{circular_3d}: spherical\n    layout (see L{GraphBase.layout_circle})\n\n  - C{star}: star layout (see L{GraphBase.layout_star})\n\n  - C{sugiyama}: Sugiyama layout (see L{Graph.layout_sugiyama})\n\n@param layout: the layout to use. This can be one of the registered\n  layout names or a callable which returns either a L{Layout} object or\n  a list of lists containing the coordinates. If C{None}, uses the\n  value of the C{plotting.layout} configuration key.\n@return: a L{Layout} object."}, {"type": "method", "name": "igraph.Graph.layout_auto", "documentation": "Chooses and runs a suitable layout function based on simple\ntopological properties of the graph.\n\nThis function tries to choose an appropriate layout function for\nthe graph using the following rules:\n\n  1. If the graph has an attribute called C{layout}, it will be\n     used. It may either be a L{Layout} instance, a list of\n     coordinate pairs, the name of a layout function, or a\n     callable function which generates the layout when called\n     with the graph as a parameter.\n\n  2. Otherwise, if the graph has vertex attributes called C{x}\n     and C{y}, these will be used as coordinates in the layout.\n     When a 3D layout is requested (by setting C{dim} to 3),\n     a vertex attribute named C{z} will also be needed.\n\n  3. Otherwise, if the graph is connected and has at most 100\n     vertices, the Kamada-Kawai layout will be used (see\n     L{GraphBase.layout_kamada_kawai()}).\n\n  4. Otherwise, if the graph has at most 1000 vertices, the\n     Fruchterman-Reingold layout will be used (see\n     L{GraphBase.layout_fruchterman_reingold()}).\n\n  5. If everything else above failed, the DrL layout algorithm\n     will be used (see L{GraphBase.layout_drl()}).\n\nAll the arguments of this function except C{dim} are passed on\nto the chosen layout function (in case we have to call some layout\nfunction).\n\n@keyword dim: specifies whether we would like to obtain a 2D or a\n  3D layout.\n@return: a L{Layout} object."}, {"type": "method", "name": "igraph.Graph.layout_bipartite", "documentation": "Place the vertices of a bipartite graph in two layers.\n\nThe layout is created by placing the vertices in two rows, according\nto their types. The positions of the vertices within the rows are\nthen optimized to minimize the number of edge crossings using the\nheuristic used by the Sugiyama layout algorithm.\n\n@param types: an igraph vector containing the vertex types, or an\n  attribute name. Anything that evalulates to C{False} corresponds to\n  vertices of the first kind, everything else to the second kind.\n@param hgap: minimum horizontal gap between vertices in the same layer.\n@param vgap: vertical gap between the two layers.\n@param maxiter: maximum number of iterations to take in the crossing\n  reduction step. Increase this if you feel that you are getting too many\n  edge crossings.\n@return: the calculated layout."}, {"type": "method", "name": "igraph.Graph.layout_circle", "documentation": "Places the vertices of the graph uniformly on a circle or a sphere.\n\n@param dim: the desired number of dimensions for the layout. dim=2\n  means a 2D layout, dim=3 means a 3D layout.\n@param order: the order in which the vertices are placed along the\n  circle. Not supported when I{dim} is not equal to 2.\n@return: the calculated layout."}, {"type": "method", "name": "igraph.Graph.layout_davidson_harel", "documentation": "Places the vertices on a 2D plane according to the Davidson-Harel layout\nalgorithm.\n\nThe algorithm uses simulated annealing and a sophisticated energy function,\nwhich is unfortunately hard to parameterize for different graphs. The\noriginal publication did not disclose any parameter values, and the ones\nbelow were determined by experimentation.\n\nThe algorithm consists of two phases: an annealing phase and a fine-tuning\nphase. There is no simulated annealing in the second phase.\n\n@param seed: if C{None}, uses a random starting layout for the algorithm.\n  If a matrix (list of lists), uses the given matrix as the starting\n  position.\n@param maxiter: Number of iterations to perform in the annealing phase.\n@param fineiter: Number of iterations to perform in the fine-tuning phase.\n  Negative numbers set up a reasonable default from the base-2 logarithm\n  of the vertex count, bounded by 10 from above.\n@param cool_fact: Cooling factor of the simulated annealing phase.\n@param weight_node_dist: Weight for the node-node distances in the energy\n  function.\n@param weight_border: Weight for the distance from the border component of\n  the energy function. Zero means that vertices are allowed to sit on the\n  border of the area designated for the layout.\n@param weight_edge_lengths: Weight for the edge length component of the\n  energy function. Negative numbers are replaced by the density of the\n  graph divided by 10.\n@param weight_edge_crossings: Weight for the edge crossing component of the\n  energy function. Negative numbers are replaced by one minus the square\n  root of the density of the graph.\n@param weight_node_edge_dist: Weight for the node-edge distance component\n  of the energy function. Negative numbers are replaced by 0.2 minus\n  0.2 times the density of the graph.\n@return: the calculated layout."}, {"type": "method", "name": "igraph.Graph.layout_drl", "documentation": "Places the vertices on a 2D plane or in the 3D space ccording to the DrL\nlayout algorithm.\n\nThis is an algorithm suitable for quite large graphs, but it can be\nsurprisingly slow for small ones (where the simpler force-based layouts\nlike C{layout_kamada_kawai()} or C{layout_fruchterman_reingold()} are\nmore useful.\n\n@param weights: edge weights to be used. Can be a sequence or iterable or\n  even an edge attribute name.\n@param seed: if C{None}, uses a random starting layout for the\n  algorithm. If a matrix (list of lists), uses the given matrix\n  as the starting position.\n@param fixed: ignored. We used to assume that the DrL layout supports\n  fixed nodes, but later it turned out that the argument has no effect\n  in the original DrL code. We kept the argument for sake of backwards\n  compatibility, but it will have no effect on the final layout.\n@param options: if you give a string argument here, you can select from\n  five default preset parameterisations: C{default}, C{coarsen} for a\n  coarser layout, C{coarsest} for an even coarser layout, C{refine} for\n  refining an existing layout and C{final} for finalizing a layout. If\n  you supply an object that is not a string, the DrL layout parameters\n  are retrieved from the respective keys of the object (so it should\n  be a dict or something else that supports the mapping protocol).\n  The following keys can be used:\n  \n    - C{edge_cut}: edge cutting is done in the late stages of the\n      algorithm in order to achieve less dense layouts. Edges are\n      cut if there is a lot of stress on them (a large value in the\n      objective function sum). The edge cutting parameter is a value\n      between 0 and 1 with 0 representing no edge cutting and 1\n      representing maximal edge cutting.\n\n    - C{init_iterations}: number of iterations in the initialization\n      phase\n\n    - C{init_temperature}: start temperature during initialization\n\n    - C{init_attraction}: attraction during initialization\n\n    - C{init_damping_mult}: damping multiplier during initialization\n\n    - C{liquid_iterations}, C{liquid_temperature}, C{liquid_attraction},\n      C{liquid_damping_mult}: same parameters for the liquid phase\n\n    - C{expansion_iterations}, C{expansion_temperature},\n      C{expansion_attraction}, C{expansion_damping_mult}:\n      parameters for the expansion phase\n\n    - C{cooldown_...}: parameters for the cooldown phase\n\n    - C{crunch_...}: parameters for the crunch phase\n\n    - C{simmer_...}: parameters for the simmer phase\n\n  \n  Instead of a mapping, you can also use an arbitrary Python object\n  here: if the object does not support the mapping protocol, an\n  attribute of the object with the same name is looked up instead. If\n  a parameter cannot be found either as a key or an attribute, the\n  default from the C{default} preset will be used.\n\n@param dim: the desired number of dimensions for the layout. dim=2\n  means a 2D layout, dim=3 means a 3D layout.\n@return: the calculated layout."}, {"type": "method", "name": "igraph.Graph.layout_fruchterman_reingold", "documentation": "Places the vertices on a 2D plane according to the\nFruchterman-Reingold algorithm.\n\nThis is a force directed layout, see Fruchterman, T. M. J. and Reingold, E. M.:\nGraph Drawing by Force-directed Placement.\nSoftware -- Practice and Experience, 21/11, 1129--1164, 1991\n\n@param weights: edge weights to be used. Can be a sequence or iterable or\n  even an edge attribute name.\n@param niter: the number of iterations to perform. The default\n  is 500.\n@param start_temp: Real scalar, the start temperature. This is the \n  maximum amount of movement alloved along one axis, within one step,\n  for a vertex. Currently it is decreased linearly to zero during\n  the iteration. The default is the square root of the number of \n  vertices divided by 10.\n@param minx: if not C{None}, it must be a vector with exactly as many\n  elements as there are vertices in the graph. Each element is a\n  minimum constraint on the X value of the vertex in the layout.\n@param maxx: similar to I{minx}, but with maximum constraints\n@param miny: similar to I{minx}, but with the Y coordinates\n@param maxy: similar to I{maxx}, but with the Y coordinates\n@param minz: similar to I{minx}, but with the Z coordinates. Use only\n  for 3D layouts (C{dim}=3).\n@param maxz: similar to I{maxx}, but with the Z coordinates. Use only\n  for 3D layouts (C{dim}=3).\n@param seed: if C{None}, uses a random starting layout for the\n  algorithm. If a matrix (list of lists), uses the given matrix\n  as the starting position.\n@param grid: whether to use a faster, but less accurate grid-based\n  implementation of the algorithm. C{\"auto\"} decides based on the number\n  of vertices in the graph; a grid will be used if there are at least 1000\n  vertices. C{\"grid\"} is equivalent to C{True}, C{\"nogrid\"} is equivalent\n  to C{False}.\n@return: the calculated layout."}, {"type": "method", "name": "igraph.Graph.layout_fruchterman_reingold_3d", "documentation": "Alias for L{layout_fruchterman_reingold()} with dim=3.\n\n@see: Graph.layout_fruchterman_reingold()"}, {"type": "method", "name": "igraph.Graph.layout_graphopt", "documentation": "This is a port of the graphopt layout algorithm by Michael Schmuhl.\ngraphopt version 0.4.1 was rewritten in C and the support for layers\nwas removed.\n\ngraphopt uses physical analogies for defining attracting and repelling\nforces among the vertices and then the physical system is simulated\nuntil it reaches an equilibrium or the maximal number of iterations is\nreached.\n\nSee U{http://www.schmuhl.org/graphopt/} for the original graphopt.\n\n@param niter: the number of iterations to perform. Should be a couple\n  of hundred in general.\n\n@param node_charge: the charge of the vertices, used to calculate electric\n  repulsion.\n@param node_mass: the mass of the vertices, used for the spring forces\n@param spring_length: the length of the springs\n@param spring_constant: the spring constant\n@param max_sa_movement: the maximum amount of movement allowed in a single\n  step along a single axis.\n@param seed: a matrix containing a seed layout from which the algorithm\n  will be started. If C{None}, a random layout will be used.\n@return: the calculated layout."}, {"type": "method", "name": "igraph.Graph.layout_grid", "documentation": "Places the vertices of a graph in a 2D or 3D grid.\n\n@param width: the number of vertices in a single row of the layout.\n  Zero or negative numbers mean that the width should be determined\n  automatically.\n@param height: the number of vertices in a single column of the layout.\n  Zero or negative numbers mean that the height should be determined\n  automatically. It must not be given if the number of dimensions is 2.\n@param dim: the desired number of dimensions for the layout. dim=2\n  means a 2D layout, dim=3 means a 3D layout.\n@return: the calculated layout."}, {"type": "method", "name": "igraph.Graph.layout_grid_3d", "documentation": "Alias for L{layout_grid()} with dim=3.\n\n@see: Graph.layout_grid()"}, {"type": "method", "name": "igraph.Graph.layout_kamada_kawai", "documentation": "Places the vertices on a plane according to the Kamada-Kawai algorithm.\n\nThis is a force directed layout, see Kamada, T. and Kawai, S.:\nAn Algorithm for Drawing General Undirected Graphs.\nInformation Processing Letters, 31/1, 7--15, 1989.\n\n@param maxiter: the maximum number of iterations to perform. C{None} selects\n  a reasonable default based on the number of vertices.\n@param seed: when C{None}, uses a circular layout as a starting point for the\n  algorithm when no bounds are given, or a random layout when bounds are\n  specified for the coordinated. When the argument is a matrix (list of\n  lists), it uses the given matrix as the initial layout.\n@param epsilon: quit if the energy of the system changes less than\n  epsilon. See the original paper for details.\n@param kkconst: the Kamada-Kawai vertex attraction constant.\n  C{None} means the number of vertices.\n@param minx: if not C{None}, it must be a vector with exactly as many\n  elements as there are vertices in the graph. Each element is a\n  minimum constraint on the X value of the vertex in the layout.\n@param maxx: similar to I{minx}, but with maximum constraints\n@param miny: similar to I{minx}, but with the Y coordinates\n@param maxy: similar to I{maxx}, but with the Y coordinates\n@param minz: similar to I{minx}, but with the Z coordinates. Use only\n  for 3D layouts (C{dim}=3).\n@param maxz: similar to I{maxx}, but with the Z coordinates. Use only\n  for 3D layouts (C{dim}=3).\n@param dim: the desired number of dimensions for the layout. dim=2\n  means a 2D layout, dim=3 means a 3D layout.\n@param weights: edge weights to be used. Can be a sequence or iterable or\n  even an edge attribute name.\n@return: the calculated layout."}, {"type": "method", "name": "igraph.Graph.layout_kamada_kawai_3d", "documentation": "Alias for L{layout_kamada_kawai()} with dim=3.\n\n@see: Graph.layout_kamada_kawai()"}, {"type": "method", "name": "igraph.Graph.layout_lgl", "documentation": "Places the vertices on a 2D plane according to the Large Graph Layout.\n\n@param maxiter: the number of iterations to perform.\n@param maxdelta: the maximum distance to move a vertex in\n  an iteration. If negative, defaults to the number of vertices.\n@param area: the area of the square on which the vertices\n  will be placed. If negative, defaults to the number of vertices\n  squared.\n@param coolexp: the cooling exponent of the simulated annealing.\n@param repulserad: determines the radius at which vertex-vertex\n  repulsion cancels out attraction of adjacent vertices.\n  If negative, defaults to M{area} times the number of vertices.\n@param cellsize: the size of the grid cells. When calculating the\n  repulsion forces, only vertices in the same or neighboring\n  grid cells are taken into account. Defaults to the fourth\n  root of M{area}.\n@param root: the root vertex, this is placed first, its neighbors\n  in the first iteration, second neighbors in the second,\n  etc. C{None} means that a random vertex will be chosen.\n@return: the calculated layout."}, {"type": "method", "name": "igraph.Graph.layout_mds", "documentation": "Places the vertices in an Euclidean space with the given number of\ndimensions using multidimensional scaling.\n\nThis layout requires a distance matrix, where the intersection of\nrow M{i} and column M{j} specifies the desired distance between\nvertex M{i} and vertex M{j}. The algorithm will try to place the\nvertices in a way that approximates the distance relations\nprescribed in the distance matrix. igraph uses the classical\nmultidimensional scaling by Torgerson (see reference below).\n\nFor unconnected graphs, the method will decompose the graph into\nweakly connected components and then lay out the components\nindividually using the appropriate parts of the distance matrix.\n\nB{Reference}: Cox & Cox: Multidimensional Scaling (1994), Chapman and\nHall, London.\n\n@param dist: the distance matrix. It must be symmetric and the\n  symmetry is not checked -- results are unspecified when a\n  non-symmetric distance matrix is used. If this parameter is\n  C{None}, the shortest path lengths will be used as distances.\n  Directed graphs are treated as undirected when calculating\n  the shortest path lengths to ensure symmetry.\n@param dim: the number of dimensions. For 2D layouts, supply\n  2 here; for 3D layouts, supply 3.\n@param arpack_options: an L{ARPACKOptions} object used to fine-tune\n  the ARPACK eigenvector calculation. If omitted, the module-level\n  variable called C{arpack_options} is used.\n@return: the calculated layout."}, {"type": "method", "name": "igraph.Graph.layout_random", "documentation": "Places the vertices of the graph randomly.\n\n@param dim: the desired number of dimensions for the layout. dim=2\n  means a 2D layout, dim=3 means a 3D layout.\n@return: the coordinate pairs in a list."}, {"type": "method", "name": "igraph.Graph.layout_random_3d", "documentation": "Alias for L{layout_random()} with dim=3.\n\n@see: Graph.layout_random()"}, {"type": "method", "name": "igraph.Graph.layout_reingold_tilford", "documentation": "Places the vertices on a 2D plane according to the Reingold-Tilford\nlayout algorithm.\n\nThis is a tree layout. If the given graph is not a tree, a breadth-first\nsearch is executed first to obtain a possible spanning tree.\n\nB{Reference}: EM Reingold, JS Tilford: Tidier Drawings of Trees. I{IEEE\nTransactions on Software Engineering} 7:22, 223-228, 1981.\n\n@param mode: specifies which edges to consider when builing the tree.\n  If it is C{OUT} then only the outgoing, if it is C{IN} then only the\n  incoming edges of a parent are considered. If it is C{ALL} then all\n  edges are used (this was the behaviour in igraph 0.5 and before).\n  This parameter also influences how the root vertices are calculated\n  if they are not given. See the I{root} parameter.\n@param root: the index of the root vertex or root vertices.\n  If this is a non-empty vector then the supplied vertex IDs are\n  used as the roots of the trees (or a single tree if the graph is\n  connected). If this is C{None} or an empty list, the root vertices\n  are automatically calculated in such a way so that all other vertices\n  would be reachable from them. Currently, automatic root selection\n  prefers low eccentricity vertices in small graphs (fewer than 500\n  vertices) and high degree vertices in large graphs. This heuristic\n  may change in future versions. Specify roots manually for a consistent\n  output.\n@param rootlevel: this argument is useful when drawing forests which are\n  not trees. It specifies the level of the root vertices for every tree\n  in the forest.\n@return: the calculated layout.\n\n@see: layout_reingold_tilford_circular"}, {"type": "method", "name": "igraph.Graph.layout_reingold_tilford_circular", "documentation": "Circular Reingold-Tilford layout for trees.\n\nThis layout is similar to the Reingold-Tilford layout, but the vertices\nare placed in a circular way, with the root vertex in the center.\n\nSee L{layout_reingold_tilford} for the explanation of the parameters.\n\nB{Reference}: EM Reingold, JS Tilford: Tidier Drawings of Trees. I{IEEE\nTransactions on Software Engineering} 7:22, 223-228, 1981.\n\n@return: the calculated layout.\n\n@see: layout_reingold_tilford"}, {"type": "method", "name": "igraph.Graph.layout_sphere", "documentation": "Alias for L{layout_circle()} with dim=3.\n\n@see: Graph.layout_circle()"}, {"type": "method", "name": "igraph.Graph.layout_star", "documentation": "Calculates a star-like layout for the graph.\n\n@param center: the ID of the vertex to put in the center\n@param order: a numeric vector giving the order of the vertices\n  (including the center vertex!). If it is C{None}, the vertices\n  will be placed in increasing vertex ID order.\n@return: the calculated layout."}, {"type": "method", "name": "igraph.Graph.layout_sugiyama", "documentation": "Places the vertices using a layered Sugiyama layout.\n\nThis is a layered layout that is most suitable for directed acyclic graphs,\nalthough it works on undirected or cyclic graphs as well.\n\nEach vertex is assigned to a layer and each layer is placed on a horizontal\nline. Vertices within the same layer are then permuted using the barycenter\nheuristic that tries to minimize edge crossings.\n\nDummy vertices will be added on edges that span more than one layer. The\nreturned layout therefore contains more rows than the number of nodes in\nthe original graph; the extra rows correspond to the dummy vertices.\n\nB{References}:\n\n  - K Sugiyama, S Tagawa, M Toda: Methods for visual understanding of\n    hierarchical system structures. I{IEEE Systems, Man and Cybernetics}\n    11(2):109-125, 1981.\n\n  - P Eades, X Lin and WF Smyth: A fast effective heuristic for the\n    feedback arc set problem. I{Information Processing Letters} 47:319-323, 1993.\n\n@param layers: a vector specifying a non-negative integer layer index for\n  each vertex, or the name of a numeric vertex attribute that contains\n  the layer indices. If C{None}, a layering will be determined\n  automatically. For undirected graphs, a spanning tree will be extracted\n  and vertices will be assigned to layers using a breadth first search from\n  the node with the largest degree. For directed graphs, cycles are broken\n  by reversing the direction of edges in an approximate feedback arc set\n  using the heuristic of Eades, Lin and Smyth, and then using longest path\n  layering to place the vertices in layers.\n@param weights: edge weights to be used. Can be a sequence or iterable or\n  even an edge attribute name.\n@param hgap: minimum horizontal gap between vertices in the same layer.\n@param vgap: vertical gap between layers. The layer index will be\n  multiplied by I{vgap} to obtain the Y coordinate.\n@param maxiter: maximum number of iterations to take in the crossing\n  reduction step. Increase this if you feel that you are getting too many\n  edge crossings.\n@param return_extended_graph: specifies that the extended graph with the\n  added dummy vertices should also be returned. When this is C{True}, the\n  result will be a tuple containing the layout and the extended graph. The\n  first |V| nodes of the extended graph will correspond to the nodes of the\n  original graph, the remaining ones are dummy nodes. Plotting the extended\n  graph with the returned layout and hidden dummy nodes will produce a layout\n  that is similar to the original graph, but with the added edge bends.\n  The extended graph also contains an edge attribute called C{_original_eid}\n  which specifies the ID of the edge in the original graph from which the\n  edge of the extended graph was created.\n@return: the calculated layout, which may (and usually will) have more rows\n  than the number of vertices; the remaining rows correspond to the dummy\n  nodes introduced in the layering step. When C{return_extended_graph} is\n  C{True}, it will also contain the extended graph."}, {"type": "method", "name": "igraph.Graph.layout_umap", "documentation": "Uniform Manifold Approximation and Projection (UMAP).\n\nThis layout is a probabilistic algorithm that places vertices that are connected\nand have a short distance close by in the embedded space.\n\nB{Reference}: L McInnes, J Healy, J Melville: UMAP: Uniform Manifold Approximation\nand Projection for Dimension Reduction. arXiv:1802.03426.\n\n@param dist: distances associated with the graph edges. If None, all edges will\n  be assumed to convey the same distance between the vertices. Either this\n  argument of the C{weights} argument can be set, but not both. It is fine to\n  set neither.\n@param weights: precomputed edge weights if you have them, as an alternative\n  to setting the C{dist} argument. Zero weights will be ignored if this\n  argument is set, e.g. if you computed the weights via\n  igraph.umap_compute_weights().\n@param dim: the desired number of dimensions for the layout. dim=2\n  means a 2D layout, dim=3 means a 3D layout.\n@param seed: if C{None}, uses a random starting layout for the\n  algorithm. If a matrix (list of lists), uses the given matrix\n  as the starting position.\n@param min_dist: the minimal distance in the embedded space beyond which the\n  probability of being located closeby decreases.\n@param epochs: the number of epochs (iterations) the algorithm will iterate\n  over. Accuracy increases with more epochs, at the cost of longer runtimes.\n  Values between 50 and 1000 are typical.\n  Notice that UMAP does not technically converge for symmetry reasons, but a\n  larger number of epochs should generally give an equivalent or better layout.\n@return: the calculated layout.\n\nPlease note that if distances are set, the graph is usually directed, whereas\nif weights are precomputed, the graph will be treated as undirected. A special\ncase is when the graph is directed but the precomputed weights are symmetrized\nin a way only one of each pair of opposite edges has nonzero weight, e.g. as\ncomputed by igraph.umap_compute_weights(). For example:\nC{weights = igraph.umap_compute_weights(graph, dist)}\nC{layout = graph.layout_umap(weights=weights)}\n\n@see: igraph.umap_compute_weights()"}, {"type": "method", "name": "igraph.Graph.maxflow", "documentation": "Returns a maximum flow between the given source and target vertices\nin a graph.\n\nA maximum flow from I{source} to I{target} is an assignment of\nnon-negative real numbers to the edges of the graph, satisfying\ntwo properties:\n\n    1. For each edge, the flow (i.e. the assigned number) is not\n       more than the capacity of the edge (see the I{capacity}\n       argument)\n\n    2. For every vertex except the source and the target, the\n       incoming flow is the same as the outgoing flow.\n\nThe value of the flow is the incoming flow of the target or the\noutgoing flow of the source (which are equal). The maximum flow\nis the maximum possible such value.\n\n@param capacity: the edge capacities (weights). If C{None}, all\n  edges have equal weight. May also be an attribute name.\n@return: a L{Flow} object describing the maximum flow"}, {"type": "method", "name": "igraph.Graph.maximum_bipartite_matching", "documentation": "Finds a maximum matching in a bipartite graph.\n\nA maximum matching is a set of edges such that each vertex is incident on\nat most one matched edge and the number (or weight) of such edges in the\nset is as large as possible.\n\n@param types: vertex types in a list or the name of a vertex attribute\n  holding vertex types. Types should be denoted by zeros and ones (or\n  C{False} and C{True}) for the two sides of the bipartite graph.\n  If omitted, it defaults to C{type}, which is the default vertex type\n  attribute for bipartite graphs.\n@param weights: edge weights to be used. Can be a sequence or iterable or\n  even an edge attribute name.\n@param eps: a small real number used in equality tests in the weighted\n  bipartite matching algorithm. Two real numbers are considered equal in\n  the algorithm if their difference is smaller than this value. This\n  is required to avoid the accumulation of numerical errors. If you\n  pass C{None} here, igraph will try to determine an appropriate value\n  automatically.\n@return: an instance of L{Matching}."}, {"type": "method", "name": "igraph.Graph.mincut", "documentation": "Calculates the minimum cut between the given source and target vertices\nor within the whole graph.\n\nThe minimum cut is the minimum set of edges that needs to be removed to\nseparate the source and the target (if they are given) or to disconnect the\ngraph (if neither the source nor the target are given). The minimum is\ncalculated using the weights (capacities) of the edges, so the cut with\nthe minimum total capacity is calculated.\n\nFor undirected graphs and no source and target, the method uses the\nStoer-Wagner algorithm. For a given source and target, the method uses the\npush-relabel algorithm; see the references below.\n\n@param source: the source vertex ID. If C{None}, the target must also be\n  C{None} and the calculation will be done for the entire graph (i.e.\n  all possible vertex pairs).\n@param target: the target vertex ID. If C{None}, the source must also be\n  C{None} and the calculation will be done for the entire graph (i.e.\n  all possible vertex pairs).\n@param capacity: the edge capacities (weights). If C{None}, all\n  edges have equal weight. May also be an attribute name.\n@return: a L{Cut} object describing the minimum cut"}, {"type": "method", "name": "igraph.Graph.modularity", "documentation": "Calculates the modularity score of the graph with respect to a given\nclustering.\n\nThe modularity of a graph w.r.t. some division measures how good the\ndivision is, or how separated are the different vertex types from each\nother. It's defined as M{Q=1/(2m)*sum(Aij-gamma*ki*kj/(2m)delta(ci,cj),i,j)}.\nM{m} is the number of edges, M{Aij} is the element of the M{A}\nadjacency matrix in row M{i} and column M{j}, M{ki} is the degree of\nnode M{i}, M{kj} is the degree of node M{j}, and M{Ci} and C{cj} are\nthe types of the two vertices (M{i} and M{j}), and M{gamma} is a resolution\nparameter that defaults to 1 for the classical definition of modularity.\nM{delta(x,y)} is one iff M{x=y}, 0 otherwise.\n\nIf edge weights are given, the definition of modularity is modified as\nfollows: M{Aij} becomes the weight of the corresponding edge, M{ki}\nis the total weight of edges adjacent to vertex M{i}, M{kj} is the\ntotal weight of edges adjacent to vertex M{j} and M{m} is the total\nedge weight in the graph.\n\nB{Reference}: MEJ Newman and M Girvan: Finding and evaluating community\nstructure in networks. I{Phys Rev E} 69 026113, 2004.\n\n@param membership: a membership list or a L{VertexClustering} object\n@param weights: optional edge weights or C{None} if all edges are\n  weighed equally. Attribute names are also allowed.\n@param resolution: the resolution parameter I{gamma} in the formula above.\n  The classical definition of modularity is retrieved when the resolution\n  parameter is set to 1.\n@param directed: whether to consider edge directions if the graph is directed.\n  C{True} will use the directed variant of the modularity measure where the\n  in- and out-degrees of nodes are treated separately; C{False} will treat\n  directed graphs as undirected.\n@return: the modularity score"}, {"type": "method", "name": "igraph.Graph.outdegree", "documentation": "Returns the out-degrees in a list.\n\nSee L{GraphBase.degree} for possible arguments."}, {"type": "method", "name": "igraph.Graph.pagerank", "documentation": "Calculates the PageRank values of a graph.\n\n@param vertices: the indices of the vertices being queried.\n  C{None} means all of the vertices.\n@param directed: whether to consider directed paths.\n@param damping: the damping factor. M{1-damping} is the probability of\n  resetting the random walk to a uniform distribution in each step.\n@param weights: edge weights to be used. Can be a sequence or iterable\n  or even an edge attribute name.\n@param arpack_options: an L{ARPACKOptions} object used to fine-tune\n  the ARPACK eigenvector calculation. If omitted, the module-level\n  variable called C{arpack_options} is used. This argument is\n  ignored if not the ARPACK implementation is used, see the\n  I{implementation} argument.\n@param implementation: which implementation to use to solve the\n  PageRank eigenproblem. Possible values are:\n    - C{\"prpack\"}: use the PRPACK library. This is a new\n      implementation in igraph 0.7\n    - C{\"arpack\"}: use the ARPACK library. This implementation\n      was used from version 0.5, until version 0.7.\n@return: a list with the PageRank values of the specified vertices."}, {"type": "method", "name": "igraph.Graph.path_length_hist", "documentation": "Returns the path length histogram of the graph\n\n@param directed: whether to consider directed paths. Ignored for\n  undirected graphs.\n@return: a L{Histogram} object. The object will also have an\n  C{unconnected} attribute that stores the number of unconnected\n  vertex pairs (where the second vertex can not be reached from\n  the first one). The latter one will be of type long (and not\n  a simple integer), since this can be I{very} large."}, {"type": "method", "name": "igraph.Graph.save", "documentation": "Unified writing function for graphs.\n\nThis method tries to identify the format of the graph given in\nthe first parameter (based on extension) and calls the corresponding\nwriter method.\n\nThe remaining arguments are passed to the writer method without\nany changes.\n\n@param f: the file containing the graph to be saved\n@param format: the format of the file (if one wants to override the\n  format determined from the filename extension, or the filename itself\n  is a stream). C{None} means auto-detection. Possible values are:\n\n    - C{\"adjacency\"}: adjacency matrix format\n\n    - C{\"dimacs\"}: DIMACS format\n\n    - C{\"dot\"}, C{\"graphviz\"}: GraphViz DOT format\n\n    - C{\"edgelist\"}, C{\"edges\"} or C{\"edge\"}: numeric edge list format\n\n    - C{\"gml\"}: GML format\n\n    - C{\"graphml\"} and C{\"graphmlz\"}: standard and gzipped GraphML\n      format\n\n    - C{\"gw\"}, C{\"leda\"}, C{\"lgr\"}: LEDA native format\n\n    - C{\"lgl\"}: LGL format\n\n    - C{\"ncol\"}: NCOL format\n\n    - C{\"net\"}, C{\"pajek\"}: Pajek format\n\n    - C{\"pickle\"}, C{\"picklez\"}: standard and gzipped Python pickled\n      format\n\n    - C{\"svg\"}: SVG format\n\n@raises IOError: if the file format can't be identified and\n  none was given."}, {"type": "method", "name": "igraph.Graph.shortest_paths", "documentation": "Deprecated alias to L{Graph.distances()}."}, {"type": "method", "name": "igraph.Graph.shortest_paths_dijkstra", "documentation": "Deprecated alias to L{Graph.distances()}."}, {"type": "method", "name": "igraph.Graph.spanning_tree", "documentation": "Calculates a minimum spanning tree for a graph.\n\nB{Reference}: Prim, R.C. Shortest connection networks and some\ngeneralizations. I{Bell System Technical Journal} 36:1389-1401, 1957.\n\n@param weights: a vector containing weights for every edge in\n  the graph. C{None} means that the graph is unweighted.\n@param return_tree: whether to return the minimum spanning tree (when\n  C{return_tree} is C{True}) or to return the IDs of the edges in\n  the minimum spanning tree instead (when C{return_tree} is C{False}).\n  The default is C{True} for historical reasons as this argument was\n  introduced in igraph 0.6.\n@return: the spanning tree as a L{Graph} object if C{return_tree}\n  is C{True} or the IDs of the edges that constitute the spanning\n  tree if C{return_tree} is C{False}."}, {"type": "method", "name": "igraph.Graph.st_mincut", "documentation": "Calculates the minimum cut between the source and target vertices in a\ngraph.\n\n@param source: the source vertex ID\n@param target: the target vertex ID\n@param capacity: the capacity of the edges. It must be a list or a valid\n  attribute name or C{None}. In the latter case, every edge will have the\n  same capacity.\n@return: the value of the minimum cut, the IDs of vertices in the\n  first and second partition, and the IDs of edges in the cut,\n  packed in a 4-tuple"}, {"type": "method", "name": "igraph.Graph.summary", "documentation": "Returns the summary of the graph.\n\nThe output of this method is similar to the output of the\nC{__str__} method. If I{verbosity} is zero, only the header line\nis returned (see C{__str__} for more details), otherwise the\nheader line and the edge list is printed.\n\nBehind the scenes, this method constructs a L{GraphSummary}\nobject and invokes its C{__str__} method.\n\n@param verbosity: if zero, only the header line is returned\n  (see C{__str__} for more details), otherwise the header line\n  and the full edge list is printed.\n@param width: the number of characters to use in one line.\n  If C{None}, no limit will be enforced on the line lengths.\n@return: the summary of the graph."}, {"type": "method", "name": "igraph.Graph.to_dict_dict", "documentation": "Export graph to dictionary of dicts of edge attributes\n\nThis function is the reverse of Graph.DictDict.\n\nExample:\n\n  >>> g = Graph.Full(3)\n  >>> g.es['name'] = ['first_edge', 'second', 'third']\n  >>> g.to_dict_dict()\n  {0: {1: {'name': 'first_edge'}, 2: {'name': 'second'}}, 1: {2: {'name': 'third'}}}\n\n@param use_vids: whether to label vertices in the output data\n  structure by their ids or their vertex_name_attr attribute. If\n  use_vids=False but vertices lack a vertex_name_attr attribute, an\n  AttributeError is raised.\n@param edge_attrs: list of edge attributes to export.\n  None (default) signified all attributes (unlike Graph.to_tuple_list). A\n  string is acceptable to signify a single attribute and will be wrapped\n  in a list internally.\n@param skip_none: whether to skip, for each edge, attributes that\n  have a value of None. This is useful if only some edges are expected to\n  possess an attribute.\n@param vertex_name_attr: only used with use_vids=False to choose what\n  vertex attribute to use to name your vertices in the output data\n  structure.\n\n@return: dictionary of dictionaries of dictionaries, with the outer keys\n  vertex ids/names, the middle keys ids/names of their neighbors, and the\n  innermost dictionary representing attributes of that edge."}, {"type": "method", "name": "igraph.Graph.to_dict_list", "documentation": "Export graph as two lists of dictionaries, for vertices and edges.\n\nThis function is the reverse of Graph.DictList.\n\nExample:\n\n  >>> g = Graph([(0, 1), (1, 2)])\n  >>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n  >>> g.es[\"name\"] = [\"first_edge\", \"second\"]\n\n  >>> g.to_dict_list()\n  ([{\"name\": \"apple\"}, {\"name\": \"pear\"}, {\"name\": \"peach\"}],\n   [{\"source\": 0, \"target\": 1, \"name\": \"first_edge\"},\n    {\"source\" 0, \"target\": 2, name\": \"second\"}])\n\n  >>> g.to_dict_list(use_vids=False)\n  ([{\"name\": \"apple\"}, {\"name\": \"pear\"}, {\"name\": \"peach\"}],\n   [{\"source\": \"apple\", \"target\": \"pear\", \"name\": \"first_edge\"},\n    {\"source\" \"apple\", \"target\": \"peach\", name\": \"second\"}])\n\n@param use_vids: whether to label vertices in the output data\n  structure by their ids or their vertex_name_attr attribute. If\n  use_vids=False but vertices lack a vertex_name_attr attribute, an\n  AttributeError is raised.\n@param skip_none: whether to skip, for each edge, attributes that\n  have a value of None. This is useful if only some edges are expected to\n  possess an attribute.\n@param vertex_name_attr: only used with use_vids=False to choose what\n  vertex attribute to use to name your vertices in the output data\n  structure.\n\n@return: a tuple with two lists of dictionaries, representing the vertices\n  and the edges, respectively, with their attributes."}, {"type": "method", "name": "igraph.Graph.to_graph_tool", "documentation": "Converts the graph to graph-tool\n\nData types: graph-tool only accepts specific data types. See the\nfollowing web page for a list:\n\nhttps://graph-tool.skewed.de/static/doc/quickstart.html\n\nNote: because of the restricted data types in graph-tool, vertex and\nedge attributes require to be type-consistent across all vertices or\nedges. If you set the property for only some vertices/edges, the other\nwill be tagged as None in igraph, so they can only be converted\nto graph-tool with the type 'object' and any other conversion will\nfail.\n\n@param graph_attributes: dictionary of graph attributes to transfer.\n  Keys are attributes from the graph, values are data types (see\n  below). C{None} means no graph attributes are transferred.\n@param vertex_attributes: dictionary of vertex attributes to transfer.\n  Keys are attributes from the vertices, values are data types (see\n  below). C{None} means no vertex attributes are transferred.\n@param edge_attributes: dictionary of edge attributes to transfer.\n  Keys are attributes from the edges, values are data types (see\n  below). C{None} means no vertex attributes are transferred."}, {"type": "method", "name": "igraph.Graph.to_list_dict", "documentation": "Export graph to a dictionary of lists (or other sequences).\n\nThis function is the reverse of Graph.ListDict.\n\nExample:\n\n  >>> g = Graph.Full(3)\n  >>> g.to_sequence_dict() -> {0: [1, 2], 1: [2]}\n  >>> g.to_sequence_dict(sequence_constructor=tuple) -> {0: (1, 2), 1: (2,)}\n  >>> g.vs['name'] = ['apple', 'pear', 'peach']\n  >>> g.to_sequence_dict(use_vids=False)\n  {'apple': ['pear', 'peach'], 'pear': ['peach']}\n\n@param use_vids: whether to label vertices in the output data\n  structure by their ids or their vertex_name_attr attribute. If\n  use_vids=False but vertices lack a vertex_name_attr attribute, an\n  AttributeError is raised.\n@param sequence_constructor: constructor for the data structure\n  to be used as values of the dictionary. The default (list) makes a dict\n  of lists, with each list representing the neighbors of the vertex\n  specified in the respective dictionary key.\n@param vertex_name_attr: only used with use_vids=False to choose what\n  vertex attribute to use to name your vertices in the output data\n  structure.\n\n@return: dictionary of sequences, keyed by vertices, with each value\n  containing the neighbors of that vertex."}, {"type": "method", "name": "igraph.Graph.to_networkx", "documentation": "Converts the graph to networkx format.\n\nigraph has ordered vertices and edges, but networkx does not. To keep\ntrack of the original order, the '_igraph_index' vertex property is\nadded to both vertices and edges.\n\n@param create_using: specifies which NetworkX graph class to use when\n    constructing the graph. C{None} means to let igraph infer the most\n    appropriate class based on whether the graph is directed and whether\n    it has multi-edges.\n@param vertex_attr_hashable: vertex attribute used to name vertices\n    in the exported network. The default \"_nx_name\" ensures round trip\n    conversions to/from networkx are lossless."}, {"type": "method", "name": "igraph.Graph.to_tuple_list", "documentation": "Export graph to a list of edge tuples\n\nThis function is the reverse of Graph.TupleList.\n\nExample:\n\n  >>> g = Graph.Full(3)\n  >>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n  >>> g.es[\"name\"] = [\"first_edge\", \"second\", \"third\"]\n\n  >>> # Get name of the edge\n  >>> g.to_tuple_list(edge_attrs=[\"name\"])\n  [(0, 1, \"first_edge\"), (0, 2, \"second\"), (1, 2, \"third\")]\n\n  >>> # Use vertex names, no edge attributes\n  >>> g.to_tuple_list(use_vids=False)\n  [(\"apple\", \"pear\"), (\"apple\", \"peach\"), (\"pear\", \"peach\")]\n\n@param use_vids: whether to label vertices in the output data\n  structure by their ids or their vertex_name_attr attribute. If\n  use_vids=False but vertices lack a vertex_name_attr attribute, an\n  AttributeError is raised.\n@param edge_attrs: list of edge attributes to export\n  in addition to source and target vertex, which are always the first two\n  elements of each tuple. None (default) is equivalent to an empty list. A\n  string is acceptable to signify a single attribute and will be wrapped in\n  a list internally.\n@param vertex_name_attr: only used with use_vids=False to choose what\n  vertex attribute to use to name your vertices in the output data\n  structure.\n\n@return: a list of tuples, each representing an edge of the graph."}, {"type": "method", "name": "igraph.Graph.transitivity_avglocal_undirected", "documentation": "Calculates the average of the vertex transitivities of the graph.\n\nIn the unweighted case, the transitivity measures the probability that\ntwo neighbors of a vertex are connected. In case of the average local\ntransitivity, this probability is calculated for each vertex and then\nthe average is taken. Vertices with less than two neighbors require\nspecial treatment, they will either be left out from the calculation\nor they will be considered as having zero transitivity, depending on\nthe I{mode} parameter. The calculation is slightly more involved for\nweighted graphs; in this case, weights are taken into account according\nto the formula of Barrat et al (see the references).\n\nNote that this measure is different from the global transitivity\nmeasure (see L{transitivity_undirected()}) as it simply takes the\naverage local transitivity across the whole network.\n\nB{References}\n\n  - Watts DJ and Strogatz S: Collective dynamics of small-world\n    networks. I{Nature} 393(6884):440-442, 1998.\n  - Barrat A, Barthelemy M, Pastor-Satorras R and Vespignani A:\n    The architecture of complex weighted networks. I{PNAS} 101, 3747\n    (2004). U{http://arxiv.org/abs/cond-mat/0311416}.\n\n@param mode: defines how to treat vertices with degree less than two.\n  If C{TRANSITIVITY_ZERO} or C{\"zero\"}, these vertices will have zero\n  transitivity. If C{TRANSITIVITY_NAN} or C{\"nan\"}, these vertices\n  will be excluded from the average.\n@param weights: edge weights to be used. Can be a sequence or iterable\n  or even an edge attribute name.\n\n@see: L{transitivity_undirected()}, L{transitivity_local_undirected()}"}, {"type": "method", "name": "igraph.Graph.triad_census", "documentation": "Calculates the triad census of the graph.\n\nB{Reference}: Davis, J.A. and Leinhardt, S. The Structure of\nPositive Interpersonal Relations in Small Groups. In:\nJ. Berger (Ed.), Sociological Theories in Progress, Volume 2,\n218-251. Boston: Houghton Mifflin (1972).\n\n@return: a L{TriadCensus} object."}, {"type": "method", "name": "igraph.Graph.union", "documentation": "Creates the union of two (or more) graphs.\n\n@param other: graph or list of graphs to be united with the current one.\n@param byname: whether to use vertex names instead of ids. See\n  L{igraph.operators.union} for details.\n@return: the union graph"}, {"type": "method", "name": "igraph.Graph.write", "documentation": "Unified writing function for graphs.\n\nThis method tries to identify the format of the graph given in\nthe first parameter (based on extension) and calls the corresponding\nwriter method.\n\nThe remaining arguments are passed to the writer method without\nany changes.\n\n@param f: the file containing the graph to be saved\n@param format: the format of the file (if one wants to override the\n  format determined from the filename extension, or the filename itself\n  is a stream). C{None} means auto-detection. Possible values are:\n\n    - C{\"adjacency\"}: adjacency matrix format\n\n    - C{\"dimacs\"}: DIMACS format\n\n    - C{\"dot\"}, C{\"graphviz\"}: GraphViz DOT format\n\n    - C{\"edgelist\"}, C{\"edges\"} or C{\"edge\"}: numeric edge list format\n\n    - C{\"gml\"}: GML format\n\n    - C{\"graphml\"} and C{\"graphmlz\"}: standard and gzipped GraphML\n      format\n\n    - C{\"gw\"}, C{\"leda\"}, C{\"lgr\"}: LEDA native format\n\n    - C{\"lgl\"}: LGL format\n\n    - C{\"ncol\"}: NCOL format\n\n    - C{\"net\"}, C{\"pajek\"}: Pajek format\n\n    - C{\"pickle\"}, C{\"picklez\"}: standard and gzipped Python pickled\n      format\n\n    - C{\"svg\"}: SVG format\n\n@raises IOError: if the file format can't be identified and\n  none was given."}, {"type": "method", "name": "igraph.Graph.write_adjacency", "documentation": "Writes the adjacency matrix of the graph to the given file\n\nAll the remaining arguments not mentioned here are passed intact\nto L{Graph.get_adjacency}.\n\n@param f: the name of the file to be written.\n@param sep: the string that separates the matrix elements in a row\n@param eol: the string that separates the rows of the matrix. Please\n  note that igraph is able to read back the written adjacency matrix\n  if and only if this is a single newline character"}, {"type": "method", "name": "igraph.Graph.write_dimacs", "documentation": "Writes the graph in DIMACS format to the given file.\n\n@param f: the name of the file to be written or a Python file handle.\n@param source: the source vertex ID. If C{None}, igraph will try to\n  infer it from the C{source} graph attribute.\n@param target: the target vertex ID. If C{None}, igraph will try to\n  infer it from the C{target} graph attribute.\n@param capacity: the capacities of the edges in a list or the name of\n  an edge attribute that holds the capacities. If there is no such\n  edge attribute, every edge will have a capacity of 1."}, {"type": "method", "name": "igraph.Graph.write_graphmlz", "documentation": "Writes the graph to a zipped GraphML file.\n\nThe library uses the gzip compression algorithm, so the resulting\nfile can be unzipped with regular gzip uncompression (like\nC{gunzip} or C{zcat} from Unix command line) or the Python C{gzip}\nmodule.\n\nUses a temporary file to store intermediate GraphML data, so\nmake sure you have enough free space to store the unzipped\nGraphML file as well.\n\n@param f: the name of the file to be written.\n@param compresslevel: the level of compression. 1 is fastest and\n  produces the least compression, and 9 is slowest and produces\n  the most compression."}, {"type": "method", "name": "igraph.Graph.write_pickle", "documentation": "Saves the graph in Python pickled format\n\n@param fname: the name of the file or a stream to save to. If\n  C{None}, saves the graph to a string and returns the string.\n@param version: pickle protocol version to be used. If -1, uses\n  the highest protocol available\n@return: C{None} if the graph was saved successfully to the\n  given file, or a string if C{fname} was C{None}."}, {"type": "method", "name": "igraph.Graph.write_picklez", "documentation": "Saves the graph in Python pickled format, compressed with\ngzip.\n\nSaving in this format is a bit slower than saving in a Python pickle\nwithout compression, but the final file takes up much less space on\nthe hard drive.\n\n@param fname: the name of the file or a stream to save to.\n@param version: pickle protocol version to be used. If -1, uses\n  the highest protocol available\n@return: C{None} if the graph was saved successfully to the\n  given file."}, {"type": "method", "name": "igraph.Graph.write_svg", "documentation": "Saves the graph as an SVG (Scalable Vector Graphics) file\n\nThe file will be Inkscape (http://inkscape.org) compatible.\nIn Inkscape, as nodes are rearranged, the edges auto-update.\n\n@param fname: the name of the file or a Python file handle\n@param layout: the layout of the graph. Can be either an\n  explicitly specified layout (using a list of coordinate\n  pairs) or the name of a layout algorithm (which should\n  refer to a method in the L{Graph} object, but without\n  the C{layout_} prefix.\n@param width: the preferred width in pixels (default: 400)\n@param height: the preferred height in pixels (default: 400)\n@param labels: the vertex labels. Either it is the name of\n  a vertex attribute to use, or a list explicitly specifying\n  the labels. It can also be C{None}.\n@param colors: the vertex colors. Either it is the name of\n  a vertex attribute to use, or a list explicitly specifying\n  the colors. A color can be anything acceptable in an SVG\n  file.\n@param shapes: the vertex shapes. Either it is the name of\n  a vertex attribute to use, or a list explicitly specifying\n  the shapes as integers. Shape 0 means hidden (nothing is drawn),\n  shape 1 is a circle, shape 2 is a rectangle and shape 3 is a\n  rectangle that automatically sizes to the inner text.\n@param vertex_size: vertex size in pixels\n@param edge_colors: the edge colors. Either it is the name\n  of an edge attribute to use, or a list explicitly specifying\n  the colors. A color can be anything acceptable in an SVG\n  file.\n@param edge_stroke_widths: the stroke widths of the edges. Either\n  it is the name of an edge attribute to use, or a list explicitly\n  specifying the stroke widths. The stroke width can be anything\n  acceptable in an SVG file.\n@param font_size: font size. If it is a string, it is written into\n  the SVG file as-is (so you can specify anything which is valid\n  as the value of the C{font-size} style). If it is a number, it\n  is interpreted as pixel size and converted to the proper attribute\n  value accordingly."}, {"type": "class", "name": "igraph.GraphBase", "documentation": "Low-level representation of a graph.\n\nDon't use it directly, use L{igraph.Graph} instead."}, {"type": "class", "name": "igraph.GraphSummary", "documentation": "Summary representation of a graph.\n\nThe summary representation includes a header line and the list of\nedges. The header line consists of C{IGRAPH}, followed by a\nfour-character long code, the number of vertices, the number of\nedges, two dashes (C{--}) and the name of the graph (i.e.\nthe contents of the C{name} attribute, if any). For instance,\na header line may look like this::\n\n    IGRAPH U--- 4 5 --\n\nThe four-character code describes some basic properties of the\ngraph. The first character is C{U} if the graph is undirected,\nC{D} if it is directed. The second letter is C{N} if the graph\nhas a vertex attribute called C{name}, or a dash otherwise. The\nthird letter is C{W} if the graph is weighted (i.e. it has an\nedge attribute called C{weight}), or a dash otherwise. The\nfourth letter is C{B} if the graph has a vertex attribute called\nC{type}; this is usually used for bipartite graphs.\n\nEdges may be presented as an ordinary edge list or an adjacency\nlist. By default, this depends on the number of edges; however,\nyou can control it with the appropriate constructor arguments."}, {"type": "method", "name": "igraph.GraphSummary.__init__", "documentation": "Constructs a summary representation of a graph.\n\n@param verbosity: the verbosity of the summary. If zero, only\n  the header line will be returned. If one, the header line\n  and the list of edges will both be returned.\n@param width: the maximal width of each line in the summary.\n  C{None} means that no limit will be enforced.\n@param max_rows: the maximal number of rows to print in a single\n  table (e.g., vertex attribute table or edge attribute table)\n@param edge_list_format: format of the edge list in the summary.\n  Supported formats are: C{compressed}, C{adjlist}, C{edgelist},\n  C{auto}, which selects automatically from the other three based\n  on some simple criteria.\n@param print_graph_attributes: whether to print graph attributes\n  if there are any.\n@param print_vertex_attributes: whether to print vertex attributes\n  if there are any.\n@param print_edge_attributes: whether to print edge attributes\n  if there are any.\n@param full: False has no effect; True turns on the attribute\n  printing for graph, vertex and edge attributes with verbosity 1."}, {"type": "method", "name": "igraph.GraphSummary.__str__", "documentation": "Returns the summary representation as a string."}, {"type": "method", "name": "igraph.GraphSummary._construct_edgelist_adjlist", "documentation": "Constructs the part in the summary that prints the edge list in an\nadjacency list format."}, {"type": "method", "name": "igraph.GraphSummary._construct_edgelist_compressed", "documentation": "Constructs the part in the summary that prints the edge list in a\ncompressed format suitable for graphs with mostly small degrees."}, {"type": "method", "name": "igraph.GraphSummary._construct_edgelist_edgelist", "documentation": "Constructs the part in the summary that prints the edge list in a\nfull edge list format."}, {"type": "method", "name": "igraph.GraphSummary._construct_graph_attributes", "documentation": "Constructs the part in the summary that lists the graph attributes."}, {"type": "method", "name": "igraph.GraphSummary._construct_header", "documentation": "Constructs the header part of the summary."}, {"type": "method", "name": "igraph.GraphSummary._construct_vertex_attributes", "documentation": "Constructs the part in the summary that lists the vertex attributes."}, {"type": "method", "name": "igraph.GraphSummary._edge_attribute_iterator", "documentation": "Returns an iterator that yields the rows of the edge attribute table\nin the summary. C{attribute_order} must be a list containing the names of\nthe attributes to be presented in this table."}, {"type": "method", "name": "igraph.GraphSummary._infer_column_alignment", "documentation": "Infers the preferred alignment for the given vertex and edge attributes\nin the tables by peeking into the attribute values of the first 100 vertices\nor edges. Numeric attributes will be aligned right, everything else will be\naligned left."}, {"type": "method", "name": "igraph.GraphSummary._new_table", "documentation": "Constructs a new table to pretty-print vertex and edge attributes"}, {"type": "method", "name": "igraph.GraphSummary._vertex_attribute_iterator", "documentation": "Returns an iterator that yields the rows of the vertex attribute table\nin the summary. C{attribute_order} must be a list containing the names of\nthe attributes to be presented in this table."}, {"type": "class", "name": "igraph.Histogram", "documentation": "Generic histogram class for real numbers\n\nExample:\n\n    >>> h = Histogram(5)     # Initializing, bin width = 5\n    >>> h << [2,3,2,7,8,5,5,0,7,9]     # Adding more items\n    >>> print(h)\n    N = 10, mean +- sd: 4.8000 +- 2.9740\n    [ 0,  5): **** (4)\n    [ 5, 10): ****** (6)"}, {"type": "method", "name": "igraph.Histogram.__init__", "documentation": "Initializes the histogram with the given data set.\n\n@param bin_width: the bin width of the histogram.\n@param data: the data set to be used. Must contain real numbers."}, {"type": "method", "name": "igraph.Histogram.__lshift__", "documentation": "Adds a single number or the elements of an iterable to the histogram.\n\n@param data: the data to be added"}, {"type": "method", "name": "igraph.Histogram.__plot__", "documentation": "Plotting support"}, {"type": "method", "name": "igraph.Histogram.__str__", "documentation": "Return str(self)."}, {"type": "method", "name": "igraph.Histogram._get_bin", "documentation": "Returns the bin index corresponding to the given number.\n\n@param num: the number for which the bin is being sought\n@param create: whether to create a new bin if no bin exists yet.\n@return: the index of the bin or C{None} if no bin exists yet and\n  {create} is C{False}."}, {"type": "method", "name": "igraph.Histogram.add", "documentation": "Adds a single number to the histogram.\n\n@param num: the number to be added\n@param repeat: number of repeated additions"}, {"type": "method", "name": "igraph.Histogram.add_many", "documentation": "Adds a single number or the elements of an iterable to the histogram.\n\n@param data: the data to be added"}, {"type": "method", "name": "igraph.Histogram.bins", "documentation": "Generator returning the bins of the histogram in increasing order\n\n@return: a tuple with the following elements: left bound, right bound,\n  number of elements in the bin"}, {"type": "method", "name": "igraph.Histogram.clear", "documentation": "Clears the collected data"}, {"type": "method", "name": "igraph.Histogram.to_string", "documentation": "Returns the string representation of the histogram.\n\n@param max_width: the maximal width of each line of the string\n  This value may not be obeyed if it is too small.\n@param show_bars: specify whether the histogram bars should be shown\n@param show_counts: specify whether the histogram counts should be\n  shown. If both I{show_bars} and I{show_counts} are C{False},\n  only a general descriptive statistics (number of elements, mean and\n  standard deviation) is shown."}, {"type": "class", "name": "igraph.InternalError", "documentation": "Common base class for all non-exit exceptions."}, {"type": "class", "name": "igraph.Layout", "documentation": "Represents the layout of a graph.\n\nA layout is practically a list of coordinates in an n-dimensional\nspace. This class is generic in the sense that it can store coordinates\nin any n-dimensional space.\n\nLayout objects are not associated directly with a graph. This is deliberate:\nthere were times when I worked with almost identical copies of the same\ngraph, the only difference was that they had different colors assigned to\nthe vertices. It was particularly convenient for me to use the same layout\nfor all of them, especially when I made figures for a paper. However,\nC{igraph} will of course refuse to draw a graph with a layout that has\nfewer coordinates than the node count of the graph.\n\nLayouts behave exactly like lists when they are accessed using the item\nindex operator (C{[...]}). They can even be iterated through. Items\nreturned by the index operator are only copies of the coordinates,\nbut the stored coordinates can be modified by directly assigning to\nan index.\n\n    >>> layout = Layout([(0, 1), (0, 2)])\n    >>> coords = layout[1]\n    >>> print(coords)\n    [0, 2]\n    >>> coords = (0, 3)\n    >>> print(layout[1])\n    [0, 2]\n    >>> layout[1] = coords\n    >>> print(layout[1])\n    [0, 3]"}, {"type": "method", "name": "igraph.Layout.__copy__", "documentation": null}, {"type": "method", "name": "igraph.Layout.__delitem__", "documentation": null}, {"type": "method", "name": "igraph.Layout.__getitem__", "documentation": null}, {"type": "method", "name": "igraph.Layout.__init__", "documentation": "Constructor.\n\n@param coords: the coordinates to be stored in the layout.\n@param dim: the number of dimensions. If C{None}, the number of\ndimensions is determined automatically from the length of the first\nitem of the coordinate list. If there are no entries in the coordinate\nlist, the default will be 2.  Generally, this should be given if the\nlength of the coordinate list is zero, otherwise it should be left as\nis."}, {"type": "method", "name": "igraph.Layout.__len__", "documentation": null}, {"type": "method", "name": "igraph.Layout.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.Layout.__setitem__", "documentation": null}, {"type": "method", "name": "igraph.Layout.append", "documentation": "Appends a new point to the layout"}, {"type": "method", "name": "igraph.Layout.boundaries", "documentation": "Returns the boundaries of the layout.\n\nThe boundaries are the minimum and maximum coordinates along all\ndimensions.\n\n@param border: this value gets subtracted from the minimum bounds\n  and gets added to the maximum bounds before returning the coordinates\n  of the box. Defaults to zero.\n@return: the minimum and maximum coordinates along all dimensions,\n  in a tuple containing two lists, one for the minimum coordinates,\n  the other one for the maximum.\n@raises ValueError: if the layout contains no layout items"}, {"type": "method", "name": "igraph.Layout.bounding_box", "documentation": "Returns the bounding box of the layout.\n\nThe bounding box of the layout is the smallest box enclosing all the\npoints in the layout.\n\n@param border: this value gets subtracted from the minimum bounds\n  and gets added to the maximum bounds before returning the coordinates\n  of the box. Defaults to zero.\n@return: the coordinates of the lower left and the upper right corner\n  of the box. \"Lower left\" means the minimum coordinates and \"upper right\"\n  means the maximum. These are encapsulated in a L{BoundingBox} object."}, {"type": "method", "name": "igraph.Layout.center", "documentation": "Centers the layout around the given point.\n\nThe point itself can be supplied as multiple unnamed arguments, as a\nsimple unnamed list or as a keyword argument. This operation moves\nthe centroid of the layout to the given point. If no point is supplied,\ndefaults to the origin of the coordinate system.\n\n@keyword p: the point where the centroid of the layout will be after\n  the operation."}, {"type": "method", "name": "igraph.Layout.centroid", "documentation": "Returns the centroid of the layout.\n\nThe centroid of the layout is the arithmetic mean of the points in\nthe layout.\n\n@return: the centroid as a list of floats"}, {"type": "method", "name": "igraph.Layout.copy", "documentation": "Creates an exact copy of the layout."}, {"type": "method", "name": "igraph.Layout.fit_into", "documentation": "Fits the layout into the given bounding box.\n\nThe layout will be modified in-place.\n\n@param bbox: the bounding box in which to fit the layout. If the\n  dimension of the layout is d, it can either be a d-tuple (defining\n  the sizes of the box), a 2d-tuple (defining the coordinates of the\n  top left and the bottom right point of the box), or a L{BoundingBox}\n  object (for 2D layouts only).\n@param keep_aspect_ratio: whether to keep the aspect ratio of the current\n  layout. If C{False}, the layout will be rescaled to fit exactly into\n  the bounding box. If C{True}, the original aspect ratio of the layout\n  will be kept and it will be centered within the bounding box."}, {"type": "method", "name": "igraph.Layout.mirror", "documentation": "Mirrors the layout along the given dimension(s)\n\n@param dim: the list of dimensions or a single dimension"}, {"type": "method", "name": "igraph.Layout.rotate", "documentation": "Rotates the layout by the given degrees on the plane defined by\nthe given two dimensions.\n\n@param angle: the angle of the rotation, specified in degrees.\n@param dim1: the first axis of the plane of the rotation.\n@param dim2: the second axis of the plane of the rotation.\n@keyword origin: the origin of the rotation. If not specified, the\n  origin will be the origin of the coordinate system."}, {"type": "method", "name": "igraph.Layout.scale", "documentation": "Scales the layout.\n\nScaling parameters can be provided either through the C{scale} keyword\nargument or through plain unnamed arguments. If a single integer or\nfloat is given, it is interpreted as a uniform multiplier to be applied\non all dimensions. If it is a list or tuple, its length must be equal to\nthe number of dimensions in the layout, and each element must be an\ninteger or float describing the scaling coefficient in one of the\ndimensions.\n\n@keyword scale: scaling coefficients (integer, float, list or tuple)\n@keyword origin: the origin of scaling (this point will stay in place).\n  Optional, defaults to the origin of the coordinate system being used."}, {"type": "method", "name": "igraph.Layout.to_radial", "documentation": "Converts a planar layout to a radial one\n\nThis method applies only to 2D layouts. The X coordinate of the\nlayout is transformed to an angle, with min(x) corresponding to\nthe parameter called I{min_angle} and max(y) corresponding to\nI{max_angle}. Angles are given in degrees, zero degree corresponds\nto the direction pointing upwards. The Y coordinate is\ninterpreted as a radius, with min(y) belonging to the minimum and\nmax(y) to the maximum radius given in the arguments.\n\nThis is not a fully generic polar coordinate transformation, but\nit is fairly useful in creating radial tree layouts from ordinary\ntop-down ones (that's why the Y coordinate belongs to the radius).\nIt can also be used in conjunction with the Fruchterman-Reingold\nlayout algorithm via its I{miny} and I{maxy} parameters (see\nL{Graph.layout_fruchterman_reingold()<GraphBase.layout_fruchterman_reingold()>})\nto produce radial layouts where the radius belongs to some property of\nthe vertices.\n\n@param min_angle: the angle corresponding to the minimum X value\n@param max_angle: the angle corresponding to the maximum X value\n@param min_radius: the radius corresponding to the minimum Y value\n@param max_radius: the radius corresponding to the maximum Y value"}, {"type": "method", "name": "igraph.Layout.transform", "documentation": "Performs an arbitrary transformation on the layout\n\nAdditional positional and keyword arguments are passed intact to\nthe given function.\n\n@param function: a function which receives the coordinates as a\n  tuple and returns the transformed tuple."}, {"type": "method", "name": "igraph.Layout.translate", "documentation": "Translates the layout.\n\nThe translation vector can be provided either through the C{v} keyword\nargument or through plain unnamed arguments. If unnamed arguments are\nused, the vector can be supplied as a single list (or tuple) or just as\na series of arguments. In all cases, the translation vector must have\nthe same number of dimensions as the layout.\n\n@keyword v: the translation vector"}, {"type": "class", "name": "igraph.Matching", "documentation": "A matching of vertices in a graph.\n\nA matching of an undirected graph is a set of edges such that each\nvertex is incident on at most one matched edge. When each vertex is\nincident on I{exactly} one matched edge, the matching called\nI{perfect}. This class is used in C{igraph} to represent non-perfect\nand perfect matchings in undirected graphs.\n\nThis class is usually not instantiated directly, everything\nis taken care of by the functions that return matchings.\n\nExamples:\n\n  >>> from igraph import Graph\n  >>> g = Graph.Famous(\"noperfectmatching\")\n  >>> matching = g.maximum_matching()"}, {"type": "method", "name": "igraph.Matching.__init__", "documentation": "Initializes the matching.\n\n@param graph: the graph the matching belongs to\n@param matching: a numeric vector where element I{i} corresponds to\n  vertex I{i} of the graph. Element I{i} is -1 or if the corresponding\n  vertex is unmatched, otherwise it contains the index of the vertex to\n  which vertex I{i} is matched.\n@param types: the types of the vertices if the graph is bipartite.\n  It must either be the name of a vertex attribute (which will be\n  retrieved for all vertices) or a list. Elements in the list will be\n  converted to boolean values C{True} or C{False}, and this will\n  determine which part of the bipartite graph a given vertex belongs to.\n@raise ValueError: if the matching vector supplied does not describe\n  a valid matching of the graph."}, {"type": "method", "name": "igraph.Matching.__len__", "documentation": null}, {"type": "method", "name": "igraph.Matching.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.Matching.__str__", "documentation": "Return str(self)."}, {"type": "method", "name": "igraph.Matching.edges", "documentation": "Returns an edge sequence that contains the edges in the matching.\n\nIf there are multiple edges between a pair of matched vertices, only one\nof them will be returned."}, {"type": "method", "name": "igraph.Matching.is_matched", "documentation": "Returns whether the given vertex is matched to another one."}, {"type": "method", "name": "igraph.Matching.is_maximal", "documentation": "Returns whether the matching is maximal.\n\nA matching is maximal when it is not possible to extend it any more\nwith extra edges; in other words, unmatched vertices in the graph\nmust be adjacent to matched vertices only."}, {"type": "method", "name": "igraph.Matching.match_of", "documentation": "Returns the vertex a given vertex is matched to.\n\n@param vertex: the vertex we are interested in; either an integer index\n  or an instance of L{Vertex}.\n@return: the index of the vertex matched to the given vertex, either as\n  an integer index (if I{vertex} was integer) or as an instance of\n  L{Vertex}. When the vertex is unmatched, returns C{None}."}, {"type": "class", "name": "igraph.MatplotlibGraphDrawer", "documentation": "Graph drawer that uses a pyplot.Axes as context"}, {"type": "method", "name": "igraph.MatplotlibGraphDrawer.__init__", "documentation": "Constructs the graph drawer and associates it with the mpl Axes\n\n@param ax: the matplotlib Axes to draw into.\n@param vertex_drawer_factory: a factory method that returns an\n    L{AbstractVertexDrawer} instance bound to the given Matplotlib axes.\n    The factory method must take three parameters: the axes and the\n    palette to be used for drawing colored vertices, and the layout of\n    the graph. The default vertex drawer is L{MatplotlibVertexDrawer}.\n@param edge_drawer_factory: a factory method that returns an\n    L{AbstractEdgeDrawer} instance bound to a given Matplotlib Axes.\n    The factory method must take two parameters: the Axes and the palette\n    to be used for drawing colored edges. The default edge drawer is\n    L{MatplotlibEdgeDrawer}."}, {"type": "method", "name": "igraph.MatplotlibGraphDrawer._determine_edge_order", "documentation": "Returns the order in which the edge of the given graph have to be\ndrawn, assuming that the relevant keyword arguments (C{edge_order} and\nC{edge_order_by}) are given in C{kwds} as a dictionary. If neither\nC{edge_order} nor C{edge_order_by} is present in C{kwds}, this\nfunction returns C{None} to indicate that the graph drawer is free to\nchoose the most convenient edge ordering."}, {"type": "method", "name": "igraph.MatplotlibGraphDrawer._determine_vertex_order", "documentation": "Returns the order in which the vertices of the given graph have to be\ndrawn, assuming that the relevant keyword arguments (C{vertex_order} and\nC{vertex_order_by}) are given in C{kwds} as a dictionary. If neither\nC{vertex_order} nor C{vertex_order_by} is present in C{kwds}, this\nfunction returns C{None} to indicate that the graph drawer is free to\nchoose the most convenient vertex ordering."}, {"type": "method", "name": "igraph.MatplotlibGraphDrawer.draw", "documentation": "Abstract method, must be implemented in derived classes."}, {"type": "method", "name": "igraph.MatplotlibGraphDrawer.ensure_layout", "documentation": "Helper method that ensures that I{layout} is an instance\nof L{Layout}. If it is not, the method will try to convert\nit to a L{Layout} according to the following rules:\n\n  - If I{layout} is a string, it is assumed to be a name\n    of an igraph layout, and it will be passed on to the\n    C{layout} method of the given I{graph} if I{graph} is\n    not C{None}.\n\n  - If I{layout} is C{None} and I{graph} has a \"layout\"\n    attribute, call this same function with the value of that\n    attribute.\n\n  - If I{layout} is C{None} and I{graph} does not have a \"layout\"\n    attribute, the C{layout} method of I{graph} will be invoked\n    with no parameters, which will call the default layout algorithm.\n\n  - Otherwise, I{layout} will be passed on to the constructor\n    of L{Layout}. This handles lists of lists, lists of tuples\n    and such.\n\nIf I{layout} is already a L{Layout} instance, it will still\nbe copied and a copy will be returned. This is because graph\ndrawers are allowed to transform the layout for their purposes,\nand we don't want the transformation to propagate back to the\ncaller."}, {"type": "class", "name": "igraph.Matrix", "documentation": "Simple matrix data type.\n\nOf course there are much more advanced matrix data types for Python (for\ninstance, the C{ndarray} data type of Numeric Python) and this implementation\ndoes not want to compete with them. The only role of this data type is to\nprovide a convenient interface for the matrices returned by the C{Graph}\nobject (for instance, allow indexing with tuples in the case of adjacency\nmatrices and so on)."}, {"type": "method", "name": "igraph.Matrix.Fill", "documentation": "Creates a matrix filled with the given value\n\n@param value: the value to be used\n@keyword shape: the shape of the matrix. Can be a single integer,\n  two integers or a tuple. If a single integer is\n  given here, the matrix is assumed to be square-shaped."}, {"type": "method", "name": "igraph.Matrix.Identity", "documentation": "Creates an identity matrix.\n\n@keyword shape: the shape of the matrix. Can be a single integer,\n  two integers or a tuple. If a single integer is\n  given here, the matrix is assumed to be square-shaped."}, {"type": "method", "name": "igraph.Matrix.Zero", "documentation": "Creates a matrix filled with zeros.\n\n@keyword shape: the shape of the matrix. Can be a single integer,\n  two integers or a tuple. If a single integer is\n  given here, the matrix is assumed to be square-shaped."}, {"type": "method", "name": "igraph.Matrix.__add__", "documentation": "Adds the given value to the matrix.\n\n@param other: either a scalar or a matrix. Scalars will\n  be added to each element of the matrix. Matrices will\n  be added together elementwise.\n@return: the result matrix"}, {"type": "method", "name": "igraph.Matrix.__eq__", "documentation": "Checks whether a given matrix is equal to another one"}, {"type": "method", "name": "igraph.Matrix.__getitem__", "documentation": "Returns a single item, a row or a column of the matrix\n\n@param i: if a single integer, returns the M{i}th row as a list. If a\n  slice, returns the corresponding rows as another L{Matrix} object. If\n  a 2-tuple, the first element of the tuple is used to select a row and\n  the second is used to select a column."}, {"type": "method", "name": "igraph.Matrix.__hash__", "documentation": "Returns a hash value for a matrix."}, {"type": "method", "name": "igraph.Matrix.__iadd__", "documentation": "In-place addition of a matrix or scalar."}, {"type": "method", "name": "igraph.Matrix.__init__", "documentation": "Initializes a matrix.\n\n@param data: the elements of the matrix as a list of lists, or C{None} to\n  create a 0x0 matrix."}, {"type": "method", "name": "igraph.Matrix.__isub__", "documentation": "In-place subtraction of a matrix or scalar."}, {"type": "method", "name": "igraph.Matrix.__iter__", "documentation": "Support for iteration.\n\nThis is actually implemented as a generator, so there is no need for a\nseparate iterator class. The generator returns I{copies} of the rows in\nthe matrix as lists to avoid messing around with the internals. Feel\nfree to do anything with the copies, the changes won't be reflected in\nthe original matrix."}, {"type": "method", "name": "igraph.Matrix.__len__", "documentation": "Returns the number of rows in the matrix."}, {"type": "method", "name": "igraph.Matrix.__ne__", "documentation": "Checks whether a given matrix is not equal to another one"}, {"type": "method", "name": "igraph.Matrix.__plot__", "documentation": "Plots the matrix to the given Cairo context or matplotlib Axes.\n\nBesides the usual self-explanatory plotting parameters (C{context},\nC{bbox}, C{palette}), it accepts the following keyword arguments:\n\n  - C{style}: the style of the plot. C{boolean} is useful for plotting\n    matrices with boolean (C{True}/C{False} or 0/1) values: C{False}\n    will be shown with a white box and C{True} with a black box.\n    C{palette} uses the given palette to represent numbers by colors,\n    the minimum will be assigned to palette color index 0 and the maximum\n    will be assigned to the length of the palette. C{None} draws transparent\n    cell backgrounds only. The default style is C{boolean} (but it may\n    change in the future). C{None} values in the matrix are treated\n    specially in both cases: nothing is drawn in the cell corresponding\n    to C{None}.\n\n  - C{square}: whether the cells of the matrix should be square or not.\n    Default is C{True}.\n\n  - C{grid_width}: line width of the grid shown on the matrix. If zero or\n    negative, the grid is turned off. The grid is also turned off if the size\n    of a cell is less than three times the given line width. Default is C{1}.\n    Fractional widths are also allowed.\n\n  - C{border_width}: line width of the border drawn around the matrix.\n    If zero or negative, the border is turned off. Default is C{1}.\n\n  - C{row_names}: the names of the rows\n\n  - C{col_names}: the names of the columns.\n\n  - C{values}: values to be displayed in the cells. If C{None} or\n    C{False}, no values are displayed. If C{True}, the values come\n    from the matrix being plotted. If it is another matrix, the\n    values of that matrix are shown in the cells. In this case,\n    the shape of the value matrix must match the shape of the\n    matrix being plotted.\n\n  - C{value_format}: a format string or a callable that specifies how\n    the values should be plotted. If it is a callable, it must be a\n    function that expects a single value and returns a string.\n    Example: C{\"%#.2f\"} for floating-point numbers with always exactly\n    two digits after the decimal point. See the Python documentation of\n    the C{%} operator for details on the format string. If the format\n    string is not given, it defaults to the C{str} function.\n\nIf only the row names or the column names are given and the matrix\nis square-shaped, the same names are used for both column and row\nnames."}, {"type": "method", "name": "igraph.Matrix.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.Matrix.__setitem__", "documentation": "Sets a single item, a row or a column of the matrix\n\n@param i: if a single integer, sets the M{i}th row as a list. If a\n  slice, sets the corresponding rows from another L{Matrix} object.\n  If a 2-tuple, the first element of the tuple is used to select a row\n  and the second is used to select a column.\n@param value: the new value"}, {"type": "method", "name": "igraph.Matrix.__str__", "documentation": "Return str(self)."}, {"type": "method", "name": "igraph.Matrix.__sub__", "documentation": "Subtracts the given value from the matrix.\n\n@param other: either a scalar or a matrix. Scalars will\n  be subtracted from each element of the matrix. Matrices will\n  be subtracted together elementwise.\n@return: the result matrix"}, {"type": "method", "name": "igraph.Matrix._get_data", "documentation": "Returns the data stored in the matrix as a list of lists"}, {"type": "method", "name": "igraph.Matrix._set_data", "documentation": "Sets the data stored in the matrix"}, {"type": "method", "name": "igraph.Matrix.max", "documentation": "Returns the maximum of the matrix along the given dimension\n\n@param dim: the dimension. 0 means determining the column maximums, 1 means\n  determining the row maximums. If C{None}, the global maximum is\n  returned."}, {"type": "method", "name": "igraph.Matrix.min", "documentation": "Returns the minimum of the matrix along the given dimension\n\n@param dim: the dimension. 0 means determining the column minimums, 1 means\n  determining the row minimums. If C{None}, the global minimum is\n  returned."}, {"type": "class", "name": "igraph.Palette", "documentation": "Base class of color palettes.\n\nColor palettes are mappings that assign integers from the range\n0..M{n-1} to colors (4-tuples). M{n} is called the size or length\nof the palette. C{igraph} comes with a number of predefined palettes,\nso this class is useful for you only if you want to define your\nown palette. This can be done by subclassing this class and implementing\nthe L{Palette._get} method as necessary.\n\nPalettes can also be used as lists or dicts, for the C{__getitem__}\nmethod is overridden properly to call L{Palette.get}."}, {"type": "method", "name": "igraph.Palette.__getitem__", "documentation": "Returns the given color from the palette.\n\nValues are cached: if the specific value given has already been\nlooked up, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@note: you shouldn't override this method in subclasses, override\n  L{_get} instead. If you override this method, lookups in the\n  L{known_colors} dict won't work, so you won't be able to refer to\n  colors by names or RGBA quadruplets, only by integer indices. The\n  caching functionality will disappear as well. However,\n  feel free to override this method if this is exactly the behaviour\n  you want.\n\n@param v: the color to be retrieved. If it is an integer, it is\n  passed to L{Palette._get} to be translated to an RGBA quadruplet.\n  Otherwise it is passed to L{color_name_to_rgb()} to determine the\n  RGBA values.\n\n@return: the color as an RGBA quadruplet"}, {"type": "method", "name": "igraph.Palette.__init__", "documentation": "Initialize self.  See help(type(self)) for accurate signature."}, {"type": "method", "name": "igraph.Palette.__len__", "documentation": "Returns the number of colors in this palette"}, {"type": "method", "name": "igraph.Palette.__plot__", "documentation": "Plots the colors of the palette on the given Cairo context/mpl Axes\n\nSupported keywork arguments in both Cairo and matplotlib are:\n\n  - C{orientation}: the orientation of the palette. Must be one of\n    the following values: C{left-right}, C{bottom-top}, C{right-left}\n    or C{top-bottom}. Possible aliases: C{horizontal} = C{left-right},\n    C{vertical} = C{bottom-top}, C{lr} = C{left-right},\n    C{rl} = C{right-left}, C{tb} = C{top-bottom}, C{bt} = C{bottom-top}.\n    The default is C{left-right}.\n\nAdditional supported keyword arguments in Cairo are:\n\n  - C{border_width}: line width of the border shown around the palette.\n    If zero or negative, the border is turned off. Default is C{1}.\n\n  - C{grid_width}: line width of the grid that separates palette cells.\n    If zero or negative, the grid is turned off. The grid is also\n    turned off if the size of a cell is less than three times the given\n    line width. Default is C{0}.  Fractional widths are also allowed.\n\nKeyword arguments in matplotlib are passes to Axes.imshow."}, {"type": "method", "name": "igraph.Palette.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.Palette._get", "documentation": "Override this method in a subclass to create a custom palette.\n\nYou can safely assume that v is an integer in the range 0..M{n-1}\nwhere M{n} is the size of the palette.\n\n@param v: numerical index of the color to be retrieved\n@return: a 4-tuple containing the RGBA values"}, {"type": "method", "name": "igraph.Palette.clear_cache", "documentation": "Clears the result cache.\n\nThe return values of L{Palette.get} are cached. Use this method\nto clear the cache."}, {"type": "method", "name": "igraph.Palette.get", "documentation": "Returns the given color from the palette.\n\nValues are cached: if the specific value given has already been\nlooked up, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@note: you shouldn't override this method in subclasses, override\n  L{_get} instead. If you override this method, lookups in the\n  L{known_colors} dict won't work, so you won't be able to refer to\n  colors by names or RGBA quadruplets, only by integer indices. The\n  caching functionality will disappear as well. However,\n  feel free to override this method if this is exactly the behaviour\n  you want.\n\n@param v: the color to be retrieved. If it is an integer, it is\n  passed to L{Palette._get} to be translated to an RGBA quadruplet.\n  Otherwise it is passed to L{color_name_to_rgb()} to determine the\n  RGBA values.\n\n@return: the color as an RGBA quadruplet"}, {"type": "method", "name": "igraph.Palette.get_many", "documentation": "Returns multiple colors from the palette.\n\nValues are cached: if the specific value given has already been\nlooked upon, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@param colors: the list of colors to be retrieved. The palette class\n  tries to make an educated guess here: if it is not possible to\n  interpret the value you passed here as a list of colors, the\n  class will simply try to interpret it as a single color by\n  forwarding the value to L{Palette.get}.\n@return: the colors as a list of RGBA quadruplets. The result will\n  be a list even if you passed a single color index or color name."}, {"type": "class", "name": "igraph.Plot", "documentation": "Class representing an arbitrary plot that uses the Cairo plotting\nbackend.\n\nObjects that you can plot include graphs, matrices, palettes, clusterings,\ncovers, and dendrograms.\n\nIn Cairo, every plot has an associated surface object. The surface is an\ninstance of C{cairo.Surface}, a member of the C{pycairo} library. The\nsurface itself provides a unified API to various plotting targets like SVG\nfiles, X11 windows, PostScript files, PNG files and so on. C{igraph} does\nnot usually know on which surface it is plotting at each point in time,\nsince C{pycairo} takes care of the actual drawing. Everything that's\nsupported by C{pycairo} should be supported by this class as well.\n\nCurrent Cairo surfaces include:\n\n  - C{cairo.GlitzSurface} -- OpenGL accelerated surface for the X11\n    Window System.\n\n  - C{cairo.ImageSurface} -- memory buffer surface. Can be written to a\n    C{PNG} image file.\n\n  - C{cairo.PDFSurface} -- PDF document surface.\n\n  - C{cairo.PSSurface} -- PostScript document surface.\n\n  - C{cairo.SVGSurface} -- SVG (Scalable Vector Graphics) document surface.\n\n  - C{cairo.Win32Surface} -- Microsoft Windows screen rendering.\n\n  - C{cairo.XlibSurface} -- X11 Window System screen rendering.\n\nIf you create a C{Plot} object with a string given as the target surface,\nthe string will be treated as a filename, and its extension will decide\nwhich surface class will be used. Please note that not all surfaces might\nbe available, depending on your C{pycairo} installation.\n\nA C{Plot} has an assigned default palette (see L{igraph.drawing.colors.Palette})\nwhich is used for plotting objects.\n\nA C{Plot} object also has a list of objects to be plotted with their\nrespective bounding boxes, palettes and opacities. Palettes assigned to an\nobject override the default palette of the plot. Objects can be added by the\nL{Plot.add} method and removed by the L{Plot.remove} method."}, {"type": "method", "name": "igraph.Plot.__init__", "documentation": "Creates a new plot.\n\n@param target: the target surface to write to. It can be one of the\n  following types:\n\n    - C{None} -- a Cairo surface will be created and the object will be\n      plotted there.\n\n    - C{cairo.Surface} -- the given Cairo surface will be used.\n\n    - C{string} -- a file with the given name will be created and an\n      appropriate Cairo surface will be attached to it.\n\n@param bbox: the bounding box of the surface. It is interpreted\n  differently with different surfaces: PDF and PS surfaces will treat it\n  as points (1 point = 1/72 inch). Image surfaces will treat it as\n  pixels. SVG surfaces will treat it as an abstract unit, but it will\n  mostly be interpreted as pixels when viewing the SVG file in Firefox.\n\n@param palette: the palette primarily used on the plot if the\n  added objects do not specify a private palette. Must be either\n  an L{igraph.drawing.colors.Palette} object or a string referring\n  to a valid key of C{igraph.drawing.colors.palettes} (see module\n  L{igraph.drawing.colors}) or C{None}. In the latter case, the default\n  palette given by the configuration key C{plotting.palette} is used.\n\n@param background: the background color. If C{None}, the background\n  will be transparent. You can use any color specification here that is\n  understood by L{igraph.drawing.colors.color_name_to_rgba}."}, {"type": "method", "name": "igraph.Plot._repr_svg_", "documentation": "Returns an SVG representation of this plot as a string.\n\nThis method is used by IPython to display this plot inline."}, {"type": "method", "name": "igraph.Plot.add", "documentation": "Adds an object to the plot.\n\nArguments not specified here are stored and passed to the object's\nplotting function when necessary. Since you are most likely interested\nin the arguments acceptable by graphs, see L{Graph.__plot__} for more\ndetails.\n\n@param obj: the object to be added\n@param bbox: the bounding box of the object. If C{None}, the object\n  will fill the entire area of the plot.\n@param palette: the color palette used for drawing the object. If the\n  object tries to get a color assigned to a positive integer, it\n  will use this palette. If C{None}, defaults to the global palette\n  of the plot.\n@param opacity: the opacity of the object being plotted, in the range\n  0.0-1.0\n\n@see: Graph.__plot__"}, {"type": "method", "name": "igraph.Plot.mark_dirty", "documentation": "Marks the plot as dirty (should be redrawn)"}, {"type": "method", "name": "igraph.Plot.redraw", "documentation": "Redraws the plot"}, {"type": "method", "name": "igraph.Plot.remove", "documentation": "Removes an object from the plot.\n\nIf the object has been added multiple times and no bounding box\nwas specified, it removes the instance which occurs M{idx}th\nin the list of identical instances of the object.\n\n@param obj: the object to be removed\n@param bbox: optional bounding box specification for the object.\n  If given, only objects with exactly this bounding box will be\n  considered.\n@param idx: if multiple objects match the specification given by\n  M{obj} and M{bbox}, only the M{idx}th occurrence will be removed.\n@return: C{True} if the object has been removed successfully,\n  C{False} if the object was not on the plot at all or M{idx}\n  was larger than the count of occurrences"}, {"type": "method", "name": "igraph.Plot.save", "documentation": "Saves the plot.\n\n@param fname: the filename to save to. It is ignored if the surface\n  of the plot is not an C{ImageSurface}."}, {"type": "class", "name": "igraph.Point", "documentation": "Class representing a point on the 2D plane."}, {"type": "method", "name": "igraph.Point.FromPolar", "documentation": "Constructs a point from polar coordinates.\n\nC{radius} is the distance of the point from the origin; C{angle} is the\nangle between the X axis and the vector pointing to the point from\nthe origin."}, {"type": "method", "name": "igraph.Point.__add__", "documentation": "Adds the coordinates of a point to another one"}, {"type": "method", "name": "igraph.Point.__div__", "documentation": "Divides the coordinates by a scalar"}, {"type": "method", "name": "igraph.Point.__getnewargs__", "documentation": "Return self as a plain tuple.  Used by copy and pickle."}, {"type": "method", "name": "igraph.Point.__mul__", "documentation": "Multiplies the coordinates by a scalar"}, {"type": "method", "name": "igraph.Point.__new__", "documentation": "Create new instance of _Point(x, y)"}, {"type": "method", "name": "igraph.Point.__repr__", "documentation": "Return a nicely formatted representation string"}, {"type": "method", "name": "igraph.Point.__rmul__", "documentation": "Multiplies the coordinates by a scalar"}, {"type": "method", "name": "igraph.Point.__sub__", "documentation": "Subtracts the coordinates of a point to another one"}, {"type": "method", "name": "igraph.Point._asdict", "documentation": "Return a new dict which maps field names to their values."}, {"type": "method", "name": "igraph.Point._make", "documentation": "Make a new _Point object from a sequence or iterable"}, {"type": "method", "name": "igraph.Point._replace", "documentation": "Return a new _Point object replacing specified fields with new values"}, {"type": "method", "name": "igraph.Point.as_polar", "documentation": "Returns the polar coordinate representation of the point.\n\n@return: the radius and the angle in a tuple."}, {"type": "method", "name": "igraph.Point.distance", "documentation": "Returns the distance of the point from another one.\n\nExample:\n\n    >>> p1 = Point(5, 7)\n    >>> p2 = Point(8, 3)\n    >>> p1.distance(p2)\n    5.0"}, {"type": "method", "name": "igraph.Point.interpolate", "documentation": "Linearly interpolates between the coordinates of this point and\nanother one.\n\n@param  other:  the other point\n@param  ratio:  the interpolation ratio between 0 and 1. Zero will\n  return this point, 1 will return the other point."}, {"type": "method", "name": "igraph.Point.length", "documentation": "Returns the length of the vector pointing from the origin to this\npoint."}, {"type": "method", "name": "igraph.Point.normalized", "documentation": "Normalizes the coordinates of the point s.t. its length will be 1\nafter normalization. Returns the normalized point."}, {"type": "method", "name": "igraph.Point.sq_length", "documentation": "Returns the squared length of the vector pointing from the origin\nto this point."}, {"type": "method", "name": "igraph.Point.towards", "documentation": "Returns the point that is at a given distance from this point\ntowards another one."}, {"type": "class", "name": "igraph.PrecalculatedPalette", "documentation": "A palette that returns colors from a pre-calculated list of colors"}, {"type": "method", "name": "igraph.PrecalculatedPalette.__getitem__", "documentation": "Returns the given color from the palette.\n\nValues are cached: if the specific value given has already been\nlooked up, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@note: you shouldn't override this method in subclasses, override\n  L{_get} instead. If you override this method, lookups in the\n  L{known_colors} dict won't work, so you won't be able to refer to\n  colors by names or RGBA quadruplets, only by integer indices. The\n  caching functionality will disappear as well. However,\n  feel free to override this method if this is exactly the behaviour\n  you want.\n\n@param v: the color to be retrieved. If it is an integer, it is\n  passed to L{Palette._get} to be translated to an RGBA quadruplet.\n  Otherwise it is passed to L{color_name_to_rgb()} to determine the\n  RGBA values.\n\n@return: the color as an RGBA quadruplet"}, {"type": "method", "name": "igraph.PrecalculatedPalette.__init__", "documentation": "Creates the palette backed by the given list. The list must contain\nRGBA quadruplets or color names, which will be resolved first by\nL{color_name_to_rgba()}. Anything that is understood by\nL{color_name_to_rgba()} is OK here."}, {"type": "method", "name": "igraph.PrecalculatedPalette.__len__", "documentation": "Returns the number of colors in this palette"}, {"type": "method", "name": "igraph.PrecalculatedPalette.__plot__", "documentation": "Plots the colors of the palette on the given Cairo context/mpl Axes\n\nSupported keywork arguments in both Cairo and matplotlib are:\n\n  - C{orientation}: the orientation of the palette. Must be one of\n    the following values: C{left-right}, C{bottom-top}, C{right-left}\n    or C{top-bottom}. Possible aliases: C{horizontal} = C{left-right},\n    C{vertical} = C{bottom-top}, C{lr} = C{left-right},\n    C{rl} = C{right-left}, C{tb} = C{top-bottom}, C{bt} = C{bottom-top}.\n    The default is C{left-right}.\n\nAdditional supported keyword arguments in Cairo are:\n\n  - C{border_width}: line width of the border shown around the palette.\n    If zero or negative, the border is turned off. Default is C{1}.\n\n  - C{grid_width}: line width of the grid that separates palette cells.\n    If zero or negative, the grid is turned off. The grid is also\n    turned off if the size of a cell is less than three times the given\n    line width. Default is C{0}.  Fractional widths are also allowed.\n\nKeyword arguments in matplotlib are passes to Axes.imshow."}, {"type": "method", "name": "igraph.PrecalculatedPalette.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.PrecalculatedPalette._get", "documentation": "This method will only be called if the requested color index is\noutside the size of the palette. In that case, we throw an exception"}, {"type": "method", "name": "igraph.PrecalculatedPalette.clear_cache", "documentation": "Clears the result cache.\n\nThe return values of L{Palette.get} are cached. Use this method\nto clear the cache."}, {"type": "method", "name": "igraph.PrecalculatedPalette.get", "documentation": "Returns the given color from the palette.\n\nValues are cached: if the specific value given has already been\nlooked up, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@note: you shouldn't override this method in subclasses, override\n  L{_get} instead. If you override this method, lookups in the\n  L{known_colors} dict won't work, so you won't be able to refer to\n  colors by names or RGBA quadruplets, only by integer indices. The\n  caching functionality will disappear as well. However,\n  feel free to override this method if this is exactly the behaviour\n  you want.\n\n@param v: the color to be retrieved. If it is an integer, it is\n  passed to L{Palette._get} to be translated to an RGBA quadruplet.\n  Otherwise it is passed to L{color_name_to_rgb()} to determine the\n  RGBA values.\n\n@return: the color as an RGBA quadruplet"}, {"type": "method", "name": "igraph.PrecalculatedPalette.get_many", "documentation": "Returns multiple colors from the palette.\n\nValues are cached: if the specific value given has already been\nlooked upon, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@param colors: the list of colors to be retrieved. The palette class\n  tries to make an educated guess here: if it is not possible to\n  interpret the value you passed here as a list of colors, the\n  class will simply try to interpret it as a single color by\n  forwarding the value to L{Palette.get}.\n@return: the colors as a list of RGBA quadruplets. The result will\n  be a list even if you passed a single color index or color name."}, {"type": "class", "name": "igraph.RainbowPalette", "documentation": "A palette that varies the hue of the colors along a scale.\n\nColors in a rainbow palette all have the same saturation, value and\nalpha components, while the hue is varied between two given extremes\nlinearly. This palette has the advantage that it wraps around nicely\nif the hue is varied between zero and one (which is the default).\n\nExample:\n\n    >>> pal = RainbowPalette(n=120)\n    >>> pal.get(0)\n    (1.0, 0.0, 0.0, 1.0)\n    >>> pal.get(20)\n    (1.0, 1.0, 0.0, 1.0)\n    >>> pal.get(40)\n    (0.0, 1.0, 0.0, 1.0)\n    >>> pal = RainbowPalette(n=120, s=1, v=0.5, alpha=0.75)\n    >>> pal.get(60)\n    (0.0, 0.5, 0.5, 0.75)\n    >>> pal.get(80)\n    (0.0, 0.0, 0.5, 0.75)\n    >>> pal.get(100)\n    (0.5, 0.0, 0.5, 0.75)\n    >>> pal = RainbowPalette(n=120)\n    >>> pal2 = RainbowPalette(n=120, start=0.5, end=0.5)\n    >>> pal.get(60) == pal2.get(0)\n    True\n    >>> pal.get(90) == pal2.get(30)\n    True\n\nThis palette was modeled after the C{rainbow} command of R."}, {"type": "method", "name": "igraph.RainbowPalette.__getitem__", "documentation": "Returns the given color from the palette.\n\nValues are cached: if the specific value given has already been\nlooked up, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@note: you shouldn't override this method in subclasses, override\n  L{_get} instead. If you override this method, lookups in the\n  L{known_colors} dict won't work, so you won't be able to refer to\n  colors by names or RGBA quadruplets, only by integer indices. The\n  caching functionality will disappear as well. However,\n  feel free to override this method if this is exactly the behaviour\n  you want.\n\n@param v: the color to be retrieved. If it is an integer, it is\n  passed to L{Palette._get} to be translated to an RGBA quadruplet.\n  Otherwise it is passed to L{color_name_to_rgb()} to determine the\n  RGBA values.\n\n@return: the color as an RGBA quadruplet"}, {"type": "method", "name": "igraph.RainbowPalette.__init__", "documentation": "Creates a rainbow palette.\n\n@param n: the number of colors in the palette.\n@param s: the saturation of the colors in the palette.\n@param v: the value component of the colors in the palette.\n@param start: the hue at which the rainbow begins (between 0 and 1).\n@param end: the hue at which the rainbow ends (between 0 and 1).\n@param alpha: the alpha component of the colors in the palette."}, {"type": "method", "name": "igraph.RainbowPalette.__len__", "documentation": "Returns the number of colors in this palette"}, {"type": "method", "name": "igraph.RainbowPalette.__plot__", "documentation": "Plots the colors of the palette on the given Cairo context/mpl Axes\n\nSupported keywork arguments in both Cairo and matplotlib are:\n\n  - C{orientation}: the orientation of the palette. Must be one of\n    the following values: C{left-right}, C{bottom-top}, C{right-left}\n    or C{top-bottom}. Possible aliases: C{horizontal} = C{left-right},\n    C{vertical} = C{bottom-top}, C{lr} = C{left-right},\n    C{rl} = C{right-left}, C{tb} = C{top-bottom}, C{bt} = C{bottom-top}.\n    The default is C{left-right}.\n\nAdditional supported keyword arguments in Cairo are:\n\n  - C{border_width}: line width of the border shown around the palette.\n    If zero or negative, the border is turned off. Default is C{1}.\n\n  - C{grid_width}: line width of the grid that separates palette cells.\n    If zero or negative, the grid is turned off. The grid is also\n    turned off if the size of a cell is less than three times the given\n    line width. Default is C{0}.  Fractional widths are also allowed.\n\nKeyword arguments in matplotlib are passes to Axes.imshow."}, {"type": "method", "name": "igraph.RainbowPalette.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.RainbowPalette._get", "documentation": "Returns the color corresponding to the given color index.\n\n@param v: numerical index of the color to be retrieved\n@return: a 4-tuple containing the RGBA values"}, {"type": "method", "name": "igraph.RainbowPalette.clear_cache", "documentation": "Clears the result cache.\n\nThe return values of L{Palette.get} are cached. Use this method\nto clear the cache."}, {"type": "method", "name": "igraph.RainbowPalette.get", "documentation": "Returns the given color from the palette.\n\nValues are cached: if the specific value given has already been\nlooked up, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@note: you shouldn't override this method in subclasses, override\n  L{_get} instead. If you override this method, lookups in the\n  L{known_colors} dict won't work, so you won't be able to refer to\n  colors by names or RGBA quadruplets, only by integer indices. The\n  caching functionality will disappear as well. However,\n  feel free to override this method if this is exactly the behaviour\n  you want.\n\n@param v: the color to be retrieved. If it is an integer, it is\n  passed to L{Palette._get} to be translated to an RGBA quadruplet.\n  Otherwise it is passed to L{color_name_to_rgb()} to determine the\n  RGBA values.\n\n@return: the color as an RGBA quadruplet"}, {"type": "method", "name": "igraph.RainbowPalette.get_many", "documentation": "Returns multiple colors from the palette.\n\nValues are cached: if the specific value given has already been\nlooked upon, its value will be returned from the cache instead of\ncalculating it again. Use L{Palette.clear_cache} to clear the cache\nif necessary.\n\n@param colors: the list of colors to be retrieved. The palette class\n  tries to make an educated guess here: if it is not possible to\n  interpret the value you passed here as a list of colors, the\n  class will simply try to interpret it as a single color by\n  forwarding the value to L{Palette.get}.\n@return: the colors as a list of RGBA quadruplets. The result will\n  be a list even if you passed a single color index or color name."}, {"type": "class", "name": "igraph.Rectangle", "documentation": "Class representing a rectangle."}, {"type": "method", "name": "igraph.Rectangle.__and__", "documentation": "Returns the intersection of this rectangle with another.\n\nExample::\n\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.intersection(r2)\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2 & r1\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2.intersection(r1) == r1.intersection(r2)\n    True\n    >>> r1.intersection(r3)\n    Rectangle(0.0, 0.0, 0.0, 0.0)"}, {"type": "method", "name": "igraph.Rectangle.__bool__", "documentation": null}, {"type": "method", "name": "igraph.Rectangle.__eq__", "documentation": "Return self==value."}, {"type": "method", "name": "igraph.Rectangle.__hash__", "documentation": "Return hash(self)."}, {"type": "method", "name": "igraph.Rectangle.__init__", "documentation": "Creates a rectangle.\n\nThe corners of the rectangle can be specified by either a tuple\n(four items, two for each corner, respectively), four separate numbers\n(X and Y coordinates for each corner) or two separate numbers (width\nand height, the upper left corner is assumed to be at (0,0))"}, {"type": "method", "name": "igraph.Rectangle.__ior__", "documentation": "Expands this rectangle to include itself and another completely while\nstill being as small as possible.\n\nExample::\n\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1 |= r2\n    >>> r1\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r1 |= r3\n    >>> r1\n    Rectangle(10.0, 10.0, 90.0, 90.0)"}, {"type": "method", "name": "igraph.Rectangle.__ne__", "documentation": "Return self!=value."}, {"type": "method", "name": "igraph.Rectangle.__or__", "documentation": "Returns the union of this rectangle with another.\n\nThe resulting rectangle is the smallest rectangle that contains both\nrectangles.\n\nExample::\n\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.union(r2)\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r2 | r1\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r2.union(r1) == r1.union(r2)\n    True\n    >>> r1.union(r3)\n    Rectangle(10.0, 10.0, 90.0, 90.0)"}, {"type": "method", "name": "igraph.Rectangle.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.Rectangle.contract", "documentation": "Contracts the rectangle by the given margins.\n\n@return: a new L{Rectangle} object."}, {"type": "method", "name": "igraph.Rectangle.expand", "documentation": "Expands the rectangle by the given margins.\n\n@return: a new L{Rectangle} object."}, {"type": "method", "name": "igraph.Rectangle.intersection", "documentation": "Returns the intersection of this rectangle with another.\n\nExample::\n\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.intersection(r2)\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2 & r1\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2.intersection(r1) == r1.intersection(r2)\n    True\n    >>> r1.intersection(r3)\n    Rectangle(0.0, 0.0, 0.0, 0.0)"}, {"type": "method", "name": "igraph.Rectangle.isdisjoint", "documentation": "Returns C{True} if the two rectangles have no intersection.\n\nExample::\n\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.isdisjoint(r2)\n    False\n    >>> r2.isdisjoint(r1)\n    False\n    >>> r1.isdisjoint(r3)\n    True\n    >>> r3.isdisjoint(r1)\n    True"}, {"type": "method", "name": "igraph.Rectangle.isempty", "documentation": "Returns C{True} if the rectangle is empty (i.e. it has zero\nwidth and height).\n\nExample::\n\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(70, 70, 90, 90)\n    >>> r1.isempty()\n    False\n    >>> r2.isempty()\n    False\n    >>> r1.intersection(r2).isempty()\n    True"}, {"type": "method", "name": "igraph.Rectangle.translate", "documentation": "Translates the rectangle in-place.\n\nExample:\n\n    >>> r = Rectangle(10, 20, 50, 70)\n    >>> r.translate(30, -10)\n    >>> r\n    Rectangle(40.0, 10.0, 80.0, 60.0)\n\n@param dx: the X coordinate of the translation vector\n@param dy: the Y coordinate of the translation vector"}, {"type": "method", "name": "igraph.Rectangle.union", "documentation": "Returns the union of this rectangle with another.\n\nThe resulting rectangle is the smallest rectangle that contains both\nrectangles.\n\nExample::\n\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.union(r2)\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r2 | r1\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r2.union(r1) == r1.union(r2)\n    True\n    >>> r1.union(r3)\n    Rectangle(10.0, 10.0, 90.0, 90.0)"}, {"type": "class", "name": "igraph.RunningMean", "documentation": "Running mean calculator.\n\nThis class can be used to calculate the mean of elements from a\nlist, tuple, iterable or any other data source. The mean is\ncalculated on the fly without explicitly summing the values,\nso it can be used for data sets with arbitrary item count. Also\ncapable of returning the standard deviation (also calculated on\nthe fly)"}, {"type": "method", "name": "igraph.RunningMean.__complex__", "documentation": null}, {"type": "method", "name": "igraph.RunningMean.__float__", "documentation": null}, {"type": "method", "name": "igraph.RunningMean.__init__", "documentation": "RunningMean(items=None, n=0.0, mean=0.0, sd=0.0)\n\nInitializes the running mean calculator.\n\nThere are two possible ways to initialize the calculator.\nFirst, one can provide an iterable of items; alternatively,\none can specify the number of items, the mean and the\nstandard deviation if we want to continue an interrupted\ncalculation.\n\n@param items: the items that are used to initialize the\n  running mean calcuator. If C{items} is given, C{n},\n  C{mean} and C{sd} must be zeros.\n@param n: the initial number of elements already processed.\n  If this is given, C{items} must be C{None}.\n@param mean: the initial mean. If this is given, C{items}\n  must be C{None}.\n@param sd: the initial standard deviation. If this is given,\n  C{items} must be C{None}."}, {"type": "method", "name": "igraph.RunningMean.__int__", "documentation": null}, {"type": "method", "name": "igraph.RunningMean.__len__", "documentation": null}, {"type": "method", "name": "igraph.RunningMean.__lshift__", "documentation": "RunningMean.add(values)\n\nAdds the values in the given iterable to the elements from\nwhich we calculate the mean. Can also accept a single number.\nThe left shift (C{<<}) operator is aliased to this function,\nso you can use it to add elements as well:\n\n  >>> rm=RunningMean()\n  >>> rm << [1,2,3,4]\n  >>> rm.result               # doctest:+ELLIPSIS\n  (2.5, 1.290994...)\n\n@param values: the element(s) to be added\n@type values: iterable"}, {"type": "method", "name": "igraph.RunningMean.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.RunningMean.__str__", "documentation": "Return str(self)."}, {"type": "method", "name": "igraph.RunningMean.add", "documentation": "RunningMean.add(value, repeat=1)\n\nAdds the given value to the elements from which we calculate\nthe mean and the standard deviation.\n\n@param value: the element to be added\n@param repeat: number of repeated additions"}, {"type": "method", "name": "igraph.RunningMean.add_many", "documentation": "RunningMean.add(values)\n\nAdds the values in the given iterable to the elements from\nwhich we calculate the mean. Can also accept a single number.\nThe left shift (C{<<}) operator is aliased to this function,\nso you can use it to add elements as well:\n\n  >>> rm=RunningMean()\n  >>> rm << [1,2,3,4]\n  >>> rm.result               # doctest:+ELLIPSIS\n  (2.5, 1.290994...)\n\n@param values: the element(s) to be added\n@type values: iterable"}, {"type": "method", "name": "igraph.RunningMean.clear", "documentation": "Resets the running mean calculator."}, {"type": "class", "name": "igraph.TriadCensus", "documentation": "Triad census of a graph.\n\nThis is a pretty simple class - basically it is a tuple, but it allows\nthe user to refer to its individual items by the following triad names:\n\n  - C{003} -- the empty graph\n  - C{012} -- a graph with a single directed edge (C{A --> B, C})\n  - C{102} -- a graph with a single mutual edge (C{A <-> B, C})\n  - C{021D} -- the binary out-tree (C{A <-- B --> C})\n  - C{021U} -- the binary in-tree (C{A --> B <-- C})\n  - C{021C} -- the directed line (C{A --> B --> C})\n  - C{111D} -- C{A <-> B <-- C}\n  - C{111U} -- C{A <-> B --> C}\n  - C{030T} -- C{A --> B <-- C, A --> C}\n  - C{030C} -- C{A <-- B <-- C, A --> C}\n  - C{201} -- C{A <-> B <-> C}\n  - C{120D} -- C{A <-- B --> C, A <-> C}\n  - C{120U} -- C{A --> B <-- C, A <-> C}\n  - C{120C} -- C{A --> B --> C, A <-> C}\n  - C{210C} -- C{A --> B <-> C, A <-> C}\n  - C{300} -- the complete graph (C{A <-> B <-> C, A <-> C})\n\nAttribute and item accessors are provided. Due to the syntax of Python,\nattribute names are not allowed to start with a number, therefore the\ntriad names must be prepended with a lowercase C{t} when accessing\nthem as attributes. This is not necessary with the item accessor syntax.\n\nExamples:\n\n  >>> from igraph import Graph\n  >>> g=Graph.Erdos_Renyi(100, 0.2, directed=True)\n  >>> tc=g.triad_census()\n  >>> print(tc.t003)                    #doctest:+SKIP\n  39864\n  >>> print(tc[\"030C\"])                 #doctest:+SKIP\n  1206"}, {"type": "method", "name": "igraph.TriadCensus.__getattr__", "documentation": null}, {"type": "method", "name": "igraph.TriadCensus.__getitem__", "documentation": "Return self[key]."}, {"type": "method", "name": "igraph.TriadCensus.__repr__", "documentation": "Return repr(self)."}, {"type": "method", "name": "igraph.TriadCensus.__str__", "documentation": "Return str(self)."}, {"type": "class", "name": "igraph.UniqueIdGenerator", "documentation": "A dictionary-like class that can be used to assign unique IDs to\nnames (say, vertex names).\n\nUsage:\n\n>>> gen = UniqueIdGenerator()\n>>> gen[\"A\"]\n0\n>>> gen[\"B\"]\n1\n>>> gen[\"C\"]\n2\n>>> gen[\"A\"]      # Retrieving already existing ID\n0\n>>> gen.add(\"D\")  # Synonym of gen[\"D\"]\n3\n>>> len(gen)      # Number of already used IDs\n4\n>>> \"C\" in gen\nTrue\n>>> \"E\" in gen\nFalse"}, {"type": "method", "name": "igraph.UniqueIdGenerator.__contains__", "documentation": "Checks whether C{item} already has an ID or not."}, {"type": "method", "name": "igraph.UniqueIdGenerator.__getitem__", "documentation": "Retrieves the ID corresponding to C{item}. Generates a new ID for\nC{item} if it is the first time we request an ID for it."}, {"type": "method", "name": "igraph.UniqueIdGenerator.__init__", "documentation": "Creates a new unique ID generator. C{id_generator} specifies how do we\nassign new IDs to elements that do not have an ID yet. If it is C{None},\nelements will be assigned integer identifiers starting from 0. If it is\nan integer, elements will be assigned identifiers starting from the given\ninteger. If it is an iterator or generator, its C{next()} method will be\ncalled every time a new ID is needed."}, {"type": "method", "name": "igraph.UniqueIdGenerator.__len__", "documentation": "Returns the number of items."}, {"type": "method", "name": "igraph.UniqueIdGenerator.__setitem__", "documentation": "Overrides the ID for C{item}."}, {"type": "method", "name": "igraph.UniqueIdGenerator.add", "documentation": "Retrieves the ID corresponding to C{item}. Generates a new ID for\nC{item} if it is the first time we request an ID for it."}, {"type": "method", "name": "igraph.UniqueIdGenerator.reverse_dict", "documentation": "Returns the reverse mapping, i.e., the one that maps from generated\nIDs to their corresponding objects"}, {"type": "method", "name": "igraph.UniqueIdGenerator.values", "documentation": "Returns the values stored so far. If the generator generates items\naccording to the standard sorting order, the values returned will be\nexactly in the order they were added. This holds for integer IDs for\ninstance (but for many other ID generators as well)."}, {"type": "class", "name": "igraph.Vertex", "documentation": "Class representing a single vertex in a graph.\n\nThe vertex is referenced by its index, so if the underlying graph\nchanges, the semantics of the vertex object might change as well\n(if the vertex indices are altered in the original graph).\n\nThe attributes of the vertex can be accessed by using the vertex\nas a hash:\n\n  >>> v[\"color\"] = \"red\"                  #doctest: +SKIP\n  >>> print(v[\"color\"])                     #doctest: +SKIP\n  red"}, {"type": "class", "name": "igraph.VertexClustering", "documentation": "The clustering of the vertex set of a graph.\n\nThis class extends L{Clustering} by linking it to a specific L{Graph} object\nand by optionally storing the modularity score of the clustering.\nIt also provides some handy methods like getting the subgraph corresponding\nto a cluster and such.\n\n@note: since this class is linked to a L{Graph}, destroying the graph by the\n  C{del} operator does not free the memory occupied by the graph if there\n  exists a L{VertexClustering} that references the L{Graph}."}, {"type": "method", "name": "igraph.VertexClustering.FromAttribute", "documentation": "Creates a vertex clustering based on the value of a vertex attribute.\n\nVertices having the same attribute will correspond to the same cluster.\n\n@param graph: the graph on which we are working\n@param attribute: name of the attribute on which the clustering\n    is based.\n@param intervals: for numeric attributes, you can either pass a single\n    number or a list of numbers here. A single number means that the\n    vertices will be put in bins of that width and vertices ending up\n    in the same bin will be in the same cluster. A list of numbers\n    specify the bin positions explicitly; e.g., C{[10, 20, 30]} means\n    that there will be four categories: vertices with the attribute\n    value less than 10, between 10 and 20, between 20 and 30 and over 30.\n    Intervals are closed from the left and open from the right.\n@param params: additional parameters to be stored in this object.\n\n@return: a new VertexClustering object"}, {"type": "method", "name": "igraph.VertexClustering.__getitem__", "documentation": "Returns the members of the specified cluster.\n\n@param idx: the index of the cluster\n@return: the members of the specified cluster as a list\n@raise IndexError: if the index is out of bounds"}, {"type": "method", "name": "igraph.VertexClustering.__init__", "documentation": "Creates a clustering object for a given graph.\n\n@param graph: the graph that will be associated to the clustering\n@param membership: the membership list. The length of the list must\n  be equal to the number of vertices in the graph. If C{None}, every\n  vertex is assumed to belong to the same cluster.\n@param modularity: the modularity score of the clustering. If C{None},\n  it will be calculated when needed.\n@param params: additional parameters to be stored in this object.\n@param modularity_params: arguments that should be passed to\n  L{Graph.modularity} when the modularity is (re)calculated. If the\n  original graph was weighted, you should pass a dictionary\n  containing a C{weight} key with the appropriate value here."}, {"type": "method", "name": "igraph.VertexClustering.__iter__", "documentation": "Iterates over the clusters in this clustering.\n\nThis method will return a generator that generates the clusters\none by one."}, {"type": "method", "name": "igraph.VertexClustering.__len__", "documentation": "Returns the number of clusters.\n\n@return: the number of clusters"}, {"type": "method", "name": "igraph.VertexClustering.__plot__", "documentation": "Plots the clustering to the given Cairo context or matplotlib Axes.\n\nThis is done by calling L{Graph.__plot__()} with the same arguments, but\ncoloring the graph vertices according to the current clustering (unless\noverridden by the C{vertex_color} argument explicitly).\n\nThis method understands all the positional and keyword arguments that\nare understood by L{Graph.__plot__()}, only the differences will be\nhighlighted here:\n\n  - C{mark_groups}: whether to highlight some of the vertex groups by\n    colored polygons. Besides the values accepted by L{Graph.__plot__}\n    (i.e., a dict mapping colors to vertex indices, a list containing\n    lists of vertex indices, or C{False}), the following are also\n    accepted:\n\n      - C{True}: all the groups will be highlighted, the colors matching\n        the corresponding color indices from the current palette\n        (see the C{palette} keyword argument of L{Graph.__plot__}).\n\n      - A dict mapping cluster indices or tuples of vertex indices to\n        color names.  The given clusters or vertex groups will be\n        highlighted by the given colors.\n\n      - A list of cluster indices. This is equivalent to passing a\n        dict mapping numeric color indices from the current palette\n        to cluster indices; therefore, the cluster referred to by element\n        I{i} of the list will be highlighted by color I{i} from the\n        palette.\n\n    The value of the C{plotting.mark_groups} configuration key is also\n    taken into account here; if that configuration key is C{True} and\n    C{mark_groups} is not given explicitly, it will automatically be set\n    to C{True}.\n\n    In place of lists of vertex indices, you may also use L{VertexSeq}\n    instances.\n\n    In place of color names, you may also use color indices into the\n    current palette. C{None} as a color name will mean that the\n    corresponding group is ignored.\n\n  - C{palette}: the palette used to resolve numeric color indices to RGBA\n    values. By default, this is an instance of L{ClusterColoringPalette}.\n\n@see: L{Graph.__plot__()} for more supported keyword arguments."}, {"type": "method", "name": "igraph.VertexClustering.__str__", "documentation": "Return str(self)."}, {"type": "method", "name": "igraph.VertexClustering._formatted_cluster_iterator", "documentation": "Iterates over the clusters and formats them into a string to be\npresented in the summary."}, {"type": "method", "name": "igraph.VertexClustering._recalculate_modularity_safe", "documentation": "Recalculates the stored modularity value and swallows all exceptions\nraised by the modularity function (if any).\n\n@return: the new modularity score or C{None} if the modularity function\ncould not be calculated."}, {"type": "method", "name": "igraph.VertexClustering.as_cover", "documentation": "Returns a L{VertexCover} that contains the same clusters as this\nclustering."}, {"type": "method", "name": "igraph.VertexClustering.cluster_graph", "documentation": "Returns a graph where each cluster is contracted into a single\nvertex.\n\nIn the resulting graph, vertex M{i} represents cluster M{i} in this\nclustering. Vertex M{i} and M{j} will be connected if there was\nat least one connected vertex pair M{(a, b)} in the original graph such\nthat vertex M{a} was in cluster M{i} and vertex M{b} was in cluster\nM{j}.\n\n@param combine_vertices: specifies how to derive the attributes of\n  the vertices in the new graph from the attributes of the old ones.\n  See L{Graph.contract_vertices()<igraph._igraph.GraphBase.contract_vertices>}\n  for more details.\n@param combine_edges: specifies how to derive the attributes of the\n  edges in the new graph from the attributes of the old ones. See\n  L{Graph.simplify()<igraph._igraph.GraphBase.simplify>} for more details.\n  If you specify C{False} here, edges will not be combined, and the\n  number of edges between the vertices representing the original\n  clusters will be equal to the number of edges between the members of\n  those clusters in the original graph.\n\n@return: the new graph."}, {"type": "method", "name": "igraph.VertexClustering.compare_to", "documentation": "Compares this clustering to another one using some similarity or\ndistance metric.\n\nThis is a convenience method that simply calls L{compare_communities}\nwith the two clusterings as arguments. Any extra positional or keyword\nargument is also forwarded to L{compare_communities}."}, {"type": "method", "name": "igraph.VertexClustering.crossing", "documentation": "Returns a boolean vector where element M{i} is C{True} iff edge\nM{i} lies between clusters, C{False} otherwise."}, {"type": "method", "name": "igraph.VertexClustering.giant", "documentation": "Returns the largest cluster of the clustered graph.\n\nThe largest cluster is a cluster for which no larger cluster exists in\nthe clustering. It may also be known as the I{giant community} if the\nclustering represents the result of a community detection function.\n\nPrecondition: the vertex set of the graph hasn't been modified since the\nmoment the cover was constructed.\n\n@note: there can be multiple largest clusters, this method will return\n  the copy of an arbitrary one if there are multiple largest clusters.\n\n@return: a copy of the largest cluster."}, {"type": "method", "name": "igraph.VertexClustering.recalculate_modularity", "documentation": "Recalculates the stored modularity value.\n\nThis method must be called before querying the modularity score of the\nclustering through the class member C{modularity} or C{q} if the\ngraph has been modified (edges have been added or removed) since the\ncreation of the L{VertexClustering} object.\n\n@return: the new modularity score"}, {"type": "method", "name": "igraph.VertexClustering.size", "documentation": "Returns the size of a given cluster.\n\n@param idx: the cluster in which we are interested."}, {"type": "method", "name": "igraph.VertexClustering.size_histogram", "documentation": "Returns the histogram of cluster sizes.\n\n@param bin_width: the bin width of the histogram\n@return: a L{Histogram} object"}, {"type": "method", "name": "igraph.VertexClustering.sizes", "documentation": "Returns the size of given clusters.\n\nThe indices are given as positional arguments. If there are no\npositional arguments, the function will return the sizes of all clusters."}, {"type": "method", "name": "igraph.VertexClustering.subgraph", "documentation": "Get the subgraph belonging to a given cluster.\n\nPrecondition: the vertex set of the graph hasn't been modified since the\nmoment the cover was constructed.\n\n@param idx: the cluster index\n@return: a copy of the subgraph"}, {"type": "method", "name": "igraph.VertexClustering.subgraphs", "documentation": "Gets all the subgraphs belonging to each of the clusters.\n\nPrecondition: the vertex set of the graph hasn't been modified since the\nmoment the cover was constructed.\n\n@return: a list containing copies of the subgraphs"}, {"type": "method", "name": "igraph.VertexClustering.summary", "documentation": "Returns the summary of the clustering.\n\nThe summary includes the number of items and clusters, and also the\nlist of members for each of the clusters if the verbosity is nonzero.\n\n@param verbosity: determines whether the cluster members should be\n  printed. Zero verbosity prints the number of items and clusters only.\n@return: the summary of the clustering as a string."}, {"type": "class", "name": "igraph.VertexCover", "documentation": "The cover of the vertex set of a graph.\n\nThis class extends L{Cover} by linking it to a specific L{Graph} object.\nIt also provides some handy methods like getting the subgraph corresponding\nto a cluster and such.\n\n@note: since this class is linked to a L{Graph}, destroying the graph by the\n  C{del} operator does not free the memory occupied by the graph if there\n  exists a L{VertexCover} that references the L{Graph}."}, {"type": "method", "name": "igraph.VertexCover.__getitem__", "documentation": "Returns the cluster with the given index."}, {"type": "method", "name": "igraph.VertexCover.__init__", "documentation": "Creates a cover object for a given graph.\n\n@param graph: the graph that will be associated to the cover\n@param clusters: the list of clusters. If C{None}, it is assumed\n  that there is only a single cluster that covers the whole graph."}, {"type": "method", "name": "igraph.VertexCover.__iter__", "documentation": "Iterates over the clusters in this cover."}, {"type": "method", "name": "igraph.VertexCover.__len__", "documentation": "Returns the number of clusters in this cover."}, {"type": "method", "name": "igraph.VertexCover.__plot__", "documentation": "Plots the cover to the given Cairo context or matplotlib Axes.\n\nThis is done by calling L{Graph.__plot__()} with the same arguments, but\ndrawing nice colored blobs around the vertex groups.\n\nThis method understands all the positional and keyword arguments that\nare understood by L{Graph.__plot__()}, only the differences will be\nhighlighted here:\n\n  - C{mark_groups}: whether to highlight the vertex clusters by\n    colored polygons. Besides the values accepted by L{Graph.__plot__}\n    (i.e., a dict mapping colors to vertex indices, a list containing\n    lists of vertex indices, or C{False}), the following are also\n    accepted:\n\n      - C{True}: all the clusters will be highlighted, the colors matching\n        the corresponding color indices from the current palette\n        (see the C{palette} keyword argument of L{Graph.__plot__}).\n\n      - A dict mapping cluster indices or tuples of vertex indices to\n        color names.  The given clusters or vertex groups will be\n        highlighted by the given colors.\n\n      - A list of cluster indices. This is equivalent to passing a\n        dict mapping numeric color indices from the current palette\n        to cluster indices; therefore, the cluster referred to by element\n        I{i} of the list will be highlighted by color I{i} from the\n        palette.\n\n    The value of the C{plotting.mark_groups} configuration key is also\n    taken into account here; if that configuration key is C{True} and\n    C{mark_groups} is not given explicitly, it will automatically be set\n    to C{True}.\n\n    In place of lists of vertex indices, you may also use L{VertexSeq}\n    instances.\n\n    In place of color names, you may also use color indices into the\n    current palette. C{None} as a color name will mean that the\n    corresponding group is ignored.\n\n  - C{palette}: the palette used to resolve numeric color indices to RGBA\n    values. By default, this is an instance of L{ClusterColoringPalette}.\n\n@see: L{Graph.__plot__()} for more supported keyword arguments."}, {"type": "method", "name": "igraph.VertexCover.__str__", "documentation": "Returns a string representation of the cover."}, {"type": "method", "name": "igraph.VertexCover._formatted_cluster_iterator", "documentation": "Iterates over the clusters and formats them into a string to be\npresented in the summary."}, {"type": "method", "name": "igraph.VertexCover._resolve_names_in_clusters", "documentation": null}, {"type": "method", "name": "igraph.VertexCover.crossing", "documentation": "Returns a boolean vector where element M{i} is C{True} iff edge\nM{i} lies between clusters, C{False} otherwise."}, {"type": "method", "name": "igraph.VertexCover.size", "documentation": "Returns the size of a given cluster.\n\n@param idx: the cluster in which we are interested."}, {"type": "method", "name": "igraph.VertexCover.size_histogram", "documentation": "Returns the histogram of cluster sizes.\n\n@param bin_width: the bin width of the histogram\n@return: a L{Histogram} object"}, {"type": "method", "name": "igraph.VertexCover.sizes", "documentation": "Returns the size of given clusters.\n\nThe indices are given as positional arguments. If there are no\npositional arguments, the function will return the sizes of all clusters."}, {"type": "method", "name": "igraph.VertexCover.subgraph", "documentation": "Get the subgraph belonging to a given cluster.\n\nPrecondition: the vertex set of the graph hasn't been modified since the\nmoment the cover was constructed.\n\n@param idx: the cluster index\n@return: a copy of the subgraph"}, {"type": "method", "name": "igraph.VertexCover.subgraphs", "documentation": "Gets all the subgraphs belonging to each of the clusters.\n\nPrecondition: the vertex set of the graph hasn't been modified since the\nmoment the cover was constructed.\n\n@return: a list containing copies of the subgraphs"}, {"type": "method", "name": "igraph.VertexCover.summary", "documentation": "Returns the summary of the cover.\n\nThe summary includes the number of items and clusters, and also the\nlist of members for each of the clusters if the verbosity is nonzero.\n\n@param verbosity: determines whether the cluster members should be\n  printed. Zero verbosity prints the number of items and clusters only.\n@return: the summary of the cover as a string."}, {"type": "class", "name": "igraph.VertexDendrogram", "documentation": "The dendrogram resulting from the hierarchical clustering of the\nvertex set of a graph."}, {"type": "method", "name": "igraph.VertexDendrogram.__init__", "documentation": "Creates a dendrogram object for a given graph.\n\n@param graph: the graph that will be associated to the clustering\n@param merges: the merges performed given in matrix form.\n@param optimal_count: the optimal number of clusters where the\n  dendrogram should be cut. This is a hint usually provided by the\n  clustering algorithm that produces the dendrogram. C{None} means\n  that such a hint is not available; the optimal count will then be\n  selected based on the modularity in such a case.\n@param modularity_params: arguments that should be passed to\n  L{Graph.modularity} when the modularity is (re)calculated. If the\n  original graph was weighted, you should pass a dictionary\n  containing a C{weight} key with the appropriate value here."}, {"type": "method", "name": "igraph.VertexDendrogram.__plot__", "documentation": "Draws the vertex dendrogram on the given Cairo context or matplotlib Axes\n\nSee L{Dendrogram.__plot__} for the list of supported keyword\narguments."}, {"type": "method", "name": "igraph.VertexDendrogram.__str__", "documentation": "Return str(self)."}, {"type": "method", "name": "igraph.VertexDendrogram._convert_matrix_to_tuple_repr", "documentation": "Converts the matrix representation of a clustering to a tuple\nrepresentation.\n\n@param merges: the matrix representation of the clustering\n@return: the tuple representation of the clustering"}, {"type": "method", "name": "igraph.VertexDendrogram._traverse_inorder", "documentation": "Conducts an inorder traversal of the merge tree.\n\nThe inorder traversal returns the nodes on the last level in the order\nthey should be drawn so that no edges cross each other.\n\n@return: the result of the inorder traversal in a list."}, {"type": "method", "name": "igraph.VertexDendrogram.as_clustering", "documentation": "Cuts the dendrogram at the given level and returns a corresponding\nL{VertexClustering} object.\n\n@param n: the desired number of clusters. Merges are replayed from the\n  beginning until the membership vector has exactly M{n} distinct elements\n  or until there are no more recorded merges, whichever happens first.\n  If C{None}, the optimal count hint given by the clustering algorithm\n  will be used If the optimal count was not given either, it will be\n  calculated by selecting the level where the modularity is maximal.\n@return: a new L{VertexClustering} object."}, {"type": "method", "name": "igraph.VertexDendrogram.format", "documentation": "Formats the dendrogram in a foreign format.\n\nCurrently only the Newick format is supported.\n\nExample:\n\n    >>> d = Dendrogram([(2, 3), (0, 1), (4, 5)])\n    >>> d.format()\n    '((2,3)4,(0,1)5)6;'\n    >>> d.names = list(\"ABCDEFG\")\n    >>> d.format()\n    '((C,D)E,(A,B)F)G;'"}, {"type": "method", "name": "igraph.VertexDendrogram.summary", "documentation": "Returns the summary of the dendrogram.\n\nThe summary includes the number of leafs and branches, and also an\nASCII art representation of the dendrogram unless it is too large.\n\n@param verbosity: determines whether the ASCII representation of the\n  dendrogram should be printed. Zero verbosity prints only the number\n  of leafs and branches.\n@param max_leaf_count: the maximal number of leafs to print in the\n  ASCII representation. If the dendrogram has more leafs than this\n  limit, the ASCII representation will not be printed even if the\n  verbosity is larger than or equal to 1.\n@return: the summary of the dendrogram as a string."}, {"type": "class", "name": "igraph.VertexSeq", "documentation": "Class representing a sequence of vertices in the graph.\n\nThis class is most easily accessed by the C{vs} field of the\nL{Graph} object, which returns an ordered sequence of all vertices in\nthe graph. The vertex sequence can be refined by invoking the\nL{VertexSeq.select()} method. L{VertexSeq.select()} can also be\naccessed by simply calling the L{VertexSeq} object.\n\nAn alternative way to create a vertex sequence referring to a given\ngraph is to use the constructor directly:\n\n  >>> g = Graph.Full(3)\n  >>> vs = VertexSeq(g)\n  >>> restricted_vs = VertexSeq(g, [0, 1])\n\nThe individual vertices can be accessed by indexing the vertex sequence\nobject. It can be used as an iterable as well, or even in a list\ncomprehension:\n\n  >>> g=Graph.Full(3)\n  >>> for v in g.vs:\n  ...   v[\"value\"] = v.index ** 2\n  ...\n  >>> [v[\"value\"] ** 0.5 for v in g.vs]\n  [0.0, 1.0, 2.0]\n\nThe vertex set can also be used as a dictionary where the keys are the\nattribute names. The values corresponding to the keys are the values\nof the given attribute for every vertex selected by the sequence.\n\n  >>> g=Graph.Full(3)\n  >>> for idx, v in enumerate(g.vs):\n  ...   v[\"weight\"] = idx*(idx+1)\n  ...\n  >>> g.vs[\"weight\"]\n  [0, 2, 6]\n  >>> g.vs.select(1,2)[\"weight\"] = [10, 20]\n  >>> g.vs[\"weight\"]\n  [0, 10, 20]\n\nIf you specify a sequence that is shorter than the number of vertices in\nthe VertexSeq, the sequence is reused:\n\n  >>> g = Graph.Tree(7, 2)\n  >>> g.vs[\"color\"] = [\"red\", \"green\"]\n  >>> g.vs[\"color\"]\n  ['red', 'green', 'red', 'green', 'red', 'green', 'red']\n\nYou can even pass a single string or integer, it will be considered as a\nsequence of length 1:\n\n  >>> g.vs[\"color\"] = \"red\"\n  >>> g.vs[\"color\"]\n  ['red', 'red', 'red', 'red', 'red', 'red', 'red']\n\nSome methods of the vertex sequences are simply proxy methods to the\ncorresponding methods in the L{Graph} object. One such example is\nC{VertexSeq.degree()}:\n\n  >>> g=Graph.Tree(7, 2)\n  >>> g.vs.degree()\n  [2, 3, 3, 1, 1, 1, 1]\n  >>> g.vs.degree() == g.degree()\n  True"}, {"type": "method", "name": "igraph.VertexSeq.__call__", "documentation": "Shorthand notation to select()\n\nThis method simply passes all its arguments to L{VertexSeq.select()}."}, {"type": "method", "name": "igraph.VertexSeq.attributes", "documentation": "Returns the list of all the vertex attributes in the graph\nassociated to this vertex sequence."}, {"type": "method", "name": "igraph.VertexSeq.betweenness", "documentation": "Proxy method to L{Graph.betweenness()}\n\nThis method calls the C{betweenness()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.betweenness() for details."}, {"type": "method", "name": "igraph.VertexSeq.bibcoupling", "documentation": "Proxy method to L{Graph.bibcoupling()}\n\nThis method calls the C{bibcoupling()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.bibcoupling() for details."}, {"type": "method", "name": "igraph.VertexSeq.closeness", "documentation": "Proxy method to L{Graph.closeness()}\n\nThis method calls the C{closeness()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.closeness() for details."}, {"type": "method", "name": "igraph.VertexSeq.cocitation", "documentation": "Proxy method to L{Graph.cocitation()}\n\nThis method calls the C{cocitation()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.cocitation() for details."}, {"type": "method", "name": "igraph.VertexSeq.constraint", "documentation": "Proxy method to L{Graph.constraint()}\n\nThis method calls the C{constraint()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.constraint() for details."}, {"type": "method", "name": "igraph.VertexSeq.degree", "documentation": "Proxy method to L{Graph.degree()}\n\nThis method calls the C{degree()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.degree() for details."}, {"type": "method", "name": "igraph.VertexSeq.delete", "documentation": "Proxy method to L{Graph.delete_vertices()}\n\nThis method calls the C{delete_vertices()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.delete_vertices() for details."}, {"type": "method", "name": "igraph.VertexSeq.distances", "documentation": "Proxy method to L{Graph.distances()}\n\nThis method calls the C{distances()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.distances() for details."}, {"type": "method", "name": "igraph.VertexSeq.diversity", "documentation": "Proxy method to L{Graph.diversity()}\n\nThis method calls the C{diversity()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.diversity() for details."}, {"type": "method", "name": "igraph.VertexSeq.eccentricity", "documentation": "Proxy method to L{Graph.eccentricity()}\n\nThis method calls the C{eccentricity()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.eccentricity() for details."}, {"type": "method", "name": "igraph.VertexSeq.find", "documentation": "Returns the first vertex of the vertex sequence that matches some\ncriteria.\n\nThe selection criteria are equal to the ones allowed by L{VertexSeq.select}.\nSee L{VertexSeq.select} for more details.\n\nFor instance, to find the first vertex with name C{foo} in graph C{g}:\n\n    >>> g.vs.find(name=\"foo\")            #doctest:+SKIP\n\nTo find an arbitrary isolated vertex:\n\n    >>> g.vs.find(_degree=0)             #doctest:+SKIP"}, {"type": "method", "name": "igraph.VertexSeq.get_shortest_paths", "documentation": "Proxy method to L{Graph.get_shortest_paths()}\n\nThis method calls the C{get_shortest_paths()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.get_shortest_paths() for details."}, {"type": "method", "name": "igraph.VertexSeq.indegree", "documentation": "Proxy method to L{Graph.indegree()}\n\nThis method calls the C{indegree()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.indegree() for details."}, {"type": "method", "name": "igraph.VertexSeq.is_minimal_separator", "documentation": "Proxy method to L{Graph.is_minimal_separator()}\n\nThis method calls the C{is_minimal_separator()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.is_minimal_separator() for details."}, {"type": "method", "name": "igraph.VertexSeq.is_separator", "documentation": "Proxy method to L{Graph.is_separator()}\n\nThis method calls the C{is_separator()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.is_separator() for details."}, {"type": "method", "name": "igraph.VertexSeq.isoclass", "documentation": "Proxy method to L{Graph.isoclass()}\n\nThis method calls the C{isoclass()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.isoclass() for details."}, {"type": "method", "name": "igraph.VertexSeq.maxdegree", "documentation": "Proxy method to L{Graph.maxdegree()}\n\nThis method calls the C{maxdegree()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.maxdegree() for details."}, {"type": "method", "name": "igraph.VertexSeq.outdegree", "documentation": "Proxy method to L{Graph.outdegree()}\n\nThis method calls the C{outdegree()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.outdegree() for details."}, {"type": "method", "name": "igraph.VertexSeq.pagerank", "documentation": "Proxy method to L{Graph.pagerank()}\n\nThis method calls the C{pagerank()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.pagerank() for details."}, {"type": "method", "name": "igraph.VertexSeq.personalized_pagerank", "documentation": "Proxy method to L{Graph.personalized_pagerank()}\n\nThis method calls the C{personalized_pagerank()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.personalized_pagerank() for details."}, {"type": "method", "name": "igraph.VertexSeq.select", "documentation": "Selects a subset of the vertex sequence based on some criteria\n\nThe selection criteria can be specified by the positional and the keyword\narguments. Positional arguments are always processed before keyword\narguments.\n\n  - If the first positional argument is C{None}, an empty sequence is\n    returned.\n\n  - If the first positional argument is a callable object, the object\n    will be called for every vertex in the sequence. If it returns\n    C{True}, the vertex will be included, otherwise it will\n    be excluded.\n\n  - If the first positional argument is an iterable, it must return\n    integers and they will be considered as indices of the current\n    vertex set (NOT the whole vertex set of the graph -- the\n    difference matters when one filters a vertex set that has\n    already been filtered by a previous invocation of\n    L{VertexSeq.select()}. In this case, the indices do not refer\n    directly to the vertices of the graph but to the elements of\n    the filtered vertex sequence.\n\n  - If the first positional argument is an integer, all remaining\n    arguments are expected to be integers. They are considered as\n    indices of the current vertex set again.\n\nKeyword arguments can be used to filter the vertices based on their\nattributes. The name of the keyword specifies the name of the attribute\nand the filtering operator, they should be concatenated by an\nunderscore (C{_}) character. Attribute names can also contain\nunderscores, but operator names don't, so the operator is always the\nlargest trailing substring of the keyword name that does not contain\nan underscore. Possible operators are:\n\n  - C{eq}: equal to\n\n  - C{ne}: not equal to\n\n  - C{lt}: less than\n\n  - C{gt}: greater than\n\n  - C{le}: less than or equal to\n\n  - C{ge}: greater than or equal to\n\n  - C{in}: checks if the value of an attribute is in a given list\n\n  - C{notin}: checks if the value of an attribute is not in a given\n    list\n\nFor instance, if you want to filter vertices with a numeric C{age}\nproperty larger than 200, you have to write:\n\n  >>> g.vs.select(age_gt=200)                   #doctest: +SKIP\n\nSimilarly, to filter vertices whose C{type} is in a list of predefined\ntypes:\n\n  >>> list_of_types = [\"HR\", \"Finance\", \"Management\"]\n  >>> g.vs.select(type_in=list_of_types)        #doctest: +SKIP\n\nIf the operator is omitted, it defaults to C{eq}. For instance, the\nfollowing selector selects vertices whose C{cluster} property equals\nto 2:\n\n  >>> g.vs.select(cluster=2)                    #doctest: +SKIP\n\nIn the case of an unknown operator, it is assumed that the\nrecognized operator is part of the attribute name and the actual\noperator is C{eq}.\n\nAttribute names inferred from keyword arguments are treated specially\nif they start with an underscore (C{_}). These are not real attributes\nbut refer to specific properties of the vertices, e.g., its degree.\nThe rule is as follows: if an attribute name starts with an underscore,\nthe rest of the name is interpreted as a method of the L{Graph} object.\nThis method is called with the vertex sequence as its first argument\n(all others left at default values) and vertices are filtered\naccording to the value returned by the method. For instance, if you\nwant to exclude isolated vertices:\n\n  >>> g = Graph.Famous(\"zachary\")\n  >>> non_isolated = g.vs.select(_degree_gt=0)\n\nFor properties that take a long time to be computed (e.g., betweenness\ncentrality for large graphs), it is advised to calculate the values\nin advance and store it in a graph attribute. The same applies when\nyou are selecting based on the same property more than once in the\nsame C{select()} call to avoid calculating it twice unnecessarily.\nFor instance, the following would calculate betweenness centralities\ntwice:\n\n  >>> edges = g.vs.select(_betweenness_gt=10, _betweenness_lt=30)\n\nIt is advised to use this instead:\n\n  >>> g.vs[\"bs\"] = g.betweenness()\n  >>> edges = g.vs.select(bs_gt=10, bs_lt=30)\n\n@return: the new, filtered vertex sequence"}, {"type": "method", "name": "igraph.VertexSeq.shortest_paths", "documentation": "Proxy method to L{Graph.shortest_paths()}\n\nThis method calls the C{shortest_paths()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.shortest_paths() for details."}, {"type": "method", "name": "igraph.VertexSeq.similarity_dice", "documentation": "Proxy method to L{Graph.similarity_dice()}\n\nThis method calls the C{similarity_dice()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.similarity_dice() for details."}, {"type": "method", "name": "igraph.VertexSeq.similarity_jaccard", "documentation": "Proxy method to L{Graph.similarity_jaccard()}\n\nThis method calls the C{similarity_jaccard()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.similarity_jaccard() for details."}, {"type": "method", "name": "igraph.VertexSeq.subgraph", "documentation": "Proxy method to L{Graph.subgraph()}\n\nThis method calls the C{subgraph()} method of the L{Graph} class\nrestricted to this sequence, and returns the result.\n\n@see: Graph.subgraph() for details."}, {"type": "function", "name": "igraph._all_st_cuts", "documentation": "Returns all the cuts between the source and target vertices in a\ndirected graph.\n\nThis function lists all edge-cuts between a source and a target vertex.\nEvery cut is listed exactly once.\n\nB{Reference}: JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in\ngraphs. I{Algorithmica} 15, 351-372, 1996.\n\n@param source: the source vertex ID\n@param target: the target vertex ID\n@return: a list of L{Cut} objects."}, {"type": "function", "name": "igraph._all_st_mincuts", "documentation": "Returns all the mincuts between the source and target vertices in a\ndirected graph.\n\nThis function lists all minimum edge-cuts between a source and a target\nvertex.\n\nB{Reference}: JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in\ngraphs. I{Algorithmica} 15, 351-372, 1996.\n\n@param source: the source vertex ID\n@param target: the target vertex ID\n@param capacity: the edge capacities (weights). If C{None}, all\n  edges have equal weight. May also be an attribute name.\n@return: a list of L{Cut} objects."}, {"type": "function", "name": "igraph._clear", "documentation": "Clears the graph, deleting all vertices, edges, and attributes.\n\n@see: L{GraphBase.delete_vertices} and L{Graph.delete_edges}."}, {"type": "function", "name": "igraph._clusters", "documentation": "Deprecated alias to L{Graph.connected_components()}."}, {"type": "function", "name": "igraph._degree_distribution", "documentation": "Calculates the degree distribution of the graph.\n\nUnknown keyword arguments are directly passed to L{GraphBase.degree}.\n\n@param bin_width: the bin width of the histogram\n@return: a histogram representing the degree distribution of the\n  graph."}, {"type": "function", "name": "igraph._export_edge_dataframe", "documentation": "Export edges with attributes to pandas.DataFrame\n\nIf you want to use source and target vertex IDs as index, you can do:\n\n>>> from string import ascii_letters\n>>> graph = Graph.GRG(25, 0.4)\n>>> graph.vs[\"name\"] = ascii_letters[:graph.vcount()]\n>>> df = graph.get_edge_dataframe()\n>>> df.set_index(['source', 'target'], inplace=True)\n\nThe index will be a pandas.MultiIndex. You can use the C{drop=False}\noption to keep the C{source} and C{target} columns.\n\nIf you want to use vertex names in the source and target columns:\n\n>>> df = graph.get_edge_dataframe()\n>>> df_vert = graph.get_vertex_dataframe()\n>>> df['source'].replace(df_vert['name'], inplace=True)\n>>> df['target'].replace(df_vert['name'], inplace=True)\n>>> df_vert.set_index('name', inplace=True)  # Optional\n\n@return: a pandas.DataFrame representing edges and their attributes.\n  The index uses edge IDs, from 0 to M - 1 where M is the number of\n  edges. The first two columns of the dataframe represent the IDs of\n  source and target vertices for each edge. These columns have names\n  \"source\" and \"target\". If your edges have attributes with the same\n  names, they will be present in the dataframe, but not in the first\n  two columns."}, {"type": "function", "name": "igraph._export_vertex_dataframe", "documentation": "Export vertices with attributes to pandas.DataFrame\n\nIf you want to use vertex names as index, you can do:\n\n>>> from string import ascii_letters\n>>> graph = Graph.GRG(25, 0.4)\n>>> graph.vs[\"name\"] = ascii_letters[:graph.vcount()]\n>>> df = graph.get_vertex_dataframe()\n>>> df.set_index('name', inplace=True)\n\n@return: a pandas.DataFrame representing vertices and their attributes.\n  The index uses vertex IDs, from 0 to N - 1 where N is the number of\n  vertices."}, {"type": "function", "name": "igraph._get_biadjacency", "documentation": "Returns the bipartite adjacency matrix of a bipartite graph. The\nbipartite adjacency matrix is an M{n} times M{m} matrix, where M{n} and\nM{m} are the number of vertices in the two vertex classes.\n\n@param types: an igraph vector containing the vertex types, or an\n  attribute name. Anything that evalulates to C{False} corresponds to\n  vertices of the first kind, everything else to the second kind.\n@return: the bipartite adjacency matrix and two lists in a triplet. The\n  first list defines the mapping between row indices of the matrix and the\n  original vertex IDs. The second list is the same for the column indices."}, {"type": "function", "name": "igraph._get_inclist", "documentation": "Returns the incidence list representation of the graph.\n\nThe incidence list representation is a list of lists. Each\nitem of the outer list belongs to a single vertex of the graph.\nThe inner list contains the IDs of the incident edges of the\ngiven vertex.\n\n@param mode: if C{\"out\"}, returns the successors of the vertex. If\n  C{\"in\"}, returns the predecessors of the vertex. If C{\"all\"}, both\n  the predecessors and the successors will be returned. Ignored\n  for undirected graphs."}, {"type": "function", "name": "igraph._gomory_hu_tree", "documentation": "Calculates the Gomory-Hu tree of an undirected graph with optional\nedge capacities.\n\nThe Gomory-Hu tree is a concise representation of the value of all the\nmaximum flows (or minimum cuts) in a graph. The vertices of the tree\ncorrespond exactly to the vertices of the original graph in the same order.\nEdges of the Gomory-Hu tree are annotated by flow values.  The value of\nthe maximum flow (or minimum cut) between an arbitrary (u,v) vertex\npair in the original graph is then given by the minimum flow value (i.e.\nedge annotation) along the shortest path between u and v in the\nGomory-Hu tree.\n\n@param capacity: the edge capacities (weights). If C{None}, all\n  edges have equal weight. May also be an attribute name.\n@param flow: the name of the edge attribute in the returned graph\n  in which the flow values will be stored.\n@return: the Gomory-Hu tree as a L{Graph} object."}, {"type": "function", "name": "igraph._indegree", "documentation": "Returns the in-degrees in a list.\n\nSee L{GraphBase.degree} for possible arguments."}, {"type": "function", "name": "igraph._maxflow", "documentation": "Returns a maximum flow between the given source and target vertices\nin a graph.\n\nA maximum flow from I{source} to I{target} is an assignment of\nnon-negative real numbers to the edges of the graph, satisfying\ntwo properties:\n\n    1. For each edge, the flow (i.e. the assigned number) is not\n       more than the capacity of the edge (see the I{capacity}\n       argument)\n\n    2. For every vertex except the source and the target, the\n       incoming flow is the same as the outgoing flow.\n\nThe value of the flow is the incoming flow of the target or the\noutgoing flow of the source (which are equal). The maximum flow\nis the maximum possible such value.\n\n@param capacity: the edge capacities (weights). If C{None}, all\n  edges have equal weight. May also be an attribute name.\n@return: a L{Flow} object describing the maximum flow"}, {"type": "function", "name": "igraph._mincut", "documentation": "Calculates the minimum cut between the given source and target vertices\nor within the whole graph.\n\nThe minimum cut is the minimum set of edges that needs to be removed to\nseparate the source and the target (if they are given) or to disconnect the\ngraph (if neither the source nor the target are given). The minimum is\ncalculated using the weights (capacities) of the edges, so the cut with\nthe minimum total capacity is calculated.\n\nFor undirected graphs and no source and target, the method uses the\nStoer-Wagner algorithm. For a given source and target, the method uses the\npush-relabel algorithm; see the references below.\n\n@param source: the source vertex ID. If C{None}, the target must also be\n  C{None} and the calculation will be done for the entire graph (i.e.\n  all possible vertex pairs).\n@param target: the target vertex ID. If C{None}, the source must also be\n  C{None} and the calculation will be done for the entire graph (i.e.\n  all possible vertex pairs).\n@param capacity: the edge capacities (weights). If C{None}, all\n  edges have equal weight. May also be an attribute name.\n@return: a L{Cut} object describing the minimum cut"}, {"type": "function", "name": "igraph._outdegree", "documentation": "Returns the out-degrees in a list.\n\nSee L{GraphBase.degree} for possible arguments."}, {"type": "function", "name": "igraph._pagerank", "documentation": "Calculates the PageRank values of a graph.\n\n@param vertices: the indices of the vertices being queried.\n  C{None} means all of the vertices.\n@param directed: whether to consider directed paths.\n@param damping: the damping factor. M{1-damping} is the probability of\n  resetting the random walk to a uniform distribution in each step.\n@param weights: edge weights to be used. Can be a sequence or iterable\n  or even an edge attribute name.\n@param arpack_options: an L{ARPACKOptions} object used to fine-tune\n  the ARPACK eigenvector calculation. If omitted, the module-level\n  variable called C{arpack_options} is used. This argument is\n  ignored if not the ARPACK implementation is used, see the\n  I{implementation} argument.\n@param implementation: which implementation to use to solve the\n  PageRank eigenproblem. Possible values are:\n    - C{\"prpack\"}: use the PRPACK library. This is a new\n      implementation in igraph 0.7\n    - C{\"arpack\"}: use the ARPACK library. This implementation\n      was used from version 0.5, until version 0.7.\n@return: a list with the PageRank values of the specified vertices."}, {"type": "function", "name": "igraph._shortest_paths", "documentation": "Deprecated alias to L{Graph.distances()}."}, {"type": "function", "name": "igraph._st_mincut", "documentation": "Calculates the minimum cut between the source and target vertices in a\ngraph.\n\n@param source: the source vertex ID\n@param target: the target vertex ID\n@param capacity: the capacity of the edges. It must be a list or a valid\n  attribute name or C{None}. In the latter case, every edge will have the\n  same capacity.\n@return: the value of the minimum cut, the IDs of vertices in the\n  first and second partition, and the IDs of edges in the cut,\n  packed in a 4-tuple"}, {"type": "function", "name": "igraph._write_graph_to_adjacency_file", "documentation": "Writes the adjacency matrix of the graph to the given file\n\nAll the remaining arguments not mentioned here are passed intact\nto L{Graph.get_adjacency}.\n\n@param f: the name of the file to be written.\n@param sep: the string that separates the matrix elements in a row\n@param eol: the string that separates the rows of the matrix. Please\n  note that igraph is able to read back the written adjacency matrix\n  if and only if this is a single newline character"}, {"type": "function", "name": "igraph._write_graph_to_dimacs_file", "documentation": "Writes the graph in DIMACS format to the given file.\n\n@param f: the name of the file to be written or a Python file handle.\n@param source: the source vertex ID. If C{None}, igraph will try to\n  infer it from the C{source} graph attribute.\n@param target: the target vertex ID. If C{None}, igraph will try to\n  infer it from the C{target} graph attribute.\n@param capacity: the capacities of the edges in a list or the name of\n  an edge attribute that holds the capacities. If there is no such\n  edge attribute, every edge will have a capacity of 1."}, {"type": "function", "name": "igraph._write_graph_to_file", "documentation": "Unified writing function for graphs.\n\nThis method tries to identify the format of the graph given in\nthe first parameter (based on extension) and calls the corresponding\nwriter method.\n\nThe remaining arguments are passed to the writer method without\nany changes.\n\n@param f: the file containing the graph to be saved\n@param format: the format of the file (if one wants to override the\n  format determined from the filename extension, or the filename itself\n  is a stream). C{None} means auto-detection. Possible values are:\n\n    - C{\"adjacency\"}: adjacency matrix format\n\n    - C{\"dimacs\"}: DIMACS format\n\n    - C{\"dot\"}, C{\"graphviz\"}: GraphViz DOT format\n\n    - C{\"edgelist\"}, C{\"edges\"} or C{\"edge\"}: numeric edge list format\n\n    - C{\"gml\"}: GML format\n\n    - C{\"graphml\"} and C{\"graphmlz\"}: standard and gzipped GraphML\n      format\n\n    - C{\"gw\"}, C{\"leda\"}, C{\"lgr\"}: LEDA native format\n\n    - C{\"lgl\"}: LGL format\n\n    - C{\"ncol\"}: NCOL format\n\n    - C{\"net\"}, C{\"pajek\"}: Pajek format\n\n    - C{\"pickle\"}, C{\"picklez\"}: standard and gzipped Python pickled\n      format\n\n    - C{\"svg\"}: SVG format\n\n@raises IOError: if the file format can't be identified and\n  none was given."}, {"type": "function", "name": "igraph._write_graph_to_graphmlz_file", "documentation": "Writes the graph to a zipped GraphML file.\n\nThe library uses the gzip compression algorithm, so the resulting\nfile can be unzipped with regular gzip uncompression (like\nC{gunzip} or C{zcat} from Unix command line) or the Python C{gzip}\nmodule.\n\nUses a temporary file to store intermediate GraphML data, so\nmake sure you have enough free space to store the unzipped\nGraphML file as well.\n\n@param f: the name of the file to be written.\n@param compresslevel: the level of compression. 1 is fastest and\n  produces the least compression, and 9 is slowest and produces\n  the most compression."}, {"type": "function", "name": "igraph._write_graph_to_pickle_file", "documentation": "Saves the graph in Python pickled format\n\n@param fname: the name of the file or a stream to save to. If\n  C{None}, saves the graph to a string and returns the string.\n@param version: pickle protocol version to be used. If -1, uses\n  the highest protocol available\n@return: C{None} if the graph was saved successfully to the\n  given file, or a string if C{fname} was C{None}."}, {"type": "function", "name": "igraph._write_graph_to_picklez_file", "documentation": "Saves the graph in Python pickled format, compressed with\ngzip.\n\nSaving in this format is a bit slower than saving in a Python pickle\nwithout compression, but the final file takes up much less space on\nthe hard drive.\n\n@param fname: the name of the file or a stream to save to.\n@param version: pickle protocol version to be used. If -1, uses\n  the highest protocol available\n@return: C{None} if the graph was saved successfully to the\n  given file."}, {"type": "function", "name": "igraph._write_graph_to_svg", "documentation": "Saves the graph as an SVG (Scalable Vector Graphics) file\n\nThe file will be Inkscape (http://inkscape.org) compatible.\nIn Inkscape, as nodes are rearranged, the edges auto-update.\n\n@param fname: the name of the file or a Python file handle\n@param layout: the layout of the graph. Can be either an\n  explicitly specified layout (using a list of coordinate\n  pairs) or the name of a layout algorithm (which should\n  refer to a method in the L{Graph} object, but without\n  the C{layout_} prefix.\n@param width: the preferred width in pixels (default: 400)\n@param height: the preferred height in pixels (default: 400)\n@param labels: the vertex labels. Either it is the name of\n  a vertex attribute to use, or a list explicitly specifying\n  the labels. It can also be C{None}.\n@param colors: the vertex colors. Either it is the name of\n  a vertex attribute to use, or a list explicitly specifying\n  the colors. A color can be anything acceptable in an SVG\n  file.\n@param shapes: the vertex shapes. Either it is the name of\n  a vertex attribute to use, or a list explicitly specifying\n  the shapes as integers. Shape 0 means hidden (nothing is drawn),\n  shape 1 is a circle, shape 2 is a rectangle and shape 3 is a\n  rectangle that automatically sizes to the inner text.\n@param vertex_size: vertex size in pixels\n@param edge_colors: the edge colors. Either it is the name\n  of an edge attribute to use, or a list explicitly specifying\n  the colors. A color can be anything acceptable in an SVG\n  file.\n@param edge_stroke_widths: the stroke widths of the edges. Either\n  it is the name of an edge attribute to use, or a list explicitly\n  specifying the stroke widths. The stroke width can be anything\n  acceptable in an SVG file.\n@param font_size: font size. If it is a string, it is written into\n  the SVG file as-is (so you can specify anything which is valid\n  as the value of the C{font-size} style). If it is a number, it\n  is interpreted as pixel size and converted to the proper attribute\n  value accordingly."}, {"type": "function", "name": "igraph.autocurve", "documentation": "Calculates curvature values for each of the edges in the graph to make\nsure that multiple edges are shown properly on a graph plot.\n\nThis function checks the multiplicity of each edge in the graph and\nassigns curvature values (numbers between -1 and 1, corresponding to\nCCW (-1), straight (0) and CW (1) curved edges) to them. The assigned\nvalues are either stored in an edge attribute or returned as a list,\ndepending on the value of the I{attribute} argument.\n\n@param graph: the graph on which the calculation will be run\n@param attribute: the name of the edge attribute to save the curvature\n  values to. The default value is C{curved}, which is the name of the\n  edge attribute the default graph plotter checks to decide whether an\n  edge should be curved on the plot or not. If I{attribute} is C{None},\n  the result will not be stored.\n@param default: the default curvature for single edges. Zero means that\n  single edges will be straight. If you want single edges to be curved\n  as well, try passing 0.5 or -0.5 here.\n@return: the list of curvature values if I{attribute} is C{None},\n  otherwise C{None}."}, {"type": "function", "name": "igraph.color_name_to_rgb", "documentation": "Converts a color given in one of the supported color formats to\nR-G-B values.\n\nThis is done by calling L{color_name_to_rgba} and then throwing away\nthe alpha value.\n\n@see: color_name_to_rgba for more details about what formats are\n  understood by this function."}, {"type": "function", "name": "igraph.color_name_to_rgba", "documentation": "Converts a color given in one of the supported color formats to\nR-G-B-A values.\n\nExamples:\n\n  >>> color_name_to_rgba(\"red\")\n  (1.0, 0.0, 0.0, 1.0)\n  >>> color_name_to_rgba(\"#ff8000\") == (1.0, 128/255.0, 0.0, 1.0)\n  True\n  >>> color_name_to_rgba(\"#ff800080\") == (1.0, 128/255.0, 0.0, 128/255.0)\n  True\n  >>> color_name_to_rgba(\"#08f\") == (0.0, 136/255.0, 1.0, 1.0)\n  True\n  >>> color_name_to_rgba(\"rgb(100%, 50%, 0%)\")\n  (1.0, 0.5, 0.0, 1.0)\n  >>> color_name_to_rgba(\"rgba(100%, 50%, 0%, 25%)\")\n  (1.0, 0.5, 0.0, 0.25)\n  >>> color_name_to_rgba(\"hsla(120, 100%, 50%, 0.5)\")\n  (0.0, 1.0, 0.0, 0.5)\n  >>> color_name_to_rgba(\"hsl(60, 100%, 50%)\")\n  (1.0, 1.0, 0.0, 1.0)\n  >>> color_name_to_rgba(\"hsv(60, 100%, 100%)\")\n  (1.0, 1.0, 0.0, 1.0)\n\n@param color: the color to be converted in one of the following formats:\n  - B{CSS3 color specification}: C{#rrggbb}, C{#rgb}, C{#rrggbbaa}, C{#rgba},\n    C{rgb(red, green, blue)}, C{rgba(red, green, blue, alpha)},\n    C{hsl(hue, saturation, lightness)}, C{hsla(hue, saturation, lightness, alpha)},\n    C{hsv(hue, saturation, value)} and C{hsva(hue, saturation, value, alpha)}\n    where the components are given as hexadecimal numbers in the first four\n    cases and as decimals or percentages (0%-100%) in the remaining cases.\n    Red, green and blue components are between 0 and 255; hue is between 0\n    and 360; saturation, lightness and value is between 0 and 100; alpha is\n    between 0 and 1.\n  - B{Valid HTML color names}, i.e. those that are present in the HTML 4.0\n    specification\n  - B{Valid X11 color names}, see U{http://en.wikipedia.org/wiki/X11_color_names}\n  - B{Red-green-blue components} given separately in either a comma-, slash- or\n    whitespace-separated string or a list or a tuple, in the range of 0-255.\n    An alpha value of 255 (maximal opacity) will be assumed.\n  - B{Red-green-blue-alpha components} given separately in either a comma-, slash-\n    or whitespace-separated string or a list or a tuple, in the range of 0-255\n  - B{A single palette index} given either as a string or a number. Uses\n    the palette given in the C{palette} parameter of the method call.\n@param palette: the palette to be used if a single number is passed to\n  the method. Must be an instance of L{colors.Palette}.\n\n@return: the RGBA values corresponding to the given color in a 4-tuple.\n  Since these colors are primarily used by Cairo routines, the tuples\n  contain floats in the range 0.0-1.0"}, {"type": "function", "name": "igraph.compare_communities", "documentation": "Compares two community structures using various distance measures.\n\nFor measures involving entropies (e.g., the variation of information metric),\nigraph uses natural logarithms.\n\nB{References}\n\n  - Meila M: Comparing clusterings by the variation of information. In:\n    Scholkopf B, Warmuth MK (eds). Learning Theory and Kernel Machines: 16th\n    Annual Conference on Computational Learning Theory and 7th Kernel\n    Workship, COLT/Kernel 2003, Washington, DC, USA. Lecture Notes in Computer\n    Science, vol. 2777, Springer, 2003. ISBN: 978-3-540-40720-1.\n  - Danon L, Diaz-Guilera A, Duch J, Arenas A: Comparing community structure\n    identification. I{J Stat Mech} P09008, 2005.\n  - van Dongen S: Performance criteria for graph clustering and Markov\n    cluster experiments. Technical Report INS-R0012, National Research\n    Institute for Mathematics and Computer Science in the Netherlands,\n    Amsterdam, May 2000.\n  - Rand WM: Objective criteria for the evaluation of clustering\n    methods. I{J Am Stat Assoc} 66(336):846-850, 1971.\n  - Hubert L and Arabie P: Comparing partitions. I{Journal of\n    Classification} 2:193-218, 1985.\n\n@param comm1: the first community structure as a membership list or\n  as a L{Clustering} object.\n@param comm2: the second community structure as a membership list or\n  as a L{Clustering} object.\n@param method: the measure to use. C{\"vi\"} or C{\"meila\"} means the\n  variation of information metric of Meila (2003), C{\"nmi\"} or C{\"danon\"}\n  means the normalized mutual information as defined by Danon et al. (2005),\n  C{\"split-join\"} means the split-join distance of van Dongen (2000),\n  C{\"rand\"} means the Rand index of Rand (1971), C{\"adjusted_rand\"}\n  means the adjusted Rand index of Hubert and Arabie (1985).\n@param remove_none: whether to remove C{None} entries from the membership\n  lists. This is handy if your L{Clustering} object was constructed using\n  L{VertexClustering.FromAttribute} using an attribute which was not defined\n  for all the vertices. If C{remove_none} is C{False}, a C{None} entry in\n  either C{comm1} or C{comm2} will result in an exception. If C{remove_none}\n  is C{True}, C{None} values are filtered away and only the remaining lists\n  are compared.\n\n@return: the calculated measure."}, {"type": "function", "name": "igraph.deprecated", "documentation": "Prints a warning message related to the deprecation of some igraph\nfeature."}, {"type": "function", "name": "igraph.disjoint_union", "documentation": "Graph disjoint union.\n\nThe disjoint union of two or more graphs is created.\n\nThis function keeps the attributes of all graphs. All graph, vertex and\nedge attributes are copied to the result. If an attribute is present in\nmultiple graphs and would result a name clash, then this attribute is\nrenamed by adding suffixes: _1, _2, etc.\n\nAn error is generated if some input graphs are directed and others are\nundirected.\n\nParameters:\n    graphs: list of graphs. A lazy sequence is not acceptable.\n\nReturns:\n    the disjoint union graph"}, {"type": "function", "name": "igraph.get_include", "documentation": "Returns the folder that contains the C API headers of the Python\ninterface of igraph."}, {"type": "function", "name": "igraph.hsl_to_rgb", "documentation": "Converts a color given by its HSL coordinates (hue, saturation,\nlightness) to RGB coordinates.\n\nEach of the HSL coordinates must be in the range [0, 1]."}, {"type": "function", "name": "igraph.hsla_to_rgba", "documentation": "Converts a color given by its HSLA coordinates (hue, saturation,\nlightness, alpha) to RGBA coordinates.\n\nEach of the HSLA coordinates must be in the range [0, 1]."}, {"type": "function", "name": "igraph.hsv_to_rgb", "documentation": "Converts a color given by its HSV coordinates (hue, saturation,\nvalue) to RGB coordinates.\n\nEach of the HSV coordinates must be in the range [0, 1]."}, {"type": "function", "name": "igraph.hsva_to_rgba", "documentation": "Converts a color given by its HSVA coordinates (hue, saturation,\nvalue, alpha) to RGB coordinates.\n\nEach of the HSVA coordinates must be in the range [0, 1]."}, {"type": "function", "name": "igraph.init_configuration", "documentation": "Default mechanism to initiate igraph configuration\n\nThis method loads the user-specific configuration file from the\nuser's home directory, or if it does not exist, creates a default\nconfiguration.\n\nThe method is safe to be called multiple times, it will not parse\nthe configuration file twice.\n\n@return: the L{Configuration} object loaded or created."}, {"type": "function", "name": "igraph.intersection", "documentation": "Graph intersection.\n\nThe intersection of two or more graphs is created. The graphs may have\nidentical or overlapping vertex sets. Edges which are included in all\ngraphs will be part of the new graph.\n\nThis function keeps the attributes of all graphs. All graph, vertex and\nedge attributes are copied to the result. If an attribute is present in\nmultiple graphs and would result a name clash, then this attribute is\nrenamed by adding suffixes: _1, _2, etc.\n\nThe ``name`` vertex attribute is treated specially if the operation is\nperformed based on symbolic vertex names. In this case ``name`` must be\npresent in all graphs, and it is not renamed in the result graph.\n\nAn error is generated if some input graphs are directed and others are\nundirected.\n\nParameters:\n    graphs: list of graphs. A lazy sequence is not acceptable.\n    byname: bool or 'auto' specifying the function behaviour with\n        respect to names vertices (i.e. vertices with the 'name' attribute). If\n        False, ignore vertex names. If True, merge vertices based on names. If\n        'auto', use True if all graphs have named vertices and False otherwise\n        (in the latter case, a warning is generated too).\n    keep_all_vertices: bool specifying if vertices that are not present\n        in all graphs should be kept in the intersection.\n\nReturns:\n    the intersection graph\n\nRaises:\n    RuntimeError: if 'byname' is set to True and some graphs are not named or\n        the set of names is not unique in one of the graphs"}, {"type": "function", "name": "igraph.load", "documentation": "Loads a graph from the given filename.\n\nThis is just a convenience function, calls L{Graph.Read} directly.\nAll arguments are passed unchanged to L{Graph.Read}\n\n@param filename: the name of the file to be loaded"}, {"type": "function", "name": "igraph.mean", "documentation": "Returns the mean of an iterable.\n\nExample:\n\n    >>> mean([1, 4, 7, 11])\n    5.75\n\n@param xs: an iterable yielding numbers.\n@return: the mean of the numbers provided by the iterable.\n\n@see: RunningMean() if you also need the variance or the standard deviation"}, {"type": "function", "name": "igraph.median", "documentation": "Returns the median of an unsorted or sorted numeric vector.\n\n@param xs: the vector itself.\n@param sort: whether to sort the vector. If you know that the vector is\n  sorted already, pass C{False} here.\n@return: the median, which will always be a float, even if the vector\n  contained integers originally."}, {"type": "function", "name": "igraph.numpy_to_contiguous_memoryview", "documentation": "Converts a NumPy array or matrix into a contiguous memoryview object\nthat is suitable to be forwarded to the Graph constructor.\n\nThis is used internally to allow us to use a NumPy array or matrix\ndirectly when constructing a Graph."}, {"type": "function", "name": "igraph.percentile", "documentation": "Returns the pth percentile of an unsorted or sorted numeric vector.\n\nThis is equivalent to calling quantile(xs, p/100.0); see L{quantile}\nfor more details on the calculation.\n\nExample:\n\n    >>> round(percentile([15, 20, 40, 35, 50], 40), 2)\n    26.0\n    >>> for perc in percentile([15, 20, 40, 35, 50], (0, 25, 50, 75, 100)):\n    ...     print(\"%.2f\" % perc)\n    ...\n    15.00\n    17.50\n    35.00\n    45.00\n    50.00\n\n@param xs: the vector itself.\n@param p: the percentile we are looking for. It may also be a list if you\n  want to calculate multiple quantiles with a single call. The default\n  value calculates the 25th, 50th and 75th percentile.\n@param sort: whether to sort the vector. If you know that the vector is\n  sorted already, pass C{False} here.\n@return: the pth percentile, which will always be a float, even if the vector\n  contained integers originally. If p is a list, the result will also be a\n  list containing the percentiles for each item in the list."}, {"type": "function", "name": "igraph.plot", "documentation": "Plots the given object to the given target.\n\nPositional and keyword arguments not explicitly mentioned here will be\npassed down to the C{__plot__} method of the object being plotted.\nSince you are most likely interested in the keyword arguments available\nfor graph plots, see L{Graph.__plot__} as well.\n\n@param obj: the object to be plotted\n@param target: the target where the object should be plotted. It can be one\n  of the following types:\n\n    - C{matplotib.axes.Axes} -- a matplotlib/pyplot axes in which the\n      graph will be plotted. Drawing is delegated to the chosen matplotlib\n      backend, and you can use interactive backends and matplotlib\n      functions to save to file as well.\n\n    - C{string} -- a file with the given name will be created and the plot\n      will be stored there. If you are using the Cairo backend, an\n      appropriate Cairo surface will be attached to the file. If you are\n      using the matplotlib backend, the Figure will be saved to that file\n      using Figure.savefig with default parameters. The supported image\n      formats for Cairo are: PNG, PDF, SVG and PostScript; matplotlib might\n      support additional formats.\n\n    - C{cairo.Surface} -- the given Cairo surface will be used. This can\n      refer to a PNG image, an arbitrary window, an SVG file, anything that\n      Cairo can handle.\n\n    - C{None} -- If you are using the Cairo backend, no plotting will be\n      performed; igraph simply returns a CairoPlot_ object that you can use\n      to manipulate the plot and save it to a file later. If you are using\n      the matplotlib backend, a Figure objet and an Axes are created and\n      the Axes is returned so you can manipulate it further. Similarly, if\n      you are using the plotly backend, a Figure object is returned.\n\n@param bbox: the bounding box of the plot. It must be a tuple with either\n  two or four integers, or a L{BoundingBox} object. If this is a tuple\n  with two integers, it is interpreted as the width and height of the plot\n  (in pixels for PNG images and on-screen plots, or in points for PDF,\n  SVG and PostScript plots, where 72 pt = 1 inch = 2.54 cm). If this is\n  a tuple with four integers, the first two denotes the X and Y coordinates\n  of a corner and the latter two denoting the X and Y coordinates of the\n  opposite corner. Ignored for Matplotlib plots.\n\n@keyword opacity: the opacity of the object being plotted. It can be\n  used to overlap several plots of the same graph if you use the same\n  layout for them -- for instance, you might plot a graph with opacity\n  0.5 and then plot its spanning tree over it with opacity 0.1. To\n  achieve this, you'll need to modify the L{Plot} object returned with\n  L{Plot.add}. Ignored for Matplotlib plots.\n\n@keyword palette: the palette primarily used on the plot if the\n  added objects do not specify a private palette. Must be either\n  an L{igraph.drawing.colors.Palette} object or a string referring\n  to a valid key of C{igraph.drawing.colors.palettes} (see module\n  L{igraph.drawing.colors}) or C{None}. In the latter case, the default\n  palette given by the configuration key C{plotting.palette} is used.\n\n@keyword margin: the top, right, bottom, left margins as a 4-tuple.\n  If it has less than 4 elements or is a single float, the elements\n  will be re-used until the length is at least 4. The default margin\n  is 20 units on each side. Ignored for Matplotlib plots.\n\n@keyword inline: whether to try and show the plot object inline in the\n  current IPython notebook. Passing C{None} here or omitting this keyword\n  argument will look up the preferred behaviour from the\n  C{shell.ipython.inlining.Plot} configuration key.  Note that this keyword\n  argument has an effect only if igraph is run inside IPython and C{target}\n  is C{None}.\n\n@keyword backend: the plotting backend to use; one of C{\"cairo\"},\n  C{\"matplotlib\"} or C{\"plotly\"}. C{None} means to try to decide the backend\n  from the plotting target and the default igraph configuration object.\n\n@return: an appropriate L{CairoPlot} object for the Cairo backend, the\n  Matplotlib C{Axes} object for the Matplotlib backend, and the C{Figure}\n  object for the plotly backend.\n\n@see: Graph.__plot__"}, {"type": "function", "name": "igraph.power_law_fit", "documentation": "Fitting a power-law distribution to empirical data\n\nB{References}\n\n  - MEJ Newman: Power laws, Pareto distributions and Zipf's law.\n    I{Contemporary Physics} 46, 323-351 (2005)\n  - A Clauset, CR Shalizi, MEJ Newman: Power-law distributions\n    in empirical data. E-print (2007). arXiv:0706.1062\n\n@param data: the data to fit, a list containing integer values\n@param xmin: the lower bound for fitting the power-law. If C{None},\n  the optimal xmin value will be estimated as well. Zero means that\n  the smallest possible xmin value will be used.\n@param method: the fitting method to use. The following methods are\n  implemented so far:\n\n    - C{continuous}, C{hill}: exact maximum likelihood estimation\n      when the input data comes from a continuous scale. This is\n      known as the Hill estimator. The statistical error of\n      this estimator is M{(alpha-1) / sqrt(n)}, where alpha is the\n      estimated exponent and M{n} is the number of data points above\n      M{xmin}. The estimator is known to exhibit a small finite\n      sample-size bias of order M{O(n^-1)}, which is small when\n      M{n > 100}. igraph will try to compensate for the finite sample\n      size if n is small.\n\n    - C{discrete}: exact maximum likelihood estimation when the\n      input comes from a discrete scale (see Clauset et al. among the\n      references).\n\n    - C{auto}: exact maximum likelihood estimation where the continuous\n      method is used if the input vector contains at least one fractional\n      value and the discrete method is used if the input vector contains\n      integers only.\n@param p_precision: desired precision of the p-value calculation. The\n  precision ultimately depends on the number of resampling attempts. The\n  number of resampling trials is determined by 0.25 divided by the square\n  of the required precision. For instance, a required precision of 0.01\n  means that 2500 samples will be drawn.\n\n@return: a L{FittedPowerLaw} object. The fitted C{xmin} value and the\n  power-law exponent can be queried from the C{xmin} and C{alpha}\n  properties of the returned object."}, {"type": "function", "name": "igraph.quantile", "documentation": "Returns the qth quantile of an unsorted or sorted numeric vector.\n\nThere are a number of different ways to calculate the sample quantile. The\nmethod implemented by igraph is the one recommended by NIST. First we\ncalculate a rank n as q(N+1), where N is the number of items in xs, then we\nsplit n into its integer component k and decimal component d. If k <= 1,\nwe return the first element; if k >= N, we return the last element,\notherwise we return the linear interpolation between xs[k-1] and xs[k]\nusing a factor d.\n\nExample:\n\n    >>> round(quantile([15, 20, 40, 35, 50], 0.4), 2)\n    26.0\n\n@param xs: the vector itself.\n@param q: the quantile we are looking for. It may also be a list if you\n  want to calculate multiple quantiles with a single call. The default\n  value calculates the 25th, 50th and 75th percentile.\n@param sort: whether to sort the vector. If you know that the vector is\n  sorted already, pass C{False} here.\n@return: the qth quantile, which will always be a float, even if the vector\n  contained integers originally. If q is a list, the result will also be a\n  list containing the quantiles for each item in the list."}, {"type": "function", "name": "igraph.read", "documentation": "Loads a graph from the given filename.\n\nThis is just a convenience function, calls L{Graph.Read} directly.\nAll arguments are passed unchanged to L{Graph.Read}\n\n@param filename: the name of the file to be loaded"}, {"type": "function", "name": "igraph.rescale", "documentation": "Rescales a list of numbers into a given range.\n\n``out_range`` gives the range of the output values; by default, the minimum\nof the original numbers in the list will be mapped to the first element\nin the output range and the maximum will be mapped to the second element.\nElements between the minimum and maximum values in the input list will be\ninterpolated linearly between the first and second values of the output\nrange.\n\n``in_range`` may be used to override which numbers are mapped to the first\nand second values of the output range. This must also be a tuple, where\nthe first element will be mapped to the first element of the output range\nand the second element to the second.\n\nIf ``clamp`` is ``True``, elements which are outside the given ``out_range``\nafter rescaling are clamped to the output range to ensure that no number\nwill be outside ``out_range`` in the result.\n\nIf ``scale`` is not ``None``, it will be called for every element of ``values``\nand the rescaling will take place on the results instead. This can be used,\nfor instance, to transform the logarithm of the original values instead of\nthe actual values. A typical use-case is to map a range of values to color\nidentifiers on a logarithmic scale. Scaling also applies to the ``in_range``\nparameter if present.\n\n:param out_range: the range of output values\n:param in_range: the range of the input values; this is the range that is mapped\n    to ``out_range``. ``None`` means to use the minimum and maximum of\n    the input, respectively.\n:param clamp: specifies what to do when an input value falls outside ``in_range``.\n    ``True`` means to clamp the value to the bounds of ``in_range``,\n    ``False`` means not to clamp.\n:param scale: an optional transformation to perform on the input values before\n    mapping them to the output range.\n\nExamples:\n\n    >>> rescale(range(5), (0, 8))\n    [0.0, 2.0, 4.0, 6.0, 8.0]\n    >>> rescale(range(5), (2, 10))\n    [2.0, 4.0, 6.0, 8.0, 10.0]\n    >>> rescale(range(5), (0, 4), (1, 3))\n    [-2.0, 0.0, 2.0, 4.0, 6.0]\n    >>> rescale(range(5), (0, 4), (1, 3), clamp=True)\n    [0.0, 0.0, 2.0, 4.0, 4.0]\n    >>> rescale([0]*5, (1, 3))\n    [2.0, 2.0, 2.0, 2.0, 2.0]\n    >>> from math import log10\n    >>> rescale([1, 10, 100, 1000, 10000], (0, 8), scale=log10)\n    [0.0, 2.0, 4.0, 6.0, 8.0]\n    >>> rescale([1, 10, 100, 1000, 10000], (0, 4), (10, 1000), scale=log10)\n    [-2.0, 0.0, 2.0, 4.0, 6.0]"}, {"type": "function", "name": "igraph.rgb_to_hsl", "documentation": "Converts a color given by its RGB coordinates to HSL coordinates\n(hue, saturation, lightness).\n\nEach of the RGB coordinates must be in the range [0, 1]."}, {"type": "function", "name": "igraph.rgb_to_hsv", "documentation": "Converts a color given by its RGB coordinates to HSV coordinates\n(hue, saturation, value).\n\nEach of the RGB coordinates must be in the range [0, 1]."}, {"type": "function", "name": "igraph.rgba_to_hsla", "documentation": "Converts a color given by its RGBA coordinates to HSLA coordinates\n(hue, saturation, lightness, alpha).\n\nEach of the RGBA coordinates must be in the range [0, 1]."}, {"type": "function", "name": "igraph.rgba_to_hsva", "documentation": "Converts a color given by its RGBA coordinates to HSVA coordinates\n(hue, saturation, value, alpha).\n\nEach of the RGBA coordinates must be in the range [0, 1]."}, {"type": "function", "name": "igraph.save", "documentation": "Saves a graph to the given file.\n\nThis is just a convenience function, calls L{Graph.write} directly.\nAll arguments are passed unchanged to L{Graph.write}\n\n@param graph: the graph to be saved\n@param filename: the name of the file to be written"}, {"type": "function", "name": "igraph.split_join_distance", "documentation": "Calculates the split-join distance between two community structures.\n\nThe split-join distance is a distance measure defined on the space of\npartitions of a given set. It is the sum of the projection distance of\none partition from the other and vice versa, where the projection\nnumber of A from B is if calculated as follows:\n\n  1. For each set in A, find the set in B with which it has the\n     maximal overlap, and take note of the size of the overlap.\n\n  2. Take the sum of the maximal overlap sizes for each set in A.\n\n  3. Subtract the sum from M{n}, the number of elements in the\n     partition.\n\nNote that the projection distance is asymmetric, that's why it has to be\ncalculated in both directions and then added together.  This function\nreturns the projection distance of C{comm1} from C{comm2} and the\nprojection distance of C{comm2} from C{comm1}, and returns them in a pair.\nThe actual split-join distance is the sum of the two distances. The reason\nwhy it is presented this way is that one of the elements being zero then\nimplies that one of the partitions is a subpartition of the other (and if\nit is close to zero, then one of the partitions is close to being a\nsubpartition of the other).\n\nB{Reference}: van Dongen S: Performance criteria for graph clustering and\nMarkov cluster experiments. Technical Report INS-R0012, National Research\nInstitute for Mathematics and Computer Science in the Netherlands,\nAmsterdam, May 2000.\n\n@param comm1: the first community structure as a membership list or\n  as a L{Clustering} object.\n@param comm2: the second community structure as a membership list or\n  as a L{Clustering} object.\n@param remove_none: whether to remove C{None} entries from the membership\n  lists. This is handy if your L{Clustering} object was constructed using\n  L{VertexClustering.FromAttribute} using an attribute which was not defined\n  for all the vertices. If C{remove_none} is C{False}, a C{None} entry in\n  either C{comm1} or C{comm2} will result in an exception. If C{remove_none}\n  is C{True}, C{None} values are filtered away and only the remaining lists\n  are compared.\n\n@return: the projection distance of C{comm1} from C{comm2} and vice versa\n  in a tuple. The split-join distance is the sum of the two.\n\n@see: L{compare_communities()} with C{method = \"split-join\"} if you are\n  not interested in the individual projection distances but only the\n  sum of them."}, {"type": "function", "name": "igraph.summary", "documentation": "Prints a summary of object o to a given stream\n\nPositional and keyword arguments not explicitly mentioned here are passed\non to the underlying C{summary()} method of the object if it has any.\n\n@param obj: the object about which a human-readable summary is requested.\n@param stream: the stream to be used. If C{None}, the standard output\n  will be used."}, {"type": "function", "name": "igraph.union", "documentation": "Graph union.\n\nThe union of two or more graphs is created. The graphs may have identical\nor overlapping vertex sets. Edges which are included in at least one graph\nwill be part of the new graph.\n\nThis function keeps the attributes of all graphs. All graph, vertex and\nedge attributes are copied to the result. If an attribute is present in\nmultiple graphs and would result a name clash, then this attribute is\nrenamed by adding suffixes: _1, _2, etc.\n\nThe ``name`` vertex attribute is treated specially if the operation is\nperformed based on symbolic vertex names. In this case ``name`` must be\npresent in all graphs, and it is not renamed in the result graph.\n\nAn error is generated if some input graphs are directed and others are\nundirected.\n\nParameters:\n    graphs: list of graphs. A lazy sequence is not acceptable.\n    byname: bool or 'auto' specifying the function behaviour with\n        respect to names vertices (i.e. vertices with the 'name' attribute). If\n        False, ignore vertex names. If True, merge vertices based on names. If\n        'auto', use True if all graphs have named vertices and False otherwise\n        (in the latter case, a warning is generated too).\n\nReturns:\n    the union graph\n\nRaises:\n    RuntimeError: if 'byname' is set to True and some graphs are not named or\n        the set of names is not unique in one of the graphs"}, {"type": "function", "name": "igraph.write", "documentation": "Saves a graph to the given file.\n\nThis is just a convenience function, calls L{Graph.write} directly.\nAll arguments are passed unchanged to L{Graph.write}\n\n@param graph: the graph to be saved\n@param filename: the name of the file to be written"}]