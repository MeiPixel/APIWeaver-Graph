[{"type": "class", "name": "karateclub.AE", "documentation": "An implementation of `\"AE\" <https://arxiv.org/abs/1909.13021>`_\nfrom the Arxiv '19 paper \"MUSAE: Multi-Scale Attributed Node Embedding\". The\nprocedure does attributed random walks to approximate the pooled adjacency\nmatrix power node feature matrix product. The matrix is decomposed\nimplicitly by a Skip-Gram style optimization problem.\n\nArgs:\n    walk_number (int): Number of random walks. Default is 5.\n    walk_length (int): Length of random walks. Default is 80.\n    dimensions (int): Dimensionality of embedding. Default is 32.\n    workers (int): Number of cores. Default is 4.\n    window_size (int): Matrix power order. Default is 3.\n    epochs (int): Number of epochs. Default is 1.\n    learning_rate (float): HogWild! learning rate. Default is 0.05.\n    down_sampling (float): Down sampling rate in the corpus. Default is 0.0001.\n    min_count (int): Minimal count of node occurrences. Default is 1.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.AE.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.AE._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.AE._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.AE._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.AE._create_base_docs", "documentation": null}, {"type": "method", "name": "karateclub.AE._create_documents", "documentation": null}, {"type": "method", "name": "karateclub.AE._create_single_embedding", "documentation": null}, {"type": "method", "name": "karateclub.AE._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.AE._feature_transform", "documentation": null}, {"type": "method", "name": "karateclub.AE._learn_ae_embedding", "documentation": null}, {"type": "method", "name": "karateclub.AE._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.AE._setup_ae_features", "documentation": null}, {"type": "method", "name": "karateclub.AE.fit", "documentation": "Fitting an AE model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n    * **X** *(Scipy COO array)* - The binary matrix of node features."}, {"type": "method", "name": "karateclub.AE.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.AE.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.AE.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.ASNE", "documentation": "An implementation of `\"ASNE\" <https://arxiv.org/abs/1705.04969>`_\nfrom the TKDE '18 paper \"Attributed Social Network Embedding\". The\nprocedure implicitly factorizes a concatenated adjacency matrix and feature matrix.\n\nArgs:\n    dimensions (int): Dimensionality of embedding. Default is 128.\n    workers (int): Number of cores. Default is 4.\n    epochs (int): Number of epochs. Default is 100.\n    down_sampling (float): Down sampling frequency. Default is 0.0001.\n    learning_rate (float): HogWild! learning rate. Default is 0.05.\n    min_count (int): Minimal count of node occurrences. Default is 1.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.ASNE.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.ASNE._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.ASNE._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.ASNE._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.ASNE._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.ASNE._feature_transform", "documentation": null}, {"type": "method", "name": "karateclub.ASNE._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.ASNE.fit", "documentation": "Fitting an ASNE model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n    * **X** *(Scipy COO array)* - The matrix of node features."}, {"type": "method", "name": "karateclub.ASNE.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.ASNE.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.ASNE.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.BANE", "documentation": "An implementation of `\"BANE\" <https://shiruipan.github.io/publication/yang-binarized-2018/yang-binarized-2018.pdf>`_\nfrom the ICDM '18 paper \"Binarized Attributed Network Embedding Class\". The\nprocedure first calculates the truncated SVD of an adjacency - feature matrix\nproduct. This matrix is further decomposed by a binary CCD based technique.\n\nArgs:\n    dimensions (int): Number of embedding dimensions. Default is 32.\n    svd_iterations (int): SVD iteration count. Default is 20.\n    seed (int): Random seed. Default is 42.\n    alpha (float): Kernel matrix inversion parameter. Default is 0.3.\n    iterations (int): Matrix decomposition iterations. Default is 100.\n    binarization_iterations (int): Binarization iterations. Default is 20.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.BANE.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.BANE._binary_optimize", "documentation": "Starting 2nd optimization phase with power iterations and CCD."}, {"type": "method", "name": "karateclub.BANE._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.BANE._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.BANE._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.BANE._create_target_matrix", "documentation": "Creating a normalized sparse adjacency matrix target.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **P** *(Scipy COO matrix) - The target matrix."}, {"type": "method", "name": "karateclub.BANE._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.BANE._fit_base_SVD_model", "documentation": "Reducing the dimensionality with SVD in the 1st step."}, {"type": "method", "name": "karateclub.BANE._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.BANE._update_B", "documentation": "Updating the embedding matrix."}, {"type": "method", "name": "karateclub.BANE._update_G", "documentation": "Updating the kernel matrix."}, {"type": "method", "name": "karateclub.BANE._update_Q", "documentation": "Updating the rescaled target matrix."}, {"type": "method", "name": "karateclub.BANE.fit", "documentation": "Fitting a BANE model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n    * **X** *(Scipy COO or Numpy array)* - The matrix of node features."}, {"type": "method", "name": "karateclub.BANE.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.BANE.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.BANE.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.BigClam", "documentation": "An implementation of `\"BigClam\" <http://infolab.stanford.edu/~crucis/pubs/paper-nmfagm.pdf>`_\nfrom the WSDM '13 paper \"Overlapping Community Detection at Scale: A Non-negative Matrix\nFactorization Approach\". The procedure uses gradient ascent to create an embedding which is\nused for deciding the node-cluster affiliations.\n\nArgs:\n    dimensions (int): Number of embedding dimensions. Default 8.\n    iterations (int): Number of training iterations. Default 50.\n    learning_rate (float): Gradient ascent learning rate. Default is 0.005.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.BigClam.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.BigClam._calculate_gradient", "documentation": "Calculating the feature gradient.\n\nArg types:\n    * **node_feature** *(Numpy array)* - The node representation.\n    * **neb_features** *(Numpy array)* - The representation of node neighbours."}, {"type": "method", "name": "karateclub.BigClam._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.BigClam._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.BigClam._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.BigClam._do_updates", "documentation": "Updating the embedding and the feature sum.\n\nArg types:\n    * **node** *(int)* - The node identifier.\n    * **gradient** *(Numpy array)* - The gradient of the node representation.\n    * **node_feature** *(Numpy array)* - The node representation."}, {"type": "method", "name": "karateclub.BigClam._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.BigClam._initialize_features", "documentation": "Creating the community embedding and gradient sum.\n\nArg types:\n    * **number_of_nodes** *(int)* - The number of nodes in the graph."}, {"type": "method", "name": "karateclub.BigClam._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.BigClam.fit", "documentation": "Fitting a BigClam clustering model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be clustered."}, {"type": "method", "name": "karateclub.BigClam.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.BigClam.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.BigClam.get_memberships", "documentation": "Getting the cluster membership of nodes.\n\nReturn types:\n    * **memberships** *(dict)* - Node cluster memberships."}, {"type": "class", "name": "karateclub.BoostNE", "documentation": "An implementation of `\"BoostNE\" <https://arxiv.org/abs/1808.08627>`_\nfrom the ASONAM '19 paper \"Multi-Level Network Embedding with Boosted Low-Rank\nMatrix Approximation\". The procedure uses non-negative matrix factorization\niteratively to decompose the residuals obtained by previous factorization models.\nThe base target matrix is a pooled sum of adjacency matrix powers.\n\nArgs:\n    dimensions (int): Number of individual embedding dimensions. Default is 8.\n    iterations (int): Number of boosting iterations. Default is 16.\n    order (int): Number of adjacency matrix powers. Default is 2.\n    alpha (float): NMF regularization parameter. Default is 0.01.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.BoostNE.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.BoostNE._binary_search", "documentation": "Weighted search procedure. Choosing a random index.\n\nArg types:\n    * **weights** *(Numpy array)* - The weights for choosing an index.\n\nReturn types:\n    * **low/mid** *(int)* - Sampled index."}, {"type": "method", "name": "karateclub.BoostNE._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.BoostNE._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.BoostNE._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.BoostNE._create_D_inverse", "documentation": "Creating a sparse inverse degree matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix."}, {"type": "method", "name": "karateclub.BoostNE._create_base_matrix", "documentation": "Creating a tuple with the normalized adjacency matrix.\n\nReturn types:\n    * **(A_hat, A_hat, A_hat)** *(Tuple of SciPy arrays)* - Normalized adjacency matrices."}, {"type": "method", "name": "karateclub.BoostNE._create_target_matrix", "documentation": "Creating a log transformed target matrix.\n\nReturn types:\n    * **target_matrix** *(SciPy array)* - The PMI matrix."}, {"type": "method", "name": "karateclub.BoostNE._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.BoostNE._fit_and_score_NMF", "documentation": "Factorizing a residual matrix, returning the approximate target, and an embedding.\n\nArg types:\n    * **new_residuals** *(COO Scipy matrix)* - The residual matrix.\n\nReturn types:\n    * **scores** *(COO Scipy matrix)* - The residual scores.\n    * **W** *(Numpy array)* - The embedding matrix."}, {"type": "method", "name": "karateclub.BoostNE._reweighting", "documentation": "Re-scaling the target matrix with the anchor row and column.\n\nArg types:\n    * **X** *(COO Scipy matrix)* - The target matrix.\n    * **chosen_row** *(int)* - The row anchor.\n    * **choswen_col** *(int)* - The column anchor.\n\nReturn types:\n    * **X** *(COO Scipy matrix)* - The rescaled target matrix."}, {"type": "method", "name": "karateclub.BoostNE._sampler", "documentation": "Anchor sampling procedure.\n\nArg types:\n    * **index** *(int)* - The axis for marginalization.\n\nReturn types:\n    * **sample** *(int)* - Anchor point index."}, {"type": "method", "name": "karateclub.BoostNE._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.BoostNE._setup_base_model", "documentation": "Fitting NMF on the starting matrix."}, {"type": "method", "name": "karateclub.BoostNE._single_boosting_round", "documentation": "A method to perform anchor sampling, rescaling, factorization and scoring."}, {"type": "method", "name": "karateclub.BoostNE.fit", "documentation": "Fitting a BoostNE model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.BoostNE.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.BoostNE.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.BoostNE.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.DANMF", "documentation": "An implementation of `\"DANMF\" <https://smartyfh.com/Documents/18DANMF.pdf>`_\nfrom the CIKM '18 paper \"Deep Autoencoder-like Nonnegative Matrix Factorization for\nCommunity Detection\". The procedure uses telescopic non-negative matrix factorization\nin order to learn a cluster membership distribution over nodes. The method can be\nused in an overlapping and non-overlapping way.\n\nArgs:\n    layers (list): Autoencoder layer sizes in a list of integers. Default [32, 8].\n    pre_iterations (int): Number of pre-training epochs. Default 100.\n    iterations (int): Number of training epochs. Default 100.\n    seed (int): Random seed for weight initializations. Default 42.\n    lamb (float): Regularization parameter. Default 0.01.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.DANMF.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.DANMF._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.DANMF._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.DANMF._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.DANMF._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.DANMF._pre_training", "documentation": "Pre-training each NMF layer."}, {"type": "method", "name": "karateclub.DANMF._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.DANMF._setup_Asq", "documentation": null}, {"type": "method", "name": "karateclub.DANMF._setup_Q", "documentation": "Setting up Q matrices."}, {"type": "method", "name": "karateclub.DANMF._setup_VpVpT", "documentation": null}, {"type": "method", "name": "karateclub.DANMF._setup_target_matrices", "documentation": "Setup target matrix for pre-training process.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph being clustered."}, {"type": "method", "name": "karateclub.DANMF._setup_z", "documentation": "Setup target matrix for pre-training process.\n\nArg types:\n    * **i** *(int)* - The layer index."}, {"type": "method", "name": "karateclub.DANMF._sklearn_pretrain", "documentation": "Pre-training a single layer of the model with sklearn.\n\nArg types:\n    * **i** *(int)* - The layer index."}, {"type": "method", "name": "karateclub.DANMF._update_P", "documentation": "Setting up P matrices.\n\nArg types:\n    * **i** *(int)* - The layer index."}, {"type": "method", "name": "karateclub.DANMF._update_U", "documentation": "Updating left hand factors.\n\nArg types:\n    * **i** *(int)* - The layer index."}, {"type": "method", "name": "karateclub.DANMF._update_V", "documentation": "Updating right hand factors.\n\nArg types:\n    * **i** *(int)* - The layer index."}, {"type": "method", "name": "karateclub.DANMF.fit", "documentation": "Fitting a DANMF clustering model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be clustered."}, {"type": "method", "name": "karateclub.DANMF.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.DANMF.get_embedding", "documentation": "Getting the bottleneck layer embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The bottleneck layer embedding of nodes."}, {"type": "method", "name": "karateclub.DANMF.get_memberships", "documentation": "Getting the cluster membership of nodes.\n\nReturn types:\n    * **memberships** *(dict)*: Node cluster memberships."}, {"type": "class", "name": "karateclub.DeepWalk", "documentation": "An implementation of `\"DeepWalk\" <https://arxiv.org/abs/1403.6652>`_\nfrom the KDD '14 paper \"DeepWalk: Online Learning of Social Representations\".\nThe procedure uses random walks to approximate the pointwise mutual information\nmatrix obtained by pooling normalized adjacency matrix powers. This matrix\nis decomposed by an approximate factorization technique.\n\nArgs:\n    walk_number (int): Number of random walks. Default is 10.\n    walk_length (int): Length of random walks. Default is 80.\n    dimensions (int): Dimensionality of embedding. Default is 128.\n    workers (int): Number of cores. Default is 4.\n    window_size (int): Matrix power order. Default is 5.\n    epochs (int): Number of epochs. Default is 1.\n    learning_rate (float): HogWild! learning rate. Default is 0.05.\n    min_count (int): Minimal count of node occurrences. Default is 1.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.DeepWalk.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.DeepWalk._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.DeepWalk._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.DeepWalk._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.DeepWalk._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.DeepWalk._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.DeepWalk.fit", "documentation": "Fitting a DeepWalk model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.DeepWalk.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.DeepWalk.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.DeepWalk.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.Diff2Vec", "documentation": "An implementation of `\"Diff2Vec\" <http://homepages.inf.ed.ac.uk/s1668259/papers/sequence.pdf>`_\nfrom the CompleNet '18 paper \"Diff2Vec: Fast Sequence Based Embedding with Diffusion Graphs\".\nThe procedure creates diffusion trees from every source node in the graph. These graphs are linearized\nby a directed Eulerian walk, the walks are used for running the skip-gram algorithm the learn node\nlevel neighbourhood based embeddings.\n\nArgs:\n    diffusion_number (int): Number of diffusions. Default is 10.\n    diffusion_cover (int): Number of nodes in diffusion. Default is 80.\n    dimensions (int): Dimensionality of embedding. Default is 128.\n    workers (int): Number of cores. Default is 4.\n    window_size (int): Matrix power order. Default is 5.\n    epochs (int): Number of epochs. Default is 1.\n    learning_rate (float): HogWild! learning rate. Default is 0.05.\n    min_count (int): Minimal count of node occurrences. Default is 1.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.Diff2Vec.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.Diff2Vec._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.Diff2Vec._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.Diff2Vec._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.Diff2Vec._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.Diff2Vec._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.Diff2Vec.fit", "documentation": "Fitting a Diff2Vec model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.Diff2Vec.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.Diff2Vec.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.Diff2Vec.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.EdMot", "documentation": "An implementation of `\"Edge Motif Clustering\" <https://arxiv.org/abs/1906.04560>`_\nfrom the KDD '19 paper \"EdMot: An Edge Enhancement Approach for Motif-aware Community Detection\". The tool first creates\nthe graph of higher order motifs. This graph is clustered by the Louvain method. The resulting\ncluster memberships are stored as a dictionary.\n\nArgs:\n    component_count (int): Number of extracted motif hypergraph components. Default is 2.\n    cutoff (int): Motif edge cut-off value. Default is 50.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.EdMot.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.EdMot._calculate_motifs", "documentation": "Enumerating pairwise motif counts."}, {"type": "method", "name": "karateclub.EdMot._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.EdMot._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.EdMot._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.EdMot._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.EdMot._extract_components", "documentation": "Extracting connected components from motif graph."}, {"type": "method", "name": "karateclub.EdMot._fill_blocks", "documentation": "Filling the dense blocks of the adjacency matrix."}, {"type": "method", "name": "karateclub.EdMot._overlap", "documentation": "Calculating the neighbourhood overlap for a pair of nodes.\n\nArg types:\n    * **node_1** *(int)* - Source node 1.\n    * **node_2** *(int)* - Source node 2.\nReturn types:\n    * **overlap** *(int)* - Neighbourhood overlap score."}, {"type": "method", "name": "karateclub.EdMot._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.EdMot.fit", "documentation": "Fitting an Edge Motif clustering model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be clustered."}, {"type": "method", "name": "karateclub.EdMot.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.EdMot.get_embedding", "documentation": "Getting the embeddings (graph or node level)."}, {"type": "method", "name": "karateclub.EdMot.get_memberships", "documentation": "Getting the cluster membership of nodes.\n\nReturn types:\n    * **memberships** *(dictionary of ints)* - Cluster memberships."}, {"type": "class", "name": "karateclub.EgoNetSplitter", "documentation": "An implementation of `\"Ego-Splitting\" <https://www.eecs.yorku.ca/course_archive/2017-18/F/6412/reading/kdd17p145.pdf>`_\nfrom the KDD '17 paper \"Ego-Splitting Framework: from Non-Overlapping to Overlapping Clusters\". The tool first creates\nthe ego-nets of nodes. A persona-graph is created which is clustered by the Louvain method. The resulting overlapping\ncluster memberships are stored as a dictionary.\n\nArgs:\n    resolution (float): Resolution parameter of Python Louvain. Default 1.0.\n    seed (int): Random seed value. Default is 42.\n    weight (str): the key in the graph to use as weight. Default to 'weight'. Specify None to force using an unweighted version of the graph."}, {"type": "method", "name": "karateclub.EgoNetSplitter.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.EgoNetSplitter._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.EgoNetSplitter._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.EgoNetSplitter._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.EgoNetSplitter._create_egonet", "documentation": "Creating an ego net, extracting personas and partitioning it.\n\nArg types:\n    * **node** *(int)* - Node ID for ego-net (ego node)."}, {"type": "method", "name": "karateclub.EgoNetSplitter._create_egonets", "documentation": "Creating an ego-net for each node."}, {"type": "method", "name": "karateclub.EgoNetSplitter._create_partitions", "documentation": "Creating a non-overlapping clustering of nodes in the persona graph."}, {"type": "method", "name": "karateclub.EgoNetSplitter._create_persona_graph", "documentation": "Create a persona graph using the ego-net components."}, {"type": "method", "name": "karateclub.EgoNetSplitter._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.EgoNetSplitter._get_new_edge_ids", "documentation": "Getting the new edge identifiers.\n\nArg types:\n    * **edge** *(list of ints)* - Edge being mapped to the new identifiers."}, {"type": "method", "name": "karateclub.EgoNetSplitter._map_personalities", "documentation": "Mapping the personas to new nodes."}, {"type": "method", "name": "karateclub.EgoNetSplitter._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.EgoNetSplitter.fit", "documentation": "Fitting an Ego-Splitter clustering model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be clustered."}, {"type": "method", "name": "karateclub.EgoNetSplitter.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.EgoNetSplitter.get_embedding", "documentation": "Getting the embeddings (graph or node level)."}, {"type": "method", "name": "karateclub.EgoNetSplitter.get_memberships", "documentation": "Getting the cluster membership of nodes.\n\nReturn types:\n    * **memberships** *(dictionary of lists)* - Cluster memberships."}, {"type": "class", "name": "karateclub.Estimator", "documentation": "Estimator base class with constructor and public methods."}, {"type": "method", "name": "karateclub.Estimator.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.Estimator._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.Estimator._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.Estimator._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.Estimator._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.Estimator._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.Estimator.fit", "documentation": "Fitting a model."}, {"type": "method", "name": "karateclub.Estimator.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.Estimator.get_embedding", "documentation": "Getting the embeddings (graph or node level)."}, {"type": "method", "name": "karateclub.Estimator.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.EulerianDiffuser", "documentation": "Class to make diffusions for a given graph.\n\nArgs:\n    diffusion_number (int): Number of diffusions\n    diffusion_cover (int): Number of nodes in diffusion."}, {"type": "method", "name": "karateclub.EulerianDiffuser.__init__", "documentation": "Initialize self.  See help(type(self)) for accurate signature."}, {"type": "method", "name": "karateclub.EulerianDiffuser._run_diffusion_process", "documentation": "Generating a diffusion tree from a given source node and linearizing it\nwith a directed Eulerian tour.\n\nArg types:\n    * **node** *(int)* - The source node of the diffusion.\nReturn types:\n    * **euler** *(list of strings)* - The list of nodes in the walk."}, {"type": "method", "name": "karateclub.EulerianDiffuser.do_diffusions", "documentation": "Running diffusions from every node.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to run diffusions on."}, {"type": "class", "name": "karateclub.FGSD", "documentation": "An implementation of `\"FGSD\" <https://papers.nips.cc/paper/6614-hunt-for-the-unique-stable-sparse-and-fast-feature-learning-on-graphs>`_\nfrom the NeurIPS '17 paper \"Hunt For The Unique, Stable, Sparse And Fast Feature Learning On Graphs\".\nThe procedure calculates the Moore-Penrose spectrum of the normalized Laplacian.\nUsing this spectrum the histogram of the spectral features is used as a whole graph representation.\n\nArgs:\n    hist_bins (int): Number of histogram bins. Default is 200.\n    hist_range (int): Histogram range considered. Default is 20.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.FGSD.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.FGSD._calculate_fgsd", "documentation": "Calculating the features of a graph.\n\nArg types:\n    * **graph** *(NetworkX graph)* - A graph to be embedded.\n\nReturn types:\n    * **hist** *(Numpy array)* - The embedding of a single graph."}, {"type": "method", "name": "karateclub.FGSD._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.FGSD._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.FGSD._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.FGSD._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.FGSD._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.FGSD.fit", "documentation": "Fitting a FGSD model.\n\nArg types:\n    * **graphs** *(List of NetworkX graphs)* - The graphs to be embedded."}, {"type": "method", "name": "karateclub.FGSD.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.FGSD.get_embedding", "documentation": "Getting the embedding of graphs.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of graphs."}, {"type": "method", "name": "karateclub.FGSD.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.FSCNMF", "documentation": "An implementation of `\"FCNMF\" <https://arxiv.org/pdf/1804.05313.pdf.>`_\nfrom the Arxiv '18 paper \"Fusing Structure and Content via Non-negative Matrix\nFactorization for Embedding Information Networks\". The procedure uses a joint\nmatrix factorization technique on the adjacency and feature matrices. The node\nand feature embeddings are co-regularized for alignment of the embedding spaces.\n\nArgs:\n    dimensions (int): Number of embedding dimensions. Default is 32.\n    lower_control (float): Embedding score minimal value. Default is 10**-15.\n    iterations (int): Power iterations. Default is 500.\n    alpha_1 (float): Alignment parameter for adjacency matrix. Default is 1000.0.\n    alpha_2 (float): Adjacency basis regularization. Default is 1.0.\n    alpha_3 (float): Adjacency features regularization. Default is 1.0.\n    beta_1 (float): Alignment parameter for feature matrix. Default is 1000.0.\n    beta_2 (float): Attribute basis regularization. Default is 1.0.\n    beta_3 (float): Attribute basis regularization. Default is 1.0.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.FSCNMF.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.FSCNMF._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.FSCNMF._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.FSCNMF._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.FSCNMF._create_D_inverse", "documentation": "Creating a sparse inverse degree matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix."}, {"type": "method", "name": "karateclub.FSCNMF._create_base_matrix", "documentation": "Creating a normalized adjacency matrix.\n\nReturn types:\n    * **A_hat* - Normalized adjacency matrix."}, {"type": "method", "name": "karateclub.FSCNMF._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.FSCNMF._init_weights", "documentation": "Setup basis and feature matrices."}, {"type": "method", "name": "karateclub.FSCNMF._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.FSCNMF._update_B1", "documentation": "Update node bases."}, {"type": "method", "name": "karateclub.FSCNMF._update_B2", "documentation": "Update node features."}, {"type": "method", "name": "karateclub.FSCNMF._update_U", "documentation": "Update feature basis."}, {"type": "method", "name": "karateclub.FSCNMF._update_V", "documentation": "Update features."}, {"type": "method", "name": "karateclub.FSCNMF.fit", "documentation": "Fitting an FSCNMF model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n    * **X** *(Scipy COO or Numpy array)* - The matrix of node features."}, {"type": "method", "name": "karateclub.FSCNMF.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.FSCNMF.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.FSCNMF.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.FeatherGraph", "documentation": "An implementation of `\"FEATHER-G\" <https://arxiv.org/abs/2005.07959>`_\nfrom the CIKM '20 paper \"Characteristic Functions on Graphs: Birds of a Feather,\nfrom Statistical Descriptors to Parametric Models\". The procedure\nuses characteristic functions of node features with random walk weights to describe\nnode neighborhoods. These node level features are pooled by mean pooling to\ncreate graph level statistics.\n\nArgs:\n    order (int): Adjacency matrix powers. Default is 5.\n    eval_points (int): Number of evaluation points. Default is 25.\n    theta_max (int): Maximal evaluation point value. Default is 2.5.\n    seed (int): Random seed value. Default is 42.\n    pooling (str): Permutation invariant pooling function, one of:\n                   (:obj:`\"mean\"`, :obj:`\"max\"`, :obj:`\"min\"`). Default is \"mean.\""}, {"type": "method", "name": "karateclub.FeatherGraph.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.FeatherGraph._calculate_feather", "documentation": "Calculating the characteristic function features of a graph.\n\nArg types:\n    * **graph** *(NetworkX graph)* - A graph to be embedded.\n\nReturn types:\n    * **features** *(Numpy vector)* - The embedding of a single graph."}, {"type": "method", "name": "karateclub.FeatherGraph._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.FeatherGraph._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.FeatherGraph._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.FeatherGraph._create_d_inverse", "documentation": "Creating a sparse inverse degree matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix."}, {"type": "method", "name": "karateclub.FeatherGraph._create_node_feature_matrix", "documentation": "Calculating the node features.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph of interest.\n\nReturn types:\n    * **X** *(NumPy array)* - The node features."}, {"type": "method", "name": "karateclub.FeatherGraph._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.FeatherGraph._get_normalized_adjacency", "documentation": "Calculating the normalized adjacency matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph of interest.\n\nReturn types:\n    * **A_hat** *(SciPy array)* - The scattering matrix of the graph."}, {"type": "method", "name": "karateclub.FeatherGraph._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.FeatherGraph.fit", "documentation": "Fitting a graph level FEATHER model.\n\nArg types:\n    * **graphs** *(List of NetworkX graphs)* - The graphs to be embedded."}, {"type": "method", "name": "karateclub.FeatherGraph.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.FeatherGraph.get_embedding", "documentation": "Getting the embedding of graphs.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of graphs."}, {"type": "method", "name": "karateclub.FeatherGraph.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.FeatherNode", "documentation": "An implementation of `\"FEATHER-N\" <https://arxiv.org/abs/2005.07959>`_\nfrom the CIKM '20 paper \"Characteristic Functions on Graphs: Birds of a Feather,\nfrom Statistical Descriptors to Parametric Models\". The procedure\nuses characteristic functions of node features with random walk weights to describe\nnode neighborhoods.\n\nArgs:\n    reduction_dimensions (int): SVD reduction dimensions. Default is 64.\n    svd_iterations (int): SVD iteration count. Default is 20.\n    theta_max (float): Maximal evaluation point. Default is 2.5.\n    eval_points (int): Number of characteristic function evaluation points. Default is 25.\n    order (int): Scale - number of adjacency matrix powers. Default is 5.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.FeatherNode.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.FeatherNode._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.FeatherNode._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.FeatherNode._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.FeatherNode._create_A_tilde", "documentation": "Creating a sparse normalized adjacency matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\nReturn types:\n    * **A_tilde** *(Scipy array)* - The normalized adjacency matrix."}, {"type": "method", "name": "karateclub.FeatherNode._create_D_inverse", "documentation": "Creating a sparse inverse degree matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\nReturn types:\n    * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix."}, {"type": "method", "name": "karateclub.FeatherNode._create_reduced_features", "documentation": "Creating a dense reduced node feature matrix.\n\nArg types:\n    * **X** *(Scipy COO or Numpy array)* - The wide feature matrix.\n\nReturn types:\n    * **X** *(Numpy array)* - The reduced feature matrix of nodes."}, {"type": "method", "name": "karateclub.FeatherNode._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.FeatherNode._reduce_dimensions", "documentation": "Using Truncated SVD.\n\nArg types:\n    * **X** *(Scipy COO or Numpy array)* - The wide feature matrix.\n\nReturn types:\n    * **X** *(Numpy array)* - The reduced feature matrix of nodes."}, {"type": "method", "name": "karateclub.FeatherNode._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.FeatherNode.fit", "documentation": "Fitting a FEATHER-N model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n    * **X** *(Scipy COO or Numpy array)* - The matrix of node features."}, {"type": "method", "name": "karateclub.FeatherNode.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.FeatherNode.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.FeatherNode.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.GEMSEC", "documentation": "An implementation of `\"GEMSEC\" <https://arxiv.org/abs/1802.03997>`_\nfrom the ASONAM '19 paper \"GEMSEC: Graph Embedding with Self Clustering\".\nThe procedure uses random walks to approximate the pointwise mutual information\nmatrix obtained by pooling normalized adjacency matrix powers. This matrix\nis decomposed by an approximate factorization technique which is combined\nwith a k-means like clustering cost. A node embedding and clustering are\nlearned jointly.\n\nArgs:\n    walk_number (int): Number of random walks. Default is 5.\n    walk_length (int): Length of random walks. Default is 80.\n    dimensions (int): Dimensionality of embedding. Default is 32.\n    negative_samples (int): Number of negative samples. Default is 5.\n    window_size (int): Matrix power order. Default is 5.\n    learning_rate (float): Gradient descent learning rate. Default is 0.1.\n    clusters (int): Number of cluster centers. Default is 10.\n    gamma (float): Clustering cost weight coefficient. Default is 0.1.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.GEMSEC.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.GEMSEC._calculate_cluster_vector", "documentation": "Getting the cluster vector for the weight update.\n\nArg types:\n    * **source_node** *(int)* - Source node in the walk.\n\nReturn types:\n    * **cluster_vector** *(NumPy array) - Cluster update vector.\n    * **cluster_index** *(int)*: Node cluster membership index."}, {"type": "method", "name": "karateclub.GEMSEC._calculcate_noise_vector", "documentation": "Getting the noise vector for the weight update.\n\nArg types:\n    * **negative_samples** *(list)*: List of negative sampled nodes.\n    * **source_node** *(int)* - Source node in the walk.\n\nReturn types:\n    * **noise_vector** *(NumPy array) - Noise update vector."}, {"type": "method", "name": "karateclub.GEMSEC._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.GEMSEC._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.GEMSEC._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.GEMSEC._do_descent_for_pair", "documentation": "Updating the cluster center and the node embedding.\n\nArg types:\n    * **negative_samples** *(list)* - Negative samples.\n    * **source_node** *(int)* - Source node in the walk.\n    * **target_node** *(int)* - Target node in the walk."}, {"type": "method", "name": "karateclub.GEMSEC._do_gradient_descent", "documentation": "Updating the embedding weights and cluster centers with gradient descent."}, {"type": "method", "name": "karateclub.GEMSEC._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.GEMSEC._get_membership", "documentation": "Getting the cluster membership of a node.\n\nArg types:\n    * **node** *(int)* - The graph to be clustered.\n\nReturn types:\n    * **cluster_index** *(int)*: Node cluster membership index."}, {"type": "method", "name": "karateclub.GEMSEC._initialize_cluster_centers", "documentation": "Creating a cluster center array.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph for negative sampling."}, {"type": "method", "name": "karateclub.GEMSEC._initialize_node_embeddings", "documentation": "Creating a node embedding array.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph for negative sampling."}, {"type": "method", "name": "karateclub.GEMSEC._sample_negative_samples", "documentation": "Sampling a batch of nodes as negative samples.\n\nReturn types:\n    * **negative_samples** *(list)*: List of negative sampled nodes."}, {"type": "method", "name": "karateclub.GEMSEC._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.GEMSEC._setup_sampling_weights", "documentation": "Creating a negative sampling table.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph for negative sampling."}, {"type": "method", "name": "karateclub.GEMSEC._update_a_weight", "documentation": "Updating the weights for a pair of nodes.\n\nArg types:\n    * **source_node** *(int)* - Source node in the walk.\n    * **target_node** *(int)* - Target node in the walk."}, {"type": "method", "name": "karateclub.GEMSEC.fit", "documentation": "Fitting a GEMSEC model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.GEMSEC.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.GEMSEC.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)*: The embedding of nodes."}, {"type": "method", "name": "karateclub.GEMSEC.get_memberships", "documentation": "Getting the cluster membership of nodes.\n\nReturn types:\n    * **memberships** *(dict)*: Node cluster memberships."}, {"type": "class", "name": "karateclub.GL2Vec", "documentation": "An implementation of `\"GL2Vec\" <https://link.springer.com/chapter/10.1007/978-3-030-36718-3_1>`_\nfrom the ICONIP '19 paper \"GL2vec: Graph Embedding Enriched by Line Graphs with Edge Features\".\nFirst, the algorithm creates the line graph of each graph in the graph dataset.\nThe procedure creates Weisfeiler-Lehman tree features for nodes in graphs. Using\nthese features a document (graph) - feature co-occurence matrix is decomposed in order\nto generate representations for the graphs.\n\nThe procedure assumes that nodes have no string feature present and the WL-hashing\ndefaults to the degree centrality. However, if a node feature with the key \"feature\"\nis supported for the nodes the feature extraction happens based on the values of this key.\n\nArgs:\n    wl_iterations (int): Number of Weisfeiler-Lehman iterations. Default is 2.\n    dimensions (int): Dimensionality of embedding. Default is 128.\n    workers (int): Number of cores. Default is 4.\n    down_sampling (float): Down sampling frequency. Default is 0.0001.\n    epochs (int): Number of epochs. Default is 10.\n    learning_rate (float): HogWild! learning rate. Default is 0.025.\n    min_count (int): Minimal count of graph feature occurrences. Default is 5.\n    seed (int): Random seed for the model. Default is 42."}, {"type": "method", "name": "karateclub.GL2Vec.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.GL2Vec._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.GL2Vec._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.GL2Vec._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.GL2Vec._create_line_graph", "documentation": "Getting the embedding of graphs.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph transformed to be a line graph.\n\nReturn types:\n    * **line_graph** *(NetworkX graph)* - The line graph of the source graph."}, {"type": "method", "name": "karateclub.GL2Vec._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.GL2Vec._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.GL2Vec.fit", "documentation": "Fitting a GL2Vec model.\n\nArg types:\n    * **graphs** *(List of NetworkX graphs)* - The graphs to be embedded."}, {"type": "method", "name": "karateclub.GL2Vec.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.GL2Vec.get_embedding", "documentation": "Getting the embedding of graphs.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of graphs."}, {"type": "method", "name": "karateclub.GL2Vec.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.GLEE", "documentation": "An implementation of `\"Geometric Laplacian Eigenmaps\" <https://arxiv.org/abs/1905.09763>`_\nfrom the Journal of Complex Networks '20 paper \"GLEE: Geometric Laplacian Eigenmap Embedding\".\nThe procedure extracts the eigenvectors corresponding to the largest eigenvalues\nof the graph Laplacian. These vectors are used as the node embedding.\n\nArgs:\n    dimensions (int): Dimensionality of embedding. Default is 128.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.GLEE.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.GLEE._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.GLEE._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.GLEE._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.GLEE._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.GLEE._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.GLEE.fit", "documentation": "Fitting a Geometric Laplacian EigenMaps model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.GLEE.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.GLEE.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.GLEE.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.GeoScattering", "documentation": "An implementation of `\"GeoScattering\" <http://proceedings.mlr.press/v97/gao19e.html>`_\nfrom the ICML '19 paper \"Geometric Scattering for Graph Data Analysis\". The procedure\nuses scattering with wavelet transforms to create graph spectral descriptors. Moments of the\nwavelet transformed features are used as graph level features for the embedding.\n\nArgs:\n    order (int): Adjacency matrix powers. Default is 4.\n    moments (int): Unnormalized moments considered. Default is 4.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.GeoScattering.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.GeoScattering._calculate_geoscattering", "documentation": "Calculating the features of a graph.\n\nArg types:\n    * **graph** *(NetworkX graph)* - A graph to be embedded.\n\nReturn types:\n    * **features** *(Numpy vector)* - The embedding of a single graph."}, {"type": "method", "name": "karateclub.GeoScattering._calculate_wavelets", "documentation": "Calculating the wavelets of a normalized self-looped adjacency matrix.\n\nArg types:\n    * **A_hat** *(SciPy array)* - The normalized adjacency matrix.\n\nReturn types:\n    * **Psi** *(List of Scipy arrays)* - The wavelet matrices."}, {"type": "method", "name": "karateclub.GeoScattering._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.GeoScattering._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.GeoScattering._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.GeoScattering._create_D_inverse", "documentation": "Creating a sparse inverse degree matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix."}, {"type": "method", "name": "karateclub.GeoScattering._create_node_feature_matrix", "documentation": "Calculating the node features.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph of interest.\n\nReturn types:\n    * **X** *(NumPy array)* - The node features."}, {"type": "method", "name": "karateclub.GeoScattering._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.GeoScattering._get_first_order_features", "documentation": "Calculating the first order graph features.\n\nArg types:\n    * **Psi** *(List of Scipy arrays)* - The wavelet matrices.\n    * **X** *(NumPy array)* - The node features.\n\nReturn types:\n    * **features** *(NumPy vector)* - The first order graph features."}, {"type": "method", "name": "karateclub.GeoScattering._get_normalized_adjacency", "documentation": "Calculating the normalized adjacency matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph of interest.\n\nReturn types:\n    * **A_hat** *(SciPy array)* - The scattering matrix of the graph."}, {"type": "method", "name": "karateclub.GeoScattering._get_second_order_features", "documentation": "Calculating the second order graph features.\n\nArg types:\n    * **Psi** *(List of Scipy arrays)* - The wavelet matrices.\n    * **X** *(NumPy array)* - The node features.\n\nReturn types:\n    * **features** *(NumPy vector)* - The second order graph features."}, {"type": "method", "name": "karateclub.GeoScattering._get_zero_order_features", "documentation": "Calculating the zero-th order graph features.\n\nArg types:\n    * **X** *(NumPy array)* - The node features.\n\nReturn types:\n    * **features** *(NumPy vector)* - The zero-th order graph features."}, {"type": "method", "name": "karateclub.GeoScattering._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.GeoScattering.fit", "documentation": "Fitting a Geometric-Scattering model.\n\nArg types:\n    * **graphs** *(List of NetworkX graphs)* - The graphs to be embedded."}, {"type": "method", "name": "karateclub.GeoScattering.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.GeoScattering.get_embedding", "documentation": "Getting the embedding of graphs.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of graphs."}, {"type": "method", "name": "karateclub.GeoScattering.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.GraRep", "documentation": "An implementation of `\"GraRep\" <https://dl.acm.org/citation.cfm?id=2806512>`_\nfrom the CIKM '15 paper \"GraRep: Learning Graph Representations with Global\nStructural Information\". The procedure uses sparse truncated SVD to learn\nembeddings for the powers of the PMI matrix computed from powers of the\nnormalized adjacency matrix.\n\nArgs:\n    dimensions (int): Number of individual embedding dimensions. Default is 32.\n    iteration (int): Number of SVD iterations. Default is 10.\n    order (int): Number of PMI matrix powers. Default is 5.\n    seed (int): SVD random seed. Default is 42."}, {"type": "method", "name": "karateclub.GraRep.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.GraRep._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.GraRep._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.GraRep._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.GraRep._create_D_inverse", "documentation": "Creating a sparse inverse degree matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix."}, {"type": "method", "name": "karateclub.GraRep._create_base_matrix", "documentation": "Creating a tuple with the normalized adjacency matrix.\n\nReturn types:\n    * **(A_hat, A_hat)** *(Tuple of SciPy arrays)* - Normalized adjacency matrices."}, {"type": "method", "name": "karateclub.GraRep._create_single_embedding", "documentation": "Fitting a single SVD embedding of a PMI matrix."}, {"type": "method", "name": "karateclub.GraRep._create_target_matrix", "documentation": "Creating a log transformed target matrix.\n\nReturn types:\n    * **target_matrix** *(SciPy array)* - The PMI matrix."}, {"type": "method", "name": "karateclub.GraRep._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.GraRep._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.GraRep.fit", "documentation": "Fitting a GraRep model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.GraRep.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.GraRep.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.GraRep.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.Graph2Vec", "documentation": "An implementation of `\"Graph2Vec\" <https://arxiv.org/abs/1707.05005>`_\nfrom the MLGWorkshop '17 paper \"Graph2Vec: Learning Distributed Representations of Graphs\".\nThe procedure creates Weisfeiler-Lehman tree features for nodes in graphs. Using\nthese features a document (graph) - feature co-occurence matrix is decomposed in order\nto generate representations for the graphs.\n\nThe procedure assumes that nodes have no string feature present and the WL-hashing\ndefaults to the degree centrality. However, if a node feature with the key \"feature\"\nis supported for the nodes the feature extraction happens based on the values of this key.\n\nArgs:\n    wl_iterations (int): Number of Weisfeiler-Lehman iterations. Default is 2.\n    attributed (bool): Presence of graph attributes. Default is False.\n    dimensions (int): Dimensionality of embedding. Default is 128.\n    workers (int): Number of cores. Default is 4.\n    down_sampling (float): Down sampling frequency. Default is 0.0001.\n    epochs (int): Number of epochs. Default is 10.\n    learning_rate (float): HogWild! learning rate. Default is 0.025.\n    min_count (int): Minimal count of graph feature occurrences. Default is 5.\n    seed (int): Random seed for the model. Default is 42.\n    erase_base_features (bool): Erasing the base features. Default is False."}, {"type": "method", "name": "karateclub.Graph2Vec.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.Graph2Vec._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.Graph2Vec._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.Graph2Vec._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.Graph2Vec._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.Graph2Vec._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.Graph2Vec.fit", "documentation": "Fitting a Graph2Vec model.\n\nArg types:\n    * **graphs** *(List of NetworkX graphs)* - The graphs to be embedded."}, {"type": "method", "name": "karateclub.Graph2Vec.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.Graph2Vec.get_embedding", "documentation": "Getting the embedding of graphs.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of graphs."}, {"type": "method", "name": "karateclub.Graph2Vec.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.GraphReader", "documentation": "Class to read benchmark datasets for the community detection or node embedding task.\n\nArgs:\n    dataset (str): Dataset of interest, one of:\n        (:obj:`\"facebook\"`, :obj:`\"twitch\"`, :obj:`\"wikipedia\"`, :obj:`\"github\"`, :obj:`\"lastfm\"`, :obj:`\"deezer\"`). Default is 'wikipedia'."}, {"type": "method", "name": "karateclub.GraphReader.__init__", "documentation": "Initialize self.  See help(type(self)) for accurate signature."}, {"type": "method", "name": "karateclub.GraphReader._dataset_reader", "documentation": "Reading the dataset from the web."}, {"type": "method", "name": "karateclub.GraphReader._pandas_reader", "documentation": "Reading bytes as a Pandas dataframe."}, {"type": "method", "name": "karateclub.GraphReader.get_features", "documentation": "Getting the node features Scipy matrix.\n\nReturn types:\n    * **features** *(COO Scipy array)* - Node feature matrix."}, {"type": "method", "name": "karateclub.GraphReader.get_graph", "documentation": "Getting the graph.\n\nReturn types:\n    * **graph** *(NetworkX graph)* - Graph of interest."}, {"type": "method", "name": "karateclub.GraphReader.get_target", "documentation": "Getting the class membership of nodes.\n\nReturn types:\n    * **target** *(Numpy array)* - Class membership vector."}, {"type": "class", "name": "karateclub.GraphSetReader", "documentation": "Class to read benchmark datasets for the graph level embedding task.\n\nArgs:\n    dataset (str): Dataset of interest one of reddit10k. Default is 'reddit10k'."}, {"type": "method", "name": "karateclub.GraphSetReader.__init__", "documentation": "Initialize self.  See help(type(self)) for accurate signature."}, {"type": "method", "name": "karateclub.GraphSetReader._dataset_reader", "documentation": "Reading the dataset from the web."}, {"type": "method", "name": "karateclub.GraphSetReader._pandas_reader", "documentation": "Reading bytes as a Pandas dataframe."}, {"type": "method", "name": "karateclub.GraphSetReader.get_graphs", "documentation": "Getting the graphs.\n\nReturn types:\n    * **graphs** *(List of NetworkX graphs)* - Graphs of interest."}, {"type": "method", "name": "karateclub.GraphSetReader.get_target", "documentation": "Getting the class membership of graphs.\n\nReturn types:\n    * **target** *(Numpy array)* - Class membership vector."}, {"type": "class", "name": "karateclub.GraphWave", "documentation": "An implementation of `\"GraphWave\" <https://dl.acm.org/citation.cfm?id=2806512>`_\nfrom the KDD '18 paper \"Learning Structural Node Embeddings Via Diffusion Wavelets\".\nThe procedure first calculates the graph wavelets using a heat kernel. The wavelets\nare treated as probability distributions over nodes from a source node. Using these\nthe characteristic function is evaluated at certain gird points to learn structural\nnode embeddings of the vertices.\n\nArgs:\n    sample_number (int): Number of evaluation points. Default is 200.\n    step_size (float): Grid point step size. Default is 0.1.\n    heat_coefficient (float): Heat kernel coefficient. Default is 1.0.\n    approximation (int): Chebyshev polynomial order. Default is 100.\n    mechanism (str): Wavelet calculation method one of:\n                     (:obj:`\"exact\"`, :obj:`\"approximate\"`). Default is 'approximate'.\n    switch (int): Vertex cardinality when the wavelet calculation method switches to approximation. Default is 1000.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.GraphWave.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.GraphWave._approximate_structural_wavelet_embedding", "documentation": "Estimating the largest eigenvalue.\nSetting up the heat filter and the Cheybshev polynomial.\nUsing the approximate wavelet calculator method."}, {"type": "method", "name": "karateclub.GraphWave._approximate_wavelet_calculator", "documentation": "Given the Chebyshev polynomial and graph the approximate embedding is calculated."}, {"type": "method", "name": "karateclub.GraphWave._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.GraphWave._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.GraphWave._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.GraphWave._check_size", "documentation": "Checking the size of the target graph. Switching based on size and settings.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph being embedded."}, {"type": "method", "name": "karateclub.GraphWave._create_evaluation_points", "documentation": "Calculating the grid points."}, {"type": "method", "name": "karateclub.GraphWave._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.GraphWave._exact_structural_wavelet_embedding", "documentation": "Calculates the eigenvectors, eigenvalues and an exact embedding is created."}, {"type": "method", "name": "karateclub.GraphWave._exact_wavelet_calculator", "documentation": "Calculates the structural role embedding using the exact eigenvalue decomposition."}, {"type": "method", "name": "karateclub.GraphWave._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.GraphWave._single_wavelet_generator", "documentation": "Calculating the characteristic function for a given node, using the eigen decomposition.\n\nArg types:\n    * **node** *(int)* - The node being embedded.\n\nReturn types:\n    * **wavelet_coefficients** *(Numpy array)* - The wavelet representation of the node."}, {"type": "method", "name": "karateclub.GraphWave.fit", "documentation": "Fitting a GraphWave model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.GraphWave.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.GraphWave.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.GraphWave.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.HOPE", "documentation": "An implementation of `\"HOPE\" <https://www.kdd.org/kdd2016/papers/files/rfp0184-ouA.pdf>`_\nfrom the KDD '16 paper \"Asymmetric Transitivity Preserving Graph Embedding\". The procedure uses\nsparse SVD on the neighbourhood overlap matrix. The singular value rescaled left and right\nsingular vectors are used as the node embeddings after concatenation.\n\nArgs:\n    dimensions (int): Dimensionality of embedding. Default is 128.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.HOPE.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.HOPE._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.HOPE._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.HOPE._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.HOPE._create_target", "documentation": "Creating a target similarity matrix."}, {"type": "method", "name": "karateclub.HOPE._do_rescaled_decomposition", "documentation": "Decomposing the similarity matrix."}, {"type": "method", "name": "karateclub.HOPE._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.HOPE._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.HOPE.fit", "documentation": "Fitting a HOPE model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.HOPE.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.HOPE.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.HOPE.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.IGE", "documentation": "An implementation of `\"Invariant Graph Embedding\" <https://graphreason.github.io/papers/16.pdf>`_\nfrom the ICML 2019 Workshop on Learning and Reasoning with Graph-Structured\nData paper \"Invariant Embedding for Graph Classification\". The procedure\ncomputes a mixture of spectral and node embedding based features. Specifically,\nit uses scattering, eigenvalues and pooled node feature embeddings to create\ngraph descriptors.\n\nArgs:\n    feature_embedding_dimensions (list): Feature embedding dimensions. Default is [3, 5]\n    spectral_embedding_dimensions (list): Spectral embedding dimensions. Default is [10, 20].\n    histogram_bins (list): Number of histogram bins. Default is [10, 20].\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.IGE.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.IGE._calculate_invariant_embedding", "documentation": "Calculating features from generic embedding, spectral embeddings and histogram features.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph of interest.\n\nReturn types:\n    * **features** *(NumPy array)* - The features of the graph."}, {"type": "method", "name": "karateclub.IGE._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.IGE._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.IGE._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.IGE._create_D_inverse", "documentation": "Creating a sparse inverse degree matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix."}, {"type": "method", "name": "karateclub.IGE._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.IGE._get_embedding_features", "documentation": "Calculating the embedding features.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph of interest.\n    * **features** *(list)* - The list of graph feature NumPy arrays.\n\nReturn types:\n    * **features** *(list)* - The list of graph feature NumPy arrays."}, {"type": "method", "name": "karateclub.IGE._get_histogram_features", "documentation": "Calculating the spectral histogram features.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph of interest.\n    * **features** *(list)* - The list of graph feature NumPy arrays.\n\nReturn types:\n    * **features** *(list)* - The list of graph feature NumPy arrays."}, {"type": "method", "name": "karateclub.IGE._get_normalized_adjacency", "documentation": "Calculating the normalized adjacency matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph of interest.\n\nReturn types:\n    * **A_hat** *(SciPy array)* - The adjacency matrix of the graph."}, {"type": "method", "name": "karateclub.IGE._get_spectral_features", "documentation": "Calculating the spectral features.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph of interest.\n    * **features** *(list)* - The list of graph feature NumPy arrays.\n\nReturn types:\n    * **features** *(list)* - The list of graph feature NumPy arrays."}, {"type": "method", "name": "karateclub.IGE._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.IGE.fit", "documentation": "Fitting an Invariant Graph Embedding model.\n\nArg types:\n    * **graphs** *(List of NetworkX graphs)* - The graphs to be embedded."}, {"type": "method", "name": "karateclub.IGE.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.IGE.get_embedding", "documentation": "Getting the embedding of graphs.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of graphs."}, {"type": "method", "name": "karateclub.IGE.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.LDP", "documentation": "An implementation of `\"LDP\" <https://arxiv.org/abs/1811.03508>`_ from the\nICLR Representation Learning on Graphs and Manifolds Workshop '19 paper \"A\nSimple Yet Effective Baseline for Non-Attributed Graph Classification\". The\nprocedure calculates histograms of degree profiles. These concatenated\nhistograms form the graph representations.\n\nArgs:\n    bins (int): Number of histogram bins. Default is 32."}, {"type": "method", "name": "karateclub.LDP.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.LDP._calculate_ldp", "documentation": "Calculating the local degree profile features of a graph.\n\nArg types:\n    * **graph** *(NetworkX graph)* - A graph to be embedded.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of a single graph."}, {"type": "method", "name": "karateclub.LDP._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.LDP._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.LDP._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.LDP._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.LDP._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.LDP.fit", "documentation": "Fitting an LDP model.\n\nArg types:\n    * **graphs** *(List of NetworkX graphs)* - The graphs to be embedded."}, {"type": "method", "name": "karateclub.LDP.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.LDP.get_embedding", "documentation": "Getting the embedding of graphs.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of graphs."}, {"type": "method", "name": "karateclub.LDP.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.LabelPropagation", "documentation": "An implementation of `\"Label Propagation Clustering\" <https://arxiv.org/abs/0709.2938>`_\nfrom the Physical Review '07 paper \"Near Linear Time Algorithm to Detect Community Structures\nin Large-Scale Networks\". The tool executes a series of label propagations with unique labels.\nThe final labels are used as cluster memberships.\n\nArgs:\n    seed (int): Random seed. Default is 42.\n    iterations (int): Propagation iterations. Default is 100."}, {"type": "method", "name": "karateclub.LabelPropagation.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.LabelPropagation._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.LabelPropagation._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.LabelPropagation._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.LabelPropagation._do_a_propagation", "documentation": "Doing a propagation round."}, {"type": "method", "name": "karateclub.LabelPropagation._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.LabelPropagation._make_a_pick", "documentation": "Choosing a neighbor from a propagation source node.\n\nArg types:\n    * **neigbours** *(list)* - Neighbouring nodes."}, {"type": "method", "name": "karateclub.LabelPropagation._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.LabelPropagation.fit", "documentation": "Fitting a Label Propagation clustering model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be clustered."}, {"type": "method", "name": "karateclub.LabelPropagation.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.LabelPropagation.get_embedding", "documentation": "Getting the embeddings (graph or node level)."}, {"type": "method", "name": "karateclub.LabelPropagation.get_memberships", "documentation": "Getting the cluster membership of nodes.\n\nReturn types:\n    * **memberships** *(dict)* - Node cluster memberships."}, {"type": "class", "name": "karateclub.LaplacianEigenmaps", "documentation": "An implementation of `\"Laplacian Eigenmaps\" <https://papers.nips.cc/paper/1961-laplacian-eigenmaps-and-spectral-techniques-for-embedding-and-clustering>`_\nfrom the NIPS '01 paper \"Laplacian Eigenmaps and Spectral Techniques for Embedding and Clustering\".\nThe procedure extracts the eigenvectors corresponding to the largest eigenvalues\nof the graph Laplacian. These vectors are used as the node embedding.\n\nArgs:\n    dimensions (int): Dimensionality of embedding. Default is 128.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.LaplacianEigenmaps.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.LaplacianEigenmaps._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.LaplacianEigenmaps._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.LaplacianEigenmaps._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.LaplacianEigenmaps._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.LaplacianEigenmaps._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.LaplacianEigenmaps.fit", "documentation": "Fitting a Laplacian EigenMaps model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.LaplacianEigenmaps.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.LaplacianEigenmaps.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.LaplacianEigenmaps.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.MNMF", "documentation": "An implementation of `\"M-NMF\" <https://aaai.org/ocs/index.php/AAAI/AAAI17/paper/view/14589/13763>`_\nfrom the AAAI '17 paper \"Community Preserving Network Embedding\".\nThe procedure uses joint non-negative matrix factorization with modularity\nbased regularization in order to learn a cluster membership distribution\nover nodes. The method can be used in an overlapping and non-overlapping way.\n\nArgs:\n    dimensions (int): Number of dimensions. Default is 128.\n    clusters (int): Number of clusters. Default is 10.\n    lambd (float): KKT penalty. Default is 0.2\n    alpha (float): Clustering penalty. Default is 0.05.\n    beta (float): Modularity regularization penalty. Default is 0.05.\n    iterations (int): Number of power iterations. Default is 200.\n    lower_control (float): Floating point overflow control. Default is 10**-15.\n    eta (float): Similarity mixing parameter. Default is 5.0.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.MNMF.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.MNMF._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.MNMF._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.MNMF._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.MNMF._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.MNMF._modularity_generator", "documentation": "Calculating the sparse modularity matrix."}, {"type": "method", "name": "karateclub.MNMF._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.MNMF._setup_matrices", "documentation": "Creating parameter matrices and target matrices."}, {"type": "method", "name": "karateclub.MNMF._update_C", "documentation": "Update matrix C."}, {"type": "method", "name": "karateclub.MNMF._update_H", "documentation": "Update matrix H."}, {"type": "method", "name": "karateclub.MNMF._update_M", "documentation": "Update matrix M."}, {"type": "method", "name": "karateclub.MNMF._update_U", "documentation": "Update matrix U."}, {"type": "method", "name": "karateclub.MNMF.fit", "documentation": "Fitting an M-NMF clustering model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be clustered."}, {"type": "method", "name": "karateclub.MNMF.get_cluster_centers", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **centers** *(Numpy array)* - The cluster centers."}, {"type": "method", "name": "karateclub.MNMF.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.MNMF.get_memberships", "documentation": "Getting the cluster membership of nodes.\n\nReturn types:\n    * **memberships** *(dict)* - Node cluster memberships."}, {"type": "class", "name": "karateclub.MUSAE", "documentation": "An implementation of `\"MUSAE\" <https://arxiv.org/abs/1909.13021>`_\nfrom the Arxiv '19 paper \"MUSAE: Multi-Scale Attributed Node Embedding\". The\nprocedure does attributed random walks to approximate the adjacency matrix power\nnode feature matrix products. The matrices are decomposed implicitly by a Skip-Gram\nstyle optimizer. The individual embeddings are concatenated together to form a\nmulti-scale attributed node embedding. This way the feature distributions at different scales\nare separable.\n\nArgs:\n    walk_number (int): Number of random walks. Default is 5.\n    walk_length (int): Length of random walks. Default is 80.\n    dimensions (int): Dimensionality of embedding. Default is 32.\n    workers (int): Number of cores. Default is 4.\n    window_size (int): Matrix power order. Default is 3.\n    epochs (int): Number of epochs. Default is 1.\n    learning_rate (float): HogWild! learning rate. Default is 0.05.\n    down_sampling (float): Down sampling rate in the corpus. Default is 0.0001.\n    min_count (int): Minimal count of node occurrences. Default is 1.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.MUSAE.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.MUSAE._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.MUSAE._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.MUSAE._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.MUSAE._create_base_docs", "documentation": null}, {"type": "method", "name": "karateclub.MUSAE._create_documents", "documentation": null}, {"type": "method", "name": "karateclub.MUSAE._create_single_embedding", "documentation": null}, {"type": "method", "name": "karateclub.MUSAE._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.MUSAE._feature_transform", "documentation": null}, {"type": "method", "name": "karateclub.MUSAE._learn_musae_embedding", "documentation": null}, {"type": "method", "name": "karateclub.MUSAE._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.MUSAE._setup_musae_features", "documentation": null}, {"type": "method", "name": "karateclub.MUSAE.fit", "documentation": "Fitting a MUSAE model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n    * **X** *(Scipy COO array)* - The binary matrix of node features."}, {"type": "method", "name": "karateclub.MUSAE.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.MUSAE.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.MUSAE.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.NEU", "documentation": "An implementation of `\"NEU\" <https://www.ijcai.org/Proceedings/2017/0544.pdf>`_\nfrom the IJCAI 17 paper \"Fast Network Embedding Enhancement via High Order Proximity Approximation\".\nThe procedure uses an arbitrary embedding and augments it by higher order proximities wiht a recursive\nmeta learning algorithm.\n\nArgs:\n    L1 (float): Weight of lower order proximities. Defauls is 0.5\n    L2 (float): Weight of higer order proximities. Default is 0.25.\n    T (int): Number of iterations. Default is 1.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.NEU.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.NEU._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.NEU._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.NEU._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.NEU._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.NEU._normalize_embedding", "documentation": "Normalizes matrix rows by their Frobenius norm.\nArgs:\n    original_embedding (Numpy array): An array containing an embedding\n\nReturn types:\n    normalized_embedding (Numpy array): An array containing a normalized embedding"}, {"type": "method", "name": "karateclub.NEU._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.NEU._update_embedding", "documentation": "Performs the Network Embedding Update on the original embedding.\nArgs:\n    original_embedding (Numpy array): An array containing an embedding.\n    graph (NetworkX graph): The embedded graph.\n\nReturn types:\n    embedding (Numpy array): An array containing the updated embedding."}, {"type": "method", "name": "karateclub.NEU.fit", "documentation": "Fitting a model and performing NEU.\n\nArgs:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n    * **model** *(KC embedding model)* - Karate Club embedding."}, {"type": "method", "name": "karateclub.NEU.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.NEU.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.NEU.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.NMFADMM", "documentation": "An implementation of `\"NMF-ADMM\" <http://statweb.stanford.edu/~dlsun/papers/nmf_admm.pdf>`_\nfrom the ICASSP '14 paper \"Alternating Direction Method of Multipliers for\nNon-Negative Matrix Factorization with the Beta-Divergence\". The procedure\nlearns an embedding of the normalized adjacency matrix with by using the alternating\ndirection method of multipliers to solve a non negative matrix factorization problem.\n\nArgs:\n    dimensions (int): Number of individual embedding dimensions. Default is 32.\n    iterations (int): Number of ADMM iterations. Default is 100.\n    rho (float): ADMM Tuning parameter. Default is 1.0.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.NMFADMM.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.NMFADMM._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.NMFADMM._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.NMFADMM._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.NMFADMM._create_D_inverse", "documentation": "Creating a sparse inverse degree matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix."}, {"type": "method", "name": "karateclub.NMFADMM._create_base_matrix", "documentation": "Creating a tuple with the normalized adjacency matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **A_hat** *SciPy array* - Normalized adjacency matrix."}, {"type": "method", "name": "karateclub.NMFADMM._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.NMFADMM._init_weights", "documentation": "Initializing model weights."}, {"type": "method", "name": "karateclub.NMFADMM._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.NMFADMM._update_H", "documentation": "Updating user_2 matrix."}, {"type": "method", "name": "karateclub.NMFADMM._update_H_plus", "documentation": "Updating positive primal user_2 factors."}, {"type": "method", "name": "karateclub.NMFADMM._update_W", "documentation": "Updating user_1 matrix."}, {"type": "method", "name": "karateclub.NMFADMM._update_W_plus", "documentation": "Updating positive primal user_1 factors."}, {"type": "method", "name": "karateclub.NMFADMM._update_X", "documentation": "Updating user_1-user_2 matrix."}, {"type": "method", "name": "karateclub.NMFADMM._update_alpha_H", "documentation": "Updating item dual factors."}, {"type": "method", "name": "karateclub.NMFADMM._update_alpha_W", "documentation": "Updating user dual factors."}, {"type": "method", "name": "karateclub.NMFADMM._update_alpha_X", "documentation": "Updating target matrix dual."}, {"type": "method", "name": "karateclub.NMFADMM.fit", "documentation": "Fitting an NMF model on the normalized adjacency matrix with ADMM.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.NMFADMM.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.NMFADMM.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.NMFADMM.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.NNSED", "documentation": "An implementation of `\"NNSED\"\n<http://www.bigdatalab.ac.cn/~shenhuawei/publications/2017/cikm-sun.pdf>`_\nfrom the CIKM '17 paper \"A Non-negative Symmetric Encoder-Decoder Approach\nfor Community Detection\". The procedure uses non-negative matrix factorization\nin order to learn an unnormalized cluster membership distribution over nodes.\nThe method can be used in an overlapping and non-overlapping way.\n\nArgs:\n    layers (int): Embedding layer size. Default is 32.\n    iterations (int): Number of training epochs. Default 10.\n    seed (int): Random seed for weight initializations. Default 42.\n    noise (float): Random noise for normalization stability. Default is 10**-6."}, {"type": "method", "name": "karateclub.NNSED.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.NNSED._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.NNSED._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.NNSED._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.NNSED._create_D_inverse", "documentation": "Creating a sparse inverse degree matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix."}, {"type": "method", "name": "karateclub.NNSED._create_base_matrix", "documentation": "Creating a tuple with the normalized adjacency matrix.\n\nReturn types:\n    * **A_hat** *Scipy array* - Normalized adjacency."}, {"type": "method", "name": "karateclub.NNSED._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.NNSED._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.NNSED._setup_embeddings", "documentation": "Setup the node embedding matrices.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be clustered."}, {"type": "method", "name": "karateclub.NNSED._update_W", "documentation": "Updating the vertical basis matrix.\n\nArg types:\n    * **A** *(Scipy COO matrix)* - The normalized adjacency matrix."}, {"type": "method", "name": "karateclub.NNSED._update_Z", "documentation": "Updating the horizontal basis matrix.\n\nArg types:\n    * **A** *(Scipy COO matrix)* - The normalized adjacency matrix."}, {"type": "method", "name": "karateclub.NNSED.fit", "documentation": "Fitting an NNSED clustering model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be clustered."}, {"type": "method", "name": "karateclub.NNSED.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.NNSED.get_embedding", "documentation": "Getting the bottleneck layer embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.NNSED.get_memberships", "documentation": "Getting the cluster membership of nodes.\n\nReturn types:\n    * **memberships** *(dict)* - Node cluster memberships."}, {"type": "class", "name": "karateclub.NetLSD", "documentation": "An implementation of `\"NetLSD\" <https://arxiv.org/abs/1805.10712>`_\nfrom the KDD '18 paper \"NetLSD: Hearing the Shape of a Graph\". The procedure\ncalculate the heat kernel trace of the normalized Laplacian matrix over a\nvector of time scales. If the matrix is large it switches to an approximation\nof the eigenvalues.\n\nArgs:\n    scale_min (float): Time scale interval minimum. Default is -2.0.\n    scale_max (float): Time scale interval maximum. Default is 2.0.\n    scale_steps (int): Number of steps in time scale. Default is 250.\n    scale_approximations (int): Number of eigenvalue approximations. Default is 200.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.NetLSD.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.NetLSD._calculate_eigenvalues", "documentation": "Calculating the eigenvalues of the normalized Laplacian.\n\nArg types:\n    * **laplacian_matrix** *(SciPy COO matrix)* - The graph to be decomposed.\n\nReturn types:\n    * **eigenvalues** *(Numpy array)* - The eigenvalues of the graph."}, {"type": "method", "name": "karateclub.NetLSD._calculate_heat_kernel_trace", "documentation": "Calculating the heat kernel trace of the normalized Laplacian.\n\nArg types:\n    * **eigenvalues** *(Numpy array)* - The eigenvalues of the graph.\n\nReturn types:\n    * **heat_kernel_trace** *(Numpy array)* - The heat kernel trace of the graph."}, {"type": "method", "name": "karateclub.NetLSD._calculate_netlsd", "documentation": "Calculating the features of a graph.\n\nArg types:\n    * **graph** *(NetworkX graph)* - A graph to be embedded.\n\nReturn types:\n    * **hist** *(Numpy array)* - The embedding of a single graph."}, {"type": "method", "name": "karateclub.NetLSD._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.NetLSD._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.NetLSD._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.NetLSD._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.NetLSD._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.NetLSD._updown_linear_approx", "documentation": "Approximating the eigenvalues of the normalized Laplacian.\n\nArg types:\n    * **eigenvalues_lower** *(Numpy array)* - The smallest eigenvalues of the graph.\n    * **eigenvalues_upper** *(Numpy array)* - The largest eigenvalues of the graph.\n    * **number_of_nodes** *(int)* - The number of nodes in the graph.\n\nReturn types:\n    * **eigenvalues** *(Numpy array)* - The eigenvalues of the graph."}, {"type": "method", "name": "karateclub.NetLSD.fit", "documentation": "Fitting a NetLSD model.\n\nArg types:\n    * **graphs** *(List of NetworkX graphs)* - The graphs to be embedded."}, {"type": "method", "name": "karateclub.NetLSD.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.NetLSD.get_embedding", "documentation": "Getting the embedding of graphs.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of graphs."}, {"type": "method", "name": "karateclub.NetLSD.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.NetMF", "documentation": "An implementation of `\"NetMF\" <https://keg.cs.tsinghua.edu.cn/jietang/publications/WSDM18-Qiu-et-al-NetMF-network-embedding.pdf>`_\nfrom the WSDM '18 paper \"Network Embedding as Matrix Factorization: Unifying\nDeepWalk, LINE, PTE, and Node2Vec\". The procedure uses sparse truncated SVD to\nlearn embeddings for the pooled powers of the PMI matrix computed from powers\nof the normalized adjacency matrix.\n\nArgs:\n    dimensions (int): Number of embedding dimension. Default is 32.\n    iteration (int): Number of SVD iterations. Default is 10.\n    order (int): Number of PMI matrix powers. Default is 2.\n    negative_samples (in): Number of negative samples. Default is 1.\n    seed (int): SVD random seed. Default is 42."}, {"type": "method", "name": "karateclub.NetMF.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.NetMF._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.NetMF._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.NetMF._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.NetMF._create_D_inverse", "documentation": "Creating a sparse inverse degree matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix."}, {"type": "method", "name": "karateclub.NetMF._create_base_matrix", "documentation": "Creating the normalized adjacency matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **(A_hat, A_hat, A_hat, D_inverse)** *(SciPy arrays)* - Normalized adjacency matrices."}, {"type": "method", "name": "karateclub.NetMF._create_embedding", "documentation": "Fitting a truncated SVD embedding of a PMI matrix."}, {"type": "method", "name": "karateclub.NetMF._create_target_matrix", "documentation": "Creating a log transformed target matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **target_matrix** *(SciPy array)* - The shifted PMI matrix."}, {"type": "method", "name": "karateclub.NetMF._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.NetMF._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.NetMF.fit", "documentation": "Fitting a NetMF model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.NetMF.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.NetMF.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.NetMF.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.Node2Vec", "documentation": "An implementation of `\"Node2Vec\" <https://cs.stanford.edu/~jure/pubs/node2vec-kdd16.pdf>`_\nfrom the KDD '16 paper \"node2vec: Scalable Feature Learning for Networks\".\nThe procedure uses biased second order random walks to approximate the pointwise mutual information\nmatrix obtained by pooling normalized adjacency matrix powers. This matrix\nis decomposed by an approximate factorization technique.\n\nArgs:\n    walk_number (int): Number of random walks. Default is 10.\n    walk_length (int): Length of random walks. Default is 80.\n    p (float): Return parameter (1/p transition probability) to move towards from previous node.\n    q (float): In-out parameter (1/q transition probability) to move away from previous node.\n    dimensions (int): Dimensionality of embedding. Default is 128.\n    workers (int): Number of cores. Default is 4.\n    window_size (int): Matrix power order. Default is 5.\n    epochs (int): Number of epochs. Default is 1.\n    learning_rate (float): HogWild! learning rate. Default is 0.05.\n    min_count (int): Minimal count of node occurrences. Default is 1.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.Node2Vec.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.Node2Vec._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.Node2Vec._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.Node2Vec._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.Node2Vec._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.Node2Vec._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.Node2Vec.fit", "documentation": "Fitting a DeepWalk model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.Node2Vec.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.Node2Vec.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.Node2Vec.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.NodeSketch", "documentation": "An implementation of `\"NodeSketch\" <https://exascale.info/assets/pdf/yang2019nodesketch.pdf>`_\nfrom the KDD '19 paper \"NodeSketch: Highly-Efficient Graph Embeddings\nvia Recursive Sketching\". The procedure  starts by sketching the self-loop-augmented\nadjacency matrix of the graph to output low-order node embeddings, and then recursively\ngenerates k-order node embeddings based on the self-loop-augmented adjacency matrix\nand (k-1)-order node embeddings.\n\nArgs:\n    dimensions (int): Embedding dimensions. Default is 32.\n    iterations (int): Number of iterations (sketch order minus one). Default is 2.\n    decay (float): Exponential decay rate. Default is 0.01.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.NodeSketch.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.NodeSketch._augment_sla", "documentation": "Augment the sla matrix based on the previous sketch"}, {"type": "method", "name": "karateclub.NodeSketch._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.NodeSketch._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.NodeSketch._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.NodeSketch._do_single_sketch", "documentation": "Perform a single round of sketching"}, {"type": "method", "name": "karateclub.NodeSketch._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.NodeSketch._generate_hash_values", "documentation": "Predefine a hash matrix"}, {"type": "method", "name": "karateclub.NodeSketch._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.NodeSketch._sketch_to_np_array", "documentation": "Transform sketch to numpy array"}, {"type": "method", "name": "karateclub.NodeSketch.fit", "documentation": "Fitting a NodeSketch model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.NodeSketch.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.NodeSketch.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.NodeSketch.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.RandNE", "documentation": "An implementation of `\"RandNE\" <https://zw-zhang.github.io/files/2018_ICDM_RandNE.pdf>`_ from the ICDM '18 paper \"Billion-scale Network Embedding with Iterative Random Projection\". The procedure uses normalized adjacency matrix based\nsmoothing on an orthogonalized random normally generate base node embedding matrix.\n\nArgs:\n    dimensions (int): Number of embedding dimension. Default is 128.\n    alphas (list): Smoothing weights for adjacency matrix powers. Default is [0.5, 0.5].\n    seed (int): Random seed. Default is 42."}, {"type": "method", "name": "karateclub.RandNE.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.RandNE._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.RandNE._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.RandNE._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.RandNE._create_D_inverse", "documentation": "Creating a sparse inverse degree matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix."}, {"type": "method", "name": "karateclub.RandNE._create_embedding", "documentation": "Using the random orthogonal smoothing."}, {"type": "method", "name": "karateclub.RandNE._create_smoothing_matrix", "documentation": "Creating the normalized adjacency matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **(A_hat, A_hat, A_hat, D_inverse)** *(SciPy arrays)* - Normalized adjacency matrices."}, {"type": "method", "name": "karateclub.RandNE._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.RandNE._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.RandNE.fit", "documentation": "Fitting a NetMF model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.RandNE.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.RandNE.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.RandNE.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.RandomWalker", "documentation": "Class to do fast first-order random walks.\n\nArgs:\n    walk_length (int): Number of random walks.\n    walk_number (int): Number of nodes in truncated walk."}, {"type": "method", "name": "karateclub.RandomWalker.__init__", "documentation": "Initialize self.  See help(type(self)) for accurate signature."}, {"type": "method", "name": "karateclub.RandomWalker.do_walk", "documentation": "Doing a single truncated random walk from a source node.\n\nArg types:\n    * **node** *(int)* - The source node of the random walk.\n\nReturn types:\n    * **walk** *(list of strings)* - A single truncated random walk."}, {"type": "method", "name": "karateclub.RandomWalker.do_walks", "documentation": "Doing a fixed number of truncated random walk from every node in the graph.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to run the random walks on."}, {"type": "class", "name": "karateclub.Role2Vec", "documentation": "An implementation of `\"Role2vec\" <https://arxiv.org/abs/1802.02896>`_\nfrom the IJCAI '18 paper \"Learning Role-based Graph Embeddings\".\nThe procedure uses random walks to approximate the pointwise mutual information\nmatrix obtained by multiplying the pooled adjacency power matrix with a\nstructural feature matrix (in this case Weisfeiler-Lehman features). This way\none gets structural node embeddings.\n\nArgs:\n    walk_number (int): Number of random walks. Default is 10.\n    walk_length (int): Length of random walks. Default is 80.\n    dimensions (int): Dimensionality of embedding. Default is 128.\n    workers (int): Number of cores. Default is 4.\n    window_size (int): Matrix power order. Default is 2.\n    epochs (int): Number of epochs. Default is 1.\n    learning_rate (float): HogWild! learning rate. Default is 0.05.\n    down_sampling (float): Down sampling frequency. Default is 0.0001.\n    min_count (int): Minimal count of feature occurrences. Default is 10.\n    wl_iterations (int): Number of Weisfeiler-Lehman hashing iterations. Default is 2.\n    seed (int): Random seed value. Default is 42.\n    erase_base_features (bool): Removing the base features. Default is False."}, {"type": "method", "name": "karateclub.Role2Vec.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.Role2Vec._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.Role2Vec._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.Role2Vec._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.Role2Vec._create_documents", "documentation": "Accumulating the WL feature in neighbourhoods.\n\nArg types:\n    * **walks** *(list of lists)* - Random walks with string ids.\n\nReturn types:\n    * **new_features** *(list of TaggedDocument objects)* - The pooled features of nodes."}, {"type": "method", "name": "karateclub.Role2Vec._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.Role2Vec._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.Role2Vec._transform_walks", "documentation": "Transforming the random walks.\n\nArg types:\n    * **walks** *(list of lists)* - Random walks with string ids.\n\nReturn types:\n    * *(list of lists)* - The random walks as integers."}, {"type": "method", "name": "karateclub.Role2Vec.fit", "documentation": "Fitting a Role2vec model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.Role2Vec.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.Role2Vec.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.Role2Vec.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.SCD", "documentation": "An implementation of `\"SCD\" <http://wwwconference.org/proceedings/www2014/proceedings/p225.pdf>`_ from the\nWWW '14 paper \"High Quality, Scalable and Parallel Community Detection for\nLarge Real Graphs\". The procedure greedily optimizes the approximate weighted\ncommunity clustering metric. First, clusters are built around highly clustered nodes.\nSecond, we refine the initial partition by using the approximate WCC. These refinements\nhappen for the whole vertex set.\n\nArgs:\n    iterations (int): Refinemeent iterations. Default is 25.\n    eps (float): Epsilon score for zero division correction. Default is 10**-6.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.SCD.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.SCD._calculate_community_statistics", "documentation": "Calculating the community level statistics used for refinement."}, {"type": "method", "name": "karateclub.SCD._calculate_theta_1", "documentation": "Calculating the 1st WCC component."}, {"type": "method", "name": "karateclub.SCD._calculate_theta_2", "documentation": "Calculating the 2nd WCC component."}, {"type": "method", "name": "karateclub.SCD._calculate_theta_3", "documentation": "Calculating the 3rd WCC component."}, {"type": "method", "name": "karateclub.SCD._calculate_wcc", "documentation": "Calculating the WCC."}, {"type": "method", "name": "karateclub.SCD._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.SCD._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.SCD._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.SCD._create_initial_partition", "documentation": "Initial local clustering coefficient based cluster membership assignments."}, {"type": "method", "name": "karateclub.SCD._create_inverse_community_index", "documentation": "Creating a community - node list index."}, {"type": "method", "name": "karateclub.SCD._do_initial_assignments", "documentation": "Creating the cluster membership hash table."}, {"type": "method", "name": "karateclub.SCD._do_refinement", "documentation": null}, {"type": "method", "name": "karateclub.SCD._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.SCD._find_community_index", "documentation": "Finding the current community index."}, {"type": "method", "name": "karateclub.SCD._set_nodes", "documentation": "Creating a list of nodes."}, {"type": "method", "name": "karateclub.SCD._set_omega", "documentation": "Calculating the graph level clustering coefficient."}, {"type": "method", "name": "karateclub.SCD._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.SCD.fit", "documentation": "Fitting a Label Propagation clustering model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be clustered."}, {"type": "method", "name": "karateclub.SCD.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.SCD.get_embedding", "documentation": "Getting the embeddings (graph or node level)."}, {"type": "method", "name": "karateclub.SCD.get_memberships", "documentation": "Getting the cluster membership of nodes.\n\nReturn types:\n    * **memberships** *(dict)* - Node cluster memberships."}, {"type": "class", "name": "karateclub.SF", "documentation": "An implementation of `\"SF\" <https://arxiv.org/abs/1810.09155>`_\nfrom the NeurIPS Relational Representation Learning Workshop '18 paper \"A Simple Baseline Algorithm for Graph Classification\".\nThe procedure calculates the k lowest egeinvalues of the normalized Laplacian.\nIf the graph has a lower number of eigenvalues than k the representation is padded with zeros.\n\nArgs:\n    dimensions (int): Number of lowest eigenvalues. Default is 128.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.SF.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.SF._calculate_sf", "documentation": "Calculating the features of a graph.\n\nArg types:\n    * **graph** *(NetworkX graph)* - A graph to be embedded.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of a single graph."}, {"type": "method", "name": "karateclub.SF._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.SF._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.SF._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.SF._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.SF._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.SF.fit", "documentation": "Fitting an SF model.\n\nArg types:\n    * **graphs** *(List of NetworkX graphs)* - The graphs to be embedded."}, {"type": "method", "name": "karateclub.SF.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.SF.get_embedding", "documentation": "Getting the embedding of graphs.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of graphs."}, {"type": "method", "name": "karateclub.SF.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.SINE", "documentation": "An implementation of `\"SINE\" <https://arxiv.org/pdf/1810.06768.pdf>`_\nfrom the ICDM '18 paper \"SINE: Scalable Incomplete Network Embedding\". The\nprocedure implicitly factorizes a joint adjacency matrix power and feature matrix.\nThe decomposition happens on truncated random walks and the adjacency matrix powers\nare pooled together.\n\nArgs:\n    walk_number (int): Number of random walks. Default is 10.\n    walk_length (int): Length of random walks. Default is 80.\n    dimensions (int): Dimensionality of embedding. Default is 128.\n    workers (int): Number of cores. Default is 4.\n    window_size (int): Matrix power order. Default is 5.\n    epochs (int): Number of epochs. Default is 1.\n    learning_rate (float): HogWild! learning rate. Default is 0.05.\n    min_count (int): Minimal count of node occurrences. Default is 1.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.SINE.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.SINE._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.SINE._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.SINE._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.SINE._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.SINE._feature_transform", "documentation": null}, {"type": "method", "name": "karateclub.SINE._select_walklets", "documentation": null}, {"type": "method", "name": "karateclub.SINE._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.SINE.fit", "documentation": "Fitting a SINE model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n    * **X** *(Scipy COO array)* - The matrix of node features."}, {"type": "method", "name": "karateclub.SINE.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.SINE.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.SINE.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.SocioDim", "documentation": "An implementation of `\"SocioDim\" <https://dl.acm.org/doi/abs/10.1145/1557019.1557109>`_\nfrom the KDD '09 paper \"Relational Learning via Latent Social Dimensions\".\nThe procedure extracts the eigenvectors corresponding to the largest eigenvalues\nof the graph modularity matrix. These vectors are used as the node embedding.\n\nArgs:\n    dimensions (int): Dimensionality of embedding. Default is 128.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.SocioDim.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.SocioDim._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.SocioDim._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.SocioDim._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.SocioDim._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.SocioDim._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.SocioDim.fit", "documentation": "Fitting a Social Dimensions model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.SocioDim.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.SocioDim.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.SocioDim.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.SymmNMF", "documentation": "An implementation of `\"Symm-NMF\" <https://www.cc.gatech.edu/~hpark/papers/DaDingParkSDM12.pdf>`_\nfrom the SDM'12 paper \"Symmetric Nonnegative Matrix Factorization for Graph Clustering\". The procedure\ndecomposed the second power od the normalized adjacency matrix with an ADMM based non-negative matrix\nfactorization based technique. This results in a node embedding and each node is associated with an\nembedding factor in the created latent space.\n\nArgs:\n    dimensions (int): Number of dimensions. Default is 32.\n    iterations (int): Number of power iterations. Default is 200.\n    rho (float): Regularization tuning parameter. Default is 100.0.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.SymmNMF.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.SymmNMF._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.SymmNMF._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.SymmNMF._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.SymmNMF._create_D_inverse", "documentation": "Creating a sparse inverse degree matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix."}, {"type": "method", "name": "karateclub.SymmNMF._create_base_matrix", "documentation": "Creating a tuple with the normalized adjacency matrix.\n\nReturn types:\n    * **A_hat** *Scipy array* - Normalized adjacency."}, {"type": "method", "name": "karateclub.SymmNMF._do_admm_update", "documentation": "Doing a single ADMM update with the adjacency matrix."}, {"type": "method", "name": "karateclub.SymmNMF._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.SymmNMF._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.SymmNMF._setup_embeddings", "documentation": "Setup the node embedding matrices.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be clustered."}, {"type": "method", "name": "karateclub.SymmNMF.fit", "documentation": "Fitting a Symm-NMF clustering model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be clustered."}, {"type": "method", "name": "karateclub.SymmNMF.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.SymmNMF.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.SymmNMF.get_memberships", "documentation": "Getting the cluster membership of nodes.\n\nReturn types:\n    * **memberships** *(dict)* - Node cluster memberships."}, {"type": "class", "name": "karateclub.TADW", "documentation": "An implementation of `\"TADW\" <https://www.ijcai.org/Proceedings/15/Papers/299.pdf>`_\nfrom the IJCAI '15 paper \"Network Representation Learning with Rich Text Information\". The\nprocedure uses the node attribute matrix with a factorization matrix to reproduce a power\nof the adjacency matrix to create representations.\n\nArgs:\n    dimensions (int): Number of embedding dimensions. Default is 32.\n    reduction_dimensions (int): SVD reduction dimensions. Default is 64.\n    svd_iterations (int): SVD iteration count. Default is 20.\n    seed (int): Random seed. Default is 42.\n    alpha (float): Learning rate. Default is 0.01.\n    iterations (int): Matrix decomposition iterations. Default is 10.\n    lambd (float): Regularization coefficient. Default is 10.0."}, {"type": "method", "name": "karateclub.TADW.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.TADW._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.TADW._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.TADW._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.TADW._create_reduced_features", "documentation": "Creating a dense reduced node feature matrix.\n\nArg types:\n    * **X** *(Scipy COO or Numpy array)* - The wide feature matrix.\n\nReturn types:\n    * **T** *(Numpy array)* - The reduced feature matrix of nodes."}, {"type": "method", "name": "karateclub.TADW._create_target_matrix", "documentation": "Creating a normalized sparse adjacency matrix power target.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **A_tilde** *(Scipy COO matrix) - The target matrix."}, {"type": "method", "name": "karateclub.TADW._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.TADW._init_weights", "documentation": "Initialization of weights and loss container."}, {"type": "method", "name": "karateclub.TADW._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.TADW._update_H", "documentation": "A single update of the feature basis matrix."}, {"type": "method", "name": "karateclub.TADW._update_W", "documentation": "A single update of the node embedding matrix."}, {"type": "method", "name": "karateclub.TADW.fit", "documentation": "Fitting a TADW model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n    * **X** *(Scipy COO or Numpy array)* - The matrix of node features."}, {"type": "method", "name": "karateclub.TADW.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.TADW.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.TADW.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.TENE", "documentation": "An implementation of `\"TENE\" <https://ieeexplore.ieee.org/document/8545577>`_\nfrom the ICPR '18 paper \"Enhanced Network Embedding with Text Information\". The\nprocedure jointly factorizes the adjacency and node feature matrices using alternating\nleast squares.\n\nArgs:\n    dimensions (int): Number of embedding dimensions. Default is 32.\n    lower_control (float): Embedding score minimal value. Default is 10**-15.\n    alpha (float): Adjacency matrix regularization coefficient. Default is 0.1.\n    beta (float): Feature matrix regularization coefficient. Default is 0.1.\n    iterations (int): ALS iterations. Default is 200.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.TENE.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.TENE._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.TENE._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.TENE._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.TENE._create_D_inverse", "documentation": "Creating a sparse inverse degree matrix.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n\nReturn types:\n    * **D_inverse** *(Scipy array)* - Diagonal inverse degree matrix."}, {"type": "method", "name": "karateclub.TENE._create_base_matrix", "documentation": "Creating a normalized adjacency matrix.\n\nReturn types:\n    * **A_hat* - Normalized adjacency matrix."}, {"type": "method", "name": "karateclub.TENE._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.TENE._init_weights", "documentation": "Setup basis and feature matrices."}, {"type": "method", "name": "karateclub.TENE._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.TENE._update_C", "documentation": "Update transformation matrix."}, {"type": "method", "name": "karateclub.TENE._update_M", "documentation": "Update node bases."}, {"type": "method", "name": "karateclub.TENE._update_Q", "documentation": "Update feature bases."}, {"type": "method", "name": "karateclub.TENE._update_U", "documentation": "Update features."}, {"type": "method", "name": "karateclub.TENE._update_V", "documentation": "Update node features."}, {"type": "method", "name": "karateclub.TENE.fit", "documentation": "Fitting a TENE model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded.\n    * **T** *(Scipy COO or Numpy array)* - The matrix of node features."}, {"type": "method", "name": "karateclub.TENE.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.TENE.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.TENE.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.Walklets", "documentation": "An implementation of `\"Walklets\" <https://arxiv.org/abs/1605.02115>`_\nfrom the ASONAM '17 paper \"Don't Walk, Skip! Online Learning of Multi-scale\nNetwork Embeddings\". The procedure uses random walks to approximate the\npointwise mutual information matrix obtained by individual normalized\nadjacency matrix powers. These are all decomposed by an approximate\nfactorization technique and the embeddings are concatenated together.\n\nArgs:\n    walk_number (int): Number of random walks. Default is 10.\n    walk_length (int): Length of random walks. Default is 80.\n    dimensions (int): Dimensionality of embedding. Default is 32.\n    workers (int): Number of cores. Default is 4.\n    window_size (int): Matrix power order. Default is 4.\n    epochs (int): Number of epochs. Default is 1.\n    learning_rate (float): HogWild! learning rate. Default is 0.05.\n    min_count (int): Minimal count of node occurrences. Default is 1.\n    seed (int): Random seed value. Default is 42."}, {"type": "method", "name": "karateclub.Walklets.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.Walklets._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.Walklets._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.Walklets._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.Walklets._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.Walklets._select_walklets", "documentation": null}, {"type": "method", "name": "karateclub.Walklets._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.Walklets.fit", "documentation": "Fitting a Walklets model.\n\nArg types:\n    * **graph** *(NetworkX graph)* - The graph to be embedded."}, {"type": "method", "name": "karateclub.Walklets.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.Walklets.get_embedding", "documentation": "Getting the node embedding.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of nodes."}, {"type": "method", "name": "karateclub.Walklets.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.WaveletCharacteristic", "documentation": "An implementation of `\"WaveCharacteristic\" <https://arxiv.org/abs/2005.07959>`_\nfrom the CIKM '21 paper \"Graph Embedding via Diffusion-Wavelets-Based Node Feature \nDistribution Characterization\". The procedure uses characteristic functions of \nnode features with wavelet function weights to describe node neighborhoods. \nThese node level features are pooled by mean pooling to create graph level statistics.\n\nArgs:\n    order (int): Adjacency matrix powers. Default is 5.\n    eval_points (int): Number of characteristic function evaluations. Default is 5.\n    theta_max (float): Largest characteristic function time value. Default is 2.5.\n    tau (float): Wave function heat - time diffusion. Default is 1.0.\n    pooling (str): Pooling function appliead to the characteristic functions. Default is \"mean\"."}, {"type": "method", "name": "karateclub.WaveletCharacteristic.__init__", "documentation": "Creating an estimator."}, {"type": "method", "name": "karateclub.WaveletCharacteristic._calculate_wavelet_characteristic", "documentation": null}, {"type": "method", "name": "karateclub.WaveletCharacteristic._check_graph", "documentation": "Check the Karate Club assumptions about the graph."}, {"type": "method", "name": "karateclub.WaveletCharacteristic._check_graphs", "documentation": "Check the Karate Club assumptions for a list of graphs."}, {"type": "method", "name": "karateclub.WaveletCharacteristic._check_indexing", "documentation": "Checking the consecutive numeric indexing."}, {"type": "method", "name": "karateclub.WaveletCharacteristic._create_D_inverse", "documentation": null}, {"type": "method", "name": "karateclub.WaveletCharacteristic._create_node_feature_matrix", "documentation": null}, {"type": "method", "name": "karateclub.WaveletCharacteristic._ensure_integrity", "documentation": "Ensure walk traversal conditions."}, {"type": "method", "name": "karateclub.WaveletCharacteristic._get_normalized_adjacency", "documentation": null}, {"type": "method", "name": "karateclub.WaveletCharacteristic._heat_diffusion_ind", "documentation": null}, {"type": "method", "name": "karateclub.WaveletCharacteristic._set_seed", "documentation": "Creating the initial random seed."}, {"type": "method", "name": "karateclub.WaveletCharacteristic.fit", "documentation": "Fitting a Geometric-Scattering model.\n\nArg types:\n    * **graphs** *(List of NetworkX graphs)* - The graphs to be embedded."}, {"type": "method", "name": "karateclub.WaveletCharacteristic.get_cluster_centers", "documentation": "Getting the cluster centers."}, {"type": "method", "name": "karateclub.WaveletCharacteristic.get_embedding", "documentation": "Getting the embedding of graphs.\n\nReturn types:\n    * **embedding** *(Numpy array)* - The embedding of graphs."}, {"type": "method", "name": "karateclub.WaveletCharacteristic.get_memberships", "documentation": "Getting the membership dictionary."}, {"type": "class", "name": "karateclub.WeisfeilerLehmanHashing", "documentation": "Weisfeiler-Lehman feature extractor class.\n\nArgs:\n    graph (NetworkX graph): NetworkX graph for which we do WL hashing.\n    wl_iterations (int): Number of WL iterations.\n    attributed (bool): Presence of attributes.\n    erase_base_feature (bool): Deleting the base features."}, {"type": "method", "name": "karateclub.WeisfeilerLehmanHashing.__init__", "documentation": "Initialization method which also executes feature extraction."}, {"type": "method", "name": "karateclub.WeisfeilerLehmanHashing._do_a_recursion", "documentation": "The method does a single WL recursion.\n\nReturn types:\n    * **new_features** *(dict of strings)* - The hash table with extracted WL features."}, {"type": "method", "name": "karateclub.WeisfeilerLehmanHashing._do_recursions", "documentation": "The method does a series of WL recursions."}, {"type": "method", "name": "karateclub.WeisfeilerLehmanHashing._erase_base_features", "documentation": "Erasing the base features"}, {"type": "method", "name": "karateclub.WeisfeilerLehmanHashing._set_features", "documentation": "Creating the features."}, {"type": "method", "name": "karateclub.WeisfeilerLehmanHashing.get_graph_features", "documentation": "Return the graph level features."}, {"type": "method", "name": "karateclub.WeisfeilerLehmanHashing.get_node_features", "documentation": "Return the node level features."}]